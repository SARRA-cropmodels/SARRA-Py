{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SARRA-Py SARRA-Py is a crop simulation model implemented in Python from the SARRA family of models ( SARRA-H , SARRA-O ). SARRA-Py has the same philosophy than the rest of the SARRA family of models : a daily time step, simple dynamic hydrological balance model, used to estimate the impact of climate scenarios on annual crops, assuming that crop performance is a function of the accumulated hydrological constraints during the crop's growth cycle. SARRA-Py formalisms are based on those of its predecessors. Its main difference with SARRA-H is that SARRA-Py is spatialized, performing its calculations on a georeferenced grid. In that, it is much comparable with SARRA-O , however its Python implementation and its use of xarray architecture facilitates articulation with data formats and tools used in remote sensing and weather data analysis. SARRA-Py integrates tools to facilitate regional scale analyses. We aim its code and formalisms to be open and evolutive, recognizing that any new scientific application may require some adaptation of the tool. SARRA-Py package is provided with notebook examples to illustrate multiple use cases. Table of Contents Installation Usage Contributing Support License Installation These instructions will get you a copy of the project up and running on your machine. Clone this repository and navigate to the directory: git clone https://github.com/SARRA-cropmodels/SARRA-Py/ cd SARRA-Py (optional) set up and activate a virtual environment for a clean installation of dependencies: pyenv virtualenv 3.x.x venv_sarra_py pyenv activate venv_sarra_py Install package and its dependencies with pip: pip install . Usage This package is provided with a set of Jupyter notebooks to illustrate its use. You can find them in the notebooks folder. Do not forget to switch to a IPython kernel calling for your virtual environment if created. Contributing Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us. Support If you have any questions, feel free to post an issue in our GitHub repo . License This project is licensed under the GNU GPLv3 license - see the LICENSE file for details.","title":"Home"},{"location":"#sarra-py","text":"SARRA-Py is a crop simulation model implemented in Python from the SARRA family of models ( SARRA-H , SARRA-O ). SARRA-Py has the same philosophy than the rest of the SARRA family of models : a daily time step, simple dynamic hydrological balance model, used to estimate the impact of climate scenarios on annual crops, assuming that crop performance is a function of the accumulated hydrological constraints during the crop's growth cycle. SARRA-Py formalisms are based on those of its predecessors. Its main difference with SARRA-H is that SARRA-Py is spatialized, performing its calculations on a georeferenced grid. In that, it is much comparable with SARRA-O , however its Python implementation and its use of xarray architecture facilitates articulation with data formats and tools used in remote sensing and weather data analysis. SARRA-Py integrates tools to facilitate regional scale analyses. We aim its code and formalisms to be open and evolutive, recognizing that any new scientific application may require some adaptation of the tool. SARRA-Py package is provided with notebook examples to illustrate multiple use cases.","title":"SARRA-Py"},{"location":"#table-of-contents","text":"Installation Usage Contributing Support License","title":"Table of Contents"},{"location":"#installation","text":"These instructions will get you a copy of the project up and running on your machine. Clone this repository and navigate to the directory: git clone https://github.com/SARRA-cropmodels/SARRA-Py/ cd SARRA-Py (optional) set up and activate a virtual environment for a clean installation of dependencies: pyenv virtualenv 3.x.x venv_sarra_py pyenv activate venv_sarra_py Install package and its dependencies with pip: pip install .","title":"Installation"},{"location":"#usage","text":"This package is provided with a set of Jupyter notebooks to illustrate its use. You can find them in the notebooks folder. Do not forget to switch to a IPython kernel calling for your virtual environment if created.","title":"Usage"},{"location":"#contributing","text":"Please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.","title":"Contributing"},{"location":"#support","text":"If you have any questions, feel free to post an issue in our GitHub repo .","title":"Support"},{"location":"#license","text":"This project is licensed under the GNU GPLv3 license - see the LICENSE file for details.","title":"License"},{"location":"CONTRIBUTING/","text":"Contributing When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a code of conduct, please follow it in all your interactions with the project. Pull Request Process Ensure any install or build dependencies are removed before the end of the layer when doing a build. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters. Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer . You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you. Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Please note we have a code of conduct, please follow it in all your interactions with the project.","title":"Contributing"},{"location":"CONTRIBUTING/#pull-request-process","text":"Ensure any install or build dependencies are removed before the end of the layer when doing a build. Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters. Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer . You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you.","title":"Pull Request Process"},{"location":"CONTRIBUTING/#code-of-conduct","text":"","title":"Code of Conduct"},{"location":"CONTRIBUTING/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CONTRIBUTING/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CONTRIBUTING/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CONTRIBUTING/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CONTRIBUTING/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CONTRIBUTING/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"docs/licence/","text":"This is the licence","title":"Licence"},{"location":"docs/model_formalisms/","text":"Model formalisms As for the rest of the SARRA family of models, SARRA-Py is a crop simulation model that uses three main processes in a daily loop: Water balance : estimation of evapotranspiration, water stress index, via three reservoirs Carbon balance : based on the concept of \"big leaf\", conversion of solar energy into assimilates under water stress constraints, and repartition into biomass Phenology : evolution of phenological stages (emergence, vegetative stage, flowering, maturation) and associated processes (germination, juvenile mortality, distribution modes of biomasses, etc.). Water balance The SARRA-Py water balance process considers soil as a collection of reservoirs of varying sizes: surface, deep, and a dynamic root reservoir. Each reservoir is an entity that is homogeneous in terms of simulated processes or variables that describe its properties such as infiltration/surface runoff, drainage, storage capacity, and water consumption. The flux is simulated by filling the reservoir to its maximum capacity, traditionally the field capacity, except for groundwater phenomena where it is filled to saturation. Beyond that, the water overflows to the next reservoir, downward vertical flux. The water that overflows from the last reservoir is considered drainage. The capillary rise process is not simulated. Three representations of the reservoirs are used to estimate available water for evaporation, transpiration, and water storage processes : a fixed-size surface reservoir, that manages the soil evaporation process, a deep reservoir, on which moisture front is simulated ; this allows: 1) to limit the rooting depth to the moisture front, 2) to store water not yet accessible by roots, 3) to block rooting in the case of hard soils, and a root reservoir that evolves based on the rooting speed of roots during their development phases and simulates water availability for plant transpiration. The overall water balance equation is: stock(d+1) = stock(d) + (rain + irrigation) - runoff - drainage - (tr + evap) where stock is the water stored in the reservoirs, runoff is a function of water input and soil texture, drainage is overflow from the deep reservoir, tr is transpiration, and evap is evaporation. The size of the root reservoir prospected by roots evolves based on the daily rooting speed defined for each phenological phase and can be blocked by the moisture front or reduced in case of strong hydric stress. Carbon balance The carbon balance in SARRA-Py is based on a big-leaf approach. The photosynthetically active radiation (PAR) to be transformed into assimilates based on photosynthetic activity is estimated from 1) calculating the intercepted fraction of PAR (deduced via the Beer law from the plot-level leaf area index (LAI) and leaf geometry (factor kdf)), and 2) applying a conversion rate. The conversion rate is considered constant throughout the cycle, and is higher than commonly given since it aims at representing all produced assimilates, whereas conversion rates traditionally used in other models only take into account the increase in aerial biomass, without root biomass or maintenance respiration. This photosynthetic activity is constrained constrained by the availability of water and nutrients, representing processes such as stomatal regulation. Assimilates are then allocated between biomasses following rules that vary depending on the phases : A portion of the assimilates is consumed without producing biomass for the maintenance of living tissues, known as maintenance respiration. From emergence to flowering, biomass is split into root biomass and aerial biomass, which is further divided into leaf and stem biomass using allometric relationships. After flowering, the available assimilates allow for seed filling. The overall equation of the carbon balance is defined as: total biomass (d+1) = biomass (d) + assimilates - maintenance respiration total biomass = root biomass + leaf biomass + stem biomass + grain biomass The value of LAI, being the ratio of the limb surface to the ground surface, can then be updated from the leaf biomass based on the specific leaf area (SLA). SLA is considered to be decreasing with the age of the leaf, due to its thickening. Other factors contribute to leaf thickening, including exposure levels to radiation and competition for assimilates Additionally, its dynamics vary depending on plant type (monocotyledons and dicotyledons). The leaf surface area is nonetheless a genetic characteristic that can be defined by minimum and maximum values. In this model, minimum and maximum values, as well as linear decrease rate of SLA are taken into consideration. Finally, the grain yield potential is defined as a fixed fraction of the aerial biomass (genetic potential). It can be diminished by various processes during the reproductive phase, water stress (which result in reduced biomass during the critical phase). The grain yield is mainly dependent on the grain filling phase, where water is the main constraint and the grain demand is the highest and considered a priority. The grain yield is calculated based on the temperature of the day and the defined temperature sum for this phase, multiplied by the grain yield potential. For species with continuous flowering, the grain yield is calculated daily and can be affected by the flowering process. The influence of seeding density is also taken into account, where a linear relationship is applied for low densities and an asymptotic relationship for high densities. The carbon balance calculations for biomass, yield and LAI are simulated daily with an optimal density and converted from the actual density to the optimal density using the asymptotic relationship. Phenology Phenology is the study of the growth and development of plants and it is a crucial component of SARRA-Py. The crop growth cycle is traditionally divided into four phases: juvenile vegetative phase (BVP), photoperiod-sensitive phase (PSP), reproductive phase (RPR), and maturation phase (Matu). SARRA-Py divides these phases into seven stages to optimize calculation and control methods. These stages are determined by the sum of degree days and the length of the day, and are defined by different thresholds (temperature, PP function). The PSP phase depends on the photoperiod sensitivity of the variety, which varies with the latitude and sowing date. The RPR and maturation phases are the most sensitive to constraints and have a significant impact on yield in cereal crops. The degree days are calculated based on the temperature range between the base temperature, lethal temperature, and optimum temperatures for plant development.","title":"Model formalisms"},{"location":"docs/model_formalisms/#model-formalisms","text":"As for the rest of the SARRA family of models, SARRA-Py is a crop simulation model that uses three main processes in a daily loop: Water balance : estimation of evapotranspiration, water stress index, via three reservoirs Carbon balance : based on the concept of \"big leaf\", conversion of solar energy into assimilates under water stress constraints, and repartition into biomass Phenology : evolution of phenological stages (emergence, vegetative stage, flowering, maturation) and associated processes (germination, juvenile mortality, distribution modes of biomasses, etc.).","title":"Model formalisms"},{"location":"docs/model_formalisms/#water-balance","text":"The SARRA-Py water balance process considers soil as a collection of reservoirs of varying sizes: surface, deep, and a dynamic root reservoir. Each reservoir is an entity that is homogeneous in terms of simulated processes or variables that describe its properties such as infiltration/surface runoff, drainage, storage capacity, and water consumption. The flux is simulated by filling the reservoir to its maximum capacity, traditionally the field capacity, except for groundwater phenomena where it is filled to saturation. Beyond that, the water overflows to the next reservoir, downward vertical flux. The water that overflows from the last reservoir is considered drainage. The capillary rise process is not simulated. Three representations of the reservoirs are used to estimate available water for evaporation, transpiration, and water storage processes : a fixed-size surface reservoir, that manages the soil evaporation process, a deep reservoir, on which moisture front is simulated ; this allows: 1) to limit the rooting depth to the moisture front, 2) to store water not yet accessible by roots, 3) to block rooting in the case of hard soils, and a root reservoir that evolves based on the rooting speed of roots during their development phases and simulates water availability for plant transpiration. The overall water balance equation is: stock(d+1) = stock(d) + (rain + irrigation) - runoff - drainage - (tr + evap) where stock is the water stored in the reservoirs, runoff is a function of water input and soil texture, drainage is overflow from the deep reservoir, tr is transpiration, and evap is evaporation. The size of the root reservoir prospected by roots evolves based on the daily rooting speed defined for each phenological phase and can be blocked by the moisture front or reduced in case of strong hydric stress.","title":"Water balance"},{"location":"docs/model_formalisms/#carbon-balance","text":"The carbon balance in SARRA-Py is based on a big-leaf approach. The photosynthetically active radiation (PAR) to be transformed into assimilates based on photosynthetic activity is estimated from 1) calculating the intercepted fraction of PAR (deduced via the Beer law from the plot-level leaf area index (LAI) and leaf geometry (factor kdf)), and 2) applying a conversion rate. The conversion rate is considered constant throughout the cycle, and is higher than commonly given since it aims at representing all produced assimilates, whereas conversion rates traditionally used in other models only take into account the increase in aerial biomass, without root biomass or maintenance respiration. This photosynthetic activity is constrained constrained by the availability of water and nutrients, representing processes such as stomatal regulation. Assimilates are then allocated between biomasses following rules that vary depending on the phases : A portion of the assimilates is consumed without producing biomass for the maintenance of living tissues, known as maintenance respiration. From emergence to flowering, biomass is split into root biomass and aerial biomass, which is further divided into leaf and stem biomass using allometric relationships. After flowering, the available assimilates allow for seed filling. The overall equation of the carbon balance is defined as: total biomass (d+1) = biomass (d) + assimilates - maintenance respiration total biomass = root biomass + leaf biomass + stem biomass + grain biomass The value of LAI, being the ratio of the limb surface to the ground surface, can then be updated from the leaf biomass based on the specific leaf area (SLA). SLA is considered to be decreasing with the age of the leaf, due to its thickening. Other factors contribute to leaf thickening, including exposure levels to radiation and competition for assimilates Additionally, its dynamics vary depending on plant type (monocotyledons and dicotyledons). The leaf surface area is nonetheless a genetic characteristic that can be defined by minimum and maximum values. In this model, minimum and maximum values, as well as linear decrease rate of SLA are taken into consideration. Finally, the grain yield potential is defined as a fixed fraction of the aerial biomass (genetic potential). It can be diminished by various processes during the reproductive phase, water stress (which result in reduced biomass during the critical phase). The grain yield is mainly dependent on the grain filling phase, where water is the main constraint and the grain demand is the highest and considered a priority. The grain yield is calculated based on the temperature of the day and the defined temperature sum for this phase, multiplied by the grain yield potential. For species with continuous flowering, the grain yield is calculated daily and can be affected by the flowering process. The influence of seeding density is also taken into account, where a linear relationship is applied for low densities and an asymptotic relationship for high densities. The carbon balance calculations for biomass, yield and LAI are simulated daily with an optimal density and converted from the actual density to the optimal density using the asymptotic relationship.","title":"Carbon balance"},{"location":"docs/model_formalisms/#phenology","text":"Phenology is the study of the growth and development of plants and it is a crucial component of SARRA-Py. The crop growth cycle is traditionally divided into four phases: juvenile vegetative phase (BVP), photoperiod-sensitive phase (PSP), reproductive phase (RPR), and maturation phase (Matu). SARRA-Py divides these phases into seven stages to optimize calculation and control methods. These stages are determined by the sum of degree days and the length of the day, and are defined by different thresholds (temperature, PP function). The PSP phase depends on the photoperiod sensitivity of the variety, which varies with the latitude and sowing date. The RPR and maturation phases are the most sensitive to constraints and have a significant impact on yield in cereal crops. The degree days are calculated based on the temperature range between the base temperature, lethal temperature, and optimum temperatures for plant development.","title":"Phenology"},{"location":"docs/spatialization_strategy/","text":"Spatialization strategy SARRA-Py is a spatialized version of the crop model SARRA-H, developed to estimate the impact of climate scenarios on annual crops. The simulation is performed on a daily time step, with a simple dynamic hydrological balance model that assumes crop performance is a function of the accumulated hydrological constraints during the crop's growth cycle. The spatialization strategy used in SARRA-Py involves storing all model variables in georeferenced xarrays. Xarrays are a powerful data structure for working with geospatial arrays, as they allow for computations to be performed on regular, georeferenced grids instead of single points or non-georeferenced arrays. This enables the output of maps, making the model suitable for regional scale analyses which can provide valuable insights into the simulation results. The advantage of the spatialization strategy used in SARRA-Py is that it allows users to perform simulations across a territory, instead of just at one point. This means that the model can be used to perform spatial aggregation of the estimated values, such as drought index or potential yield. This is particularly useful for regional-scale analyses and can provide valuable information for early warning systems for food security issues, as well as for evaluating the potential impacts of climate change on crop systems. The spatialization of the simulation in SARRA-Py has several benefits for users compared to a non-spatialized version of the model. It enables the performance of simulations across a territory, making it possible to perform spatial aggregations of estimated drought indices, potential yields, and other relevant metrics. Simulation logic The whole simulation results and intermediate steps are stored in a xarray with dimensions (d, x, y), where d is the index of the Julian day and x,y are the spatial coordinates. On each day, the simulation performs a series of operations using variables from both the current day and the previous day, updating the slice in the xarray. The simulation in SARRA-Py works by updating the xarray of variables on a daily basis. For each day, the model performs a series of operations using the variables from the current and previous day, and updates the corresponding slice in the xarray. The whole simulation and its intermediate steps are stored in a 3D xarray, with dimensions for the Julian day, and the x and y spatial coordinates. Array resolution The initial resolution of the arrays is defined by the resolution of satellite rainfall estimation products, which serve as an important input to the model in computing the water balance. In SARRA-Py, the resolution of the xarrays is defined by the resolution of satellite rainfall estimation products, which serve as an important input for the model's calculation of water balance. By using these products as the resolution, the model can accurately capture the impact of rainfall on crop yield, which is one of the main drivers for crop performance. Performance However, it is worth noting that xarrays can be computationally slow, so it may be necessary to use tools such as Dask to increase performance. Despite this, the spatialization of the simulation in SARRA-Py provides a powerful tool for users, and the package is provided with notebook examples to illustrate its use.","title":"Spatialization strategy"},{"location":"docs/spatialization_strategy/#spatialization-strategy","text":"SARRA-Py is a spatialized version of the crop model SARRA-H, developed to estimate the impact of climate scenarios on annual crops. The simulation is performed on a daily time step, with a simple dynamic hydrological balance model that assumes crop performance is a function of the accumulated hydrological constraints during the crop's growth cycle. The spatialization strategy used in SARRA-Py involves storing all model variables in georeferenced xarrays. Xarrays are a powerful data structure for working with geospatial arrays, as they allow for computations to be performed on regular, georeferenced grids instead of single points or non-georeferenced arrays. This enables the output of maps, making the model suitable for regional scale analyses which can provide valuable insights into the simulation results. The advantage of the spatialization strategy used in SARRA-Py is that it allows users to perform simulations across a territory, instead of just at one point. This means that the model can be used to perform spatial aggregation of the estimated values, such as drought index or potential yield. This is particularly useful for regional-scale analyses and can provide valuable information for early warning systems for food security issues, as well as for evaluating the potential impacts of climate change on crop systems. The spatialization of the simulation in SARRA-Py has several benefits for users compared to a non-spatialized version of the model. It enables the performance of simulations across a territory, making it possible to perform spatial aggregations of estimated drought indices, potential yields, and other relevant metrics.","title":"Spatialization strategy"},{"location":"docs/spatialization_strategy/#simulation-logic","text":"The whole simulation results and intermediate steps are stored in a xarray with dimensions (d, x, y), where d is the index of the Julian day and x,y are the spatial coordinates. On each day, the simulation performs a series of operations using variables from both the current day and the previous day, updating the slice in the xarray. The simulation in SARRA-Py works by updating the xarray of variables on a daily basis. For each day, the model performs a series of operations using the variables from the current and previous day, and updates the corresponding slice in the xarray. The whole simulation and its intermediate steps are stored in a 3D xarray, with dimensions for the Julian day, and the x and y spatial coordinates.","title":"Simulation logic"},{"location":"docs/spatialization_strategy/#array-resolution","text":"The initial resolution of the arrays is defined by the resolution of satellite rainfall estimation products, which serve as an important input to the model in computing the water balance. In SARRA-Py, the resolution of the xarrays is defined by the resolution of satellite rainfall estimation products, which serve as an important input for the model's calculation of water balance. By using these products as the resolution, the model can accurately capture the impact of rainfall on crop yield, which is one of the main drivers for crop performance.","title":"Array resolution"},{"location":"docs/spatialization_strategy/#performance","text":"However, it is worth noting that xarrays can be computationally slow, so it may be necessary to use tools such as Dask to increase performance. Despite this, the spatialization of the simulation in SARRA-Py provides a powerful tool for users, and the package is provided with notebook examples to illustrate its use.","title":"Performance"},{"location":"docs/tutorial/00_-_Running_a_simulation/","text":"Tutorial 01 - Running a simulation","title":"00 - Running a simulation"},{"location":"docs/tutorial/00_-_Running_a_simulation/#tutorial-01-running-a-simulation","text":"","title":"Tutorial 01 - Running a simulation"},{"location":"reference/sarra_py/","text":"Module sarra_py View Source from .bilan_pheno import * from .bilan_carbo import * from .bilan_hydro import * from .data_preparation import * from .models import * Sub-modules sarra_py.bilan_carbo sarra_py.bilan_hydro sarra_py.bilan_pheno sarra_py.comparison_tools_old sarra_py.data_preparation sarra_py.models","title":"Index"},{"location":"reference/sarra_py/#module-sarra_py","text":"View Source from .bilan_pheno import * from .bilan_carbo import * from .bilan_hydro import * from .data_preparation import * from .models import *","title":"Module sarra_py"},{"location":"reference/sarra_py/#sub-modules","text":"sarra_py.bilan_carbo sarra_py.bilan_hydro sarra_py.bilan_pheno sarra_py.comparison_tools_old sarra_py.data_preparation sarra_py.models","title":"Sub-modules"},{"location":"reference/sarra_py/bilan_carbo/","text":"Module sarra_py.bilan_carbo View Source import numpy as np import xarray as xr def variable_dict (): \"\"\" Retrieve the dictionary of variables in the dataset with their respective units. Returns: dict: A dictionary containing the variables and their units, where the keys are the variable names and the values are the respective units. \"\"\" variables = { # climate \"ddj\" : [ \"daily thermal time\" , \"\u00b0C.j\" ], \"sdj\" : [ \"sum of thermal time since beginning of emergence\" , \"\u00b0C.j\" ], # phenology \"changePhase\" : [ \"indicator of phase transition day\" , \"binary\" ], \"numPhase\" : [ \"number of phenological stage\" , \"arbitrary units\" ], \"initPhase\" : [ \"indicator of performed phase transition\" , \"binary\" ], \"phasePhotoper\" : [ \"photoperiodic phase indicator\" , \"binary\" ], \"seuilTempPhaseSuivante\" : [ \"sum of thermal time needed to reach the next phenological phase\" , \"\u00b0C.j\" ], \"sommeDegresJourPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], \"seuilTempPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], # carbon balance \"assim\" : [ \"plant biomass assimilation\" , \"kg/ha\" ], \"assimPot\" : [ \"plant potential biomass assimilation\" , \"kg/ha\" ], \"bM\" : [ \"net growth rate of living biomass\" , \"kg/(m\u00b2.d)\" ], \"cM\" : [ \"net growth rate of dead biomass\" , \"kg/(m\u00b2.d)\" ], \"rdt\" : [ \"grain yield\" , \"kg/ha\" ], \"rdtPot\" : [ \"potential grain yield\" , \"kg/ha\" ], \"reallocation\" : [ \"amount of assimilates reallocated to the yield (supply < demand)\" , \"kg/ha\" ], \"respMaint\" : [ \"amount of assimilates consumed by maintainance respiration\" , \"kg/ha\" ], \"manqueAssim\" : [ \"deficit in assimilates (demand - supply)\" , \"kg/ha\" ], # biomass \"biomTotStadeFloraison\" : [ \"total biomass of the plant at the end of the flowering stage\" , \"kg/ha\" ], \"biomTotStadeIp\" : [ \"total biomass at the panicle initiation stage\" , \"kg/ha\" ], \"deltaBiomasseAerienne\" : [ \"increment of aerial biomass in one day\" , \"kg/(ha.d)\" ], \"deltaBiomasseFeuilles\" : [ \"increment of leaf biomass in one day\" , \"kg/(ha.d)\" ], \"biomasseAerienne\" : [ \"total aerial biomass\" , \"kg/ha\" ], \"biomasseVegetative\" : [ \"total vegetative biomass\" , \"kg/ha\" ], \"biomasseTotale\" : [ \"total biomass\" , \"kg/ha\" ], \"biomasseTige\" : [ \"total stem biomass\" , \"kg/ha\" ], \"biomasseRacinaire\" : [ \"total root biomass\" , \"kg/ha\" ], \"biomasseFeuille\" : [ \"total leaf biomass\" , \"kg/ha\" ], \"deltaBiomasseTotale\" : [ \"increment of total biomass in one day\" , \"kg/(ha.d)\" ], # evapotranspiration \"kce\" : [ \"fraction of kc attributable to soil evaporation\" , \"decimal percentage\" ], \"kcp\" : [ \"fraction of kc attributable to plant transpiration\" , \"decimal percentage\" ], \"kcTot\" : [ \"total crop coefficient\" , \"\" ], \"tr\" : [ \"actual crop transpiration\" , \"mm/d\" ], \"trPot\" : [ \"potential crop transpiration\" , \"mm/d\" ], \"trSurf\" : [ \"\" , \"\" ], # water balance \"consoRur\" : [ \"consumption of water stored in the root system\" , \"mm\" ], \"water_gathered_by_mulch\" : [ \"water captured by the mulch in one day\" , \"mm\" ], \"eauDispo\" : [ \"available water, sum of rainfall and total irrigation for the day\" , \"mm\" ], \"eauTranspi\" : [ \"water available for transpiration from the surface reservoir\" , \"mm\" ], \"correctedIrrigation\" : [ \"corrected irrigation amount\" , \"mm/d\" ], \"cstr\" : [ \"drought stress coefficient\" , \"arbitrary unit\" ], \"dayVrac\" : [ \"modulated daily root growth\" , \"mm/day\" ], \"delta_root_tank_capacity\" : [ \"change in root system water reserve\" , \"mm\" ], \"dr\" : [ \"drainage\" , \"mm\" ], \"etm\" : [ \"evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etp\" : [ \"potential evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etr\" : [ \"reference evapotranspiration\" , \"mm/d\" ], \"evap\" : [ \"evaporation from the soil moisture\" , \"mm/d\" ], \"evapPot\" : [ \"potential evaporation from the soil moisture\" , \"mm/d\" ], \"FEMcW\" : [ \"water fraction in soil volume explored by the root system\" , \"none\" ], \"fesw\" : [ \"fraction of available surface water\" , \"decimal percentage\" ], \"irrigTotDay\" : [ \"total irrigation for the day\" , \"mm\" ], \"vRac\" : [ \"reference daily root growth\" , \"mm/day\" ], \"ftsw\" : [ \"fraction of transpirable surface water\" , \"decimal percentage\" ], \"lr\" : [ \"daily water runoff\" , \"mm/d\" ], \"pFact\" : [ \"FAO reference for critical FTSW value for transpiration response\" , \"none\" ], # water tanks \"irrigation_tank_stock\" : [ \"current stock of water in the irrigation tank\" , \"mm\" ], #! renaming stockIrr to irrigation_tank_stock \"mulch_water_stock\" : [ \"water stored in crop residues (mulch)\" , \"mm\" ], #! renaming stockMc to mulch_water_stock \"root_tank_stock\" : [ \"current stock of water in the root system tank\" , \"mm\" ], #! renaming stRu to root_tank_stock \"total_tank_capacity\" : [ \"total capacity of the root system tank\" , \"mm\" ], #! renaming stRuMax to total_tank_capacity \"stRur\" : [ \"\" , \"\" ], # [\"previous season's root system tank stock\",\"mm\"], \"root_tank_capacity_previous_season\" : [ \"previous season's root system tank capacity\" , \"mm\" ], #! renaming stRurMaxPrec to root_tank_capacity_previous_season \"stRurPrec\" : [ \"previous day's root system tank stock\" , \"mm\" ], \"stRurSurf\" : [ \"surface root system tank stock\" , \"mm\" ], \"surface_tank_stock\" : [ \"current stock of water in the surface root system tank\" , \"mm\" ], #! renaming stRuSurf to surface_tank_stock \"stRuSurfPrec\" : [ \"previous day's surface root system tank stock\" , \"mm\" ], \"delta_total_tank_stock\" : [ \"change in the total root system tank stock\" , \"mm\" ], #! renaming stRuVar to delta_total_tank_stock \"irrigation_tank_capacity\" : [ \"irrigation tank capacity\" , \"mm\" ], #! renaming ruIrr to irrigation_tank_capacity \"ruRac\" : [ \"Water column that can potentially be strored in soil volume explored by root system\" , \"mm\" ], \"conv\" : [ \"\" , \"\" ], \"KAssim\" : [ \"\" , \"\" ], \"dayBiomLeaf\" : [ \"daily growth of leaf biomass\" , \"kg/ha/d\" ], \"dRdtPot\" : [ \"daily potential demand from yield\" , \"kg/ha/d\" ], \"FeuilleUp\" : [ \"\" , \"\" ], \"kRespMaint\" : [ \"\" , \"\" ], \"LitFeuille\" : [ \"\" , \"\" ], \"nbJourCompte\" : [ \"\" , \"\" ], \"nbjStress\" : [ \"\" , \"\" ], \"NbUBT\" : [ \"\" , \"\" ], \"sla\" : [ \"\" , \"\" ], \"stockRac\" : [ \"\" , \"\" ], \"sumPP\" : [ \"\" , \"\" ], \"TigeUp\" : [ \"\" , \"\" ], \"UBTCulture\" : [ \"\" , \"\" ], \"lai\" :[ \"leaf area index\" , \"m2/m2\" ], # experimental \"Ncrit\" : [ \"\" , \"\" ], } return variables def initialize_simulation ( data , grid_width , grid_height , duration , paramVariete , paramITK , date_start ): \"\"\" This function initializes variables related to crop growth in the data xarray dataset. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. ![no caption](../../docs/images/sla.png) This code has been adapted from the original InitiationCulture procedure, from the `MilBilanCarbone.pas` code of the SARRA model. Args: data (_type_): _description_ grid_width (_type_): _description_ grid_height (_type_): _description_ duration (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" ### variables to be initialized with values from parameters # from paramVariete : maximum daily thermal time (\u00b0C.j) -> #? unused ? #// data[\"sommeDegresJourMaximale\"] = (data[\"rain\"].dims, np.full( #// (duration, grid_width, grid_height), #// (paramVariete[\"SDJLevee\"] + paramVariete[\"SDJBVP\"] + paramVariete[\"SDJRPR\"] + paramVariete[\"SDJMatu1\"] + paramVariete[\"SDJMatu2\"]) #// )) #// data[\"sommeDegresJourMaximale\"].attrs = {\"units\":\"\u00b0C.j\", \"long_name\":\"Maximum thermal time\"} # from paramITK : sowing date data [ \"sowing_date\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), ( paramITK [ \"DateSemis\" ] - date_start ) . days )) # from paramITK : automatic irrigation indicator data [ \"irrigAuto\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"irrigAuto\" ])) data [ \"irrigAuto\" ] . attrs = { \"units\" : \"binary\" , \"long_name\" : \"automatic irrigation indicator\" } ####### variables qui viennent de initplotMc # Initial biomass of crop residues (mulch) (kg/ha) # Biomasse initiale des r\u00e9sidus de culture (mulch) (kg/ha) # BiomMc := BiomIniMc; data [ \"biomMc\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"biomMc\" ] . attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of crop residues (mulch)\" } # ? # StSurf := StockIniSurf; # data[\"stSurf\"] = np.full((grid_width, grid_height, duration), paramTypeSol[\"stockIniSurf\"]) # ? # Ltr := 1; data [ \"ltr\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), 1.0 )) # Initial biomass of stem residues as litter (kg/ha) # Biomasse initiale des r\u00e9sidus de tiges sous forme de liti\u00e8re (kg/ha) # LitTiges := BiomIniMc; data [ \"LitTige\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"LitTige\" ] . attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of stem residues as litter\" } ####### fin variables qui viennent de initplotMc ####### variables eau depuis InitPlotMc # Initializes variables related to crop residues boimass (mulch) in the data # xarray dataset. This code has been adapted from the original InitPlotMc # procedure, Bileau.pas code. Comments with tab indentation are from the # original code. As the rain is the first variable to be initialized in the # data xarray dataset, its dimensions are used to initialize the other # variables. # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] #// data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock #// data[\"stTot\"] = data[\"stockIniProf\"] #//data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ] . expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock #// data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] ####### fin variables eau depuis InitPlotMc # depuis meteo.pas kpar = 0.5 data [ \"par\" ] = kpar * data [ \"rg\" ] data [ \"par\" ] . attrs = { \"units\" : \"MJ/m2\" , \"long_name\" : \"par\" } # crop density if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rapDensite\" ] = data [ \"rain\" ] * 0 + compute_rapDensite ( paramITK , paramVariete ) data [ \"rapDensite\" ] . attrs = { \"units\" : \"none\" , \"long_name\" : \"sowing density adjustement factor\" } # initialize variables with values at 0 variables = variable_dict () for variable in variables : data [ variable ] = ( data [ \"rain\" ] . dims , np . zeros ( shape = ( duration , grid_width , grid_height ))) data [ variable ] . attrs = { \"units\" : variables [ variable ][ 1 ], \"long_name\" : variables [ variable ][ 0 ]} return data def estimate_kcp ( j , data , paramVariete ): \"\"\" Estimate the kcp coefficient based on the maximum crop coefficient `kcMax` and plant cover `ltr`. The computation of `kcp` is based on the EvolKcpKcIni procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `kcp` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `kcp`. The dataset should contain the following variables: - 'numPhase': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the number of phases in the crop cycle. - 'kcp': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the coefficient of crop growth. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the plant cover. paramVariete (dict): A dictionary containing the parameters for estimating `kcp`. The dictionary should contain the following key: - 'kcMax': A float, representing the maximum crop coefficient. Returns: xarray.Dataset: The updated `data` dataset with the new `kcp` values. \"\"\" data [ \"kcp\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] >= 1 , np . maximum ( 0.3 , paramVariete [ \"kcMax\" ] * ( 1 - data [ \"ltr\" ][ j ,:,:])), data [ \"kcp\" ][ j ,:,:], ) return data def estimate_ltr ( j , data , paramVariete ): \"\"\" Estimate the fraction of radiation transmitted to the soil `ltr` based on the leaf area index `lai`. `ltr` is used as a proxy for plant covering of the soil in the water balance calculation, where 1 represents no plant cover and 0 represents full plant cover. `ltr` is computed as an exponential decay function of `lai` with a decay coefficient `kdf`. This function is adapted from the EvalLtr procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `ltr` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `ltr`. The dataset should contain the following variables: - 'lai': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the leaf area index. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the fraction of radiation transmitted to the soil. paramVariete (dict): A dictionary containing the parameters for estimating `ltr`. The dictionary should contain the following key: - 'kdf': A float, representing the decay coefficient for `ltr`. Returns: xarray.Dataset: The updated `data` dataset with the new `ltr` values. \"\"\" # group 80 data [ \"ltr\" ][ j :,:,:] = np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j ,:,:]) return data def estimate_KAssim ( j , data , paramVariete ): \"\"\" This function calculates the conversion factor `KAssim`, which is used to convert assimilates into biomass. The value of `KAssim` depends on the phase of the crop. The conversion factor is calculated based on a lookup table that maps crop phases to values. The crop phase is determined by the `numPhase` field in the `data` argument, and the corresponding `KAssim` value is set in the `KAssim` field of the `data` argument. Args: j (int): An integer index specifying the time step. data (xarray.Dataset): A dataset containing the variables used in the calculation of `KAssim`. The dataset should include the fields `numPhase`, `sdj`, `seuilTemp PhasePrec`, and `seuilTemp PhaseSuivante`. The `KAssim` field of the dataset will be updated by this function. paramVariete (dict): A dictionary of parameters. It should include the fields `txAssimBVP`, `txAssimMatu1`, and `txAssimMatu2`. Returns: xarray.Dataset: The updated `data` dataset, with the `KAssim` field set to the calculated values. \"\"\" phase_equivalences = { 2 : 1 , 3 : paramVariete [ 'txAssimBVP' ], 4 : paramVariete [ 'txAssimBVP' ], #! replacing sommeDegresJourPhasePrec with seuilTempPhasePrec #// 5: paramVariete[\"txAssimBVP\"] + (data['sdj'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]) * (paramVariete['txAssimMatu1'] - paramVariete['txAssimBVP']) / (data['seuilTempPhaseSuivante'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]), 5 : paramVariete [ \"txAssimBVP\" ] + ( data [ 'sdj' ][ j ,:,:] - data [ 'seuilTempPhasePrec' ][ j ,:,:]) * ( paramVariete [ 'txAssimMatu1' ] - paramVariete [ 'txAssimBVP' ]) / ( data [ 'seuilTempPhaseSuivante' ][ j ,:,:] - data [ 'seuilTempPhasePrec' ][ j ,:,:]), #// 6: paramVariete[\"txAssimMatu1\"] + (data[\"sdj\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]) * (paramVariete[\"txAssimMatu2\"] - paramVariete[\"txAssimMatu1\"]) / (data[\"seuilTempPhaseSuivante\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]), 6 : paramVariete [ \"txAssimMatu1\" ] + ( data [ \"sdj\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]) * ( paramVariete [ \"txAssimMatu2\" ] - paramVariete [ \"txAssimMatu1\" ]) / ( data [ \"seuilTempPhaseSuivante\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]), } for phase in range ( 2 , 7 ): data [ \"KAssim\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == phase , phase_equivalences [ phase ], data [ \"KAssim\" ][ j ,:,:], ) return data def estimate_conv ( j , data , paramVariete ): \"\"\" This function calculates the conversion of assimilates into biomass. The conversion factor is determined by multiplying the KAssim value, which is dependent on the phase of the crop, with the conversion rate (txConversion) specified in the `paramVariete` argument. Args: j (int): The starting index of the calculation data (dict): A dictionary containing information on the crop growth, including the phase of the crop and the KAssim value. paramVariete (dict): A dictionary containing parameters relevant to the crop growth, including the conversion rate. Returns: dict: The input `data` dictionary with the calculated \"conv\" value added. \"\"\" data [ \"conv\" ][ j :,:,:] = ( data [ \"KAssim\" ][ j ,:,:] * paramVariete [ \"txConversion\" ]) return data def BiomDensOptSarraV4 ( j , data , paramITK ): \"\"\" si densit\u00e9 plus faible alors on consid\u00e9re qu'il faut augmenter les biomasses, LAI etc en regard de cette situation au niveau de chaque plante (car tout est rapport\u00e9 \u00e9 des kg/ha). Si elle est plus forte on ne change rien pour lors. Valeur fixe en ref au ma\u00e9s \u00e9 d\u00e9f en param\u00e9tre par vari\u00e9t\u00e9s\u00e9 rapDensite := Max(1, 70000/densite); \"\"\" \"\"\" if ~np.isnan(paramVariete[\"densOpti\"]) : paramITK[\"rapDensite\"] = np.maximum(1,paramVariete[\"densOpti\"]/paramITK[\"densite\"]) data[\"rdt\"][j,:,:] = data[\"rdt\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseRacinaire\"][j,:,:] = data[\"biomasseRacinaire\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseTige\"][j,:,:] = data[\"biomasseTige\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseFeuille\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseAerienne\"][j,:,:] = data[\"biomasseTige\"][j,:,:] + data[\"biomasseFeuille\"][j,:,:] + data[\"rdt\"][j,:,:] data[\"lai\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data[\"biomasseTotale\"][j,:,:] = data[\"biomasseAerienne\"][j,:,:] + data[\"biomasseRacinaire\"][j,:,:] return data \"\"\" return data def compute_rapDensite ( paramITK , paramVariete ): \"\"\" It basically calculates a correction factor (rapDensite). This correction factor Is calculated with an equation of form a + p * exp( -(x/(o / -log((1-a)/p) )) ) with a the densiteA parameter p the densiteP parameter$ x the actual crop density o the densOpti parameter See https://www.wolframalpha.com/input?i=a+%2B+p+*+exp%28-%28x+%2F+%28+o%2F-+log%28%281+-+a%29%2F+p%29%29%29%29 for equation visualization. This equation is probably too complex for the problem at hand. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" rapDensite = paramVariete [ \"densiteA\" ] + paramVariete [ \"densiteP\" ] * np . exp ( - ( paramITK [ \"densite\" ] / ( paramVariete [ \"densOpti\" ] /- np . log (( 1 - paramVariete [ 'densiteA' ]) / paramVariete [ \"densiteP\" ])))) return rapDensite def adjust_for_sowing_density ( j , data , paramVariete , direction ): \"\"\" This function translates the effect of sowing density on biomass and LAI. This function is adapted from the BiomDensOptSarV42 and BiomDensiteSarraV42 procedures, from the bilancarbonsarra.pas original Pascal code. Notes from CB : if density is lower than the optimal density, then we consider that we need to increase the biomass, LAI etc in regard of this situation at each plant level (because everything is related to kg/ha). If it is higher, it increases asymptotically. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" if direction == \"in\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rdt\" ][ j :,:,:] = data [ \"rdt\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:] data [ \"rdtPot\" ][ j :,:,:] = ( data [ \"rdtPot\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseRacinaire\" ][ j :,:,:] = ( data [ \"biomasseRacinaire\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseTige\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseFeuille\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:]) data [ \"lai\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] * data [ \"sla\" ][ j ,:,:]) data [ \"biomasseTotale\" ][ j :,:,:] = ( data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"biomasseRacinaire\" ][ j ,:,:]) return data if direction == \"out\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]): data [ \"rdt\" ][ j :,:,:] = ( data [ \"rdt\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"rdtPot\" ][ j :,:,:] = ( data [ \"rdtPot\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseRacinaire\" ][ j :,:,:] = ( data [ \"biomasseRacinaire\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseTige\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseFeuille\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:]) #? conflit avec fonction evolLAIphase ? #data[\"lai\"][j:,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data [ \"lai\" ][ j :,:,:] = data [ \"lai\" ][ j :,:,:] / data [ \"rapDensite\" ][ j ,:,:] data [ \"biomasseTotale\" ][ j :,:,:] = ( data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"biomasseRacinaire\" ][ j ,:,:]) #[...,np.newaxis] #data[\"biomasseTotale\"][j:,:,:] = data[\"biomasseTotale\"][j:,:,:] / data[\"rapDensite\"] return data def EvalAssimSarrahV4 ( j , data ): \"\"\" data[\"parIntercepte\"][j,:,:] = 0.5 * (1 - data[\"ltr\"][j,:,:]) * data[\"rg\"][j,:,:] data[\"assimPot\"][j:,:,:] = data[\"parIntercepte\"][j,:,:] * data[\"conv\"][j,:,:] * 10 data[\"assim\"][j,:,:] = np.where( data[\"trPot\"][j,:,:] > 0, data[\"assimPot\"][j,:,:] * data[\"tr\"][j,:,:] / data[\"trPot\"][j,:,:], 0, ) \"\"\" return data def update_assimPot ( j , data , paramVariete , paramITK ): \"\"\" Update the assimPot value based on the intensification level (NI). If the intensification level `NI` is defined in `paramITK`, the conversion rate `txConversion` is computed using a formula based on `NIYo`, `NIp`, `LGauss`, and `AGauss`. If `NI` is not defined, `assimPot` is updated using `conv`, which is updated in the `estimate_conv` function using the variables `KAssim` and `txConversion`. When NI parameter is used (from to 4), conversion rate txConversion is computed using the following formula : NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) This function is adapted from the `EvalAssimSarraV42` procedure in the `bilancarbonsarra.pas` file of the original Pascal code. Note from CB : correction of the conversion rate depending on the intensification level notes from CB reharding the EvalAssimSarraV42 procedure : Modif du 04/03/2021 : Prise en compte en plus de la densit\ufffd de semis de l'effet niveau d'intensification NI NI = 1 quand on est \ufffd l'optimum du niveau d'intensification. Dans le cas de situation contr\ufffdl\ufffd c'est la fertilit\ufffd qui est la clef principale en prenant en r\ufffdf\ufffdrence la qt\ufffd d'azote (\ufffdquivalent phosphore...) optimum Il peut aller \ufffd 0 ou \ufffdtre sup\ufffdrieur \ufffd 1 si situation sur optimum, ie un peu plus de rdt mais \ufffd cout trop \ufffdlev\ufffd... On \ufffdvalue un nouveau tx de conversion en fn du Ni au travers d'une double \ufffdquation : asympote x gaussienne invers\ufffde Et d'un NI d\ufffdfini en fn du sc\ufffdnario de simulation ou des donn\ufffdes observ\ufffdes. NIYo = D\ufffdcalage en Y de l'asymptote NIp = pente de l'asymptote LGauss = Largeur de la Guaussienne AGauss = Amplitude de la Guaussienne Conversion qui est la valeur du taux de conversion en situation optimum n'a plus besoin d'\ufffdtre utilis\ufffd sinon dans la calibration des param\ufffdtres de cette \ufffdquation en absence de donn\ufffdes sur ces param\ufffdtres on ne met aucune valeur \ufffd NI CF fichier ex IndIntensite_txConv_eq.xls} Args: - j (int): An index that represents the current iteration. - data (dict): A dictionary containing data arrays with the following keys: - \"assimPot\" (np.ndarray): An array representing the potential assimilation rate. - \"par\" (np.ndarray): An array representing photosynthetically active radiation. - \"lai\" (np.ndarray): An array representing the leaf area index. - \"conv\" (np.ndarray): An array representing the conversion rate. - paramVariete (dict): A dictionary containing parameters for the computation of the conversion rate, including: - \"txConversion\" (float): The conversion rate. - \"NIYo\" (float): The shift in the Y-axis of the asymptote. - \"NIp\" (float): The slope of the asymptote. - \"LGauss\" (float): The width of the Gaussian curve. - \"AGauss\" (float): The amplitude of the Gaussian curve. - \"kdf\" (float): The constant used in the computation of `assimPot`. - paramITK (dict): A dictionary containing the intensification level `NI` (float). Returns: - data (dict): The input `data` dictionary with the updated \"assimPot\" array. \"\"\" if ~ np . isnan ( paramITK [ \"NI\" ]): #? the following (stupidly long) line was found commented, need to check why and if this is correct paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ])) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ]) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ])) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) # NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) data [ \"assimPot\" ][ j ,:,:] = data [ \"par\" ][ j ,:,:] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j ,:,:])) * \\ paramVariete [ \"txConversion\" ] * 10 else : data [ \"assimPot\" ][ j ,:,:] = data [ \"par\" ][ j ,:,:] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j ,:,:])) * \\ data [ \"conv\" ][ j ,:,:] * 10 return data def update_assim ( j , data ): \"\"\" This function updates assim. If trPot (potential transpiration from the plant, mm) is greater than 0, then assim equals assimPot, multiplied by the ratio of effective transpiration over potential transpiration. If potential transpiration is null, then assim is null as well. Is it adapted from the EvalAssimSarraV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"assim\" ][ j ,:,:] = np . where ( data [ \"trPot\" ][ j ,:,:] > 0 , data [ \"assimPot\" ][ j ,:,:] * data [ \"tr\" ][ j ,:,:] / data [ \"trPot\" ][ j ,:,:], 0 , ) return data def calculate_maintainance_respiration ( j , data , paramVariete ): \"\"\" This function calculates the maintenance respiration `respMaint` (in kg/ha/j in equivalent dry matter) of the plant. The maintenance respiration is calculated by summing the maintenance respiration associated with total biomass and leaves biomass. If the plant's growth phase is above 4 and there is no leaf biomass, `respMaint` is set to 0. The calculation is based on the equation: coefficient_temp = 2^((average_temp - tempMaint) / 10) respiration = kRespMaint * biomass * coefficient_temp where `average_temp` is the average temperature for the day, `tempMaint` is the maintenance temperature from `variety_params`, `kRespMaint` is the maintenance respiration coefficient from `variety_params`, and `biomass` is the total or leaf biomass. Args: j (int): The time step of the calculation. data (xarray.Dataset): The input data containing the variables `tpMoy`, `biomasseTotale`, `biomasseFeuille`, and `numPhase`. The output `respMaint` will also be stored in this dataset. variety_params (dict): The parameters related to the plant variety, containing the keys `tempMaint` and `kRespMaint`. Returns: xarray.Dataset: The input `data` with the updated `respMaint` variable. \"\"\" coefficient_temp = 2 ** (( data [ \"tpMoy\" ][ j ,:,:] - paramVariete [ \"tempMaint\" ]) / 10 ) resp_totale = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseTotale\" ][ j ,:,:] * coefficient_temp resp_feuille = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseFeuille\" ][ j ,:,:] * coefficient_temp data [ \"respMaint\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 4 ) & ( data [ \"biomasseFeuille\" ][ j ,:,:] == 0 ), 0 , resp_totale + resp_feuille , ) return data def update_total_biomass ( j , data , paramVariete , paramITK ): \"\"\" Update the Total Biomass of the Plant. The total biomass is updated based on the plant's current phase and other parameters. If the plant is in phase 2 and there's a change in phase, the total biomass is initialized using crop density, grain yield per plant, and the dry weight of the grain. If the plant is not in phase 2 or there's no change in phase, the total biomass is incremented with the difference between the plant's assimilation and maintenance respiration. When passing from phase 1 to phase 2, total biomass is initialized. Initialization value is computed from crop density (plants/ha), txResGrain (grain yield per plant), and poidsSecGrain. Otherwise, total biomass is incremented with the difference between plant assimilation assim and maintainance respiration respMaint. This function is adapted from the EvolBiomTotSarrahV4 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): The current time step. data (xarray.Dataset): The data for the plant, including variables like \"biomasseTotale\", \"assim\", \"respMaint\", \"numPhase\", and \"changePhase\". paramVariete (dict): A dictionary of parameters specific to the plant variety. paramITK (dict): A dictionary of inter-tropical convergence zone parameters. Returns: xarray.Dataset: The updated data for the plant, including the updated \"biomasseTotale\" and \"deltaBiomasseTotale\" variables. \"\"\" data [ \"biomasseTotale\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), paramITK [ \"densite\" ] * np . maximum ( 1 , paramVariete [ 'densOpti' ] / paramITK [ 'densite' ]) * paramVariete [ \"txResGrain\" ] * paramVariete [ \"poidsSecGrain\" ] / 1000 , data [ \"biomasseTotale\" ][ j ,:,:] + ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]), ) # we may want to drop this variable and use the raw computation instead data [ \"deltaBiomasseTotale\" ][ j :,:,:] = ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]) return data def update_total_biomass_stade_ip ( j , data ): \"\"\" Update the total biomass of the plant at the end of the vegetative phase (ip = \"initiation paniculaire\"). If the plant has reached phase 4 and has just changed phase, the current total biomass will be copied to the \"biomTotStadeIp\" variable, which represents the total biomass at the end of the vegetative phase (initiation paniculaire). This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): Timestep index. data (xarray.Dataset): Input dataset. Returns: xarray.Dataset: The updated dataset with the \"biomTotStadeIp\" variable updated. \"\"\" data [ \"biomTotStadeIp\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 4 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeIp\" ][ j ,:,:], ) return data def update_total_biomass_at_flowering_stage ( j , data ): \"\"\" This function updates the total biomass of the plant at the end of the flowering stage (biomTotStadeFloraison). If the plant is in phase 5, and the phase has changed, then the total biomass is copied to the biomTotStadeFloraison variable. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomTotStadeFloraison\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeFloraison\" ][ j ,:,:], ) return data def update_potential_yield ( j , data , paramVariete ): \"\"\" Update the potential yield of the plant. The potential yield is initialized as an affine function of the delta between the end of the vegetative phase and the end of the flowering stage, plus a linear function of the total biomass at the end of the flowering stage. The potential yield is capped to twice the biomass of the stem to avoid unrealistic values. The update occurs if the plant is in phase 5 and its phase has changed This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): An index representing the current time step. data (xarray.Dataset): A dataset containing plant data. paramVariete (dict): A dictionary containing parameters for the plant variety. Returns: xarray.Dataset: The input `data` with the potential yield updated. \"\"\" delta_biomass_flowering_ip = data [ \"biomTotStadeFloraison\" ][ j ,:,:] - data [ \"biomTotStadeIp\" ][ j ,:,:] data [ \"rdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), ( paramVariete [ \"KRdtPotA\" ] * delta_biomass_flowering_ip + paramVariete [ \"KRdtPotB\" ]) + paramVariete [ \"KRdtBiom\" ] * data [ \"biomTotStadeFloraison\" ][ j ,:,:], data [ \"rdtPot\" ][ j ,:,:], ) #! phaseDevVeg pas utilis\u00e9 ? attention c'est un param\u00e8tre vari\u00e9tal et pas un jeu de don\u00e9es data [ \"rdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) & ( data [ \"rdtPot\" ][ j ,:,:] > data [ \"biomasseTige\" ][ j ,:,:] * 2 ) & ( paramVariete [ \"phaseDevVeg\" ] < 6 ), data [ \"biomasseTige\" ][ j ,:,:] * 2 , data [ \"rdtPot\" ][ j ,:,:], ) return data def update_potential_yield_delta ( j , data , paramVariete ): \"\"\" This function updates the delta potential yield (dRdtPot) of the plant, which is the rate at which the plant's yield is changing over time. The delta potential yield is calculated as the product of the potential yield, the ratio of actual degree days to maturity, and the ratio of actual transpiration to potential transpiration. The calculation is only done if the plant is in phase 5 and the potential transpiration is above 0. If the potential transpiration is not above 0, the delta potential yield is set to 0. For all other phases, the delta potential yield is unchanged. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: - j (int): an integer index, representing the current step of the simulation - data (xarray dataset): the simulation data, including the current state of the plant - paramVariete (dict): the variety-specific parameters used in the simulation Returns: - data (xarray dataset): the updated simulation data, including the updated delta potential yield \"\"\" data [ \"dRdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ), np . where ( ( data [ \"trPot\" ][ j ,:,:] > 0 ), np . maximum ( data [ \"rdtPot\" ][ j ,:,:] * ( data [ \"ddj\" ][ j ,:,:] / paramVariete [ \"SDJMatu1\" ]) * ( data [ \"tr\" ][ j ,:,:] / data [ \"trPot\" ][ j ,:,:]), data [ \"respMaint\" ][ j ,:,:] * 0.15 , ), 0 , ), data [ \"dRdtPot\" ][ j ,:,:], ) return data def update_aboveground_biomass ( j , data , paramVariete ): \"\"\" Update the aboveground biomass of the plant. The aboveground biomass is either updated based on a linear function of the total biomass, if the plant is in phase 2, 3, or 4, or incremented with the total biomass delta if the plant is in any other phase. This function is based on the EvolBiomAeroSarrahV3 procedure, of the ***bilancarbonsarra***, exmodules 1 & 2.pas file from the original Pascal code. Args: j (int): The current iteration step in the simulation. data (xarray.Dataset): The simulation data, including the current phase of the plant and various biomass values. paramVariete (dict): The parameters of the plant variety. Returns: xarray.Dataset: The updated simulation data, including the updated aboveground biomass and delta aboveground biomass. \"\"\" #// data[\"deltaBiomasseAerienne\"][j:,:,:] = np.copy(data[\"biomasseAerienne\"][j,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & ( data [ \"numPhase\" ][ j ,:,:] <= 4 ), np . minimum ( 0.9 , paramVariete [ \"aeroTotPente\" ] * data [ \"biomasseTotale\" ][ j ,:,:] + paramVariete [ \"aeroTotBase\" ]) * data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"deltaBiomasseTotale\" ][ j ,:,:], ) #//data[\"deltaBiomasseAerienne\"][j:,:,:] = (data[\"biomasseAerienne\"][j,:,:] - data[\"deltaBiomasseAerienne\"][j,:,:])#[...,np.newaxis] data [ \"deltaBiomasseAerienne\" ][ j :,:,:] = data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j - 1 ,:,:] return data def estimate_reallocation ( j , data , paramVariete ): \"\"\" Estimate the daily biomass reallocation between stem and leaves. This function computes the daily biomass reallocation between stem and leaves for the plant. The computation only occurs when the plant is in phase 5. The amount of biomass that can be reallocated is estimated as follows: 1. The difference between the potential yield delta and the aboveground biomass delta, bound by 0, is calculated and referred to as manqueAssim. manqueAssim represents the daily variation in biomass that remains after the plant has built its aboveground biomass. 2. The reallocation is computed as the minimum of the product of manqueAssim and the reallocation rate and the difference between the leaf biomass and 30, also bound by 0. The value of 30 is an arbitrary threshold which ensures that reallocation is 0 if the leaf biomass is below 30. If the leaf biomass is above 30, reallocation is bounded by biomasseFeuille - 30. If the plant is not in phase 5, reallocation is set to 0. This function is based on the EvalReallocationSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (int): Current time step of the simulation. data (xarray.Dataset): The dataset containing all the simulation data. paramVariete (dict): A dictionary containing the parameters for the simulation. Returns: xarray.Dataset: The updated dataset with the reallocation values. \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] == 5 ) data [ \"manqueAssim\" ][ j :,:,:] = np . where ( condition , np . maximum ( 0 , ( data [ \"dRdtPot\" ][ j ,:,:] - np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j ,:,:]))), 0 , ) data [ \"reallocation\" ][ j :,:,:] = np . where ( condition , np . minimum ( data [ \"manqueAssim\" ][ j ,:,:] * paramVariete [ \"txRealloc\" ], np . maximum ( 0.0 , data [ \"biomasseFeuille\" ][ j ,:,:] - 30 ), ), 0 , ) return data def update_root_biomass ( j , data ): \"\"\" Update the root biomass (biomasseRacinaire) for a given time step. The root biomass is computed as the difference between the total biomass and the aboveground biomass. This function is based on the EvalBiomasseRacinaire procedure, of the milbilancarbone, exmodules 1 & 2, ***milbilancarbone***.pas file from the original Pascal code Args: j (int): Time step index. data (xarray.Dataset): Input dataset containing relevant variables. Returns: xarray.Dataset: Updated dataset with the root biomass variable. \"\"\" data [ \"biomasseRacinaire\" ][ j ,:,:] = data [ \"biomasseTotale\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j ,:,:] return data def update_leaf_biomass ( j , data , paramVariete ): \"\"\" For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the leaf biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by the reallocation rate in leaves. This value is bound in 0.00000001. Otherwise, the leaf biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseFeuille\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ), np . maximum ( 0.00000001 , data [ \"biomasseFeuille\" ][ j ,:,:] - ( data [ \"reallocation\" ][ j ,:,:] - data [ \"deltaBiomasseAerienne\" ][ j ,:,:]) * paramVariete [ \"pcReallocFeuille\" ] ), data [ \"biomasseFeuille\" ][ j ,:,:], ) return data def update_stem_biomass ( j , data , paramVariete ): \"\"\" For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the stem biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by (1-reallocation rate in leaves) (if it's not leaves, it's stems...). This value is bound in 0.00000001. Otherwise, the stem biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 122 data [ \"biomasseTige\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ), np . maximum ( 0.00000001 , data [ \"biomasseTige\" ][ j ,:,:] - ( data [ \"reallocation\" ][ j ,:,:] - data [ \"deltaBiomasseAerienne\" ][ j ,:,:]) * ( 1 - paramVariete [ \"pcReallocFeuille\" ]), ), data [ \"biomasseTige\" ][ j ,:,:], ) return data def condition_positive_delta_biomass ( j , data , paramVariete ): condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & \\ ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] >= 0 ) & \\ (( data [ \"numPhase\" ][ j ,:,:] <= 4 ) | ( data [ \"numPhase\" ][ j ,:,:] <= paramVariete [ \"phaseDevVeg\" ])) # (data[\"numPhase\"][j,:,:] <= 4) return condition def update_bM_and_cM ( j , data , paramVariete ): \"\"\" This function returns the updated values of bM and cM. bM and cM are updated if the delta of aerial biomass is positive, meaning that the plant is gaining aerial biomass, and if the phase is above 1 and below 4 or the phase is below the vegetative phase. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas files from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"bM\" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), paramVariete [ \"feuilAeroBase\" ] - 0.1 , data [ \"bM\" ][ j ,:,:], ) data [ \"cM\" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), (( paramVariete [ \"feuilAeroPente\" ] * 1000 ) / data [ \"bM\" ][ j ,:,:] + 0.78 ) / 0.75 , data [ \"cM\" ][ j ,:,:], ) return data def update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ): \"\"\" Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseFeuille\" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), ( 0.1 + data [ \"bM\" ][ j ,:,:] * data [ \"cM\" ][ j ,:,:] ** (( data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"rdt\" ][ j ,:,:]) / 1000 )) \\ * ( data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"rdt\" ][ j ,:,:]), data [ \"biomasseFeuille\" ][ j ,:,:], ) return data def update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseTige\" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"biomasseFeuille\" ][ j ,:,:] - data [ \"rdt\" ][ j ,:,:], data [ \"biomasseTige\" ][ j ,:,:], ) return data def condition_positive_delta_aboveground_biomass_all_phases ( j , data ): #// condition = (data[\"numPhase\"][j,:,:] > 1) & (data[\"deltaBiomasseAerienne\"][j,:,:] >= 0) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] > 0 ) return condition def update_leaf_biomass_all_phases ( j , data , paramVariete ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseFeuille\" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ), data [ \"biomasseFeuille\" ][ j ,:,:] - data [ \"reallocation\" ][ j ,:,:] * paramVariete [ \"pcReallocFeuille\" ], data [ \"biomasseFeuille\" ][ j ,:,:], ) return data def update_stem_biomass_all_phases ( j , data , paramVariete ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseTige\" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ), data [ \"biomasseTige\" ][ j ,:,:] - ( data [ \"reallocation\" ][ j ,:,:] * ( 1 - paramVariete [ \"pcReallocFeuille\" ])), data [ \"biomasseTige\" ][ j ,:,:], ) return data def update_aboveground_biomass_step_2 ( j , data ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseAerienne\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ), data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:], data [ \"biomasseAerienne\" ][ j ,:,:], ) return data def EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ): \"\"\" This function is a wrapper It is adapted from the EvalFeuilleTigeSarrahV4 procedure from the bilancarbonsarra.pas file of the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" # data[\"deltaBiomasseFeuilles\"][j:,:,:] = np.where( # (data[\"numPhase\"][j,:,:] > 1), # data[\"biomasseFeuille\"][j,:,:], # data[\"deltaBiomasseFeuilles\"][j,:,:], # ) # if (data[\"numPhase\"][j,:,:] > 1) & (data[\"deltaBiomasseAerienne\"][j,:,:] < 0) data = update_leaf_biomass ( j , data , paramVariete ) data = update_stem_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne >= 0 and (numPhase <= 4 or numPhase <= phaseDevVeg) data = update_bM_and_cM ( j , data , paramVariete ) data = update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) data = update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne > 0 and numPhase > 1 data = update_leaf_biomass_all_phases ( j , data , paramVariete ) data = update_stem_biomass_all_phases ( j , data , paramVariete ) # condition = (data[\"numPhase\"][j,:,:] > 1) # data[\"deltaBiomasseFeuilles\"][j:,:,:] = np.where( # (data[\"numPhase\"][j,:,:] > 1), # data[\"biomasseFeuille\"][j,:,:] - data[\"deltaBiomasseFeuilles\"][j,:,:], # data[\"deltaBiomasseFeuilles\"][j,:,:], # ) # simpler formulation for updating the deltaBiomasseFeuilles data [ \"deltaBiomasseFeuilles\" ][ j :,:,:] = data [ \"biomasseFeuille\" ][ j ,:,:] - data [ \"biomasseFeuille\" ][ j - 1 ,:,:] data = update_aboveground_biomass_step_2 ( j , data ) return data def update_vegetative_biomass ( j , data ): \"\"\"_summary_ This function is adapted from the EvalBiomasseVegetati procedure from the copie milbilancarbon, exmodules 1 & 2, ***milbilancarbone*** file of the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseVegetative\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:]) return data def calculate_canopy_specific_leaf_area ( j , data , paramVariete ): \"\"\" Calculate the specific leaf area (SLA) of the canopy. If the leaf biomass is positive, and if we are at the transition day between phases 1 and 2 (numPhase = 2 and changePhase = 1), then the SLA is set to `slaMax`. If the leaf biomass is positive and increasing (deltaBiomasseFeuilles is positive), the SLA for existing leaves is calculated by reducing it by an amount proportional to the current SLA, while the SLA for new leaves is calculated as the average between SLA and `slaMax`. The SLA for the entire canopy is then calculated as the weighted average of the SLAs for existing and new leaves. If there is no increase in leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for existing leaves is calculated. If the leaf biomass is negative, the SLA is unchanged. The calculated SLA value is bounded between `slaMin` and `slaMax`. This function is adapted from the EvalSlaSarrahV3 procedure in the bilancarbonsarra.pas and exmodules 1 & 2.pas files of the original Pascal code. This calculation method assumes that young leaves have a higher SLA than old leaves and that the fraction of young leaves makes the canopy SLA increase. The `penteSLA` parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between `slaMax` and `slaMin`). Expected parameters: SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax This function estimates the specific leaf area (SLA) of the canopy. First, if the leaf biomass is positive, if numPhase = 2 and changePhase = 1, which means we are at the transition day between phases 1 and 2, sla is set to be equal to slaMax. Then, if the leaf biomass is positive, and if deltaBiomasseFeuilles is positive (meaning that the leaf biomass is increasing), SLA for already existing leaves is calculated by removing a value that is an affine function of SLA itself, and SLA for new leaves is calculated as the mean between SLA and slaMax ; then the SLA is calculated as the weighted mean of the two SLA values. Logically, if there is no newly produced leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for already existing leaves is calculated. If biomasseFeuille is negative, SLA is unchanged. Finally, if biomasseFeuille is positive, SLA value is bounded between slaMin and slaMax. This function is adapted from the EvalSlaSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas file of the original Pascal code. We note that multiple versions of the calculation methods have been used in the original procecure. We may want to go back to that if this function is problematic. Notes : In this approach, it is assumed that young leaves have a higher SLA than old leaves. The fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between SLAmax and SLAmin). This approach is known for legumes, but can also be adapted to other species. Generic/expected parameters : SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax Args: - j (int): The time step. - data (xarray.Dataset): The data for all variables. - paramVariete (dict): Parameters for the calculation. Returns: - data (xarray.Dataset): The updated data with the calculated SLA. \"\"\" condition = ( data [ \"biomasseFeuille\" ][ j ,:,:] > 0 ) & \\ ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"sla\" ][ j :,:,:] = np . where ( condition , paramVariete [ \"slaMax\" ], data [ \"sla\" ][ j ,:,:], ) ratio_old_leaf_biomass = data [ \"biomasseFeuille\" ][ j - 1 ,:,:] / data [ \"biomasseFeuille\" ][ j ,:,:] ratio_new_leaf_biomass = data [ \"deltaBiomasseFeuilles\" ][ j ,:,:] / data [ \"biomasseFeuille\" ][ j ,:,:] sla_decrease_step = paramVariete [ \"slaPente\" ] * ( data [ \"sla\" ][ j ,:,:] - paramVariete [ \"slaMin\" ]) # Modif du 10/07/2018, DeltaBiomasse neg si reallocation ne pas fair l'evol du SLA dans ces conditions data [ \"sla\" ][ j :,:,:] = np . where ( ( data [ \"biomasseFeuille\" ][ j ,:,:] > 0 ), np . where ( ( data [ \"deltaBiomasseFeuilles\" ][ j ,:,:] > 0 ), #// (data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] - data[\"deltaBiomasseFeuilles\"][j,:,:]) / data[\"biomasseFeuille\"][j,:,:] + (paramVariete[\"slaMax\"] + data[\"sla\"][j,:,:])/2 * (data[\"deltaBiomasseFeuilles\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j ,:,:] - sla_decrease_step ) * ratio_old_leaf_biomass + ( paramVariete [ \"slaMax\" ] + data [ \"sla\" ][ j ,:,:]) / 2 * ratio_new_leaf_biomass , #//(data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j ,:,:] - sla_decrease_step ) * ratio_old_leaf_biomass , ), data [ \"sla\" ][ j ,:,:], ) data [ \"sla\" ][ j :,:,:] = np . where ( ( data [ \"biomasseFeuille\" ][ j ,:,:] > 0 ), #// np.minimum(paramVariete[\"slaMin\"], np.maximum(paramVariete[\"slaMax\"], data[\"sla\"][j,:,:])), # according to original # according to ocelet version np . minimum ( paramVariete [ \"slaMax\" ], np . maximum ( paramVariete [ \"slaMin\" ], data [ \"sla\" ][ j ,:,:], ), ), data [ \"sla\" ][ j ,:,:], ) return data def calculate_leaf_area_index ( j , data ): \"\"\" Calculate the leaf area index (LAI) for a given time step. If the number of growth phase (numPhase) is less than or equal to 1, the LAI is set to 0. If the number of growth phase is between 2 and 6, the LAI is calculated as the product of the leaf biomass (biomasseFeuille) and specific leaf area (sla). If the number of growth phase is greater than 6, the LAI is set back to 0. This function is adapted from the EvolLAIPhases procedure from the milbilancarbone.pas and exmodules 1 & 2.pas file of the original Pascal code. Args: timestep (int): The time step to calculate the LAI for. data (xarray.Dataset): The xarray dataset that contains the relevant data. Returns: xarray.Dataset: The updated xarray dataset with the calculated LAI. \"\"\" data [ \"lai\" ][ j :,:,:] = xr . where ( ( data [ \"numPhase\" ][ j ,:,:] <= 1 ), 0 , np . where ( data [ \"numPhase\" ][ j ,:,:] <= 6 , data [ \"biomasseFeuille\" ][ j ,:,:] * data [ \"sla\" ][ j ,:,:], 0 , ) ) return data def update_yield_during_filling_phase ( j , data ): \"\"\" This function updates the yield value during the filling phase. During the filling phase (numPhase == 5), the yield is updated by incrementing it with the sum of `deltaBiomasseAerienne` and `reallocation`, bounded by 0 and `dRdtPot` (daily potential yield). The construction of yield is done during phase 5 only, from the variation of aerial biomass and reallocation, with a maximum of `dRdtPot`. This function is adapted from the EvolDayRdtSarraV3 procedure from the ***bilancarbonesarra***, exmodules 1 & 2.pas file of the original Pascal code. Notes : On tend vers le potentiel en fn du rapport des degresJours/sumDegresJours pour la phase de remplissage. Frein sup fn du flux de s\u00e8ve estim\u00e9 par le rapport Tr/TrPot. dRdtPot = RdtPotDuJour Args: j (int): The time step at which the calculation starts. data (xarray.Dataset): The data that contains all variables. Returns: xarray.Dataset: The input data with updated yield values. \"\"\" data [ \"rdt\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ), data [ \"rdt\" ][ j ,:,:] + np . minimum ( data [ \"dRdtPot\" ][ j ,:,:], np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j ,:,:]) + data [ 'reallocation' ][ j ,:,:]), data [ \"rdt\" ][ j ,:,:], ) return data def BiomDensiteSarraV42 ( j , data , paramITK , paramVariete ): # depuis bilancarbonsarra.pas if ~ np . isnan ( paramVariete [ \"densOpti\" ]): data [ \"rdt\" ][ j :,:,:] = ( data [ \"rdt\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"rdtPot\" ][ j :,:,:] = ( data [ \"rdtPot\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseRacinaire\" ][ j :,:,:] = ( data [ \"biomasseRacinaire\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseTige\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseFeuille\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseAerienne\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:]) #? conflit avec fonction evolLAIphase ? #data[\"lai\"][j:,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data [ \"lai\" ][ j :,:,:] = data [ \"lai\" ][ j :,:,:] / data [ \"rapDensite\" ] data [ \"biomasseTotale\" ][ j :,:,:] = ( data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"biomasseRacinaire\" ][ j ,:,:]) #[...,np.newaxis] #data[\"biomasseTotale\"][j:,:,:] = data[\"biomasseTotale\"][j:,:,:] / data[\"rapDensite\"] return data def BiomMcUBTSV3 ( j , data , paramITK ): \"\"\" depuis bilancarbonsarra.pas group 174 Pendant la croissance des cultures la d\ufffdgradation des r\ufffdsidusest calcul\ufffde sans les UBT Ici c'est pendant la saion s\ufffdche quand il n'y a des cultures pas de b\ufffdtes. Sur le mulch dress\ufffd (Up) ou couch\ufffd Lit), on calcul sa d\ufffdgradation journali\ufffdre sur les feuilles et les tiges en fn de coef KN (climat, termites...), KI ingestion par les b\ufffdtes pression en UBT seulement pour les feuilles, KT (effet pi\ufffdtinement) qui va faire passer du stade lev\ufffd en couch\ufffd et du stade couch\ufffd en ensevelissement pression en UBT Par D\ufffdfaut : KNUp = 0.001 /jour KNLit = 0.011 KN est soit une constante soit peut varier en fn climat (pas fait ref STEP) KT = 0.003 KI = 0.005 NbUBT = 10 (zone Fakara) \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] > 0 ) # group 161 data [ \"UBTCulture\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"NbUBT\" ][ j ,:,:]) #[...,np.newaxis] # group 162 data [ \"LitFeuille\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:], data [ \"LitFeuille\" ][ j ,:,:]) #[...,np.newaxis] # group 163 data [ \"LitTige\" ][ j :,:,:] = np . where ( condition , data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:], data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # group 164 data [ \"FeuilleUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"FeuilleUp\" ][ j ,:,:]) #[...,np.newaxis] # group 165 data [ \"TigeUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"TigeUp\" ][ j ,:,:]) #[...,np.newaxis] # group 166 data [ \"biomMc\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:], data [ \"biomMc\" ][ j ,:,:]) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges dress\ufffdes # FeuilleUp := max(0, (FeuilleUp - FeuilleUp * KNUp - FeuilleUp * KI * UBTCulture - FeuilleUp * KT * UBTCulture)); # group 167 data [ \"FeuilleUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"FeuilleUp\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"FeuilleUp\" ][ j ,:,:] \\ * paramITK [ \"KI\" ] * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 168 # TigeUp := max(0, (TigeUp - TigeUp * KNUp - TigeUp * KT * UBTCulture)); data [ \"TigeUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"TigeUp\" ][ j ,:,:] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges couch\ufffdes (liti\ufffdre) # group 169 # LitFeuille := max(0, (LitFeuille - LitFeuille * KNLit - LitFeuille * KI * UBTCulture - LitFeuille * KT * UBTCulture)); data [ \"LitFeuille\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitFeuille\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KI\" ] \\ * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 170 # LitTige := max(0, (LitTige - LitTige * KNLit - LitTige * KT * UBTCulture)); data [ \"LitTige\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitTige\" ][ j ,:,:] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 171 #BiomMc := LitFeuille + LitTige; data [ \"biomMc\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # #// transfert dress\ufffd \ufffd liti\ufffdre effet pi\ufffdtinement # LitFeuille := LitFeuille + FeuilleUp * KT * UBTCulture; # group 172 data [ \"LitFeuille\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # LitTige := LitTige + TigeUp * KT * UBTCulture; # group 173 data [ \"LitTige\" ][ j :,:,:] = ( data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # // le 01/03 on consid\ufffdre que toutes les pailles et feuilles dressees sont couchees # if (trunc(DayOfTheYear(DateEnCours)) = 61) then # begin # LitFeuille := LitFeuille + FeuilleUp; # LitTige := LitTige + TigeUp; # FeuilleUp := 0; # TigeUp := 0; # BiomMc := LitFeuille + LitTige; # end; return data def MAJBiomMcSV3 ( data ): \"\"\" groupe 182 A la Recolte, on calcul la part des biomasses qui restent sur place (Up), non r\ufffdcolt\ufffdes et la part qui est mise \ufffd terre (Liti\ufffdre) sur ce qui est laiss\ufffd sur place On met a jour aussi la biomasse des liti\ufffdres pour les calculs effet mulch sue lr bilan hydrique \"\"\" # if (NumPhase =7) then # begin # groupe 175 # FeuilleUp := FeuilleUp + BiomasseFeuilles * (1-TxRecolte); # groupe 176 # TigeUp := TigeUp + BiomasseTiges * (1-TxRecolte); # groupe 177 # LitFeuille := LitFeuille + FeuilleUp * TxaTerre; # groupe 178 # LitTige := LitTige + TigeUp * TxaTerre; # groupe 179 # FeuilleUp := FeuilleUp * (1-TxaTerre); # groupe 180 # TigeUp := TigeUp * (1-TxaTerre); # // LitTige := LitTige + BiomMc; # groupe 181 # BiomMC := LitFeuille + LitTige; # { BiomasseFeuilles := 0; # BiomasseTiges := 0; return data def estimate_critical_nitrogen_concentration ( j , data ): # estimate critical nitrogen concentration from plant dry matter using the Justes et al (1994) relationship data [ \"Ncrit\" ][ j ,:,:] = 5.35 * ( data [ \"biomasseTotale\" ][ j ,:,:] / 1000 ) ** ( - 0.44 ) return data Functions BiomDensOptSarraV4 def BiomDensOptSarraV4 ( j , data , paramITK ) si densit\u00e9 plus faible alors on consid\u00e9re qu'il faut augmenter les biomasses, LAI etc en regard de cette situation au niveau de chaque plante (car tout est rapport\u00e9 \u00e9 des kg/ha). Si elle est plus forte on ne change rien pour lors. Valeur fixe en ref au ma\u00e9s \u00e9 d\u00e9f en param\u00e9tre par vari\u00e9t\u00e9s\u00e9 rapDensite := Max(1, 70000/densite); View Source def BiomDensOptSarraV4 ( j , data , paramITK ): \"\"\" si densit\u00e9 plus faible alors on consid\u00e9re qu'il faut augmenter les biomasses, LAI etc en regard de cette situation au niveau de chaque plante (car tout est rapport\u00e9 \u00e9 des kg/ha). Si elle est plus forte on ne change rien pour lors. Valeur fixe en ref au ma\u00e9s \u00e9 d\u00e9f en param\u00e9tre par vari\u00e9t\u00e9s\u00e9 rapDensite := Max(1, 70000/densite); \"\"\" \"\"\" if ~np.isnan(paramVariete[\"densOpti\"]) : paramITK[\"rapDensite\"] = np.maximum(1,paramVariete[\"densOpti\"]/paramITK[\"densite\"]) data[\"rdt\"][j,:,:] = data[\"rdt\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseRacinaire\"][j,:,:] = data[\"biomasseRacinaire\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseTige\"][j,:,:] = data[\"biomasseTige\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseFeuille\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseAerienne\"][j,:,:] = data[\"biomasseTige\"][j,:,:] + data[\"biomasseFeuille\"][j,:,:] + data[\"rdt\"][j,:,:] data[\"lai\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data[\"biomasseTotale\"][j,:,:] = data[\"biomasseAerienne\"][j,:,:] + data[\"biomasseRacinaire\"][j,:,:] return data \"\"\" return data BiomDensiteSarraV42 def BiomDensiteSarraV42 ( j , data , paramITK , paramVariete ) View Source def BiomDensiteSarraV42 ( j , data , paramITK , paramVariete ) : # depuis bilancarbonsarra . pas if ~ np . isnan ( paramVariete [ \" densOpti \" ] ) : data [ \" rdt \" ][ j :,:,:] = ( data [ \" rdt \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" rdtPot \" ][ j :,:,:] = ( data [ \" rdtPot \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseRacinaire \" ][ j :,:,:] = ( data [ \" biomasseRacinaire \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseTige \" ][ j :,:,:] = ( data [ \" biomasseTige \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseFeuille \" ][ j :,:,:] = ( data [ \" biomasseFeuille \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseAerienne \" ][ j :,:,:] = ( data [ \" biomasseTige \" ][ j ,:,:] + data [ \" biomasseFeuille \" ][ j ,:,:] + data [ \" rdt \" ][ j ,:,:] ) #? conflit avec fonction evolLAIphase ? # data [ \" lai \" ][ j :,:,:] = data [ \" biomasseFeuille \" ][ j ,:,:] * data [ \" sla \" ][ j ,:,:] data [ \" lai \" ][ j :,:,:] = data [ \" lai \" ][ j :,:,:] / data [ \" rapDensite \" ] data [ \" biomasseTotale \" ][ j :,:,:] = ( data [ \" biomasseAerienne \" ][ j ,:,:] + data [ \" biomasseRacinaire \" ][ j ,:,:] ) #[..., np . newaxis ] # data [ \" biomasseTotale \" ][ j :,:,:] = data [ \" biomasseTotale \" ][ j :,:,:] / data [ \" rapDensite \" ] return data BiomMcUBTSV3 def BiomMcUBTSV3 ( j , data , paramITK ) depuis bilancarbonsarra.pas group 174 Pendant la croissance des cultures la d\ufffdgradation des r\ufffdsidusest calcul\ufffde sans les UBT Ici c'est pendant la saion s\ufffdche quand il n'y a des cultures pas de b\ufffdtes. Sur le mulch dress\ufffd (Up) ou couch\ufffd Lit), on calcul sa d\ufffdgradation journali\ufffdre sur les feuilles et les tiges en fn de coef KN (climat, termites...), KI ingestion par les b\ufffdtes pression en UBT seulement pour les feuilles, KT (effet pi\ufffdtinement) qui va faire passer du stade lev\ufffd en couch\ufffd et du stade couch\ufffd en ensevelissement pression en UBT Par D\ufffdfaut : KNUp = 0.001 /jour KNLit = 0.011 KN est soit une constante soit peut varier en fn climat (pas fait ref STEP) KT = 0.003 KI = 0.005 NbUBT = 10 (zone Fakara) View Source def BiomMcUBTSV3 ( j , data , paramITK ): \"\"\" depuis bilancarbonsarra.pas group 174 Pendant la croissance des cultures la d\ufffdgradation des r\ufffdsidusest calcul\ufffde sans les UBT Ici c'est pendant la saion s\ufffdche quand il n'y a des cultures pas de b\ufffdtes. Sur le mulch dress\ufffd (Up) ou couch\ufffd Lit), on calcul sa d\ufffdgradation journali\ufffdre sur les feuilles et les tiges en fn de coef KN (climat, termites...), KI ingestion par les b\ufffdtes pression en UBT seulement pour les feuilles, KT (effet pi\ufffdtinement) qui va faire passer du stade lev\ufffd en couch\ufffd et du stade couch\ufffd en ensevelissement pression en UBT Par D\ufffdfaut : KNUp = 0.001 /jour KNLit = 0.011 KN est soit une constante soit peut varier en fn climat (pas fait ref STEP) KT = 0.003 KI = 0.005 NbUBT = 10 (zone Fakara) \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] > 0 ) # group 161 data [ \"UBTCulture\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"NbUBT\" ][ j ,:,:]) #[...,np.newaxis] # group 162 data [ \"LitFeuille\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:], data [ \"LitFeuille\" ][ j ,:,:]) #[...,np.newaxis] # group 163 data [ \"LitTige\" ][ j :,:,:] = np . where ( condition , data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:], data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # group 164 data [ \"FeuilleUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"FeuilleUp\" ][ j ,:,:]) #[...,np.newaxis] # group 165 data [ \"TigeUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"TigeUp\" ][ j ,:,:]) #[...,np.newaxis] # group 166 data [ \"biomMc\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:], data [ \"biomMc\" ][ j ,:,:]) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges dress\ufffdes # FeuilleUp := max(0, (FeuilleUp - FeuilleUp * KNUp - FeuilleUp * KI * UBTCulture - FeuilleUp * KT * UBTCulture)); # group 167 data [ \"FeuilleUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"FeuilleUp\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"FeuilleUp\" ][ j ,:,:] \\ * paramITK [ \"KI\" ] * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 168 # TigeUp := max(0, (TigeUp - TigeUp * KNUp - TigeUp * KT * UBTCulture)); data [ \"TigeUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"TigeUp\" ][ j ,:,:] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges couch\ufffdes (liti\ufffdre) # group 169 # LitFeuille := max(0, (LitFeuille - LitFeuille * KNLit - LitFeuille * KI * UBTCulture - LitFeuille * KT * UBTCulture)); data [ \"LitFeuille\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitFeuille\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KI\" ] \\ * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 170 # LitTige := max(0, (LitTige - LitTige * KNLit - LitTige * KT * UBTCulture)); data [ \"LitTige\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitTige\" ][ j ,:,:] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 171 #BiomMc := LitFeuille + LitTige; data [ \"biomMc\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # #// transfert dress\ufffd \ufffd liti\ufffdre effet pi\ufffdtinement # LitFeuille := LitFeuille + FeuilleUp * KT * UBTCulture; # group 172 data [ \"LitFeuille\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # LitTige := LitTige + TigeUp * KT * UBTCulture; # group 173 data [ \"LitTige\" ][ j :,:,:] = ( data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # // le 01/03 on consid\ufffdre que toutes les pailles et feuilles dressees sont couchees # if (trunc(DayOfTheYear(DateEnCours)) = 61) then # begin # LitFeuille := LitFeuille + FeuilleUp; # LitTige := LitTige + TigeUp; # FeuilleUp := 0; # TigeUp := 0; # BiomMc := LitFeuille + LitTige; # end; return data EvalAssimSarrahV4 def EvalAssimSarrahV4 ( j , data ) data[\"parIntercepte\"][j,:,:] = 0.5 * (1 - data[\"ltr\"][j,:,:]) * data[\"rg\"][j,:,:] data[\"assimPot\"][j:,:,:] = data[\"parIntercepte\"][j,:,:] * data[\"conv\"][j,:,:] * 10 data[\"assim\"][j,:,:] = np.where( data[\"trPot\"][j,:,:] > 0, data[\"assimPot\"][j,:,:] * data[\"tr\"][j,:,:] / data[\"trPot\"][j,:,:], 0, ) View Source def EvalAssimSarrahV4 ( j , data ) : \"\"\" data [ \" parIntercepte \" ][ j ,:,:] = 0 . 5 * ( 1 - data [ \" ltr \" ][ j ,:,:] ) * data [ \" rg \" ][ j ,:,:] data [ \" assimPot \" ][ j :,:,:] = data [ \" parIntercepte \" ][ j ,:,:] * data [ \" conv \" ][ j ,:,:] * 10 data [ \" assim \" ][ j ,:,:] = np . where ( data [ \" trPot \" ][ j ,:,:] > 0 , data [ \" assimPot \" ][ j ,:,:] * data [ \" tr \" ][ j ,:,:] / data [ \" trPot \" ][ j ,:,:], 0 , ) \"\"\" return data EvalFeuilleTigeSarrahV4 def EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) This function is a wrapper It is adapted from the EvalFeuilleTigeSarrahV4 procedure from the bilancarbonsarra.pas file of the original Pascal code. Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) : \"\"\" This function is a wrapper It is adapted from the EvalFeuilleTigeSarrahV4 procedure from the bilancarbonsarra . pas file of the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # data [ \" deltaBiomasseFeuilles \" ][ j :,:,:] = np . where ( # ( data [ \" numPhase \" ][ j ,:,:] > 1 ) , # data [ \" biomasseFeuille \" ][ j ,:,:], # data [ \" deltaBiomasseFeuilles \" ][ j ,:,:], # ) # if ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] < 0 ) data = update_leaf_biomass ( j , data , paramVariete ) data = update_stem_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne >= 0 and ( numPhase <= 4 or numPhase <= phaseDevVeg ) data = update_bM_and_cM ( j , data , paramVariete ) data = update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) data = update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne > 0 and numPhase > 1 data = update_leaf_biomass_all_phases ( j , data , paramVariete ) data = update_stem_biomass_all_phases ( j , data , paramVariete ) # condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) # data [ \" deltaBiomasseFeuilles \" ][ j :,:,:] = np . where ( # ( data [ \" numPhase \" ][ j ,:,:] > 1 ) , # data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" deltaBiomasseFeuilles \" ][ j ,:,:], # data [ \" deltaBiomasseFeuilles \" ][ j ,:,:], # ) # simpler formulation for updating the deltaBiomasseFeuilles data [ \" deltaBiomasseFeuilles \" ][ j :,:,:] = data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" biomasseFeuille \" ][ j - 1 ,:,:] data = update_aboveground_biomass_step_2 ( j , data ) return data MAJBiomMcSV3 def MAJBiomMcSV3 ( data ) groupe 182 A la Recolte, on calcul la part des biomasses qui restent sur place (Up), non r\ufffdcolt\ufffdes et la part qui est mise \ufffd terre (Liti\ufffdre) sur ce qui est laiss\ufffd sur place On met a jour aussi la biomasse des liti\ufffdres pour les calculs effet mulch sue lr bilan hydrique View Source def MAJBiomMcSV3 ( data ) : \"\"\" groupe 182 A la Recolte, on calcul la part des biomasses qui restent sur place (Up), non r\ufffdcolt\ufffdes et la part qui est mise \ufffd terre (Liti\ufffdre) sur ce qui est laiss\ufffd sur place On met a jour aussi la biomasse des liti\ufffdres pour les calculs effet mulch sue lr bilan hydrique \"\"\" # if ( NumPhase = 7 ) then # begin # groupe 175 # FeuilleUp := FeuilleUp + BiomasseFeuilles * ( 1 - TxRecolte ); # groupe 176 # TigeUp := TigeUp + BiomasseTiges * ( 1 - TxRecolte ); # groupe 177 # LitFeuille := LitFeuille + FeuilleUp * TxaTerre ; # groupe 178 # LitTige := LitTige + TigeUp * TxaTerre ; # groupe 179 # FeuilleUp := FeuilleUp * ( 1 - TxaTerre ); # groupe 180 # TigeUp := TigeUp * ( 1 - TxaTerre ); # // LitTige := LitTige + BiomMc ; # groupe 181 # BiomMC := LitFeuille + LitTige ; # { BiomasseFeuilles := 0 ; # BiomasseTiges := 0 ; return data adjust_for_sowing_density def adjust_for_sowing_density ( j , data , paramVariete , direction ) This function translates the effect of sowing density on biomass and LAI. This function is adapted from the BiomDensOptSarV42 and BiomDensiteSarraV42 procedures, from the bilancarbonsarra.pas original Pascal code. Notes from CB : if density is lower than the optimal density, then we consider that we need to increase the biomass, LAI etc in regard of this situation at each plant level (because everything is related to kg/ha). If it is higher, it increases asymptotically. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def adjust_for_sowing_density ( j , data , paramVariete , direction ) : \"\"\" This function translates the effect of sowing density on biomass and LAI . This function is adapted from the BiomDensOptSarV42 and BiomDensiteSarraV42 procedures , from the bilancarbonsarra . pas original Pascal code . Notes from CB : if density is lower than the optimal density , then we consider that we need to increase the biomass , LAI etc in regard of this situation at each plant level ( because everything is related to kg / ha ). If it is higher , it increases asymptotically . Args: j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns: _type_: _description_ \"\"\" if direction == \"in\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rdt\" ][ j: , : , : ] = data [ \"rdt\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ] data [ \"rdtPot\" ][ j: , : , : ] = ( data [ \"rdtPot\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseRacinaire\" ][ j: , : , : ] = ( data [ \"biomasseRacinaire\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseTige\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseFeuille\" ][ j: , : , : ] = ( data [ \"biomasseFeuille\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseAerienne\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] + data [ \"biomasseFeuille\" ][ j , : , : ] + data [ \"rdt\" ][ j , : , : ]) data [ \"lai\" ][ j: , : , : ] = ( data [ \"biomasseFeuille\" ][ j , : , : ] * data [ \"sla\" ][ j , : , : ]) data [ \"biomasseTotale\" ][ j: , : , : ] = ( data [ \"biomasseAerienne\" ][ j , : , : ] + data [ \"biomasseRacinaire\" ][ j , : , : ]) return data if direction == \"out\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rdt\" ][ j: , : , : ] = ( data [ \"rdt\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"rdtPot\" ][ j: , : , : ] = ( data [ \"rdtPot\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseRacinaire\" ][ j: , : , : ] = ( data [ \"biomasseRacinaire\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseTige\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseFeuille\" ][ j: , : , : ] = ( data [ \"biomasseFeuille\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseAerienne\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] + data [ \"biomasseFeuille\" ][ j , : , : ] + data [ \"rdt\" ][ j , : , : ]) # ? conflit avec fonction evolLAIphase ? # data [ \"lai\" ][ j: , : , : ] = data [ \"biomasseFeuille\" ][ j , : , : ] * data [ \"sla\" ][ j , : , : ] data [ \"lai\" ][ j: , : , : ] = data [ \"lai\" ][ j: , : , : ] / data [ \"rapDensite\" ][ j , : , : ] data [ \"biomasseTotale\" ][ j: , : , : ] = ( data [ \"biomasseAerienne\" ][ j , : , : ] + data [ \"biomasseRacinaire\" ][ j , : , : ])#[..., np . newaxis ] # data [ \"biomasseTotale\" ][ j: , : , : ] = data [ \"biomasseTotale\" ][ j: , : , : ] / data [ \"rapDensite\" ] return data calculate_canopy_specific_leaf_area def calculate_canopy_specific_leaf_area ( j , data , paramVariete ) Calculate the specific leaf area (SLA) of the canopy. If the leaf biomass is positive, and if we are at the transition day between phases 1 and 2 (numPhase = 2 and changePhase = 1), then the SLA is set to slaMax . If the leaf biomass is positive and increasing (deltaBiomasseFeuilles is positive), the SLA for existing leaves is calculated by reducing it by an amount proportional to the current SLA, while the SLA for new leaves is calculated as the average between SLA and slaMax . The SLA for the entire canopy is then calculated as the weighted average of the SLAs for existing and new leaves. If there is no increase in leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for existing leaves is calculated. If the leaf biomass is negative, the SLA is unchanged. The calculated SLA value is bounded between slaMin and slaMax . This function is adapted from the EvalSlaSarrahV3 procedure in the bilancarbonsarra.pas and exmodules 1 & 2.pas files of the original Pascal code. This calculation method assumes that young leaves have a higher SLA than old leaves and that the fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between slaMax and slaMin ). Expected parameters: SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax This function estimates the specific leaf area (SLA) of the canopy. First, if the leaf biomass is positive, if numPhase = 2 and changePhase = 1, which means we are at the transition day between phases 1 and 2, sla is set to be equal to slaMax. Then, if the leaf biomass is positive, and if deltaBiomasseFeuilles is positive (meaning that the leaf biomass is increasing), SLA for already existing leaves is calculated by removing a value that is an affine function of SLA itself, and SLA for new leaves is calculated as the mean between SLA and slaMax ; then the SLA is calculated as the weighted mean of the two SLA values. Logically, if there is no newly produced leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for already existing leaves is calculated. If biomasseFeuille is negative, SLA is unchanged. Finally, if biomasseFeuille is positive, SLA value is bounded between slaMin and slaMax. This function is adapted from the EvalSlaSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas file of the original Pascal code. We note that multiple versions of the calculation methods have been used in the original procecure. We may want to go back to that if this function is problematic. Notes : In this approach, it is assumed that young leaves have a higher SLA than old leaves. The fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between SLAmax and SLAmin). This approach is known for legumes, but can also be adapted to other species. Generic/expected parameters : SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax Args: - j (int): The time step. - data (xarray.Dataset): The data for all variables. - paramVariete (dict): Parameters for the calculation. Returns: - data (xarray.Dataset): The updated data with the calculated SLA. View Source def calculate_canopy_specific_leaf_area ( j , data , paramVariete ) : \" \"\" Calculate the specific leaf area (SLA) of the canopy. If the leaf biomass is positive, and if we are at the transition day between phases 1 and 2 (numPhase = 2 and changePhase = 1), then the SLA is set to `slaMax`. If the leaf biomass is positive and increasing (deltaBiomasseFeuilles is positive), the SLA for existing leaves is calculated by reducing it by an amount proportional to the current SLA, while the SLA for new leaves is calculated as the average between SLA and `slaMax`. The SLA for the entire canopy is then calculated as the weighted average of the SLAs for existing and new leaves. If there is no increase in leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for existing leaves is calculated. If the leaf biomass is negative, the SLA is unchanged. The calculated SLA value is bounded between `slaMin` and `slaMax`. This function is adapted from the EvalSlaSarrahV3 procedure in the bilancarbonsarra.pas and exmodules 1 & 2.pas files of the original Pascal code. This calculation method assumes that young leaves have a higher SLA than old leaves and that the fraction of young leaves makes the canopy SLA increase. The `penteSLA` parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between `slaMax` and `slaMin`). Expected parameters: SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax This function estimates the specific leaf area (SLA) of the canopy. First, if the leaf biomass is positive, if numPhase = 2 and changePhase = 1, which means we are at the transition day between phases 1 and 2, sla is set to be equal to slaMax. Then, if the leaf biomass is positive, and if deltaBiomasseFeuilles is positive (meaning that the leaf biomass is increasing), SLA for already existing leaves is calculated by removing a value that is an affine function of SLA itself, and SLA for new leaves is calculated as the mean between SLA and slaMax ; then the SLA is calculated as the weighted mean of the two SLA values. Logically, if there is no newly produced leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for already existing leaves is calculated. If biomasseFeuille is negative, SLA is unchanged. Finally, if biomasseFeuille is positive, SLA value is bounded between slaMin and slaMax. This function is adapted from the EvalSlaSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas file of the original Pascal code. We note that multiple versions of the calculation methods have been used in the original procecure. We may want to go back to that if this function is problematic. Notes : In this approach, it is assumed that young leaves have a higher SLA than old leaves. The fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between SLAmax and SLAmin). This approach is known for legumes, but can also be adapted to other species. Generic/expected parameters : SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax Args: - j (int): The time step. - data (xarray.Dataset): The data for all variables. - paramVariete (dict): Parameters for the calculation. Returns: - data (xarray.Dataset): The updated data with the calculated SLA. \"\" \" condition = ( data [ \"biomasseFeuille\" ][ j , : , : ] > 0 ) & \\ ( data [ \"numPhase\" ][ j , : , : ] == 2 ) & \\ ( data [ \"changePhase\" ][ j , : , : ] == 1 ) data [ \"sla\" ][ j : , : , : ] = np . where ( condition , paramVariete [ \"slaMax\" ] , data [ \"sla\" ][ j , : , : ] , ) ratio_old_leaf_biomass = data [ \"biomasseFeuille\" ][ j - 1 , : , : ] / data [ \"biomasseFeuille\" ][ j , : , : ] ratio_new_leaf_biomass = data [ \"deltaBiomasseFeuilles\" ][ j , : , : ] / data [ \"biomasseFeuille\" ][ j , : , : ] sla_decrease_step = paramVariete [ \"slaPente\" ] * ( data [ \"sla\" ][ j , : , : ] - paramVariete [ \"slaMin\" ] ) # Modif du 10/07/2018, DeltaBiomasse neg si reallocation ne pas fair l'evol du SLA dans ces conditions data [ \"sla\" ][ j : , : , : ] = np . where ( ( data [ \"biomasseFeuille\" ][ j , : , : ] > 0 ), np . where ( ( data [ \"deltaBiomasseFeuilles\" ][ j , : , : ] > 0 ), #// (data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] - data[\"deltaBiomasseFeuilles\"][j,:,:]) / data[\"biomasseFeuille\"][j,:,:] + (paramVariete[\"slaMax\"] + data[\"sla\"][j,:,:])/2 * (data[\"deltaBiomasseFeuilles\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j , : , : ] - sla_decrease_step ) * ratio_old_leaf_biomass + ( paramVariete [ \"slaMax\" ] + data [ \"sla\" ][ j , : , : ] ) / 2 * ratio_new_leaf_biomass , #//(data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j , : , : ] - sla_decrease_step ) * ratio_old_leaf_biomass , ), data [ \"sla\" ][ j , : , : ] , ) data [ \"sla\" ][ j : , : , : ] = np . where ( ( data [ \"biomasseFeuille\" ][ j , : , : ] > 0 ), #// np.minimum(paramVariete[\"slaMin\"], np.maximum(paramVariete[\"slaMax\"], data[\"sla\"][j,:,:])), # according to original # according to ocelet version np . minimum ( paramVariete [ \"slaMax\" ] , np . maximum ( paramVariete [ \"slaMin\" ] , data [ \"sla\" ][ j , : , : ] , ), ), data [ \"sla\" ][ j , : , : ] , ) return data calculate_leaf_area_index def calculate_leaf_area_index ( j , data ) Calculate the leaf area index (LAI) for a given time step. If the number of growth phase (numPhase) is less than or equal to 1, the LAI is set to 0. If the number of growth phase is between 2 and 6, the LAI is calculated as the product of the leaf biomass (biomasseFeuille) and specific leaf area (sla). If the number of growth phase is greater than 6, the LAI is set back to 0. This function is adapted from the EvolLAIPhases procedure from the milbilancarbone.pas and exmodules 1 & 2.pas file of the original Pascal code. Parameters: Name Type Description Default timestep int The time step to calculate the LAI for. None data xarray.Dataset The xarray dataset that contains the relevant data. None Returns: Type Description xarray.Dataset The updated xarray dataset with the calculated LAI. View Source def calculate_leaf_area_index ( j , data ) : \"\"\" Calculate the leaf area index ( LAI ) for a given time step . If the number of growth phase ( numPhase ) is less than or equal to 1 , the LAI is set to 0 . If the number of growth phase is between 2 and 6 , the LAI is calculated as the product of the leaf biomass ( biomasseFeuille ) and specific leaf area ( sla ) . If the number of growth phase is greater than 6 , the LAI is set back to 0 . This function is adapted from the EvolLAIPhases procedure from the milbilancarbone . pas and exmodules 1 & 2 . pas file of the original Pascal code . Args : timestep ( int ) : The time step to calculate the LAI for . data ( xarray . Dataset ) : The xarray dataset that contains the relevant data . Returns : xarray . Dataset : The updated xarray dataset with the calculated LAI . \"\"\" data [ \" lai \" ][ j :,:,:] = xr . where ( ( data [ \" numPhase \" ][ j ,:,:] <= 1 ) , 0 , np . where ( data [ \" numPhase \" ][ j ,:,:] <= 6 , data [ \" biomasseFeuille \" ][ j ,:,:] * data [ \" sla \" ][ j ,:,:], 0 , ) ) return data calculate_maintainance_respiration def calculate_maintainance_respiration ( j , data , paramVariete ) This function calculates the maintenance respiration respMaint (in kg/ha/j in equivalent dry matter) of the plant. The maintenance respiration is calculated by summing the maintenance respiration associated with total biomass and leaves biomass. If the plant's growth phase is above 4 and there is no leaf biomass, respMaint is set to 0. The calculation is based on the equation: coefficient_temp = 2^((average_temp - tempMaint) / 10) respiration = kRespMaint * biomass * coefficient_temp where average_temp is the average temperature for the day, tempMaint is the maintenance temperature from variety_params , kRespMaint is the maintenance respiration coefficient from variety_params , and biomass is the total or leaf biomass. Parameters: Name Type Description Default j int The time step of the calculation. None data xarray.Dataset The input data containing the variables tpMoy , biomasseTotale , biomasseFeuille , and numPhase . The output respMaint will also be stored in this dataset. None variety_params dict The parameters related to the plant variety, containing the keys tempMaint and kRespMaint . None Returns: Type Description xarray.Dataset The input data with the updated respMaint variable. View Source def calculate_maintainance_respiration ( j , data , paramVariete ) : \" \"\" This function calculates the maintenance respiration `respMaint` (in kg/ha/j in equivalent dry matter) of the plant. The maintenance respiration is calculated by summing the maintenance respiration associated with total biomass and leaves biomass. If the plant's growth phase is above 4 and there is no leaf biomass, `respMaint` is set to 0. The calculation is based on the equation: coefficient_temp = 2^((average_temp - tempMaint) / 10) respiration = kRespMaint * biomass * coefficient_temp where `average_temp` is the average temperature for the day, `tempMaint` is the maintenance temperature from `variety_params`, `kRespMaint` is the maintenance respiration coefficient from `variety_params`, and `biomass` is the total or leaf biomass. Args: j (int): The time step of the calculation. data (xarray.Dataset): The input data containing the variables `tpMoy`, `biomasseTotale`, `biomasseFeuille`, and `numPhase`. The output `respMaint` will also be stored in this dataset. variety_params (dict): The parameters related to the plant variety, containing the keys `tempMaint` and `kRespMaint`. Returns: xarray.Dataset: The input `data` with the updated `respMaint` variable. \"\" \" coefficient_temp = 2 ** (( data [ \"tpMoy\" ][ j , : , : ] - paramVariete [ \"tempMaint\" ] ) / 10 ) resp_totale = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseTotale\" ][ j , : , : ] * coefficient_temp resp_feuille = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseFeuille\" ][ j , : , : ] * coefficient_temp data [ \"respMaint\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] > 4 ) & ( data [ \"biomasseFeuille\" ][ j , : , : ] == 0 ), 0 , resp_totale + resp_feuille , ) return data compute_rapDensite def compute_rapDensite ( paramITK , paramVariete ) It basically calculates a correction factor (rapDensite). This correction factor Is calculated with an equation of form a + p * exp( -(x/(o / -log((1-a)/p) )) ) with a the densiteA parameter p the densiteP parameter$ x the actual crop density o the densOpti parameter See https://www.wolframalpha.com/input?i=a+%2B+p+*+exp%28-%28x+%2F+%28+o%2F-+log%28%281+-+a%29%2F+p%29%29%29%29 for equation visualization. This equation is probably too complex for the problem at hand. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def compute_rapDensite ( paramITK , paramVariete ) : \"\"\" It basically calculates a correction factor (rapDensite). This correction factor Is calculated with an equation of form a + p * exp( -(x/(o / -log((1-a)/p) )) ) with a the densiteA parameter p the densiteP parameter$ x the actual crop density o the densOpti parameter See https://www.wolframalpha.com/input?i=a+%2B+p+*+exp%28-%28x+%2F+%28+o%2F-+log%28%281+-+a%29%2F+p%29%29%29%29 for equation visualization. This equation is probably too complex for the problem at hand. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" rapDensite = paramVariete [ \"densiteA\" ] + paramVariete [ \"densiteP\" ] * np . exp ( - ( paramITK [ \"densite\" ] / ( paramVariete [ \"densOpti\" ] /- np . log (( 1 - paramVariete [ ' densiteA ' ]) / paramVariete [ \"densiteP\" ])))) return rapDensite condition_positive_delta_aboveground_biomass_all_phases def condition_positive_delta_aboveground_biomass_all_phases ( j , data ) View Source def condition_positive_delta_aboveground_biomass_all_phases ( j , data ) : # // condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] >= 0 ) condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] > 0 ) return condition condition_positive_delta_biomass def condition_positive_delta_biomass ( j , data , paramVariete ) View Source def condition_positive_delta_biomass ( j , data , paramVariete ) : condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & \\ ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] >= 0 ) & \\ (( data [ \" numPhase \" ][ j ,:,:] <= 4 ) | ( data [ \" numPhase \" ][ j ,:,:] <= paramVariete [ \" phaseDevVeg \" ] )) # ( data [ \" numPhase \" ][ j ,:,:] <= 4 ) return condition estimate_KAssim def estimate_KAssim ( j , data , paramVariete ) This function calculates the conversion factor KAssim , which is used to convert assimilates into biomass. The value of KAssim depends on the phase of the crop. The conversion factor is calculated based on a lookup table that maps crop phases to values. The crop phase is determined by the numPhase field in the data argument, and the corresponding KAssim value is set in the KAssim field of the data argument. Parameters: Name Type Description Default j int An integer index specifying the time step. None data xarray.Dataset A dataset containing the variables used in the calculation of KAssim . The dataset should include the fields numPhase , sdj , seuilTemp PhasePrec , and seuilTemp PhaseSuivante . The KAssim field of the dataset will be updated by this function. None paramVariete dict A dictionary of parameters. It should include the fields txAssimBVP , txAssimMatu1 , and txAssimMatu2 . None Returns: Type Description xarray.Dataset The updated data dataset, with the KAssim field set to the calculated values. View Source def estimate_KAssim ( j , data , paramVariete ) : \" \"\" This function calculates the conversion factor `KAssim`, which is used to convert assimilates into biomass. The value of `KAssim` depends on the phase of the crop. The conversion factor is calculated based on a lookup table that maps crop phases to values. The crop phase is determined by the `numPhase` field in the `data` argument, and the corresponding `KAssim` value is set in the `KAssim` field of the `data` argument. Args: j (int): An integer index specifying the time step. data (xarray.Dataset): A dataset containing the variables used in the calculation of `KAssim`. The dataset should include the fields `numPhase`, `sdj`, `seuilTemp PhasePrec`, and `seuilTemp PhaseSuivante`. The `KAssim` field of the dataset will be updated by this function. paramVariete (dict): A dictionary of parameters. It should include the fields `txAssimBVP`, `txAssimMatu1`, and `txAssimMatu2`. Returns: xarray.Dataset: The updated `data` dataset, with the `KAssim` field set to the calculated values. \"\" \" phase_equivalences = { 2 : 1 , 3 : paramVariete [ 'txAssimBVP' ] , 4 : paramVariete [ 'txAssimBVP' ] , #! replacing sommeDegresJourPhasePrec with seuilTempPhasePrec #// 5: paramVariete[\"txAssimBVP\"] + (data['sdj'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]) * (paramVariete['txAssimMatu1'] - paramVariete['txAssimBVP']) / (data['seuilTempPhaseSuivante'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]), 5 : paramVariete [ \"txAssimBVP\" ] + ( data [ 'sdj' ][ j , : , : ] - data [ 'seuilTempPhasePrec' ][ j , : , : ] ) * ( paramVariete [ 'txAssimMatu1' ] - paramVariete [ 'txAssimBVP' ] ) / ( data [ 'seuilTempPhaseSuivante' ][ j , : , : ] - data [ 'seuilTempPhasePrec' ][ j , : , : ] ), #// 6: paramVariete[\"txAssimMatu1\"] + (data[\"sdj\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]) * (paramVariete[\"txAssimMatu2\"] - paramVariete[\"txAssimMatu1\"]) / (data[\"seuilTempPhaseSuivante\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]), 6 : paramVariete [ \"txAssimMatu1\" ] + ( data [ \"sdj\" ][ j , : , : ] - data [ \"seuilTempPhasePrec\" ][ j , : , : ] ) * ( paramVariete [ \"txAssimMatu2\" ] - paramVariete [ \"txAssimMatu1\" ] ) / ( data [ \"seuilTempPhaseSuivante\" ][ j , : , : ] - data [ \"seuilTempPhasePrec\" ][ j , : , : ] ), } for phase in range ( 2 , 7 ) : data [ \"KAssim\" ][ j : , : , : ] = np . where ( data [ \"numPhase\" ][ j , : , : ] == phase , phase_equivalences [ phase ] , data [ \"KAssim\" ][ j , : , : ] , ) return data estimate_conv def estimate_conv ( j , data , paramVariete ) This function calculates the conversion of assimilates into biomass. The conversion factor is determined by multiplying the KAssim value, which is dependent on the phase of the crop, with the conversion rate (txConversion) specified in the paramVariete argument. Parameters: Name Type Description Default j int The starting index of the calculation None data dict A dictionary containing information on the crop growth, including the phase of the crop and the KAssim value. None paramVariete dict A dictionary containing parameters relevant to the crop growth, including the conversion rate. None Returns: Type Description dict The input data dictionary with the calculated \"conv\" value added. View Source def estimate_conv ( j , data , paramVariete ) : \" \"\" This function calculates the conversion of assimilates into biomass. The conversion factor is determined by multiplying the KAssim value, which is dependent on the phase of the crop, with the conversion rate (txConversion) specified in the `paramVariete` argument. Args: j (int): The starting index of the calculation data (dict): A dictionary containing information on the crop growth, including the phase of the crop and the KAssim value. paramVariete (dict): A dictionary containing parameters relevant to the crop growth, including the conversion rate. Returns: dict: The input `data` dictionary with the calculated \" conv \" value added. \"\" \" data [ \"conv\" ][ j : , : , : ] = ( data [ \"KAssim\" ][ j , : , : ] * paramVariete [ \"txConversion\" ] ) return data estimate_critical_nitrogen_concentration def estimate_critical_nitrogen_concentration ( j , data ) View Source def estimate_critical_nitrogen_concentration ( j , data ) : # estimate critical nitrogen concentration from plant dry matter using the Justes et al ( 1994 ) relationship data [ \" Ncrit \" ][ j ,:,:] = 5 . 35 * ( data [ \" biomasseTotale \" ][ j ,:,:] / 1000 ) ** ( - 0 . 44 ) return data estimate_kcp def estimate_kcp ( j , data , paramVariete ) Estimate the kcp coefficient based on the maximum crop coefficient kcMax and plant cover ltr . The computation of kcp is based on the EvolKcpKcIni procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Parameters: Name Type Description Default j int The starting index for updating kcp in the data dataset. None data xarray.Dataset A dataset containing the data used in the computation of kcp . The dataset should contain the following variables: - 'numPhase': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the number of phases in the crop cycle. - 'kcp': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the coefficient of crop growth. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the plant cover. None paramVariete dict A dictionary containing the parameters for estimating kcp . The dictionary should contain the following key: - 'kcMax': A float, representing the maximum crop coefficient. None Returns: Type Description xarray.Dataset The updated data dataset with the new kcp values. View Source def estimate_kcp ( j , data , paramVariete ) : \" \"\" Estimate the kcp coefficient based on the maximum crop coefficient `kcMax` and plant cover `ltr`. The computation of `kcp` is based on the EvolKcpKcIni procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `kcp` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `kcp`. The dataset should contain the following variables: - 'numPhase': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the number of phases in the crop cycle. - 'kcp': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the coefficient of crop growth. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the plant cover. paramVariete (dict): A dictionary containing the parameters for estimating `kcp`. The dictionary should contain the following key: - 'kcMax': A float, representing the maximum crop coefficient. Returns: xarray.Dataset: The updated `data` dataset with the new `kcp` values. \"\" \" data [ \"kcp\" ][ j : , : , : ] = np . where ( data [ \"numPhase\" ][ j , : , : ] >= 1 , np . maximum ( 0.3 , paramVariete [ \"kcMax\" ] * ( 1 - data [ \"ltr\" ][ j , : , : ] )), data [ \"kcp\" ][ j , : , : ] , ) return data estimate_ltr def estimate_ltr ( j , data , paramVariete ) Estimate the fraction of radiation transmitted to the soil ltr based on the leaf area index lai . ltr is used as a proxy for plant covering of the soil in the water balance calculation, where 1 represents no plant cover and 0 represents full plant cover. ltr is computed as an exponential decay function of lai with a decay coefficient kdf . This function is adapted from the EvalLtr procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Parameters: Name Type Description Default j int The starting index for updating ltr in the data dataset. None data xarray.Dataset A dataset containing the data used in the computation of ltr . The dataset should contain the following variables: - 'lai': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the leaf area index. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the fraction of radiation transmitted to the soil. None paramVariete dict A dictionary containing the parameters for estimating ltr . The dictionary should contain the following key: - 'kdf': A float, representing the decay coefficient for ltr . None Returns: Type Description xarray.Dataset The updated data dataset with the new ltr values. View Source def estimate_ltr ( j , data , paramVariete ) : \" \"\" Estimate the fraction of radiation transmitted to the soil `ltr` based on the leaf area index `lai`. `ltr` is used as a proxy for plant covering of the soil in the water balance calculation, where 1 represents no plant cover and 0 represents full plant cover. `ltr` is computed as an exponential decay function of `lai` with a decay coefficient `kdf`. This function is adapted from the EvalLtr procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `ltr` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `ltr`. The dataset should contain the following variables: - 'lai': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the leaf area index. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the fraction of radiation transmitted to the soil. paramVariete (dict): A dictionary containing the parameters for estimating `ltr`. The dictionary should contain the following key: - 'kdf': A float, representing the decay coefficient for `ltr`. Returns: xarray.Dataset: The updated `data` dataset with the new `ltr` values. \"\" \" # group 80 data [ \"ltr\" ][ j : , : , : ] = np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j , : , : ] ) return data estimate_reallocation def estimate_reallocation ( j , data , paramVariete ) Estimate the daily biomass reallocation between stem and leaves. This function computes the daily biomass reallocation between stem and leaves for the plant. The computation only occurs when the plant is in phase 5. The amount of biomass that can be reallocated is estimated as follows: The difference between the potential yield delta and the aboveground biomass delta, bound by 0, is calculated and referred to as manqueAssim. manqueAssim represents the daily variation in biomass that remains after the plant has built its aboveground biomass. The reallocation is computed as the minimum of the product of manqueAssim and the reallocation rate and the difference between the leaf biomass and 30, also bound by 0. The value of 30 is an arbitrary threshold which ensures that reallocation is 0 if the leaf biomass is below 30. If the leaf biomass is above 30, reallocation is bounded by biomasseFeuille - 30. If the plant is not in phase 5, reallocation is set to 0. This function is based on the EvalReallocationSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Parameters: Name Type Description Default j int Current time step of the simulation. None data xarray.Dataset The dataset containing all the simulation data. None paramVariete dict A dictionary containing the parameters for the simulation. None Returns: Type Description xarray.Dataset The updated dataset with the reallocation values. View Source def estimate_reallocation ( j , data , paramVariete ): \"\"\" Estimate the daily biomass reallocation between stem and leaves. This function computes the daily biomass reallocation between stem and leaves for the plant. The computation only occurs when the plant is in phase 5. The amount of biomass that can be reallocated is estimated as follows: 1. The difference between the potential yield delta and the aboveground biomass delta, bound by 0, is calculated and referred to as manqueAssim. manqueAssim represents the daily variation in biomass that remains after the plant has built its aboveground biomass. 2. The reallocation is computed as the minimum of the product of manqueAssim and the reallocation rate and the difference between the leaf biomass and 30, also bound by 0. The value of 30 is an arbitrary threshold which ensures that reallocation is 0 if the leaf biomass is below 30. If the leaf biomass is above 30, reallocation is bounded by biomasseFeuille - 30. If the plant is not in phase 5, reallocation is set to 0. This function is based on the EvalReallocationSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (int): Current time step of the simulation. data (xarray.Dataset): The dataset containing all the simulation data. paramVariete (dict): A dictionary containing the parameters for the simulation. Returns: xarray.Dataset: The updated dataset with the reallocation values. \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] == 5 ) data [ \"manqueAssim\" ][ j :,:,:] = np . where ( condition , np . maximum ( 0 , ( data [ \"dRdtPot\" ][ j ,:,:] - np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j ,:,:]))), 0 , ) data [ \"reallocation\" ][ j :,:,:] = np . where ( condition , np . minimum ( data [ \"manqueAssim\" ][ j ,:,:] * paramVariete [ \"txRealloc\" ], np . maximum ( 0.0 , data [ \"biomasseFeuille\" ][ j ,:,:] - 30 ), ), 0 , ) return data initialize_simulation def initialize_simulation ( data , grid_width , grid_height , duration , paramVariete , paramITK , date_start ) This function initializes variables related to crop growth in the data xarray dataset. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. This code has been adapted from the original InitiationCulture procedure, from the MilBilanCarbone.pas code of the SARRA model. Parameters: Name Type Description Default data type description grid_width ( type ): description None grid_height type description duration ( type ): description None paramVariete type description None Returns: Type Description type description View Source def initialize_simulation ( data , grid_width , grid_height , duration , paramVariete , paramITK , date_start ) : \"\"\" This function initializes variables related to crop growth in the data xarray dataset . As the rain is the first variable to be initialized in the data xarray dataset , its dimensions are used to initialize the other variables . ! [ no caption ](.. / .. / docs / images / sla . png ) This code has been adapted from the original InitiationCulture procedure , from the ` MilBilanCarbone . pas ` code of the SARRA model . Args : data ( _type_ ) : _description_ grid_width ( _type_ ) : _description_ grid_height ( _type_ ) : _description_ duration ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" ### variables to be initialized with values from parameters # from paramVariete : maximum daily thermal time (\u00b0C.j) -> #? unused ? # // data[\"sommeDegresJourMaximale\"] = (data[\"rain\"].dims, np.full( # // (duration, grid_width, grid_height), # // (paramVariete[\"SDJLevee\"] + paramVariete[\"SDJBVP\"] + paramVariete[\"SDJRPR\"] + paramVariete[\"SDJMatu1\"] + paramVariete[\"SDJMatu2\"]) # // )) #// data[\"sommeDegresJourMaximale\"].attrs = { \"units\" : \"\u00b0C.j\" , \"long_name\" : \"Maximum thermal time\" } # from paramITK : sowing date data [ \"sowing_date\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), ( paramITK [ \"DateSemis\" ] - date_start ). days )) # from paramITK : automatic irrigation indicator data [ \"irrigAuto\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"irrigAuto\" ])) data [ \"irrigAuto\" ]. attrs = { \"units\" : \"binary\" , \"long_name\" : \"automatic irrigation indicator\" } ####### variables qui viennent de initplotMc # Initial biomass of crop residues (mulch) (kg/ha) # Biomasse initiale des r\u00e9sidus de culture (mulch) (kg/ha) # BiomMc := BiomIniMc; data [ \"biomMc\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"biomMc\" ]. attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of crop residues (mulch)\" } # ? # StSurf := StockIniSurf; # data[\"stSurf\"] = np.full((grid_width, grid_height, duration), paramTypeSol[\"stockIniSurf\"]) # ? # Ltr := 1; data [ \"ltr\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), 1.0 )) # Initial biomass of stem residues as litter (kg/ha) # Biomasse initiale des r\u00e9sidus de tiges sous forme de liti\u00e8re (kg/ha) # LitTiges := BiomIniMc; data [ \"LitTige\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"LitTige\" ]. attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of stem residues as litter\" } ####### fin variables qui viennent de initplotMc ####### variables eau depuis InitPlotMc # Initializes variables related to crop residues boimass (mulch) in the data # xarray dataset. This code has been adapted from the original InitPlotMc # procedure, Bileau.pas code. Comments with tab indentation are from the # original code. As the rain is the first variable to be initialized in the # data xarray dataset, its dimensions are used to initialize the other # variables. # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity # // data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ]. dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis , : , : ], duration , axis = 0 )) # // data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity # // data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] # // data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock # // data[\"stTot\"] = data[\"stockIniProf\"] # //data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ]. dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis , : , : ], duration , axis = 0 )) # // data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity # // data[\"ruSurf\"], data [ \"surface_tank_capacity\" ]. expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity # // data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock # // data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] ####### fin variables eau depuis InitPlotMc # depuis meteo.pas kpar = 0.5 data [ \"par\" ] = kpar * data [ \"rg\" ] data [ \"par\" ]. attrs = { \"units\" : \"MJ/m2\" , \"long_name\" : \"par\" } # crop density if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rapDensite\" ] = data [ \"rain\" ] * 0 + compute_rapDensite ( paramITK , paramVariete ) data [ \"rapDensite\" ]. attrs = { \"units\" : \"none\" , \"long_name\" : \"sowing density adjustement factor\" } # initialize variables with values at 0 variables = variable_dict () for variable in variables : data [ variable ] = ( data [ \"rain\" ]. dims , np . zeros ( shape = ( duration , grid_width , grid_height ))) data [ variable ]. attrs = { \"units\" : variables [ variable ][ 1 ], \"long_name\" : variables [ variable ][ 0 ]} return data update_aboveground_biomass def update_aboveground_biomass ( j , data , paramVariete ) Update the aboveground biomass of the plant. The aboveground biomass is either updated based on a linear function of the total biomass, if the plant is in phase 2, 3, or 4, or incremented with the total biomass delta if the plant is in any other phase. This function is based on the EvolBiomAeroSarrahV3 procedure, of the bilancarbonsarra , exmodules 1 & 2.pas file from the original Pascal code. Parameters: Name Type Description Default j int The current iteration step in the simulation. None data xarray.Dataset The simulation data, including the current phase of the plant and various biomass values. None paramVariete dict The parameters of the plant variety. None Returns: Type Description xarray.Dataset The updated simulation data, including the updated aboveground biomass and delta aboveground biomass. View Source def update_aboveground_biomass ( j , data , paramVariete ): \"\"\" Update the aboveground biomass of the plant. The aboveground biomass is either updated based on a linear function of the total biomass, if the plant is in phase 2, 3, or 4, or incremented with the total biomass delta if the plant is in any other phase. This function is based on the EvolBiomAeroSarrahV3 procedure, of the ***bilancarbonsarra***, exmodules 1 & 2.pas file from the original Pascal code. Args: j (int): The current iteration step in the simulation. data (xarray.Dataset): The simulation data, including the current phase of the plant and various biomass values. paramVariete (dict): The parameters of the plant variety. Returns: xarray.Dataset: The updated simulation data, including the updated aboveground biomass and delta aboveground biomass. \"\"\" #// data[\"deltaBiomasseAerienne\"][j:,:,:] = np.copy(data[\"biomasseAerienne\"][j,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & ( data [ \"numPhase\" ][ j ,:,:] <= 4 ), np . minimum ( 0.9 , paramVariete [ \"aeroTotPente\" ] * data [ \"biomasseTotale\" ][ j ,:,:] + paramVariete [ \"aeroTotBase\" ]) * data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"deltaBiomasseTotale\" ][ j ,:,:], ) #//data[\"deltaBiomasseAerienne\"][j:,:,:] = (data[\"biomasseAerienne\"][j,:,:] - data[\"deltaBiomasseAerienne\"][j,:,:])#[...,np.newaxis] data [ \"deltaBiomasseAerienne\" ][ j :,:,:] = data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j - 1 ,:,:] return data update_aboveground_biomass_step_2 def update_aboveground_biomass_step_2 ( j , data ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_aboveground_biomass_step_2 ( j , data ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseAerienne \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) , data [ \" biomasseTige \" ][ j ,:,:] + data [ \" biomasseFeuille \" ][ j ,:,:] + data [ \" rdt \" ][ j ,:,:], data [ \" biomasseAerienne \" ][ j ,:,:], ) return data update_assim def update_assim ( j , data ) This function updates assim. If trPot (potential transpiration from the plant, mm) is greater than 0, then assim equals assimPot, multiplied by the ratio of effective transpiration over potential transpiration. If potential transpiration is null, then assim is null as well. Is it adapted from the EvalAssimSarraV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_assim ( j , data ) : \"\"\" This function updates assim . If trPot ( potential transpiration from the plant , mm ) is greater than 0 , then assim equals assimPot , multiplied by the ratio of effective transpiration over potential transpiration . If potential transpiration is null , then assim is null as well . Is it adapted from the EvalAssimSarraV42 procedure , of the bilancarbonsarra . pas file from the original Pascal code Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" assim \" ][ j ,:,:] = np . where ( data [ \" trPot \" ][ j ,:,:] > 0 , data [ \" assimPot \" ][ j ,:,:] * data [ \" tr \" ][ j ,:,:] / data [ \" trPot \" ][ j ,:,:], 0 , ) return data update_assimPot def update_assimPot ( j , data , paramVariete , paramITK ) Update the assimPot value based on the intensification level (NI). If the intensification level NI is defined in paramITK , the conversion rate txConversion is computed using a formula based on NIYo , NIp , LGauss , and AGauss . If NI is not defined, assimPot is updated using conv , which is updated in the estimate_conv function using the variables KAssim and txConversion . When NI parameter is used (from to 4), conversion rate txConversion is computed using the following formula : NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5 ((NI - LGauss)/AGauss) (NI- LGauss)/AGauss))/(AGauss*2.506628274631) This function is adapted from the EvalAssimSarraV42 procedure in the bilancarbonsarra.pas file of the original Pascal code. Note from CB : correction of the conversion rate depending on the intensification level notes from CB reharding the EvalAssimSarraV42 procedure : Modif du 04/03/2021 : Prise en compte en plus de la densit\ufffd de semis de l'effet niveau d'intensification NI NI = 1 quand on est \ufffd l'optimum du niveau d'intensification. Dans le cas de situation contr\ufffdl\ufffd c'est la fertilit\ufffd qui est la clef principale en prenant en r\ufffdf\ufffdrence la qt\ufffd d'azote (\ufffdquivalent phosphore...) optimum Il peut aller \ufffd 0 ou \ufffdtre sup\ufffdrieur \ufffd 1 si situation sur optimum, ie un peu plus de rdt mais \ufffd cout trop \ufffdlev\ufffd... On \ufffdvalue un nouveau tx de conversion en fn du Ni au travers d'une double \ufffdquation : asympote x gaussienne invers\ufffde Et d'un NI d\ufffdfini en fn du sc\ufffdnario de simulation ou des donn\ufffdes observ\ufffdes. NIYo = D\ufffdcalage en Y de l'asymptote NIp = pente de l'asymptote LGauss = Largeur de la Guaussienne AGauss = Amplitude de la Guaussienne Conversion qui est la valeur du taux de conversion en situation optimum n'a plus besoin d'\ufffdtre utilis\ufffd sinon dans la calibration des param\ufffdtres de cette \ufffdquation en absence de donn\ufffdes sur ces param\ufffdtres on ne met aucune valeur \ufffd NI CF fichier ex IndIntensite_txConv_eq.xls} Args: - j (int): An index that represents the current iteration. - data (dict): A dictionary containing data arrays with the following keys: - \"assimPot\" (np.ndarray): An array representing the potential assimilation rate. - \"par\" (np.ndarray): An array representing photosynthetically active radiation. - \"lai\" (np.ndarray): An array representing the leaf area index. - \"conv\" (np.ndarray): An array representing the conversion rate. - paramVariete (dict): A dictionary containing parameters for the computation of the conversion rate, including: - \"txConversion\" (float): The conversion rate. - \"NIYo\" (float): The shift in the Y-axis of the asymptote. - \"NIp\" (float): The slope of the asymptote. - \"LGauss\" (float): The width of the Gaussian curve. - \"AGauss\" (float): The amplitude of the Gaussian curve. - \"kdf\" (float): The constant used in the computation of assimPot . - paramITK (dict): A dictionary containing the intensification level NI (float). Returns: - data (dict): The input data dictionary with the updated \"assimPot\" array. View Source def update_assimPot ( j , data , paramVariete , paramITK ) : \" \"\" Update the assimPot value based on the intensification level (NI). If the intensification level `NI` is defined in `paramITK`, the conversion rate `txConversion` is computed using a formula based on `NIYo`, `NIp`, `LGauss`, and `AGauss`. If `NI` is not defined, `assimPot` is updated using `conv`, which is updated in the `estimate_conv` function using the variables `KAssim` and `txConversion`. When NI parameter is used (from to 4), conversion rate txConversion is computed using the following formula : NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) This function is adapted from the `EvalAssimSarraV42` procedure in the `bilancarbonsarra.pas` file of the original Pascal code. Note from CB : correction of the conversion rate depending on the intensification level notes from CB reharding the EvalAssimSarraV42 procedure : Modif du 04/03/2021 : Prise en compte en plus de la densit\ufffd de semis de l'effet niveau d'intensification NI NI = 1 quand on est \ufffd l'optimum du niveau d'intensification. Dans le cas de situation contr\ufffdl\ufffd c'est la fertilit\ufffd qui est la clef principale en prenant en r\ufffdf\ufffdrence la qt\ufffd d'azote (\ufffdquivalent phosphore...) optimum Il peut aller \ufffd 0 ou \ufffdtre sup\ufffdrieur \ufffd 1 si situation sur optimum, ie un peu plus de rdt mais \ufffd cout trop \ufffdlev\ufffd... On \ufffdvalue un nouveau tx de conversion en fn du Ni au travers d'une double \ufffdquation : asympote x gaussienne invers\ufffde Et d'un NI d\ufffdfini en fn du sc\ufffdnario de simulation ou des donn\ufffdes observ\ufffdes. NIYo = D\ufffdcalage en Y de l'asymptote NIp = pente de l'asymptote LGauss = Largeur de la Guaussienne AGauss = Amplitude de la Guaussienne Conversion qui est la valeur du taux de conversion en situation optimum n'a plus besoin d'\ufffdtre utilis\ufffd sinon dans la calibration des param\ufffdtres de cette \ufffdquation en absence de donn\ufffdes sur ces param\ufffdtres on ne met aucune valeur \ufffd NI CF fichier ex IndIntensite_txConv_eq.xls} Args: - j (int): An index that represents the current iteration. - data (dict): A dictionary containing data arrays with the following keys: - \" assimPot \" (np.ndarray): An array representing the potential assimilation rate. - \" par \" (np.ndarray): An array representing photosynthetically active radiation. - \" lai \" (np.ndarray): An array representing the leaf area index. - \" conv \" (np.ndarray): An array representing the conversion rate. - paramVariete (dict): A dictionary containing parameters for the computation of the conversion rate, including: - \" txConversion \" (float): The conversion rate. - \" NIYo \" (float): The shift in the Y-axis of the asymptote. - \" NIp \" (float): The slope of the asymptote. - \" LGauss \" (float): The width of the Gaussian curve. - \" AGauss \" (float): The amplitude of the Gaussian curve. - \" kdf \" (float): The constant used in the computation of `assimPot`. - paramITK (dict): A dictionary containing the intensification level `NI` (float). Returns: - data (dict): The input `data` dictionary with the updated \" assimPot \" array. \"\" \" if ~ np . isnan ( paramITK [ \"NI\" ] ) : #? the following (stupidly long) line was found commented, need to check why and if this is correct paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ] )) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ] ) / paramVariete [ \"AGauss\" ] ) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ] ) / paramVariete [ \"AGauss\" ] )) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) # NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) data [ \"assimPot\" ][ j , : , : ] = data [ \"par\" ][ j , : , : ] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j , : , : ] )) * \\ paramVariete [ \"txConversion\" ] * 10 else : data [ \"assimPot\" ][ j , : , : ] = data [ \"par\" ][ j , : , : ] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j , : , : ] )) * \\ data [ \"conv\" ][ j , : , : ] * 10 return data update_bM_and_cM def update_bM_and_cM ( j , data , paramVariete ) This function returns the updated values of bM and cM. bM and cM are updated if the delta of aerial biomass is positive, meaning that the plant is gaining aerial biomass, and if the phase is above 1 and below 4 or the phase is below the vegetative phase. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas files from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_bM_and_cM ( j , data , paramVariete ) : \"\"\" This function returns the updated values of bM and cM . bM and cM are updated if the delta of aerial biomass is positive , meaning that the plant is gaining aerial biomass , and if the phase is above 1 and below 4 or the phase is below the vegetative phase . This function is adapted from the EvalFeuilleTigeSarrahV4 procedure , of the bilancarbonsarra . pas files from the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" bM \" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , paramVariete [ \" feuilAeroBase \" ] - 0 . 1 , data [ \" bM \" ][ j ,:,:], ) data [ \" cM \" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , (( paramVariete [ \" feuilAeroPente \" ] * 1000 ) / data [ \" bM \" ][ j ,:,:] + 0 . 78 ) / 0 . 75 , data [ \" cM \" ][ j ,:,:], ) return data update_leaf_biomass def update_leaf_biomass ( j , data , paramVariete ) For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the leaf biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by the reallocation rate in leaves. This value is bound in 0.00000001. Otherwise, the leaf biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_leaf_biomass ( j , data , paramVariete ) : \"\"\" For phase above 1 and if the delta of aerial biomass is negative , meaning that the plant is losing aerial biomass , the leaf biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by the reallocation rate in leaves . This value is bound in 0 . 00000001 . Otherwise , the leaf biomass is not updated . This function is adapted from the EvalFeuilleTigeSarrahV4 procedure , of the bilancarbonsarra . pas and exmodules 1 & 2 . pas files from the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseFeuille \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] < 0 ) , np . maximum ( 0 . 00000001 , data [ \" biomasseFeuille \" ][ j ,:,:] - ( data [ \" reallocation \" ][ j ,:,:] - data [ \" deltaBiomasseAerienne \" ][ j ,:,:] ) * paramVariete [ \" pcReallocFeuille \" ] ) , data [ \" biomasseFeuille \" ][ j ,:,:], ) return data update_leaf_biomass_all_phases def update_leaf_biomass_all_phases ( j , data , paramVariete ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_leaf_biomass_all_phases ( j , data , paramVariete ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseFeuille \" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ) , data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" reallocation \" ][ j ,:,:] * paramVariete [ \" pcReallocFeuille \" ], data [ \" biomasseFeuille \" ][ j ,:,:], ) return data update_leaf_biomass_positive_delta_aboveground_biomass def update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) : \"\"\" Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseFeuille \" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , ( 0 . 1 + data [ \" bM \" ][ j ,:,:] * data [ \" cM \" ][ j ,:,:] ** (( data [ \" biomasseAerienne \" ][ j ,:,:] - data [ \" rdt \" ][ j ,:,:] ) / 1000 )) \\ * ( data [ \" biomasseAerienne \" ][ j ,:,:] - data [ \" rdt \" ][ j ,:,:] ) , data [ \" biomasseFeuille \" ][ j ,:,:], ) return data update_potential_yield def update_potential_yield ( j , data , paramVariete ) Update the potential yield of the plant. The potential yield is initialized as an affine function of the delta between the end of the vegetative phase and the end of the flowering stage, plus a linear function of the total biomass at the end of the flowering stage. The potential yield is capped to twice the biomass of the stem to avoid unrealistic values. The update occurs if the plant is in phase 5 and its phase has changed This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Parameters: Name Type Description Default j int An index representing the current time step. None data xarray.Dataset A dataset containing plant data. None paramVariete dict A dictionary containing parameters for the plant variety. None Returns: Type Description xarray.Dataset The input data with the potential yield updated. View Source def update_potential_yield ( j , data , paramVariete ) : \" \"\" Update the potential yield of the plant. The potential yield is initialized as an affine function of the delta between the end of the vegetative phase and the end of the flowering stage, plus a linear function of the total biomass at the end of the flowering stage. The potential yield is capped to twice the biomass of the stem to avoid unrealistic values. The update occurs if the plant is in phase 5 and its phase has changed This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): An index representing the current time step. data (xarray.Dataset): A dataset containing plant data. paramVariete (dict): A dictionary containing parameters for the plant variety. Returns: xarray.Dataset: The input `data` with the potential yield updated. \"\" \" delta_biomass_flowering_ip = data [ \"biomTotStadeFloraison\" ][ j , : , : ] - data [ \"biomTotStadeIp\" ][ j , : , : ] data [ \"rdtPot\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] == 5 ) & ( data [ \"changePhase\" ][ j , : , : ] == 1 ), ( paramVariete [ \"KRdtPotA\" ] * delta_biomass_flowering_ip + paramVariete [ \"KRdtPotB\" ] ) + paramVariete [ \"KRdtBiom\" ] * data [ \"biomTotStadeFloraison\" ][ j , : , : ] , data [ \"rdtPot\" ][ j , : , : ] , ) #! phaseDevVeg pas utilis\u00e9 ? attention c'est un param\u00e8tre vari\u00e9tal et pas un jeu de don\u00e9es data [ \"rdtPot\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] == 5 ) & ( data [ \"changePhase\" ][ j , : , : ] == 1 ) & ( data [ \"rdtPot\" ][ j , : , : ] > data [ \"biomasseTige\" ][ j , : , : ] * 2 ) & ( paramVariete [ \"phaseDevVeg\" ] < 6 ), data [ \"biomasseTige\" ][ j , : , : ] * 2 , data [ \"rdtPot\" ][ j , : , : ] , ) return data update_potential_yield_delta def update_potential_yield_delta ( j , data , paramVariete ) This function updates the delta potential yield (dRdtPot) of the plant, which is the rate at which the plant's yield is changing over time. The delta potential yield is calculated as the product of the potential yield, the ratio of actual degree days to maturity, and the ratio of actual transpiration to potential transpiration. The calculation is only done if the plant is in phase 5 and the potential transpiration is above 0. If the potential transpiration is not above 0, the delta potential yield is set to 0. For all other phases, the delta potential yield is unchanged. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: - j (int): an integer index, representing the current step of the simulation - data (xarray dataset): the simulation data, including the current state of the plant - paramVariete (dict): the variety-specific parameters used in the simulation Returns: - data (xarray dataset): the updated simulation data, including the updated delta potential yield View Source def update_potential_yield_delta ( j , data , paramVariete ): \"\"\" This function updates the delta potential yield (dRdtPot) of the plant, which is the rate at which the plant's yield is changing over time. The delta potential yield is calculated as the product of the potential yield, the ratio of actual degree days to maturity, and the ratio of actual transpiration to potential transpiration. The calculation is only done if the plant is in phase 5 and the potential transpiration is above 0. If the potential transpiration is not above 0, the delta potential yield is set to 0. For all other phases, the delta potential yield is unchanged. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: - j (int): an integer index, representing the current step of the simulation - data (xarray dataset): the simulation data, including the current state of the plant - paramVariete (dict): the variety-specific parameters used in the simulation Returns: - data (xarray dataset): the updated simulation data, including the updated delta potential yield \"\"\" data [ \"dRdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ), np . where ( ( data [ \"trPot\" ][ j ,:,:] > 0 ), np . maximum ( data [ \"rdtPot\" ][ j ,:,:] * ( data [ \"ddj\" ][ j ,:,:] / paramVariete [ \"SDJMatu1\" ]) * ( data [ \"tr\" ][ j ,:,:] / data [ \"trPot\" ][ j ,:,:]), data [ \"respMaint\" ][ j ,:,:] * 0.15 , ), 0 , ), data [ \"dRdtPot\" ][ j ,:,:], ) return data update_root_biomass def update_root_biomass ( j , data ) Update the root biomass (biomasseRacinaire) for a given time step. The root biomass is computed as the difference between the total biomass and the aboveground biomass. This function is based on the EvalBiomasseRacinaire procedure, of the milbilancarbone, exmodules 1 & 2, milbilancarbone .pas file from the original Pascal code Parameters: Name Type Description Default j int Time step index. None data xarray.Dataset Input dataset containing relevant variables. None Returns: Type Description xarray.Dataset Updated dataset with the root biomass variable. View Source def update_root_biomass ( j , data ): \"\"\" Update the root biomass (biomasseRacinaire) for a given time step. The root biomass is computed as the difference between the total biomass and the aboveground biomass. This function is based on the EvalBiomasseRacinaire procedure, of the milbilancarbone, exmodules 1 & 2, ***milbilancarbone***.pas file from the original Pascal code Args: j (int): Time step index. data (xarray.Dataset): Input dataset containing relevant variables. Returns: xarray.Dataset: Updated dataset with the root biomass variable. \"\"\" data [ \"biomasseRacinaire\" ][ j ,:,:] = data [ \"biomasseTotale\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j ,:,:] return data update_stem_biomass def update_stem_biomass ( j , data , paramVariete ) For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the stem biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by (1-reallocation rate in leaves) (if it's not leaves, it's stems...). This value is bound in 0.00000001. Otherwise, the stem biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stem_biomass ( j , data , paramVariete ) : \"\"\" For phase above 1 and if the delta of aerial biomass is negative , meaning that the plant is losing aerial biomass , the stem biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by ( 1 - reallocation rate in leaves ) ( if it ' s not leaves, it ' s stems ... ) . This value is bound in 0 . 00000001 . Otherwise , the stem biomass is not updated . This function is adapted from the EvalFeuilleTigeSarrahV4 procedure , of the bilancarbonsarra . pas and exmodules 1 & 2 . pas files from the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 122 data [ \" biomasseTige \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] < 0 ) , np . maximum ( 0 . 00000001 , data [ \" biomasseTige \" ][ j ,:,:] - ( data [ \" reallocation \" ][ j ,:,:] - data [ \" deltaBiomasseAerienne \" ][ j ,:,:] ) * ( 1 - paramVariete [ \" pcReallocFeuille \" ] ) , ) , data [ \" biomasseTige \" ][ j ,:,:], ) return data update_stem_biomass_all_phases def update_stem_biomass_all_phases ( j , data , paramVariete ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stem_biomass_all_phases ( j , data , paramVariete ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseTige \" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ) , data [ \" biomasseTige \" ][ j ,:,:] - ( data [ \" reallocation \" ][ j ,:,:] * ( 1 - paramVariete [ \" pcReallocFeuille \" ] )) , data [ \" biomasseTige \" ][ j ,:,:], ) return data update_stem_biomass_positive_delta_aboveground_biomass def update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseTige \" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , data [ \" biomasseAerienne \" ][ j ,:,:] - data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" rdt \" ][ j ,:,:], data [ \" biomasseTige \" ][ j ,:,:], ) return data update_total_biomass def update_total_biomass ( j , data , paramVariete , paramITK ) Update the Total Biomass of the Plant. The total biomass is updated based on the plant's current phase and other parameters. If the plant is in phase 2 and there's a change in phase, the total biomass is initialized using crop density, grain yield per plant, and the dry weight of the grain. If the plant is not in phase 2 or there's no change in phase, the total biomass is incremented with the difference between the plant's assimilation and maintenance respiration. When passing from phase 1 to phase 2, total biomass is initialized. Initialization value is computed from crop density (plants/ha), txResGrain (grain yield per plant), and poidsSecGrain. Otherwise, total biomass is incremented with the difference between plant assimilation assim and maintainance respiration respMaint. This function is adapted from the EvolBiomTotSarrahV4 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Parameters: Name Type Description Default j int The current time step. None data xarray.Dataset The data for the plant, including variables like \"biomasseTotale\", \"assim\", \"respMaint\", \"numPhase\", and \"changePhase\". None paramVariete dict A dictionary of parameters specific to the plant variety. None paramITK dict A dictionary of inter-tropical convergence zone parameters. None Returns: Type Description xarray.Dataset The updated data for the plant, including the updated \"biomasseTotale\" and \"deltaBiomasseTotale\" variables. View Source def update_total_biomass ( j , data , paramVariete , paramITK ): \"\"\" Update the Total Biomass of the Plant. The total biomass is updated based on the plant's current phase and other parameters. If the plant is in phase 2 and there's a change in phase, the total biomass is initialized using crop density, grain yield per plant, and the dry weight of the grain. If the plant is not in phase 2 or there's no change in phase, the total biomass is incremented with the difference between the plant's assimilation and maintenance respiration. When passing from phase 1 to phase 2, total biomass is initialized. Initialization value is computed from crop density (plants/ha), txResGrain (grain yield per plant), and poidsSecGrain. Otherwise, total biomass is incremented with the difference between plant assimilation assim and maintainance respiration respMaint. This function is adapted from the EvolBiomTotSarrahV4 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): The current time step. data (xarray.Dataset): The data for the plant, including variables like \"biomasseTotale\", \"assim\", \"respMaint\", \"numPhase\", and \"changePhase\". paramVariete (dict): A dictionary of parameters specific to the plant variety. paramITK (dict): A dictionary of inter-tropical convergence zone parameters. Returns: xarray.Dataset: The updated data for the plant, including the updated \"biomasseTotale\" and \"deltaBiomasseTotale\" variables. \"\"\" data [ \"biomasseTotale\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), paramITK [ \"densite\" ] * np . maximum ( 1 , paramVariete [ 'densOpti' ] / paramITK [ 'densite' ]) * paramVariete [ \"txResGrain\" ] * paramVariete [ \"poidsSecGrain\" ] / 1000 , data [ \"biomasseTotale\" ][ j ,:,:] + ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]), ) # we may want to drop this variable and use the raw computation instead data [ \"deltaBiomasseTotale\" ][ j :,:,:] = ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]) return data update_total_biomass_at_flowering_stage def update_total_biomass_at_flowering_stage ( j , data ) This function updates the total biomass of the plant at the end of the flowering stage (biomTotStadeFloraison). If the plant is in phase 5, and the phase has changed, then the total biomass is copied to the biomTotStadeFloraison variable. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_biomass_at_flowering_stage ( j , data ): \"\"\" This function updates the total biomass of the plant at the end of the flowering stage (biomTotStadeFloraison). If the plant is in phase 5, and the phase has changed, then the total biomass is copied to the biomTotStadeFloraison variable. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomTotStadeFloraison\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeFloraison\" ][ j ,:,:], ) return data update_total_biomass_stade_ip def update_total_biomass_stade_ip ( j , data ) Update the total biomass of the plant at the end of the vegetative phase (ip = \"initiation paniculaire\"). If the plant has reached phase 4 and has just changed phase, the current total biomass will be copied to the \"biomTotStadeIp\" variable, which represents the total biomass at the end of the vegetative phase (initiation paniculaire). This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): Timestep index. data (xarray.Dataset): Input dataset. Returns: xarray.Dataset: The updated dataset with the \"biomTotStadeIp\" variable updated. View Source def update_total_biomass_stade_ip ( j , data ): \"\"\" Update the total biomass of the plant at the end of the vegetative phase (ip = \"initiation paniculaire\"). If the plant has reached phase 4 and has just changed phase, the current total biomass will be copied to the \"biomTotStadeIp\" variable, which represents the total biomass at the end of the vegetative phase (initiation paniculaire). This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): Timestep index. data (xarray.Dataset): Input dataset. Returns: xarray.Dataset: The updated dataset with the \"biomTotStadeIp\" variable updated. \"\"\" data [ \"biomTotStadeIp\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 4 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeIp\" ][ j ,:,:], ) return data update_vegetative_biomass def update_vegetative_biomass ( j , data ) summary This function is adapted from the EvalBiomasseVegetati procedure from the copie milbilancarbon, exmodules 1 & 2, milbilancarbone file of the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_vegetative_biomass ( j , data ) : \"\"\" _summary_ This function is adapted from the EvalBiomasseVegetati procedure from the copie milbilancarbon , exmodules 1 & 2 , *** milbilancarbone *** file of the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseVegetative \" ][ j :,:,:] = ( data [ \" biomasseTige \" ][ j ,:,:] + data [ \" biomasseFeuille \" ][ j ,:,:] ) return data update_yield_during_filling_phase def update_yield_during_filling_phase ( j , data ) This function updates the yield value during the filling phase. During the filling phase (numPhase == 5), the yield is updated by incrementing it with the sum of deltaBiomasseAerienne and reallocation , bounded by 0 and dRdtPot (daily potential yield). The construction of yield is done during phase 5 only, from the variation of aerial biomass and reallocation, with a maximum of dRdtPot . This function is adapted from the EvolDayRdtSarraV3 procedure from the bilancarbonesarra , exmodules 1 & 2.pas file of the original Pascal code. Notes : On tend vers le potentiel en fn du rapport des degresJours/sumDegresJours pour la phase de remplissage. Frein sup fn du flux de s\u00e8ve estim\u00e9 par le rapport Tr/TrPot. dRdtPot = RdtPotDuJour Parameters: Name Type Description Default j int The time step at which the calculation starts. None data xarray.Dataset The data that contains all variables. None Returns: Type Description xarray.Dataset The input data with updated yield values. View Source def update_yield_during_filling_phase ( j , data ) : \" \"\" This function updates the yield value during the filling phase. During the filling phase (numPhase == 5), the yield is updated by incrementing it with the sum of `deltaBiomasseAerienne` and `reallocation`, bounded by 0 and `dRdtPot` (daily potential yield). The construction of yield is done during phase 5 only, from the variation of aerial biomass and reallocation, with a maximum of `dRdtPot`. This function is adapted from the EvolDayRdtSarraV3 procedure from the ***bilancarbonesarra***, exmodules 1 & 2.pas file of the original Pascal code. Notes : On tend vers le potentiel en fn du rapport des degresJours/sumDegresJours pour la phase de remplissage. Frein sup fn du flux de s\u00e8ve estim\u00e9 par le rapport Tr/TrPot. dRdtPot = RdtPotDuJour Args: j (int): The time step at which the calculation starts. data (xarray.Dataset): The data that contains all variables. Returns: xarray.Dataset: The input data with updated yield values. \"\" \" data [ \"rdt\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] == 5 ), data [ \"rdt\" ][ j , : , : ] + np . minimum ( data [ \"dRdtPot\" ][ j , : , : ] , np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j , : , : ] ) + data [ 'reallocation' ][ j , : , : ] ), data [ \"rdt\" ][ j , : , : ] , ) return data variable_dict def variable_dict ( ) Retrieve the dictionary of variables in the dataset with their respective units. Returns: Type Description dict A dictionary containing the variables and their units, where the keys are the variable names and the values are the respective units. View Source def variable_dict (): \"\"\" Retrieve the dictionary of variables in the dataset with their respective units. Returns: dict: A dictionary containing the variables and their units, where the keys are the variable names and the values are the respective units. \"\"\" variables = { # climate \"ddj\" : [ \"daily thermal time\" , \"\u00b0C.j\" ], \"sdj\" : [ \"sum of thermal time since beginning of emergence\" , \"\u00b0C.j\" ], # phenology \"changePhase\" : [ \"indicator of phase transition day\" , \"binary\" ], \"numPhase\" : [ \"number of phenological stage\" , \"arbitrary units\" ], \"initPhase\" : [ \"indicator of performed phase transition\" , \"binary\" ], \"phasePhotoper\" : [ \"photoperiodic phase indicator\" , \"binary\" ], \"seuilTempPhaseSuivante\" : [ \"sum of thermal time needed to reach the next phenological phase\" , \"\u00b0C.j\" ], \"sommeDegresJourPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], \"seuilTempPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], # carbon balance \"assim\" : [ \"plant biomass assimilation\" , \"kg/ha\" ], \"assimPot\" : [ \"plant potential biomass assimilation\" , \"kg/ha\" ], \"bM\" : [ \"net growth rate of living biomass\" , \"kg/(m\u00b2.d)\" ], \"cM\" : [ \"net growth rate of dead biomass\" , \"kg/(m\u00b2.d)\" ], \"rdt\" : [ \"grain yield\" , \"kg/ha\" ], \"rdtPot\" : [ \"potential grain yield\" , \"kg/ha\" ], \"reallocation\" : [ \"amount of assimilates reallocated to the yield (supply < demand)\" , \"kg/ha\" ], \"respMaint\" : [ \"amount of assimilates consumed by maintainance respiration\" , \"kg/ha\" ], \"manqueAssim\" : [ \"deficit in assimilates (demand - supply)\" , \"kg/ha\" ], # biomass \"biomTotStadeFloraison\" : [ \"total biomass of the plant at the end of the flowering stage\" , \"kg/ha\" ], \"biomTotStadeIp\" : [ \"total biomass at the panicle initiation stage\" , \"kg/ha\" ], \"deltaBiomasseAerienne\" : [ \"increment of aerial biomass in one day\" , \"kg/(ha.d)\" ], \"deltaBiomasseFeuilles\" : [ \"increment of leaf biomass in one day\" , \"kg/(ha.d)\" ], \"biomasseAerienne\" : [ \"total aerial biomass\" , \"kg/ha\" ], \"biomasseVegetative\" : [ \"total vegetative biomass\" , \"kg/ha\" ], \"biomasseTotale\" : [ \"total biomass\" , \"kg/ha\" ], \"biomasseTige\" : [ \"total stem biomass\" , \"kg/ha\" ], \"biomasseRacinaire\" : [ \"total root biomass\" , \"kg/ha\" ], \"biomasseFeuille\" : [ \"total leaf biomass\" , \"kg/ha\" ], \"deltaBiomasseTotale\" : [ \"increment of total biomass in one day\" , \"kg/(ha.d)\" ], # evapotranspiration \"kce\" : [ \"fraction of kc attributable to soil evaporation\" , \"decimal percentage\" ], \"kcp\" : [ \"fraction of kc attributable to plant transpiration\" , \"decimal percentage\" ], \"kcTot\" : [ \"total crop coefficient\" , \"\" ], \"tr\" : [ \"actual crop transpiration\" , \"mm/d\" ], \"trPot\" : [ \"potential crop transpiration\" , \"mm/d\" ], \"trSurf\" : [ \"\" , \"\" ], # water balance \"consoRur\" : [ \"consumption of water stored in the root system\" , \"mm\" ], \"water_gathered_by_mulch\" : [ \"water captured by the mulch in one day\" , \"mm\" ], \"eauDispo\" : [ \"available water, sum of rainfall and total irrigation for the day\" , \"mm\" ], \"eauTranspi\" : [ \"water available for transpiration from the surface reservoir\" , \"mm\" ], \"correctedIrrigation\" : [ \"corrected irrigation amount\" , \"mm/d\" ], \"cstr\" : [ \"drought stress coefficient\" , \"arbitrary unit\" ], \"dayVrac\" : [ \"modulated daily root growth\" , \"mm/day\" ], \"delta_root_tank_capacity\" : [ \"change in root system water reserve\" , \"mm\" ], \"dr\" : [ \"drainage\" , \"mm\" ], \"etm\" : [ \"evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etp\" : [ \"potential evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etr\" : [ \"reference evapotranspiration\" , \"mm/d\" ], \"evap\" : [ \"evaporation from the soil moisture\" , \"mm/d\" ], \"evapPot\" : [ \"potential evaporation from the soil moisture\" , \"mm/d\" ], \"FEMcW\" : [ \"water fraction in soil volume explored by the root system\" , \"none\" ], \"fesw\" : [ \"fraction of available surface water\" , \"decimal percentage\" ], \"irrigTotDay\" : [ \"total irrigation for the day\" , \"mm\" ], \"vRac\" : [ \"reference daily root growth\" , \"mm/day\" ], \"ftsw\" : [ \"fraction of transpirable surface water\" , \"decimal percentage\" ], \"lr\" : [ \"daily water runoff\" , \"mm/d\" ], \"pFact\" : [ \"FAO reference for critical FTSW value for transpiration response\" , \"none\" ], # water tanks \"irrigation_tank_stock\" : [ \"current stock of water in the irrigation tank\" , \"mm\" ], #! renaming stockIrr to irrigation_tank_stock \"mulch_water_stock\" : [ \"water stored in crop residues (mulch)\" , \"mm\" ], #! renaming stockMc to mulch_water_stock \"root_tank_stock\" : [ \"current stock of water in the root system tank\" , \"mm\" ], #! renaming stRu to root_tank_stock \"total_tank_capacity\" : [ \"total capacity of the root system tank\" , \"mm\" ], #! renaming stRuMax to total_tank_capacity \"stRur\" : [ \"\" , \"\" ], # [\"previous season's root system tank stock\",\"mm\"], \"root_tank_capacity_previous_season\" : [ \"previous season's root system tank capacity\" , \"mm\" ], #! renaming stRurMaxPrec to root_tank_capacity_previous_season \"stRurPrec\" : [ \"previous day's root system tank stock\" , \"mm\" ], \"stRurSurf\" : [ \"surface root system tank stock\" , \"mm\" ], \"surface_tank_stock\" : [ \"current stock of water in the surface root system tank\" , \"mm\" ], #! renaming stRuSurf to surface_tank_stock \"stRuSurfPrec\" : [ \"previous day's surface root system tank stock\" , \"mm\" ], \"delta_total_tank_stock\" : [ \"change in the total root system tank stock\" , \"mm\" ], #! renaming stRuVar to delta_total_tank_stock \"irrigation_tank_capacity\" : [ \"irrigation tank capacity\" , \"mm\" ], #! renaming ruIrr to irrigation_tank_capacity \"ruRac\" : [ \"Water column that can potentially be strored in soil volume explored by root system\" , \"mm\" ], \"conv\" : [ \"\" , \"\" ], \"KAssim\" : [ \"\" , \"\" ], \"dayBiomLeaf\" : [ \"daily growth of leaf biomass\" , \"kg/ha/d\" ], \"dRdtPot\" : [ \"daily potential demand from yield\" , \"kg/ha/d\" ], \"FeuilleUp\" : [ \"\" , \"\" ], \"kRespMaint\" : [ \"\" , \"\" ], \"LitFeuille\" : [ \"\" , \"\" ], \"nbJourCompte\" : [ \"\" , \"\" ], \"nbjStress\" : [ \"\" , \"\" ], \"NbUBT\" : [ \"\" , \"\" ], \"sla\" : [ \"\" , \"\" ], \"stockRac\" : [ \"\" , \"\" ], \"sumPP\" : [ \"\" , \"\" ], \"TigeUp\" : [ \"\" , \"\" ], \"UBTCulture\" : [ \"\" , \"\" ], \"lai\" :[ \"leaf area index\" , \"m2/m2\" ], # experimental \"Ncrit\" : [ \"\" , \"\" ], } return variables","title":"Bilan Carbo"},{"location":"reference/sarra_py/bilan_carbo/#module-sarra_pybilan_carbo","text":"View Source import numpy as np import xarray as xr def variable_dict (): \"\"\" Retrieve the dictionary of variables in the dataset with their respective units. Returns: dict: A dictionary containing the variables and their units, where the keys are the variable names and the values are the respective units. \"\"\" variables = { # climate \"ddj\" : [ \"daily thermal time\" , \"\u00b0C.j\" ], \"sdj\" : [ \"sum of thermal time since beginning of emergence\" , \"\u00b0C.j\" ], # phenology \"changePhase\" : [ \"indicator of phase transition day\" , \"binary\" ], \"numPhase\" : [ \"number of phenological stage\" , \"arbitrary units\" ], \"initPhase\" : [ \"indicator of performed phase transition\" , \"binary\" ], \"phasePhotoper\" : [ \"photoperiodic phase indicator\" , \"binary\" ], \"seuilTempPhaseSuivante\" : [ \"sum of thermal time needed to reach the next phenological phase\" , \"\u00b0C.j\" ], \"sommeDegresJourPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], \"seuilTempPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], # carbon balance \"assim\" : [ \"plant biomass assimilation\" , \"kg/ha\" ], \"assimPot\" : [ \"plant potential biomass assimilation\" , \"kg/ha\" ], \"bM\" : [ \"net growth rate of living biomass\" , \"kg/(m\u00b2.d)\" ], \"cM\" : [ \"net growth rate of dead biomass\" , \"kg/(m\u00b2.d)\" ], \"rdt\" : [ \"grain yield\" , \"kg/ha\" ], \"rdtPot\" : [ \"potential grain yield\" , \"kg/ha\" ], \"reallocation\" : [ \"amount of assimilates reallocated to the yield (supply < demand)\" , \"kg/ha\" ], \"respMaint\" : [ \"amount of assimilates consumed by maintainance respiration\" , \"kg/ha\" ], \"manqueAssim\" : [ \"deficit in assimilates (demand - supply)\" , \"kg/ha\" ], # biomass \"biomTotStadeFloraison\" : [ \"total biomass of the plant at the end of the flowering stage\" , \"kg/ha\" ], \"biomTotStadeIp\" : [ \"total biomass at the panicle initiation stage\" , \"kg/ha\" ], \"deltaBiomasseAerienne\" : [ \"increment of aerial biomass in one day\" , \"kg/(ha.d)\" ], \"deltaBiomasseFeuilles\" : [ \"increment of leaf biomass in one day\" , \"kg/(ha.d)\" ], \"biomasseAerienne\" : [ \"total aerial biomass\" , \"kg/ha\" ], \"biomasseVegetative\" : [ \"total vegetative biomass\" , \"kg/ha\" ], \"biomasseTotale\" : [ \"total biomass\" , \"kg/ha\" ], \"biomasseTige\" : [ \"total stem biomass\" , \"kg/ha\" ], \"biomasseRacinaire\" : [ \"total root biomass\" , \"kg/ha\" ], \"biomasseFeuille\" : [ \"total leaf biomass\" , \"kg/ha\" ], \"deltaBiomasseTotale\" : [ \"increment of total biomass in one day\" , \"kg/(ha.d)\" ], # evapotranspiration \"kce\" : [ \"fraction of kc attributable to soil evaporation\" , \"decimal percentage\" ], \"kcp\" : [ \"fraction of kc attributable to plant transpiration\" , \"decimal percentage\" ], \"kcTot\" : [ \"total crop coefficient\" , \"\" ], \"tr\" : [ \"actual crop transpiration\" , \"mm/d\" ], \"trPot\" : [ \"potential crop transpiration\" , \"mm/d\" ], \"trSurf\" : [ \"\" , \"\" ], # water balance \"consoRur\" : [ \"consumption of water stored in the root system\" , \"mm\" ], \"water_gathered_by_mulch\" : [ \"water captured by the mulch in one day\" , \"mm\" ], \"eauDispo\" : [ \"available water, sum of rainfall and total irrigation for the day\" , \"mm\" ], \"eauTranspi\" : [ \"water available for transpiration from the surface reservoir\" , \"mm\" ], \"correctedIrrigation\" : [ \"corrected irrigation amount\" , \"mm/d\" ], \"cstr\" : [ \"drought stress coefficient\" , \"arbitrary unit\" ], \"dayVrac\" : [ \"modulated daily root growth\" , \"mm/day\" ], \"delta_root_tank_capacity\" : [ \"change in root system water reserve\" , \"mm\" ], \"dr\" : [ \"drainage\" , \"mm\" ], \"etm\" : [ \"evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etp\" : [ \"potential evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etr\" : [ \"reference evapotranspiration\" , \"mm/d\" ], \"evap\" : [ \"evaporation from the soil moisture\" , \"mm/d\" ], \"evapPot\" : [ \"potential evaporation from the soil moisture\" , \"mm/d\" ], \"FEMcW\" : [ \"water fraction in soil volume explored by the root system\" , \"none\" ], \"fesw\" : [ \"fraction of available surface water\" , \"decimal percentage\" ], \"irrigTotDay\" : [ \"total irrigation for the day\" , \"mm\" ], \"vRac\" : [ \"reference daily root growth\" , \"mm/day\" ], \"ftsw\" : [ \"fraction of transpirable surface water\" , \"decimal percentage\" ], \"lr\" : [ \"daily water runoff\" , \"mm/d\" ], \"pFact\" : [ \"FAO reference for critical FTSW value for transpiration response\" , \"none\" ], # water tanks \"irrigation_tank_stock\" : [ \"current stock of water in the irrigation tank\" , \"mm\" ], #! renaming stockIrr to irrigation_tank_stock \"mulch_water_stock\" : [ \"water stored in crop residues (mulch)\" , \"mm\" ], #! renaming stockMc to mulch_water_stock \"root_tank_stock\" : [ \"current stock of water in the root system tank\" , \"mm\" ], #! renaming stRu to root_tank_stock \"total_tank_capacity\" : [ \"total capacity of the root system tank\" , \"mm\" ], #! renaming stRuMax to total_tank_capacity \"stRur\" : [ \"\" , \"\" ], # [\"previous season's root system tank stock\",\"mm\"], \"root_tank_capacity_previous_season\" : [ \"previous season's root system tank capacity\" , \"mm\" ], #! renaming stRurMaxPrec to root_tank_capacity_previous_season \"stRurPrec\" : [ \"previous day's root system tank stock\" , \"mm\" ], \"stRurSurf\" : [ \"surface root system tank stock\" , \"mm\" ], \"surface_tank_stock\" : [ \"current stock of water in the surface root system tank\" , \"mm\" ], #! renaming stRuSurf to surface_tank_stock \"stRuSurfPrec\" : [ \"previous day's surface root system tank stock\" , \"mm\" ], \"delta_total_tank_stock\" : [ \"change in the total root system tank stock\" , \"mm\" ], #! renaming stRuVar to delta_total_tank_stock \"irrigation_tank_capacity\" : [ \"irrigation tank capacity\" , \"mm\" ], #! renaming ruIrr to irrigation_tank_capacity \"ruRac\" : [ \"Water column that can potentially be strored in soil volume explored by root system\" , \"mm\" ], \"conv\" : [ \"\" , \"\" ], \"KAssim\" : [ \"\" , \"\" ], \"dayBiomLeaf\" : [ \"daily growth of leaf biomass\" , \"kg/ha/d\" ], \"dRdtPot\" : [ \"daily potential demand from yield\" , \"kg/ha/d\" ], \"FeuilleUp\" : [ \"\" , \"\" ], \"kRespMaint\" : [ \"\" , \"\" ], \"LitFeuille\" : [ \"\" , \"\" ], \"nbJourCompte\" : [ \"\" , \"\" ], \"nbjStress\" : [ \"\" , \"\" ], \"NbUBT\" : [ \"\" , \"\" ], \"sla\" : [ \"\" , \"\" ], \"stockRac\" : [ \"\" , \"\" ], \"sumPP\" : [ \"\" , \"\" ], \"TigeUp\" : [ \"\" , \"\" ], \"UBTCulture\" : [ \"\" , \"\" ], \"lai\" :[ \"leaf area index\" , \"m2/m2\" ], # experimental \"Ncrit\" : [ \"\" , \"\" ], } return variables def initialize_simulation ( data , grid_width , grid_height , duration , paramVariete , paramITK , date_start ): \"\"\" This function initializes variables related to crop growth in the data xarray dataset. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. ![no caption](../../docs/images/sla.png) This code has been adapted from the original InitiationCulture procedure, from the `MilBilanCarbone.pas` code of the SARRA model. Args: data (_type_): _description_ grid_width (_type_): _description_ grid_height (_type_): _description_ duration (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" ### variables to be initialized with values from parameters # from paramVariete : maximum daily thermal time (\u00b0C.j) -> #? unused ? #// data[\"sommeDegresJourMaximale\"] = (data[\"rain\"].dims, np.full( #// (duration, grid_width, grid_height), #// (paramVariete[\"SDJLevee\"] + paramVariete[\"SDJBVP\"] + paramVariete[\"SDJRPR\"] + paramVariete[\"SDJMatu1\"] + paramVariete[\"SDJMatu2\"]) #// )) #// data[\"sommeDegresJourMaximale\"].attrs = {\"units\":\"\u00b0C.j\", \"long_name\":\"Maximum thermal time\"} # from paramITK : sowing date data [ \"sowing_date\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), ( paramITK [ \"DateSemis\" ] - date_start ) . days )) # from paramITK : automatic irrigation indicator data [ \"irrigAuto\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"irrigAuto\" ])) data [ \"irrigAuto\" ] . attrs = { \"units\" : \"binary\" , \"long_name\" : \"automatic irrigation indicator\" } ####### variables qui viennent de initplotMc # Initial biomass of crop residues (mulch) (kg/ha) # Biomasse initiale des r\u00e9sidus de culture (mulch) (kg/ha) # BiomMc := BiomIniMc; data [ \"biomMc\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"biomMc\" ] . attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of crop residues (mulch)\" } # ? # StSurf := StockIniSurf; # data[\"stSurf\"] = np.full((grid_width, grid_height, duration), paramTypeSol[\"stockIniSurf\"]) # ? # Ltr := 1; data [ \"ltr\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), 1.0 )) # Initial biomass of stem residues as litter (kg/ha) # Biomasse initiale des r\u00e9sidus de tiges sous forme de liti\u00e8re (kg/ha) # LitTiges := BiomIniMc; data [ \"LitTige\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"LitTige\" ] . attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of stem residues as litter\" } ####### fin variables qui viennent de initplotMc ####### variables eau depuis InitPlotMc # Initializes variables related to crop residues boimass (mulch) in the data # xarray dataset. This code has been adapted from the original InitPlotMc # procedure, Bileau.pas code. Comments with tab indentation are from the # original code. As the rain is the first variable to be initialized in the # data xarray dataset, its dimensions are used to initialize the other # variables. # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] #// data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock #// data[\"stTot\"] = data[\"stockIniProf\"] #//data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ] . expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock #// data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] ####### fin variables eau depuis InitPlotMc # depuis meteo.pas kpar = 0.5 data [ \"par\" ] = kpar * data [ \"rg\" ] data [ \"par\" ] . attrs = { \"units\" : \"MJ/m2\" , \"long_name\" : \"par\" } # crop density if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rapDensite\" ] = data [ \"rain\" ] * 0 + compute_rapDensite ( paramITK , paramVariete ) data [ \"rapDensite\" ] . attrs = { \"units\" : \"none\" , \"long_name\" : \"sowing density adjustement factor\" } # initialize variables with values at 0 variables = variable_dict () for variable in variables : data [ variable ] = ( data [ \"rain\" ] . dims , np . zeros ( shape = ( duration , grid_width , grid_height ))) data [ variable ] . attrs = { \"units\" : variables [ variable ][ 1 ], \"long_name\" : variables [ variable ][ 0 ]} return data def estimate_kcp ( j , data , paramVariete ): \"\"\" Estimate the kcp coefficient based on the maximum crop coefficient `kcMax` and plant cover `ltr`. The computation of `kcp` is based on the EvolKcpKcIni procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `kcp` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `kcp`. The dataset should contain the following variables: - 'numPhase': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the number of phases in the crop cycle. - 'kcp': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the coefficient of crop growth. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the plant cover. paramVariete (dict): A dictionary containing the parameters for estimating `kcp`. The dictionary should contain the following key: - 'kcMax': A float, representing the maximum crop coefficient. Returns: xarray.Dataset: The updated `data` dataset with the new `kcp` values. \"\"\" data [ \"kcp\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] >= 1 , np . maximum ( 0.3 , paramVariete [ \"kcMax\" ] * ( 1 - data [ \"ltr\" ][ j ,:,:])), data [ \"kcp\" ][ j ,:,:], ) return data def estimate_ltr ( j , data , paramVariete ): \"\"\" Estimate the fraction of radiation transmitted to the soil `ltr` based on the leaf area index `lai`. `ltr` is used as a proxy for plant covering of the soil in the water balance calculation, where 1 represents no plant cover and 0 represents full plant cover. `ltr` is computed as an exponential decay function of `lai` with a decay coefficient `kdf`. This function is adapted from the EvalLtr procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `ltr` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `ltr`. The dataset should contain the following variables: - 'lai': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the leaf area index. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the fraction of radiation transmitted to the soil. paramVariete (dict): A dictionary containing the parameters for estimating `ltr`. The dictionary should contain the following key: - 'kdf': A float, representing the decay coefficient for `ltr`. Returns: xarray.Dataset: The updated `data` dataset with the new `ltr` values. \"\"\" # group 80 data [ \"ltr\" ][ j :,:,:] = np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j ,:,:]) return data def estimate_KAssim ( j , data , paramVariete ): \"\"\" This function calculates the conversion factor `KAssim`, which is used to convert assimilates into biomass. The value of `KAssim` depends on the phase of the crop. The conversion factor is calculated based on a lookup table that maps crop phases to values. The crop phase is determined by the `numPhase` field in the `data` argument, and the corresponding `KAssim` value is set in the `KAssim` field of the `data` argument. Args: j (int): An integer index specifying the time step. data (xarray.Dataset): A dataset containing the variables used in the calculation of `KAssim`. The dataset should include the fields `numPhase`, `sdj`, `seuilTemp PhasePrec`, and `seuilTemp PhaseSuivante`. The `KAssim` field of the dataset will be updated by this function. paramVariete (dict): A dictionary of parameters. It should include the fields `txAssimBVP`, `txAssimMatu1`, and `txAssimMatu2`. Returns: xarray.Dataset: The updated `data` dataset, with the `KAssim` field set to the calculated values. \"\"\" phase_equivalences = { 2 : 1 , 3 : paramVariete [ 'txAssimBVP' ], 4 : paramVariete [ 'txAssimBVP' ], #! replacing sommeDegresJourPhasePrec with seuilTempPhasePrec #// 5: paramVariete[\"txAssimBVP\"] + (data['sdj'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]) * (paramVariete['txAssimMatu1'] - paramVariete['txAssimBVP']) / (data['seuilTempPhaseSuivante'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]), 5 : paramVariete [ \"txAssimBVP\" ] + ( data [ 'sdj' ][ j ,:,:] - data [ 'seuilTempPhasePrec' ][ j ,:,:]) * ( paramVariete [ 'txAssimMatu1' ] - paramVariete [ 'txAssimBVP' ]) / ( data [ 'seuilTempPhaseSuivante' ][ j ,:,:] - data [ 'seuilTempPhasePrec' ][ j ,:,:]), #// 6: paramVariete[\"txAssimMatu1\"] + (data[\"sdj\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]) * (paramVariete[\"txAssimMatu2\"] - paramVariete[\"txAssimMatu1\"]) / (data[\"seuilTempPhaseSuivante\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]), 6 : paramVariete [ \"txAssimMatu1\" ] + ( data [ \"sdj\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]) * ( paramVariete [ \"txAssimMatu2\" ] - paramVariete [ \"txAssimMatu1\" ]) / ( data [ \"seuilTempPhaseSuivante\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]), } for phase in range ( 2 , 7 ): data [ \"KAssim\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == phase , phase_equivalences [ phase ], data [ \"KAssim\" ][ j ,:,:], ) return data def estimate_conv ( j , data , paramVariete ): \"\"\" This function calculates the conversion of assimilates into biomass. The conversion factor is determined by multiplying the KAssim value, which is dependent on the phase of the crop, with the conversion rate (txConversion) specified in the `paramVariete` argument. Args: j (int): The starting index of the calculation data (dict): A dictionary containing information on the crop growth, including the phase of the crop and the KAssim value. paramVariete (dict): A dictionary containing parameters relevant to the crop growth, including the conversion rate. Returns: dict: The input `data` dictionary with the calculated \"conv\" value added. \"\"\" data [ \"conv\" ][ j :,:,:] = ( data [ \"KAssim\" ][ j ,:,:] * paramVariete [ \"txConversion\" ]) return data def BiomDensOptSarraV4 ( j , data , paramITK ): \"\"\" si densit\u00e9 plus faible alors on consid\u00e9re qu'il faut augmenter les biomasses, LAI etc en regard de cette situation au niveau de chaque plante (car tout est rapport\u00e9 \u00e9 des kg/ha). Si elle est plus forte on ne change rien pour lors. Valeur fixe en ref au ma\u00e9s \u00e9 d\u00e9f en param\u00e9tre par vari\u00e9t\u00e9s\u00e9 rapDensite := Max(1, 70000/densite); \"\"\" \"\"\" if ~np.isnan(paramVariete[\"densOpti\"]) : paramITK[\"rapDensite\"] = np.maximum(1,paramVariete[\"densOpti\"]/paramITK[\"densite\"]) data[\"rdt\"][j,:,:] = data[\"rdt\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseRacinaire\"][j,:,:] = data[\"biomasseRacinaire\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseTige\"][j,:,:] = data[\"biomasseTige\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseFeuille\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseAerienne\"][j,:,:] = data[\"biomasseTige\"][j,:,:] + data[\"biomasseFeuille\"][j,:,:] + data[\"rdt\"][j,:,:] data[\"lai\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data[\"biomasseTotale\"][j,:,:] = data[\"biomasseAerienne\"][j,:,:] + data[\"biomasseRacinaire\"][j,:,:] return data \"\"\" return data def compute_rapDensite ( paramITK , paramVariete ): \"\"\" It basically calculates a correction factor (rapDensite). This correction factor Is calculated with an equation of form a + p * exp( -(x/(o / -log((1-a)/p) )) ) with a the densiteA parameter p the densiteP parameter$ x the actual crop density o the densOpti parameter See https://www.wolframalpha.com/input?i=a+%2B+p+*+exp%28-%28x+%2F+%28+o%2F-+log%28%281+-+a%29%2F+p%29%29%29%29 for equation visualization. This equation is probably too complex for the problem at hand. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" rapDensite = paramVariete [ \"densiteA\" ] + paramVariete [ \"densiteP\" ] * np . exp ( - ( paramITK [ \"densite\" ] / ( paramVariete [ \"densOpti\" ] /- np . log (( 1 - paramVariete [ 'densiteA' ]) / paramVariete [ \"densiteP\" ])))) return rapDensite def adjust_for_sowing_density ( j , data , paramVariete , direction ): \"\"\" This function translates the effect of sowing density on biomass and LAI. This function is adapted from the BiomDensOptSarV42 and BiomDensiteSarraV42 procedures, from the bilancarbonsarra.pas original Pascal code. Notes from CB : if density is lower than the optimal density, then we consider that we need to increase the biomass, LAI etc in regard of this situation at each plant level (because everything is related to kg/ha). If it is higher, it increases asymptotically. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" if direction == \"in\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rdt\" ][ j :,:,:] = data [ \"rdt\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:] data [ \"rdtPot\" ][ j :,:,:] = ( data [ \"rdtPot\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseRacinaire\" ][ j :,:,:] = ( data [ \"biomasseRacinaire\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseTige\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseFeuille\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] * data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:]) data [ \"lai\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] * data [ \"sla\" ][ j ,:,:]) data [ \"biomasseTotale\" ][ j :,:,:] = ( data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"biomasseRacinaire\" ][ j ,:,:]) return data if direction == \"out\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]): data [ \"rdt\" ][ j :,:,:] = ( data [ \"rdt\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"rdtPot\" ][ j :,:,:] = ( data [ \"rdtPot\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseRacinaire\" ][ j :,:,:] = ( data [ \"biomasseRacinaire\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseTige\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseFeuille\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] / data [ \"rapDensite\" ][ j ,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:]) #? conflit avec fonction evolLAIphase ? #data[\"lai\"][j:,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data [ \"lai\" ][ j :,:,:] = data [ \"lai\" ][ j :,:,:] / data [ \"rapDensite\" ][ j ,:,:] data [ \"biomasseTotale\" ][ j :,:,:] = ( data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"biomasseRacinaire\" ][ j ,:,:]) #[...,np.newaxis] #data[\"biomasseTotale\"][j:,:,:] = data[\"biomasseTotale\"][j:,:,:] / data[\"rapDensite\"] return data def EvalAssimSarrahV4 ( j , data ): \"\"\" data[\"parIntercepte\"][j,:,:] = 0.5 * (1 - data[\"ltr\"][j,:,:]) * data[\"rg\"][j,:,:] data[\"assimPot\"][j:,:,:] = data[\"parIntercepte\"][j,:,:] * data[\"conv\"][j,:,:] * 10 data[\"assim\"][j,:,:] = np.where( data[\"trPot\"][j,:,:] > 0, data[\"assimPot\"][j,:,:] * data[\"tr\"][j,:,:] / data[\"trPot\"][j,:,:], 0, ) \"\"\" return data def update_assimPot ( j , data , paramVariete , paramITK ): \"\"\" Update the assimPot value based on the intensification level (NI). If the intensification level `NI` is defined in `paramITK`, the conversion rate `txConversion` is computed using a formula based on `NIYo`, `NIp`, `LGauss`, and `AGauss`. If `NI` is not defined, `assimPot` is updated using `conv`, which is updated in the `estimate_conv` function using the variables `KAssim` and `txConversion`. When NI parameter is used (from to 4), conversion rate txConversion is computed using the following formula : NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) This function is adapted from the `EvalAssimSarraV42` procedure in the `bilancarbonsarra.pas` file of the original Pascal code. Note from CB : correction of the conversion rate depending on the intensification level notes from CB reharding the EvalAssimSarraV42 procedure : Modif du 04/03/2021 : Prise en compte en plus de la densit\ufffd de semis de l'effet niveau d'intensification NI NI = 1 quand on est \ufffd l'optimum du niveau d'intensification. Dans le cas de situation contr\ufffdl\ufffd c'est la fertilit\ufffd qui est la clef principale en prenant en r\ufffdf\ufffdrence la qt\ufffd d'azote (\ufffdquivalent phosphore...) optimum Il peut aller \ufffd 0 ou \ufffdtre sup\ufffdrieur \ufffd 1 si situation sur optimum, ie un peu plus de rdt mais \ufffd cout trop \ufffdlev\ufffd... On \ufffdvalue un nouveau tx de conversion en fn du Ni au travers d'une double \ufffdquation : asympote x gaussienne invers\ufffde Et d'un NI d\ufffdfini en fn du sc\ufffdnario de simulation ou des donn\ufffdes observ\ufffdes. NIYo = D\ufffdcalage en Y de l'asymptote NIp = pente de l'asymptote LGauss = Largeur de la Guaussienne AGauss = Amplitude de la Guaussienne Conversion qui est la valeur du taux de conversion en situation optimum n'a plus besoin d'\ufffdtre utilis\ufffd sinon dans la calibration des param\ufffdtres de cette \ufffdquation en absence de donn\ufffdes sur ces param\ufffdtres on ne met aucune valeur \ufffd NI CF fichier ex IndIntensite_txConv_eq.xls} Args: - j (int): An index that represents the current iteration. - data (dict): A dictionary containing data arrays with the following keys: - \"assimPot\" (np.ndarray): An array representing the potential assimilation rate. - \"par\" (np.ndarray): An array representing photosynthetically active radiation. - \"lai\" (np.ndarray): An array representing the leaf area index. - \"conv\" (np.ndarray): An array representing the conversion rate. - paramVariete (dict): A dictionary containing parameters for the computation of the conversion rate, including: - \"txConversion\" (float): The conversion rate. - \"NIYo\" (float): The shift in the Y-axis of the asymptote. - \"NIp\" (float): The slope of the asymptote. - \"LGauss\" (float): The width of the Gaussian curve. - \"AGauss\" (float): The amplitude of the Gaussian curve. - \"kdf\" (float): The constant used in the computation of `assimPot`. - paramITK (dict): A dictionary containing the intensification level `NI` (float). Returns: - data (dict): The input `data` dictionary with the updated \"assimPot\" array. \"\"\" if ~ np . isnan ( paramITK [ \"NI\" ]): #? the following (stupidly long) line was found commented, need to check why and if this is correct paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ])) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ]) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ])) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) # NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) data [ \"assimPot\" ][ j ,:,:] = data [ \"par\" ][ j ,:,:] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j ,:,:])) * \\ paramVariete [ \"txConversion\" ] * 10 else : data [ \"assimPot\" ][ j ,:,:] = data [ \"par\" ][ j ,:,:] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j ,:,:])) * \\ data [ \"conv\" ][ j ,:,:] * 10 return data def update_assim ( j , data ): \"\"\" This function updates assim. If trPot (potential transpiration from the plant, mm) is greater than 0, then assim equals assimPot, multiplied by the ratio of effective transpiration over potential transpiration. If potential transpiration is null, then assim is null as well. Is it adapted from the EvalAssimSarraV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"assim\" ][ j ,:,:] = np . where ( data [ \"trPot\" ][ j ,:,:] > 0 , data [ \"assimPot\" ][ j ,:,:] * data [ \"tr\" ][ j ,:,:] / data [ \"trPot\" ][ j ,:,:], 0 , ) return data def calculate_maintainance_respiration ( j , data , paramVariete ): \"\"\" This function calculates the maintenance respiration `respMaint` (in kg/ha/j in equivalent dry matter) of the plant. The maintenance respiration is calculated by summing the maintenance respiration associated with total biomass and leaves biomass. If the plant's growth phase is above 4 and there is no leaf biomass, `respMaint` is set to 0. The calculation is based on the equation: coefficient_temp = 2^((average_temp - tempMaint) / 10) respiration = kRespMaint * biomass * coefficient_temp where `average_temp` is the average temperature for the day, `tempMaint` is the maintenance temperature from `variety_params`, `kRespMaint` is the maintenance respiration coefficient from `variety_params`, and `biomass` is the total or leaf biomass. Args: j (int): The time step of the calculation. data (xarray.Dataset): The input data containing the variables `tpMoy`, `biomasseTotale`, `biomasseFeuille`, and `numPhase`. The output `respMaint` will also be stored in this dataset. variety_params (dict): The parameters related to the plant variety, containing the keys `tempMaint` and `kRespMaint`. Returns: xarray.Dataset: The input `data` with the updated `respMaint` variable. \"\"\" coefficient_temp = 2 ** (( data [ \"tpMoy\" ][ j ,:,:] - paramVariete [ \"tempMaint\" ]) / 10 ) resp_totale = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseTotale\" ][ j ,:,:] * coefficient_temp resp_feuille = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseFeuille\" ][ j ,:,:] * coefficient_temp data [ \"respMaint\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 4 ) & ( data [ \"biomasseFeuille\" ][ j ,:,:] == 0 ), 0 , resp_totale + resp_feuille , ) return data def update_total_biomass ( j , data , paramVariete , paramITK ): \"\"\" Update the Total Biomass of the Plant. The total biomass is updated based on the plant's current phase and other parameters. If the plant is in phase 2 and there's a change in phase, the total biomass is initialized using crop density, grain yield per plant, and the dry weight of the grain. If the plant is not in phase 2 or there's no change in phase, the total biomass is incremented with the difference between the plant's assimilation and maintenance respiration. When passing from phase 1 to phase 2, total biomass is initialized. Initialization value is computed from crop density (plants/ha), txResGrain (grain yield per plant), and poidsSecGrain. Otherwise, total biomass is incremented with the difference between plant assimilation assim and maintainance respiration respMaint. This function is adapted from the EvolBiomTotSarrahV4 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): The current time step. data (xarray.Dataset): The data for the plant, including variables like \"biomasseTotale\", \"assim\", \"respMaint\", \"numPhase\", and \"changePhase\". paramVariete (dict): A dictionary of parameters specific to the plant variety. paramITK (dict): A dictionary of inter-tropical convergence zone parameters. Returns: xarray.Dataset: The updated data for the plant, including the updated \"biomasseTotale\" and \"deltaBiomasseTotale\" variables. \"\"\" data [ \"biomasseTotale\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), paramITK [ \"densite\" ] * np . maximum ( 1 , paramVariete [ 'densOpti' ] / paramITK [ 'densite' ]) * paramVariete [ \"txResGrain\" ] * paramVariete [ \"poidsSecGrain\" ] / 1000 , data [ \"biomasseTotale\" ][ j ,:,:] + ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]), ) # we may want to drop this variable and use the raw computation instead data [ \"deltaBiomasseTotale\" ][ j :,:,:] = ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]) return data def update_total_biomass_stade_ip ( j , data ): \"\"\" Update the total biomass of the plant at the end of the vegetative phase (ip = \"initiation paniculaire\"). If the plant has reached phase 4 and has just changed phase, the current total biomass will be copied to the \"biomTotStadeIp\" variable, which represents the total biomass at the end of the vegetative phase (initiation paniculaire). This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): Timestep index. data (xarray.Dataset): Input dataset. Returns: xarray.Dataset: The updated dataset with the \"biomTotStadeIp\" variable updated. \"\"\" data [ \"biomTotStadeIp\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 4 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeIp\" ][ j ,:,:], ) return data def update_total_biomass_at_flowering_stage ( j , data ): \"\"\" This function updates the total biomass of the plant at the end of the flowering stage (biomTotStadeFloraison). If the plant is in phase 5, and the phase has changed, then the total biomass is copied to the biomTotStadeFloraison variable. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomTotStadeFloraison\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeFloraison\" ][ j ,:,:], ) return data def update_potential_yield ( j , data , paramVariete ): \"\"\" Update the potential yield of the plant. The potential yield is initialized as an affine function of the delta between the end of the vegetative phase and the end of the flowering stage, plus a linear function of the total biomass at the end of the flowering stage. The potential yield is capped to twice the biomass of the stem to avoid unrealistic values. The update occurs if the plant is in phase 5 and its phase has changed This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): An index representing the current time step. data (xarray.Dataset): A dataset containing plant data. paramVariete (dict): A dictionary containing parameters for the plant variety. Returns: xarray.Dataset: The input `data` with the potential yield updated. \"\"\" delta_biomass_flowering_ip = data [ \"biomTotStadeFloraison\" ][ j ,:,:] - data [ \"biomTotStadeIp\" ][ j ,:,:] data [ \"rdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), ( paramVariete [ \"KRdtPotA\" ] * delta_biomass_flowering_ip + paramVariete [ \"KRdtPotB\" ]) + paramVariete [ \"KRdtBiom\" ] * data [ \"biomTotStadeFloraison\" ][ j ,:,:], data [ \"rdtPot\" ][ j ,:,:], ) #! phaseDevVeg pas utilis\u00e9 ? attention c'est un param\u00e8tre vari\u00e9tal et pas un jeu de don\u00e9es data [ \"rdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) & ( data [ \"rdtPot\" ][ j ,:,:] > data [ \"biomasseTige\" ][ j ,:,:] * 2 ) & ( paramVariete [ \"phaseDevVeg\" ] < 6 ), data [ \"biomasseTige\" ][ j ,:,:] * 2 , data [ \"rdtPot\" ][ j ,:,:], ) return data def update_potential_yield_delta ( j , data , paramVariete ): \"\"\" This function updates the delta potential yield (dRdtPot) of the plant, which is the rate at which the plant's yield is changing over time. The delta potential yield is calculated as the product of the potential yield, the ratio of actual degree days to maturity, and the ratio of actual transpiration to potential transpiration. The calculation is only done if the plant is in phase 5 and the potential transpiration is above 0. If the potential transpiration is not above 0, the delta potential yield is set to 0. For all other phases, the delta potential yield is unchanged. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: - j (int): an integer index, representing the current step of the simulation - data (xarray dataset): the simulation data, including the current state of the plant - paramVariete (dict): the variety-specific parameters used in the simulation Returns: - data (xarray dataset): the updated simulation data, including the updated delta potential yield \"\"\" data [ \"dRdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ), np . where ( ( data [ \"trPot\" ][ j ,:,:] > 0 ), np . maximum ( data [ \"rdtPot\" ][ j ,:,:] * ( data [ \"ddj\" ][ j ,:,:] / paramVariete [ \"SDJMatu1\" ]) * ( data [ \"tr\" ][ j ,:,:] / data [ \"trPot\" ][ j ,:,:]), data [ \"respMaint\" ][ j ,:,:] * 0.15 , ), 0 , ), data [ \"dRdtPot\" ][ j ,:,:], ) return data def update_aboveground_biomass ( j , data , paramVariete ): \"\"\" Update the aboveground biomass of the plant. The aboveground biomass is either updated based on a linear function of the total biomass, if the plant is in phase 2, 3, or 4, or incremented with the total biomass delta if the plant is in any other phase. This function is based on the EvolBiomAeroSarrahV3 procedure, of the ***bilancarbonsarra***, exmodules 1 & 2.pas file from the original Pascal code. Args: j (int): The current iteration step in the simulation. data (xarray.Dataset): The simulation data, including the current phase of the plant and various biomass values. paramVariete (dict): The parameters of the plant variety. Returns: xarray.Dataset: The updated simulation data, including the updated aboveground biomass and delta aboveground biomass. \"\"\" #// data[\"deltaBiomasseAerienne\"][j:,:,:] = np.copy(data[\"biomasseAerienne\"][j,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & ( data [ \"numPhase\" ][ j ,:,:] <= 4 ), np . minimum ( 0.9 , paramVariete [ \"aeroTotPente\" ] * data [ \"biomasseTotale\" ][ j ,:,:] + paramVariete [ \"aeroTotBase\" ]) * data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"deltaBiomasseTotale\" ][ j ,:,:], ) #//data[\"deltaBiomasseAerienne\"][j:,:,:] = (data[\"biomasseAerienne\"][j,:,:] - data[\"deltaBiomasseAerienne\"][j,:,:])#[...,np.newaxis] data [ \"deltaBiomasseAerienne\" ][ j :,:,:] = data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j - 1 ,:,:] return data def estimate_reallocation ( j , data , paramVariete ): \"\"\" Estimate the daily biomass reallocation between stem and leaves. This function computes the daily biomass reallocation between stem and leaves for the plant. The computation only occurs when the plant is in phase 5. The amount of biomass that can be reallocated is estimated as follows: 1. The difference between the potential yield delta and the aboveground biomass delta, bound by 0, is calculated and referred to as manqueAssim. manqueAssim represents the daily variation in biomass that remains after the plant has built its aboveground biomass. 2. The reallocation is computed as the minimum of the product of manqueAssim and the reallocation rate and the difference between the leaf biomass and 30, also bound by 0. The value of 30 is an arbitrary threshold which ensures that reallocation is 0 if the leaf biomass is below 30. If the leaf biomass is above 30, reallocation is bounded by biomasseFeuille - 30. If the plant is not in phase 5, reallocation is set to 0. This function is based on the EvalReallocationSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (int): Current time step of the simulation. data (xarray.Dataset): The dataset containing all the simulation data. paramVariete (dict): A dictionary containing the parameters for the simulation. Returns: xarray.Dataset: The updated dataset with the reallocation values. \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] == 5 ) data [ \"manqueAssim\" ][ j :,:,:] = np . where ( condition , np . maximum ( 0 , ( data [ \"dRdtPot\" ][ j ,:,:] - np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j ,:,:]))), 0 , ) data [ \"reallocation\" ][ j :,:,:] = np . where ( condition , np . minimum ( data [ \"manqueAssim\" ][ j ,:,:] * paramVariete [ \"txRealloc\" ], np . maximum ( 0.0 , data [ \"biomasseFeuille\" ][ j ,:,:] - 30 ), ), 0 , ) return data def update_root_biomass ( j , data ): \"\"\" Update the root biomass (biomasseRacinaire) for a given time step. The root biomass is computed as the difference between the total biomass and the aboveground biomass. This function is based on the EvalBiomasseRacinaire procedure, of the milbilancarbone, exmodules 1 & 2, ***milbilancarbone***.pas file from the original Pascal code Args: j (int): Time step index. data (xarray.Dataset): Input dataset containing relevant variables. Returns: xarray.Dataset: Updated dataset with the root biomass variable. \"\"\" data [ \"biomasseRacinaire\" ][ j ,:,:] = data [ \"biomasseTotale\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j ,:,:] return data def update_leaf_biomass ( j , data , paramVariete ): \"\"\" For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the leaf biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by the reallocation rate in leaves. This value is bound in 0.00000001. Otherwise, the leaf biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseFeuille\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ), np . maximum ( 0.00000001 , data [ \"biomasseFeuille\" ][ j ,:,:] - ( data [ \"reallocation\" ][ j ,:,:] - data [ \"deltaBiomasseAerienne\" ][ j ,:,:]) * paramVariete [ \"pcReallocFeuille\" ] ), data [ \"biomasseFeuille\" ][ j ,:,:], ) return data def update_stem_biomass ( j , data , paramVariete ): \"\"\" For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the stem biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by (1-reallocation rate in leaves) (if it's not leaves, it's stems...). This value is bound in 0.00000001. Otherwise, the stem biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 122 data [ \"biomasseTige\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ), np . maximum ( 0.00000001 , data [ \"biomasseTige\" ][ j ,:,:] - ( data [ \"reallocation\" ][ j ,:,:] - data [ \"deltaBiomasseAerienne\" ][ j ,:,:]) * ( 1 - paramVariete [ \"pcReallocFeuille\" ]), ), data [ \"biomasseTige\" ][ j ,:,:], ) return data def condition_positive_delta_biomass ( j , data , paramVariete ): condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & \\ ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] >= 0 ) & \\ (( data [ \"numPhase\" ][ j ,:,:] <= 4 ) | ( data [ \"numPhase\" ][ j ,:,:] <= paramVariete [ \"phaseDevVeg\" ])) # (data[\"numPhase\"][j,:,:] <= 4) return condition def update_bM_and_cM ( j , data , paramVariete ): \"\"\" This function returns the updated values of bM and cM. bM and cM are updated if the delta of aerial biomass is positive, meaning that the plant is gaining aerial biomass, and if the phase is above 1 and below 4 or the phase is below the vegetative phase. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas files from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"bM\" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), paramVariete [ \"feuilAeroBase\" ] - 0.1 , data [ \"bM\" ][ j ,:,:], ) data [ \"cM\" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), (( paramVariete [ \"feuilAeroPente\" ] * 1000 ) / data [ \"bM\" ][ j ,:,:] + 0.78 ) / 0.75 , data [ \"cM\" ][ j ,:,:], ) return data def update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ): \"\"\" Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseFeuille\" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), ( 0.1 + data [ \"bM\" ][ j ,:,:] * data [ \"cM\" ][ j ,:,:] ** (( data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"rdt\" ][ j ,:,:]) / 1000 )) \\ * ( data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"rdt\" ][ j ,:,:]), data [ \"biomasseFeuille\" ][ j ,:,:], ) return data def update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseTige\" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ), data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"biomasseFeuille\" ][ j ,:,:] - data [ \"rdt\" ][ j ,:,:], data [ \"biomasseTige\" ][ j ,:,:], ) return data def condition_positive_delta_aboveground_biomass_all_phases ( j , data ): #// condition = (data[\"numPhase\"][j,:,:] > 1) & (data[\"deltaBiomasseAerienne\"][j,:,:] >= 0) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] > 0 ) return condition def update_leaf_biomass_all_phases ( j , data , paramVariete ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseFeuille\" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ), data [ \"biomasseFeuille\" ][ j ,:,:] - data [ \"reallocation\" ][ j ,:,:] * paramVariete [ \"pcReallocFeuille\" ], data [ \"biomasseFeuille\" ][ j ,:,:], ) return data def update_stem_biomass_all_phases ( j , data , paramVariete ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseTige\" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ), data [ \"biomasseTige\" ][ j ,:,:] - ( data [ \"reallocation\" ][ j ,:,:] * ( 1 - paramVariete [ \"pcReallocFeuille\" ])), data [ \"biomasseTige\" ][ j ,:,:], ) return data def update_aboveground_biomass_step_2 ( j , data ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseAerienne\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ), data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:], data [ \"biomasseAerienne\" ][ j ,:,:], ) return data def EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ): \"\"\" This function is a wrapper It is adapted from the EvalFeuilleTigeSarrahV4 procedure from the bilancarbonsarra.pas file of the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" # data[\"deltaBiomasseFeuilles\"][j:,:,:] = np.where( # (data[\"numPhase\"][j,:,:] > 1), # data[\"biomasseFeuille\"][j,:,:], # data[\"deltaBiomasseFeuilles\"][j,:,:], # ) # if (data[\"numPhase\"][j,:,:] > 1) & (data[\"deltaBiomasseAerienne\"][j,:,:] < 0) data = update_leaf_biomass ( j , data , paramVariete ) data = update_stem_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne >= 0 and (numPhase <= 4 or numPhase <= phaseDevVeg) data = update_bM_and_cM ( j , data , paramVariete ) data = update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) data = update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne > 0 and numPhase > 1 data = update_leaf_biomass_all_phases ( j , data , paramVariete ) data = update_stem_biomass_all_phases ( j , data , paramVariete ) # condition = (data[\"numPhase\"][j,:,:] > 1) # data[\"deltaBiomasseFeuilles\"][j:,:,:] = np.where( # (data[\"numPhase\"][j,:,:] > 1), # data[\"biomasseFeuille\"][j,:,:] - data[\"deltaBiomasseFeuilles\"][j,:,:], # data[\"deltaBiomasseFeuilles\"][j,:,:], # ) # simpler formulation for updating the deltaBiomasseFeuilles data [ \"deltaBiomasseFeuilles\" ][ j :,:,:] = data [ \"biomasseFeuille\" ][ j ,:,:] - data [ \"biomasseFeuille\" ][ j - 1 ,:,:] data = update_aboveground_biomass_step_2 ( j , data ) return data def update_vegetative_biomass ( j , data ): \"\"\"_summary_ This function is adapted from the EvalBiomasseVegetati procedure from the copie milbilancarbon, exmodules 1 & 2, ***milbilancarbone*** file of the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomasseVegetative\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:]) return data def calculate_canopy_specific_leaf_area ( j , data , paramVariete ): \"\"\" Calculate the specific leaf area (SLA) of the canopy. If the leaf biomass is positive, and if we are at the transition day between phases 1 and 2 (numPhase = 2 and changePhase = 1), then the SLA is set to `slaMax`. If the leaf biomass is positive and increasing (deltaBiomasseFeuilles is positive), the SLA for existing leaves is calculated by reducing it by an amount proportional to the current SLA, while the SLA for new leaves is calculated as the average between SLA and `slaMax`. The SLA for the entire canopy is then calculated as the weighted average of the SLAs for existing and new leaves. If there is no increase in leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for existing leaves is calculated. If the leaf biomass is negative, the SLA is unchanged. The calculated SLA value is bounded between `slaMin` and `slaMax`. This function is adapted from the EvalSlaSarrahV3 procedure in the bilancarbonsarra.pas and exmodules 1 & 2.pas files of the original Pascal code. This calculation method assumes that young leaves have a higher SLA than old leaves and that the fraction of young leaves makes the canopy SLA increase. The `penteSLA` parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between `slaMax` and `slaMin`). Expected parameters: SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax This function estimates the specific leaf area (SLA) of the canopy. First, if the leaf biomass is positive, if numPhase = 2 and changePhase = 1, which means we are at the transition day between phases 1 and 2, sla is set to be equal to slaMax. Then, if the leaf biomass is positive, and if deltaBiomasseFeuilles is positive (meaning that the leaf biomass is increasing), SLA for already existing leaves is calculated by removing a value that is an affine function of SLA itself, and SLA for new leaves is calculated as the mean between SLA and slaMax ; then the SLA is calculated as the weighted mean of the two SLA values. Logically, if there is no newly produced leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for already existing leaves is calculated. If biomasseFeuille is negative, SLA is unchanged. Finally, if biomasseFeuille is positive, SLA value is bounded between slaMin and slaMax. This function is adapted from the EvalSlaSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas file of the original Pascal code. We note that multiple versions of the calculation methods have been used in the original procecure. We may want to go back to that if this function is problematic. Notes : In this approach, it is assumed that young leaves have a higher SLA than old leaves. The fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between SLAmax and SLAmin). This approach is known for legumes, but can also be adapted to other species. Generic/expected parameters : SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax Args: - j (int): The time step. - data (xarray.Dataset): The data for all variables. - paramVariete (dict): Parameters for the calculation. Returns: - data (xarray.Dataset): The updated data with the calculated SLA. \"\"\" condition = ( data [ \"biomasseFeuille\" ][ j ,:,:] > 0 ) & \\ ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"sla\" ][ j :,:,:] = np . where ( condition , paramVariete [ \"slaMax\" ], data [ \"sla\" ][ j ,:,:], ) ratio_old_leaf_biomass = data [ \"biomasseFeuille\" ][ j - 1 ,:,:] / data [ \"biomasseFeuille\" ][ j ,:,:] ratio_new_leaf_biomass = data [ \"deltaBiomasseFeuilles\" ][ j ,:,:] / data [ \"biomasseFeuille\" ][ j ,:,:] sla_decrease_step = paramVariete [ \"slaPente\" ] * ( data [ \"sla\" ][ j ,:,:] - paramVariete [ \"slaMin\" ]) # Modif du 10/07/2018, DeltaBiomasse neg si reallocation ne pas fair l'evol du SLA dans ces conditions data [ \"sla\" ][ j :,:,:] = np . where ( ( data [ \"biomasseFeuille\" ][ j ,:,:] > 0 ), np . where ( ( data [ \"deltaBiomasseFeuilles\" ][ j ,:,:] > 0 ), #// (data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] - data[\"deltaBiomasseFeuilles\"][j,:,:]) / data[\"biomasseFeuille\"][j,:,:] + (paramVariete[\"slaMax\"] + data[\"sla\"][j,:,:])/2 * (data[\"deltaBiomasseFeuilles\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j ,:,:] - sla_decrease_step ) * ratio_old_leaf_biomass + ( paramVariete [ \"slaMax\" ] + data [ \"sla\" ][ j ,:,:]) / 2 * ratio_new_leaf_biomass , #//(data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j ,:,:] - sla_decrease_step ) * ratio_old_leaf_biomass , ), data [ \"sla\" ][ j ,:,:], ) data [ \"sla\" ][ j :,:,:] = np . where ( ( data [ \"biomasseFeuille\" ][ j ,:,:] > 0 ), #// np.minimum(paramVariete[\"slaMin\"], np.maximum(paramVariete[\"slaMax\"], data[\"sla\"][j,:,:])), # according to original # according to ocelet version np . minimum ( paramVariete [ \"slaMax\" ], np . maximum ( paramVariete [ \"slaMin\" ], data [ \"sla\" ][ j ,:,:], ), ), data [ \"sla\" ][ j ,:,:], ) return data def calculate_leaf_area_index ( j , data ): \"\"\" Calculate the leaf area index (LAI) for a given time step. If the number of growth phase (numPhase) is less than or equal to 1, the LAI is set to 0. If the number of growth phase is between 2 and 6, the LAI is calculated as the product of the leaf biomass (biomasseFeuille) and specific leaf area (sla). If the number of growth phase is greater than 6, the LAI is set back to 0. This function is adapted from the EvolLAIPhases procedure from the milbilancarbone.pas and exmodules 1 & 2.pas file of the original Pascal code. Args: timestep (int): The time step to calculate the LAI for. data (xarray.Dataset): The xarray dataset that contains the relevant data. Returns: xarray.Dataset: The updated xarray dataset with the calculated LAI. \"\"\" data [ \"lai\" ][ j :,:,:] = xr . where ( ( data [ \"numPhase\" ][ j ,:,:] <= 1 ), 0 , np . where ( data [ \"numPhase\" ][ j ,:,:] <= 6 , data [ \"biomasseFeuille\" ][ j ,:,:] * data [ \"sla\" ][ j ,:,:], 0 , ) ) return data def update_yield_during_filling_phase ( j , data ): \"\"\" This function updates the yield value during the filling phase. During the filling phase (numPhase == 5), the yield is updated by incrementing it with the sum of `deltaBiomasseAerienne` and `reallocation`, bounded by 0 and `dRdtPot` (daily potential yield). The construction of yield is done during phase 5 only, from the variation of aerial biomass and reallocation, with a maximum of `dRdtPot`. This function is adapted from the EvolDayRdtSarraV3 procedure from the ***bilancarbonesarra***, exmodules 1 & 2.pas file of the original Pascal code. Notes : On tend vers le potentiel en fn du rapport des degresJours/sumDegresJours pour la phase de remplissage. Frein sup fn du flux de s\u00e8ve estim\u00e9 par le rapport Tr/TrPot. dRdtPot = RdtPotDuJour Args: j (int): The time step at which the calculation starts. data (xarray.Dataset): The data that contains all variables. Returns: xarray.Dataset: The input data with updated yield values. \"\"\" data [ \"rdt\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ), data [ \"rdt\" ][ j ,:,:] + np . minimum ( data [ \"dRdtPot\" ][ j ,:,:], np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j ,:,:]) + data [ 'reallocation' ][ j ,:,:]), data [ \"rdt\" ][ j ,:,:], ) return data def BiomDensiteSarraV42 ( j , data , paramITK , paramVariete ): # depuis bilancarbonsarra.pas if ~ np . isnan ( paramVariete [ \"densOpti\" ]): data [ \"rdt\" ][ j :,:,:] = ( data [ \"rdt\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"rdtPot\" ][ j :,:,:] = ( data [ \"rdtPot\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseRacinaire\" ][ j :,:,:] = ( data [ \"biomasseRacinaire\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseTige\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseFeuille\" ][ j :,:,:] = ( data [ \"biomasseFeuille\" ][ j ,:,:] / data [ \"rapDensite\" ]) data [ \"biomasseAerienne\" ][ j :,:,:] = ( data [ \"biomasseTige\" ][ j ,:,:] + data [ \"biomasseFeuille\" ][ j ,:,:] + data [ \"rdt\" ][ j ,:,:]) #? conflit avec fonction evolLAIphase ? #data[\"lai\"][j:,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data [ \"lai\" ][ j :,:,:] = data [ \"lai\" ][ j :,:,:] / data [ \"rapDensite\" ] data [ \"biomasseTotale\" ][ j :,:,:] = ( data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"biomasseRacinaire\" ][ j ,:,:]) #[...,np.newaxis] #data[\"biomasseTotale\"][j:,:,:] = data[\"biomasseTotale\"][j:,:,:] / data[\"rapDensite\"] return data def BiomMcUBTSV3 ( j , data , paramITK ): \"\"\" depuis bilancarbonsarra.pas group 174 Pendant la croissance des cultures la d\ufffdgradation des r\ufffdsidusest calcul\ufffde sans les UBT Ici c'est pendant la saion s\ufffdche quand il n'y a des cultures pas de b\ufffdtes. Sur le mulch dress\ufffd (Up) ou couch\ufffd Lit), on calcul sa d\ufffdgradation journali\ufffdre sur les feuilles et les tiges en fn de coef KN (climat, termites...), KI ingestion par les b\ufffdtes pression en UBT seulement pour les feuilles, KT (effet pi\ufffdtinement) qui va faire passer du stade lev\ufffd en couch\ufffd et du stade couch\ufffd en ensevelissement pression en UBT Par D\ufffdfaut : KNUp = 0.001 /jour KNLit = 0.011 KN est soit une constante soit peut varier en fn climat (pas fait ref STEP) KT = 0.003 KI = 0.005 NbUBT = 10 (zone Fakara) \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] > 0 ) # group 161 data [ \"UBTCulture\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"NbUBT\" ][ j ,:,:]) #[...,np.newaxis] # group 162 data [ \"LitFeuille\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:], data [ \"LitFeuille\" ][ j ,:,:]) #[...,np.newaxis] # group 163 data [ \"LitTige\" ][ j :,:,:] = np . where ( condition , data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:], data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # group 164 data [ \"FeuilleUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"FeuilleUp\" ][ j ,:,:]) #[...,np.newaxis] # group 165 data [ \"TigeUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"TigeUp\" ][ j ,:,:]) #[...,np.newaxis] # group 166 data [ \"biomMc\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:], data [ \"biomMc\" ][ j ,:,:]) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges dress\ufffdes # FeuilleUp := max(0, (FeuilleUp - FeuilleUp * KNUp - FeuilleUp * KI * UBTCulture - FeuilleUp * KT * UBTCulture)); # group 167 data [ \"FeuilleUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"FeuilleUp\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"FeuilleUp\" ][ j ,:,:] \\ * paramITK [ \"KI\" ] * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 168 # TigeUp := max(0, (TigeUp - TigeUp * KNUp - TigeUp * KT * UBTCulture)); data [ \"TigeUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"TigeUp\" ][ j ,:,:] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges couch\ufffdes (liti\ufffdre) # group 169 # LitFeuille := max(0, (LitFeuille - LitFeuille * KNLit - LitFeuille * KI * UBTCulture - LitFeuille * KT * UBTCulture)); data [ \"LitFeuille\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitFeuille\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KI\" ] \\ * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 170 # LitTige := max(0, (LitTige - LitTige * KNLit - LitTige * KT * UBTCulture)); data [ \"LitTige\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitTige\" ][ j ,:,:] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 171 #BiomMc := LitFeuille + LitTige; data [ \"biomMc\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # #// transfert dress\ufffd \ufffd liti\ufffdre effet pi\ufffdtinement # LitFeuille := LitFeuille + FeuilleUp * KT * UBTCulture; # group 172 data [ \"LitFeuille\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # LitTige := LitTige + TigeUp * KT * UBTCulture; # group 173 data [ \"LitTige\" ][ j :,:,:] = ( data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # // le 01/03 on consid\ufffdre que toutes les pailles et feuilles dressees sont couchees # if (trunc(DayOfTheYear(DateEnCours)) = 61) then # begin # LitFeuille := LitFeuille + FeuilleUp; # LitTige := LitTige + TigeUp; # FeuilleUp := 0; # TigeUp := 0; # BiomMc := LitFeuille + LitTige; # end; return data def MAJBiomMcSV3 ( data ): \"\"\" groupe 182 A la Recolte, on calcul la part des biomasses qui restent sur place (Up), non r\ufffdcolt\ufffdes et la part qui est mise \ufffd terre (Liti\ufffdre) sur ce qui est laiss\ufffd sur place On met a jour aussi la biomasse des liti\ufffdres pour les calculs effet mulch sue lr bilan hydrique \"\"\" # if (NumPhase =7) then # begin # groupe 175 # FeuilleUp := FeuilleUp + BiomasseFeuilles * (1-TxRecolte); # groupe 176 # TigeUp := TigeUp + BiomasseTiges * (1-TxRecolte); # groupe 177 # LitFeuille := LitFeuille + FeuilleUp * TxaTerre; # groupe 178 # LitTige := LitTige + TigeUp * TxaTerre; # groupe 179 # FeuilleUp := FeuilleUp * (1-TxaTerre); # groupe 180 # TigeUp := TigeUp * (1-TxaTerre); # // LitTige := LitTige + BiomMc; # groupe 181 # BiomMC := LitFeuille + LitTige; # { BiomasseFeuilles := 0; # BiomasseTiges := 0; return data def estimate_critical_nitrogen_concentration ( j , data ): # estimate critical nitrogen concentration from plant dry matter using the Justes et al (1994) relationship data [ \"Ncrit\" ][ j ,:,:] = 5.35 * ( data [ \"biomasseTotale\" ][ j ,:,:] / 1000 ) ** ( - 0.44 ) return data","title":"Module sarra_py.bilan_carbo"},{"location":"reference/sarra_py/bilan_carbo/#functions","text":"","title":"Functions"},{"location":"reference/sarra_py/bilan_carbo/#biomdensoptsarrav4","text":"def BiomDensOptSarraV4 ( j , data , paramITK ) si densit\u00e9 plus faible alors on consid\u00e9re qu'il faut augmenter les biomasses, LAI etc en regard de cette situation au niveau de chaque plante (car tout est rapport\u00e9 \u00e9 des kg/ha). Si elle est plus forte on ne change rien pour lors. Valeur fixe en ref au ma\u00e9s \u00e9 d\u00e9f en param\u00e9tre par vari\u00e9t\u00e9s\u00e9 rapDensite := Max(1, 70000/densite); View Source def BiomDensOptSarraV4 ( j , data , paramITK ): \"\"\" si densit\u00e9 plus faible alors on consid\u00e9re qu'il faut augmenter les biomasses, LAI etc en regard de cette situation au niveau de chaque plante (car tout est rapport\u00e9 \u00e9 des kg/ha). Si elle est plus forte on ne change rien pour lors. Valeur fixe en ref au ma\u00e9s \u00e9 d\u00e9f en param\u00e9tre par vari\u00e9t\u00e9s\u00e9 rapDensite := Max(1, 70000/densite); \"\"\" \"\"\" if ~np.isnan(paramVariete[\"densOpti\"]) : paramITK[\"rapDensite\"] = np.maximum(1,paramVariete[\"densOpti\"]/paramITK[\"densite\"]) data[\"rdt\"][j,:,:] = data[\"rdt\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseRacinaire\"][j,:,:] = data[\"biomasseRacinaire\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseTige\"][j,:,:] = data[\"biomasseTige\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseFeuille\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * paramITK[\"rapDensite\"] data[\"biomasseAerienne\"][j,:,:] = data[\"biomasseTige\"][j,:,:] + data[\"biomasseFeuille\"][j,:,:] + data[\"rdt\"][j,:,:] data[\"lai\"][j,:,:] = data[\"biomasseFeuille\"][j,:,:] * data[\"sla\"][j,:,:] data[\"biomasseTotale\"][j,:,:] = data[\"biomasseAerienne\"][j,:,:] + data[\"biomasseRacinaire\"][j,:,:] return data \"\"\" return data","title":"BiomDensOptSarraV4"},{"location":"reference/sarra_py/bilan_carbo/#biomdensitesarrav42","text":"def BiomDensiteSarraV42 ( j , data , paramITK , paramVariete ) View Source def BiomDensiteSarraV42 ( j , data , paramITK , paramVariete ) : # depuis bilancarbonsarra . pas if ~ np . isnan ( paramVariete [ \" densOpti \" ] ) : data [ \" rdt \" ][ j :,:,:] = ( data [ \" rdt \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" rdtPot \" ][ j :,:,:] = ( data [ \" rdtPot \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseRacinaire \" ][ j :,:,:] = ( data [ \" biomasseRacinaire \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseTige \" ][ j :,:,:] = ( data [ \" biomasseTige \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseFeuille \" ][ j :,:,:] = ( data [ \" biomasseFeuille \" ][ j ,:,:] / data [ \" rapDensite \" ] ) data [ \" biomasseAerienne \" ][ j :,:,:] = ( data [ \" biomasseTige \" ][ j ,:,:] + data [ \" biomasseFeuille \" ][ j ,:,:] + data [ \" rdt \" ][ j ,:,:] ) #? conflit avec fonction evolLAIphase ? # data [ \" lai \" ][ j :,:,:] = data [ \" biomasseFeuille \" ][ j ,:,:] * data [ \" sla \" ][ j ,:,:] data [ \" lai \" ][ j :,:,:] = data [ \" lai \" ][ j :,:,:] / data [ \" rapDensite \" ] data [ \" biomasseTotale \" ][ j :,:,:] = ( data [ \" biomasseAerienne \" ][ j ,:,:] + data [ \" biomasseRacinaire \" ][ j ,:,:] ) #[..., np . newaxis ] # data [ \" biomasseTotale \" ][ j :,:,:] = data [ \" biomasseTotale \" ][ j :,:,:] / data [ \" rapDensite \" ] return data","title":"BiomDensiteSarraV42"},{"location":"reference/sarra_py/bilan_carbo/#biommcubtsv3","text":"def BiomMcUBTSV3 ( j , data , paramITK ) depuis bilancarbonsarra.pas group 174 Pendant la croissance des cultures la d\ufffdgradation des r\ufffdsidusest calcul\ufffde sans les UBT Ici c'est pendant la saion s\ufffdche quand il n'y a des cultures pas de b\ufffdtes. Sur le mulch dress\ufffd (Up) ou couch\ufffd Lit), on calcul sa d\ufffdgradation journali\ufffdre sur les feuilles et les tiges en fn de coef KN (climat, termites...), KI ingestion par les b\ufffdtes pression en UBT seulement pour les feuilles, KT (effet pi\ufffdtinement) qui va faire passer du stade lev\ufffd en couch\ufffd et du stade couch\ufffd en ensevelissement pression en UBT Par D\ufffdfaut : KNUp = 0.001 /jour KNLit = 0.011 KN est soit une constante soit peut varier en fn climat (pas fait ref STEP) KT = 0.003 KI = 0.005 NbUBT = 10 (zone Fakara) View Source def BiomMcUBTSV3 ( j , data , paramITK ): \"\"\" depuis bilancarbonsarra.pas group 174 Pendant la croissance des cultures la d\ufffdgradation des r\ufffdsidusest calcul\ufffde sans les UBT Ici c'est pendant la saion s\ufffdche quand il n'y a des cultures pas de b\ufffdtes. Sur le mulch dress\ufffd (Up) ou couch\ufffd Lit), on calcul sa d\ufffdgradation journali\ufffdre sur les feuilles et les tiges en fn de coef KN (climat, termites...), KI ingestion par les b\ufffdtes pression en UBT seulement pour les feuilles, KT (effet pi\ufffdtinement) qui va faire passer du stade lev\ufffd en couch\ufffd et du stade couch\ufffd en ensevelissement pression en UBT Par D\ufffdfaut : KNUp = 0.001 /jour KNLit = 0.011 KN est soit une constante soit peut varier en fn climat (pas fait ref STEP) KT = 0.003 KI = 0.005 NbUBT = 10 (zone Fakara) \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] > 0 ) # group 161 data [ \"UBTCulture\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"NbUBT\" ][ j ,:,:]) #[...,np.newaxis] # group 162 data [ \"LitFeuille\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:], data [ \"LitFeuille\" ][ j ,:,:]) #[...,np.newaxis] # group 163 data [ \"LitTige\" ][ j :,:,:] = np . where ( condition , data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:], data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # group 164 data [ \"FeuilleUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"FeuilleUp\" ][ j ,:,:]) #[...,np.newaxis] # group 165 data [ \"TigeUp\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"TigeUp\" ][ j ,:,:]) #[...,np.newaxis] # group 166 data [ \"biomMc\" ][ j :,:,:] = np . where ( condition , data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:], data [ \"biomMc\" ][ j ,:,:]) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges dress\ufffdes # FeuilleUp := max(0, (FeuilleUp - FeuilleUp * KNUp - FeuilleUp * KI * UBTCulture - FeuilleUp * KT * UBTCulture)); # group 167 data [ \"FeuilleUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"FeuilleUp\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"FeuilleUp\" ][ j ,:,:] \\ * paramITK [ \"KI\" ] * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 168 # TigeUp := max(0, (TigeUp - TigeUp * KNUp - TigeUp * KT * UBTCulture)); data [ \"TigeUp\" ][ j :,:,:] = np . maximum ( 0 , data [ \"TigeUp\" ][ j ,:,:] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KNUp\" ] - data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] #// D\ufffdgradation des feuilles et tiges couch\ufffdes (liti\ufffdre) # group 169 # LitFeuille := max(0, (LitFeuille - LitFeuille * KNLit - LitFeuille * KI * UBTCulture - LitFeuille * KT * UBTCulture)); data [ \"LitFeuille\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitFeuille\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KI\" ] \\ * data [ \"UBTCulture\" ][ j ,:,:] - data [ \"LitFeuille\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 170 # LitTige := max(0, (LitTige - LitTige * KNLit - LitTige * KT * UBTCulture)); data [ \"LitTige\" ][ j :,:,:] = np . maximum ( 0 , data [ \"LitTige\" ][ j ,:,:] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KNLit\" ] - data [ \"LitTige\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:], ) #[...,np.newaxis] # group 171 #BiomMc := LitFeuille + LitTige; data [ \"biomMc\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"LitTige\" ][ j ,:,:]) #[...,np.newaxis] # #// transfert dress\ufffd \ufffd liti\ufffdre effet pi\ufffdtinement # LitFeuille := LitFeuille + FeuilleUp * KT * UBTCulture; # group 172 data [ \"LitFeuille\" ][ j :,:,:] = ( data [ \"LitFeuille\" ][ j ,:,:] + data [ \"FeuilleUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # LitTige := LitTige + TigeUp * KT * UBTCulture; # group 173 data [ \"LitTige\" ][ j :,:,:] = ( data [ \"LitTige\" ][ j ,:,:] + data [ \"TigeUp\" ][ j ,:,:] * paramITK [ \"KT\" ] * data [ \"UBTCulture\" ][ j ,:,:]) #[...,np.newaxis] # // le 01/03 on consid\ufffdre que toutes les pailles et feuilles dressees sont couchees # if (trunc(DayOfTheYear(DateEnCours)) = 61) then # begin # LitFeuille := LitFeuille + FeuilleUp; # LitTige := LitTige + TigeUp; # FeuilleUp := 0; # TigeUp := 0; # BiomMc := LitFeuille + LitTige; # end; return data","title":"BiomMcUBTSV3"},{"location":"reference/sarra_py/bilan_carbo/#evalassimsarrahv4","text":"def EvalAssimSarrahV4 ( j , data ) data[\"parIntercepte\"][j,:,:] = 0.5 * (1 - data[\"ltr\"][j,:,:]) * data[\"rg\"][j,:,:] data[\"assimPot\"][j:,:,:] = data[\"parIntercepte\"][j,:,:] * data[\"conv\"][j,:,:] * 10 data[\"assim\"][j,:,:] = np.where( data[\"trPot\"][j,:,:] > 0, data[\"assimPot\"][j,:,:] * data[\"tr\"][j,:,:] / data[\"trPot\"][j,:,:], 0, ) View Source def EvalAssimSarrahV4 ( j , data ) : \"\"\" data [ \" parIntercepte \" ][ j ,:,:] = 0 . 5 * ( 1 - data [ \" ltr \" ][ j ,:,:] ) * data [ \" rg \" ][ j ,:,:] data [ \" assimPot \" ][ j :,:,:] = data [ \" parIntercepte \" ][ j ,:,:] * data [ \" conv \" ][ j ,:,:] * 10 data [ \" assim \" ][ j ,:,:] = np . where ( data [ \" trPot \" ][ j ,:,:] > 0 , data [ \" assimPot \" ][ j ,:,:] * data [ \" tr \" ][ j ,:,:] / data [ \" trPot \" ][ j ,:,:], 0 , ) \"\"\" return data","title":"EvalAssimSarrahV4"},{"location":"reference/sarra_py/bilan_carbo/#evalfeuilletigesarrahv4","text":"def EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) This function is a wrapper It is adapted from the EvalFeuilleTigeSarrahV4 procedure from the bilancarbonsarra.pas file of the original Pascal code. Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) : \"\"\" This function is a wrapper It is adapted from the EvalFeuilleTigeSarrahV4 procedure from the bilancarbonsarra . pas file of the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # data [ \" deltaBiomasseFeuilles \" ][ j :,:,:] = np . where ( # ( data [ \" numPhase \" ][ j ,:,:] > 1 ) , # data [ \" biomasseFeuille \" ][ j ,:,:], # data [ \" deltaBiomasseFeuilles \" ][ j ,:,:], # ) # if ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] < 0 ) data = update_leaf_biomass ( j , data , paramVariete ) data = update_stem_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne >= 0 and ( numPhase <= 4 or numPhase <= phaseDevVeg ) data = update_bM_and_cM ( j , data , paramVariete ) data = update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) data = update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) # if deltaBiomasseAerienne > 0 and numPhase > 1 data = update_leaf_biomass_all_phases ( j , data , paramVariete ) data = update_stem_biomass_all_phases ( j , data , paramVariete ) # condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) # data [ \" deltaBiomasseFeuilles \" ][ j :,:,:] = np . where ( # ( data [ \" numPhase \" ][ j ,:,:] > 1 ) , # data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" deltaBiomasseFeuilles \" ][ j ,:,:], # data [ \" deltaBiomasseFeuilles \" ][ j ,:,:], # ) # simpler formulation for updating the deltaBiomasseFeuilles data [ \" deltaBiomasseFeuilles \" ][ j :,:,:] = data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" biomasseFeuille \" ][ j - 1 ,:,:] data = update_aboveground_biomass_step_2 ( j , data ) return data","title":"EvalFeuilleTigeSarrahV4"},{"location":"reference/sarra_py/bilan_carbo/#majbiommcsv3","text":"def MAJBiomMcSV3 ( data ) groupe 182 A la Recolte, on calcul la part des biomasses qui restent sur place (Up), non r\ufffdcolt\ufffdes et la part qui est mise \ufffd terre (Liti\ufffdre) sur ce qui est laiss\ufffd sur place On met a jour aussi la biomasse des liti\ufffdres pour les calculs effet mulch sue lr bilan hydrique View Source def MAJBiomMcSV3 ( data ) : \"\"\" groupe 182 A la Recolte, on calcul la part des biomasses qui restent sur place (Up), non r\ufffdcolt\ufffdes et la part qui est mise \ufffd terre (Liti\ufffdre) sur ce qui est laiss\ufffd sur place On met a jour aussi la biomasse des liti\ufffdres pour les calculs effet mulch sue lr bilan hydrique \"\"\" # if ( NumPhase = 7 ) then # begin # groupe 175 # FeuilleUp := FeuilleUp + BiomasseFeuilles * ( 1 - TxRecolte ); # groupe 176 # TigeUp := TigeUp + BiomasseTiges * ( 1 - TxRecolte ); # groupe 177 # LitFeuille := LitFeuille + FeuilleUp * TxaTerre ; # groupe 178 # LitTige := LitTige + TigeUp * TxaTerre ; # groupe 179 # FeuilleUp := FeuilleUp * ( 1 - TxaTerre ); # groupe 180 # TigeUp := TigeUp * ( 1 - TxaTerre ); # // LitTige := LitTige + BiomMc ; # groupe 181 # BiomMC := LitFeuille + LitTige ; # { BiomasseFeuilles := 0 ; # BiomasseTiges := 0 ; return data","title":"MAJBiomMcSV3"},{"location":"reference/sarra_py/bilan_carbo/#adjust_for_sowing_density","text":"def adjust_for_sowing_density ( j , data , paramVariete , direction ) This function translates the effect of sowing density on biomass and LAI. This function is adapted from the BiomDensOptSarV42 and BiomDensiteSarraV42 procedures, from the bilancarbonsarra.pas original Pascal code. Notes from CB : if density is lower than the optimal density, then we consider that we need to increase the biomass, LAI etc in regard of this situation at each plant level (because everything is related to kg/ha). If it is higher, it increases asymptotically. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def adjust_for_sowing_density ( j , data , paramVariete , direction ) : \"\"\" This function translates the effect of sowing density on biomass and LAI . This function is adapted from the BiomDensOptSarV42 and BiomDensiteSarraV42 procedures , from the bilancarbonsarra . pas original Pascal code . Notes from CB : if density is lower than the optimal density , then we consider that we need to increase the biomass , LAI etc in regard of this situation at each plant level ( because everything is related to kg / ha ). If it is higher , it increases asymptotically . Args: j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns: _type_: _description_ \"\"\" if direction == \"in\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rdt\" ][ j: , : , : ] = data [ \"rdt\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ] data [ \"rdtPot\" ][ j: , : , : ] = ( data [ \"rdtPot\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseRacinaire\" ][ j: , : , : ] = ( data [ \"biomasseRacinaire\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseTige\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseFeuille\" ][ j: , : , : ] = ( data [ \"biomasseFeuille\" ][ j , : , : ] * data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseAerienne\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] + data [ \"biomasseFeuille\" ][ j , : , : ] + data [ \"rdt\" ][ j , : , : ]) data [ \"lai\" ][ j: , : , : ] = ( data [ \"biomasseFeuille\" ][ j , : , : ] * data [ \"sla\" ][ j , : , : ]) data [ \"biomasseTotale\" ][ j: , : , : ] = ( data [ \"biomasseAerienne\" ][ j , : , : ] + data [ \"biomasseRacinaire\" ][ j , : , : ]) return data if direction == \"out\" : if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rdt\" ][ j: , : , : ] = ( data [ \"rdt\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"rdtPot\" ][ j: , : , : ] = ( data [ \"rdtPot\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseRacinaire\" ][ j: , : , : ] = ( data [ \"biomasseRacinaire\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseTige\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseFeuille\" ][ j: , : , : ] = ( data [ \"biomasseFeuille\" ][ j , : , : ] / data [ \"rapDensite\" ][ j , : , : ]) data [ \"biomasseAerienne\" ][ j: , : , : ] = ( data [ \"biomasseTige\" ][ j , : , : ] + data [ \"biomasseFeuille\" ][ j , : , : ] + data [ \"rdt\" ][ j , : , : ]) # ? conflit avec fonction evolLAIphase ? # data [ \"lai\" ][ j: , : , : ] = data [ \"biomasseFeuille\" ][ j , : , : ] * data [ \"sla\" ][ j , : , : ] data [ \"lai\" ][ j: , : , : ] = data [ \"lai\" ][ j: , : , : ] / data [ \"rapDensite\" ][ j , : , : ] data [ \"biomasseTotale\" ][ j: , : , : ] = ( data [ \"biomasseAerienne\" ][ j , : , : ] + data [ \"biomasseRacinaire\" ][ j , : , : ])#[..., np . newaxis ] # data [ \"biomasseTotale\" ][ j: , : , : ] = data [ \"biomasseTotale\" ][ j: , : , : ] / data [ \"rapDensite\" ] return data","title":"adjust_for_sowing_density"},{"location":"reference/sarra_py/bilan_carbo/#calculate_canopy_specific_leaf_area","text":"def calculate_canopy_specific_leaf_area ( j , data , paramVariete ) Calculate the specific leaf area (SLA) of the canopy. If the leaf biomass is positive, and if we are at the transition day between phases 1 and 2 (numPhase = 2 and changePhase = 1), then the SLA is set to slaMax . If the leaf biomass is positive and increasing (deltaBiomasseFeuilles is positive), the SLA for existing leaves is calculated by reducing it by an amount proportional to the current SLA, while the SLA for new leaves is calculated as the average between SLA and slaMax . The SLA for the entire canopy is then calculated as the weighted average of the SLAs for existing and new leaves. If there is no increase in leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for existing leaves is calculated. If the leaf biomass is negative, the SLA is unchanged. The calculated SLA value is bounded between slaMin and slaMax . This function is adapted from the EvalSlaSarrahV3 procedure in the bilancarbonsarra.pas and exmodules 1 & 2.pas files of the original Pascal code. This calculation method assumes that young leaves have a higher SLA than old leaves and that the fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between slaMax and slaMin ). Expected parameters: SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax This function estimates the specific leaf area (SLA) of the canopy. First, if the leaf biomass is positive, if numPhase = 2 and changePhase = 1, which means we are at the transition day between phases 1 and 2, sla is set to be equal to slaMax. Then, if the leaf biomass is positive, and if deltaBiomasseFeuilles is positive (meaning that the leaf biomass is increasing), SLA for already existing leaves is calculated by removing a value that is an affine function of SLA itself, and SLA for new leaves is calculated as the mean between SLA and slaMax ; then the SLA is calculated as the weighted mean of the two SLA values. Logically, if there is no newly produced leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for already existing leaves is calculated. If biomasseFeuille is negative, SLA is unchanged. Finally, if biomasseFeuille is positive, SLA value is bounded between slaMin and slaMax. This function is adapted from the EvalSlaSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas file of the original Pascal code. We note that multiple versions of the calculation methods have been used in the original procecure. We may want to go back to that if this function is problematic. Notes : In this approach, it is assumed that young leaves have a higher SLA than old leaves. The fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between SLAmax and SLAmin). This approach is known for legumes, but can also be adapted to other species. Generic/expected parameters : SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax Args: - j (int): The time step. - data (xarray.Dataset): The data for all variables. - paramVariete (dict): Parameters for the calculation. Returns: - data (xarray.Dataset): The updated data with the calculated SLA. View Source def calculate_canopy_specific_leaf_area ( j , data , paramVariete ) : \" \"\" Calculate the specific leaf area (SLA) of the canopy. If the leaf biomass is positive, and if we are at the transition day between phases 1 and 2 (numPhase = 2 and changePhase = 1), then the SLA is set to `slaMax`. If the leaf biomass is positive and increasing (deltaBiomasseFeuilles is positive), the SLA for existing leaves is calculated by reducing it by an amount proportional to the current SLA, while the SLA for new leaves is calculated as the average between SLA and `slaMax`. The SLA for the entire canopy is then calculated as the weighted average of the SLAs for existing and new leaves. If there is no increase in leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for existing leaves is calculated. If the leaf biomass is negative, the SLA is unchanged. The calculated SLA value is bounded between `slaMin` and `slaMax`. This function is adapted from the EvalSlaSarrahV3 procedure in the bilancarbonsarra.pas and exmodules 1 & 2.pas files of the original Pascal code. This calculation method assumes that young leaves have a higher SLA than old leaves and that the fraction of young leaves makes the canopy SLA increase. The `penteSLA` parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between `slaMax` and `slaMin`). Expected parameters: SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax This function estimates the specific leaf area (SLA) of the canopy. First, if the leaf biomass is positive, if numPhase = 2 and changePhase = 1, which means we are at the transition day between phases 1 and 2, sla is set to be equal to slaMax. Then, if the leaf biomass is positive, and if deltaBiomasseFeuilles is positive (meaning that the leaf biomass is increasing), SLA for already existing leaves is calculated by removing a value that is an affine function of SLA itself, and SLA for new leaves is calculated as the mean between SLA and slaMax ; then the SLA is calculated as the weighted mean of the two SLA values. Logically, if there is no newly produced leaf biomass (deltaBiomasseFeuilles is negative), only the SLA for already existing leaves is calculated. If biomasseFeuille is negative, SLA is unchanged. Finally, if biomasseFeuille is positive, SLA value is bounded between slaMin and slaMax. This function is adapted from the EvalSlaSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas file of the original Pascal code. We note that multiple versions of the calculation methods have been used in the original procecure. We may want to go back to that if this function is problematic. Notes : In this approach, it is assumed that young leaves have a higher SLA than old leaves. The fraction of young leaves makes the canopy SLA increase. The penteSLA parameter causes a general decrease in SLA (penteSLA = relative decrease per day = fraction of difference between SLAmax and SLAmin). This approach is known for legumes, but can also be adapted to other species. Generic/expected parameters : SLAmax [0.001, 0.01] SLAmin [0.001, 0.01] penteSLA [0, 0.2] SLAini = SLAmax Args: - j (int): The time step. - data (xarray.Dataset): The data for all variables. - paramVariete (dict): Parameters for the calculation. Returns: - data (xarray.Dataset): The updated data with the calculated SLA. \"\" \" condition = ( data [ \"biomasseFeuille\" ][ j , : , : ] > 0 ) & \\ ( data [ \"numPhase\" ][ j , : , : ] == 2 ) & \\ ( data [ \"changePhase\" ][ j , : , : ] == 1 ) data [ \"sla\" ][ j : , : , : ] = np . where ( condition , paramVariete [ \"slaMax\" ] , data [ \"sla\" ][ j , : , : ] , ) ratio_old_leaf_biomass = data [ \"biomasseFeuille\" ][ j - 1 , : , : ] / data [ \"biomasseFeuille\" ][ j , : , : ] ratio_new_leaf_biomass = data [ \"deltaBiomasseFeuilles\" ][ j , : , : ] / data [ \"biomasseFeuille\" ][ j , : , : ] sla_decrease_step = paramVariete [ \"slaPente\" ] * ( data [ \"sla\" ][ j , : , : ] - paramVariete [ \"slaMin\" ] ) # Modif du 10/07/2018, DeltaBiomasse neg si reallocation ne pas fair l'evol du SLA dans ces conditions data [ \"sla\" ][ j : , : , : ] = np . where ( ( data [ \"biomasseFeuille\" ][ j , : , : ] > 0 ), np . where ( ( data [ \"deltaBiomasseFeuilles\" ][ j , : , : ] > 0 ), #// (data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] - data[\"deltaBiomasseFeuilles\"][j,:,:]) / data[\"biomasseFeuille\"][j,:,:] + (paramVariete[\"slaMax\"] + data[\"sla\"][j,:,:])/2 * (data[\"deltaBiomasseFeuilles\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j , : , : ] - sla_decrease_step ) * ratio_old_leaf_biomass + ( paramVariete [ \"slaMax\" ] + data [ \"sla\" ][ j , : , : ] ) / 2 * ratio_new_leaf_biomass , #//(data[\"sla\"][j,:,:] - paramVariete[\"slaPente\"] * (data[\"sla\"][j,:,:] - paramVariete[\"slaMin\"])) * (data[\"biomasseFeuille\"][j,:,:] / data[\"biomasseFeuille\"][j,:,:]), ( data [ \"sla\" ][ j , : , : ] - sla_decrease_step ) * ratio_old_leaf_biomass , ), data [ \"sla\" ][ j , : , : ] , ) data [ \"sla\" ][ j : , : , : ] = np . where ( ( data [ \"biomasseFeuille\" ][ j , : , : ] > 0 ), #// np.minimum(paramVariete[\"slaMin\"], np.maximum(paramVariete[\"slaMax\"], data[\"sla\"][j,:,:])), # according to original # according to ocelet version np . minimum ( paramVariete [ \"slaMax\" ] , np . maximum ( paramVariete [ \"slaMin\" ] , data [ \"sla\" ][ j , : , : ] , ), ), data [ \"sla\" ][ j , : , : ] , ) return data","title":"calculate_canopy_specific_leaf_area"},{"location":"reference/sarra_py/bilan_carbo/#calculate_leaf_area_index","text":"def calculate_leaf_area_index ( j , data ) Calculate the leaf area index (LAI) for a given time step. If the number of growth phase (numPhase) is less than or equal to 1, the LAI is set to 0. If the number of growth phase is between 2 and 6, the LAI is calculated as the product of the leaf biomass (biomasseFeuille) and specific leaf area (sla). If the number of growth phase is greater than 6, the LAI is set back to 0. This function is adapted from the EvolLAIPhases procedure from the milbilancarbone.pas and exmodules 1 & 2.pas file of the original Pascal code. Parameters: Name Type Description Default timestep int The time step to calculate the LAI for. None data xarray.Dataset The xarray dataset that contains the relevant data. None Returns: Type Description xarray.Dataset The updated xarray dataset with the calculated LAI. View Source def calculate_leaf_area_index ( j , data ) : \"\"\" Calculate the leaf area index ( LAI ) for a given time step . If the number of growth phase ( numPhase ) is less than or equal to 1 , the LAI is set to 0 . If the number of growth phase is between 2 and 6 , the LAI is calculated as the product of the leaf biomass ( biomasseFeuille ) and specific leaf area ( sla ) . If the number of growth phase is greater than 6 , the LAI is set back to 0 . This function is adapted from the EvolLAIPhases procedure from the milbilancarbone . pas and exmodules 1 & 2 . pas file of the original Pascal code . Args : timestep ( int ) : The time step to calculate the LAI for . data ( xarray . Dataset ) : The xarray dataset that contains the relevant data . Returns : xarray . Dataset : The updated xarray dataset with the calculated LAI . \"\"\" data [ \" lai \" ][ j :,:,:] = xr . where ( ( data [ \" numPhase \" ][ j ,:,:] <= 1 ) , 0 , np . where ( data [ \" numPhase \" ][ j ,:,:] <= 6 , data [ \" biomasseFeuille \" ][ j ,:,:] * data [ \" sla \" ][ j ,:,:], 0 , ) ) return data","title":"calculate_leaf_area_index"},{"location":"reference/sarra_py/bilan_carbo/#calculate_maintainance_respiration","text":"def calculate_maintainance_respiration ( j , data , paramVariete ) This function calculates the maintenance respiration respMaint (in kg/ha/j in equivalent dry matter) of the plant. The maintenance respiration is calculated by summing the maintenance respiration associated with total biomass and leaves biomass. If the plant's growth phase is above 4 and there is no leaf biomass, respMaint is set to 0. The calculation is based on the equation: coefficient_temp = 2^((average_temp - tempMaint) / 10) respiration = kRespMaint * biomass * coefficient_temp where average_temp is the average temperature for the day, tempMaint is the maintenance temperature from variety_params , kRespMaint is the maintenance respiration coefficient from variety_params , and biomass is the total or leaf biomass. Parameters: Name Type Description Default j int The time step of the calculation. None data xarray.Dataset The input data containing the variables tpMoy , biomasseTotale , biomasseFeuille , and numPhase . The output respMaint will also be stored in this dataset. None variety_params dict The parameters related to the plant variety, containing the keys tempMaint and kRespMaint . None Returns: Type Description xarray.Dataset The input data with the updated respMaint variable. View Source def calculate_maintainance_respiration ( j , data , paramVariete ) : \" \"\" This function calculates the maintenance respiration `respMaint` (in kg/ha/j in equivalent dry matter) of the plant. The maintenance respiration is calculated by summing the maintenance respiration associated with total biomass and leaves biomass. If the plant's growth phase is above 4 and there is no leaf biomass, `respMaint` is set to 0. The calculation is based on the equation: coefficient_temp = 2^((average_temp - tempMaint) / 10) respiration = kRespMaint * biomass * coefficient_temp where `average_temp` is the average temperature for the day, `tempMaint` is the maintenance temperature from `variety_params`, `kRespMaint` is the maintenance respiration coefficient from `variety_params`, and `biomass` is the total or leaf biomass. Args: j (int): The time step of the calculation. data (xarray.Dataset): The input data containing the variables `tpMoy`, `biomasseTotale`, `biomasseFeuille`, and `numPhase`. The output `respMaint` will also be stored in this dataset. variety_params (dict): The parameters related to the plant variety, containing the keys `tempMaint` and `kRespMaint`. Returns: xarray.Dataset: The input `data` with the updated `respMaint` variable. \"\" \" coefficient_temp = 2 ** (( data [ \"tpMoy\" ][ j , : , : ] - paramVariete [ \"tempMaint\" ] ) / 10 ) resp_totale = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseTotale\" ][ j , : , : ] * coefficient_temp resp_feuille = paramVariete [ \"kRespMaint\" ] * data [ \"biomasseFeuille\" ][ j , : , : ] * coefficient_temp data [ \"respMaint\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] > 4 ) & ( data [ \"biomasseFeuille\" ][ j , : , : ] == 0 ), 0 , resp_totale + resp_feuille , ) return data","title":"calculate_maintainance_respiration"},{"location":"reference/sarra_py/bilan_carbo/#compute_rapdensite","text":"def compute_rapDensite ( paramITK , paramVariete ) It basically calculates a correction factor (rapDensite). This correction factor Is calculated with an equation of form a + p * exp( -(x/(o / -log((1-a)/p) )) ) with a the densiteA parameter p the densiteP parameter$ x the actual crop density o the densOpti parameter See https://www.wolframalpha.com/input?i=a+%2B+p+*+exp%28-%28x+%2F+%28+o%2F-+log%28%281+-+a%29%2F+p%29%29%29%29 for equation visualization. This equation is probably too complex for the problem at hand. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def compute_rapDensite ( paramITK , paramVariete ) : \"\"\" It basically calculates a correction factor (rapDensite). This correction factor Is calculated with an equation of form a + p * exp( -(x/(o / -log((1-a)/p) )) ) with a the densiteA parameter p the densiteP parameter$ x the actual crop density o the densOpti parameter See https://www.wolframalpha.com/input?i=a+%2B+p+*+exp%28-%28x+%2F+%28+o%2F-+log%28%281+-+a%29%2F+p%29%29%29%29 for equation visualization. This equation is probably too complex for the problem at hand. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" rapDensite = paramVariete [ \"densiteA\" ] + paramVariete [ \"densiteP\" ] * np . exp ( - ( paramITK [ \"densite\" ] / ( paramVariete [ \"densOpti\" ] /- np . log (( 1 - paramVariete [ ' densiteA ' ]) / paramVariete [ \"densiteP\" ])))) return rapDensite","title":"compute_rapDensite"},{"location":"reference/sarra_py/bilan_carbo/#condition_positive_delta_aboveground_biomass_all_phases","text":"def condition_positive_delta_aboveground_biomass_all_phases ( j , data ) View Source def condition_positive_delta_aboveground_biomass_all_phases ( j , data ) : # // condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] >= 0 ) condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] > 0 ) return condition","title":"condition_positive_delta_aboveground_biomass_all_phases"},{"location":"reference/sarra_py/bilan_carbo/#condition_positive_delta_biomass","text":"def condition_positive_delta_biomass ( j , data , paramVariete ) View Source def condition_positive_delta_biomass ( j , data , paramVariete ) : condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & \\ ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] >= 0 ) & \\ (( data [ \" numPhase \" ][ j ,:,:] <= 4 ) | ( data [ \" numPhase \" ][ j ,:,:] <= paramVariete [ \" phaseDevVeg \" ] )) # ( data [ \" numPhase \" ][ j ,:,:] <= 4 ) return condition","title":"condition_positive_delta_biomass"},{"location":"reference/sarra_py/bilan_carbo/#estimate_kassim","text":"def estimate_KAssim ( j , data , paramVariete ) This function calculates the conversion factor KAssim , which is used to convert assimilates into biomass. The value of KAssim depends on the phase of the crop. The conversion factor is calculated based on a lookup table that maps crop phases to values. The crop phase is determined by the numPhase field in the data argument, and the corresponding KAssim value is set in the KAssim field of the data argument. Parameters: Name Type Description Default j int An integer index specifying the time step. None data xarray.Dataset A dataset containing the variables used in the calculation of KAssim . The dataset should include the fields numPhase , sdj , seuilTemp PhasePrec , and seuilTemp PhaseSuivante . The KAssim field of the dataset will be updated by this function. None paramVariete dict A dictionary of parameters. It should include the fields txAssimBVP , txAssimMatu1 , and txAssimMatu2 . None Returns: Type Description xarray.Dataset The updated data dataset, with the KAssim field set to the calculated values. View Source def estimate_KAssim ( j , data , paramVariete ) : \" \"\" This function calculates the conversion factor `KAssim`, which is used to convert assimilates into biomass. The value of `KAssim` depends on the phase of the crop. The conversion factor is calculated based on a lookup table that maps crop phases to values. The crop phase is determined by the `numPhase` field in the `data` argument, and the corresponding `KAssim` value is set in the `KAssim` field of the `data` argument. Args: j (int): An integer index specifying the time step. data (xarray.Dataset): A dataset containing the variables used in the calculation of `KAssim`. The dataset should include the fields `numPhase`, `sdj`, `seuilTemp PhasePrec`, and `seuilTemp PhaseSuivante`. The `KAssim` field of the dataset will be updated by this function. paramVariete (dict): A dictionary of parameters. It should include the fields `txAssimBVP`, `txAssimMatu1`, and `txAssimMatu2`. Returns: xarray.Dataset: The updated `data` dataset, with the `KAssim` field set to the calculated values. \"\" \" phase_equivalences = { 2 : 1 , 3 : paramVariete [ 'txAssimBVP' ] , 4 : paramVariete [ 'txAssimBVP' ] , #! replacing sommeDegresJourPhasePrec with seuilTempPhasePrec #// 5: paramVariete[\"txAssimBVP\"] + (data['sdj'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]) * (paramVariete['txAssimMatu1'] - paramVariete['txAssimBVP']) / (data['seuilTempPhaseSuivante'][j,:,:] - data['sommeDegresJourPhasePrec'][j,:,:]), 5 : paramVariete [ \"txAssimBVP\" ] + ( data [ 'sdj' ][ j , : , : ] - data [ 'seuilTempPhasePrec' ][ j , : , : ] ) * ( paramVariete [ 'txAssimMatu1' ] - paramVariete [ 'txAssimBVP' ] ) / ( data [ 'seuilTempPhaseSuivante' ][ j , : , : ] - data [ 'seuilTempPhasePrec' ][ j , : , : ] ), #// 6: paramVariete[\"txAssimMatu1\"] + (data[\"sdj\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]) * (paramVariete[\"txAssimMatu2\"] - paramVariete[\"txAssimMatu1\"]) / (data[\"seuilTempPhaseSuivante\"][j,:,:] - data[\"sommeDegresJourPhasePrec\"][j,:,:]), 6 : paramVariete [ \"txAssimMatu1\" ] + ( data [ \"sdj\" ][ j , : , : ] - data [ \"seuilTempPhasePrec\" ][ j , : , : ] ) * ( paramVariete [ \"txAssimMatu2\" ] - paramVariete [ \"txAssimMatu1\" ] ) / ( data [ \"seuilTempPhaseSuivante\" ][ j , : , : ] - data [ \"seuilTempPhasePrec\" ][ j , : , : ] ), } for phase in range ( 2 , 7 ) : data [ \"KAssim\" ][ j : , : , : ] = np . where ( data [ \"numPhase\" ][ j , : , : ] == phase , phase_equivalences [ phase ] , data [ \"KAssim\" ][ j , : , : ] , ) return data","title":"estimate_KAssim"},{"location":"reference/sarra_py/bilan_carbo/#estimate_conv","text":"def estimate_conv ( j , data , paramVariete ) This function calculates the conversion of assimilates into biomass. The conversion factor is determined by multiplying the KAssim value, which is dependent on the phase of the crop, with the conversion rate (txConversion) specified in the paramVariete argument. Parameters: Name Type Description Default j int The starting index of the calculation None data dict A dictionary containing information on the crop growth, including the phase of the crop and the KAssim value. None paramVariete dict A dictionary containing parameters relevant to the crop growth, including the conversion rate. None Returns: Type Description dict The input data dictionary with the calculated \"conv\" value added. View Source def estimate_conv ( j , data , paramVariete ) : \" \"\" This function calculates the conversion of assimilates into biomass. The conversion factor is determined by multiplying the KAssim value, which is dependent on the phase of the crop, with the conversion rate (txConversion) specified in the `paramVariete` argument. Args: j (int): The starting index of the calculation data (dict): A dictionary containing information on the crop growth, including the phase of the crop and the KAssim value. paramVariete (dict): A dictionary containing parameters relevant to the crop growth, including the conversion rate. Returns: dict: The input `data` dictionary with the calculated \" conv \" value added. \"\" \" data [ \"conv\" ][ j : , : , : ] = ( data [ \"KAssim\" ][ j , : , : ] * paramVariete [ \"txConversion\" ] ) return data","title":"estimate_conv"},{"location":"reference/sarra_py/bilan_carbo/#estimate_critical_nitrogen_concentration","text":"def estimate_critical_nitrogen_concentration ( j , data ) View Source def estimate_critical_nitrogen_concentration ( j , data ) : # estimate critical nitrogen concentration from plant dry matter using the Justes et al ( 1994 ) relationship data [ \" Ncrit \" ][ j ,:,:] = 5 . 35 * ( data [ \" biomasseTotale \" ][ j ,:,:] / 1000 ) ** ( - 0 . 44 ) return data","title":"estimate_critical_nitrogen_concentration"},{"location":"reference/sarra_py/bilan_carbo/#estimate_kcp","text":"def estimate_kcp ( j , data , paramVariete ) Estimate the kcp coefficient based on the maximum crop coefficient kcMax and plant cover ltr . The computation of kcp is based on the EvolKcpKcIni procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Parameters: Name Type Description Default j int The starting index for updating kcp in the data dataset. None data xarray.Dataset A dataset containing the data used in the computation of kcp . The dataset should contain the following variables: - 'numPhase': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the number of phases in the crop cycle. - 'kcp': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the coefficient of crop growth. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the plant cover. None paramVariete dict A dictionary containing the parameters for estimating kcp . The dictionary should contain the following key: - 'kcMax': A float, representing the maximum crop coefficient. None Returns: Type Description xarray.Dataset The updated data dataset with the new kcp values. View Source def estimate_kcp ( j , data , paramVariete ) : \" \"\" Estimate the kcp coefficient based on the maximum crop coefficient `kcMax` and plant cover `ltr`. The computation of `kcp` is based on the EvolKcpKcIni procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `kcp` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `kcp`. The dataset should contain the following variables: - 'numPhase': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the number of phases in the crop cycle. - 'kcp': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the coefficient of crop growth. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the plant cover. paramVariete (dict): A dictionary containing the parameters for estimating `kcp`. The dictionary should contain the following key: - 'kcMax': A float, representing the maximum crop coefficient. Returns: xarray.Dataset: The updated `data` dataset with the new `kcp` values. \"\" \" data [ \"kcp\" ][ j : , : , : ] = np . where ( data [ \"numPhase\" ][ j , : , : ] >= 1 , np . maximum ( 0.3 , paramVariete [ \"kcMax\" ] * ( 1 - data [ \"ltr\" ][ j , : , : ] )), data [ \"kcp\" ][ j , : , : ] , ) return data","title":"estimate_kcp"},{"location":"reference/sarra_py/bilan_carbo/#estimate_ltr","text":"def estimate_ltr ( j , data , paramVariete ) Estimate the fraction of radiation transmitted to the soil ltr based on the leaf area index lai . ltr is used as a proxy for plant covering of the soil in the water balance calculation, where 1 represents no plant cover and 0 represents full plant cover. ltr is computed as an exponential decay function of lai with a decay coefficient kdf . This function is adapted from the EvalLtr procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Parameters: Name Type Description Default j int The starting index for updating ltr in the data dataset. None data xarray.Dataset A dataset containing the data used in the computation of ltr . The dataset should contain the following variables: - 'lai': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the leaf area index. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the fraction of radiation transmitted to the soil. None paramVariete dict A dictionary containing the parameters for estimating ltr . The dictionary should contain the following key: - 'kdf': A float, representing the decay coefficient for ltr . None Returns: Type Description xarray.Dataset The updated data dataset with the new ltr values. View Source def estimate_ltr ( j , data , paramVariete ) : \" \"\" Estimate the fraction of radiation transmitted to the soil `ltr` based on the leaf area index `lai`. `ltr` is used as a proxy for plant covering of the soil in the water balance calculation, where 1 represents no plant cover and 0 represents full plant cover. `ltr` is computed as an exponential decay function of `lai` with a decay coefficient `kdf`. This function is adapted from the EvalLtr procedure from the biomasse.pas and exmodules 1 & 2.pas files of the original PASCAL code. Args: j (int): The starting index for updating `ltr` in the `data` dataset. data (xarray.Dataset): A dataset containing the data used in the computation of `ltr`. The dataset should contain the following variables: - 'lai': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the leaf area index. - 'ltr': A 3-dimensional data variable with shape (num_timesteps, num_rows, num_columns), representing the fraction of radiation transmitted to the soil. paramVariete (dict): A dictionary containing the parameters for estimating `ltr`. The dictionary should contain the following key: - 'kdf': A float, representing the decay coefficient for `ltr`. Returns: xarray.Dataset: The updated `data` dataset with the new `ltr` values. \"\" \" # group 80 data [ \"ltr\" ][ j : , : , : ] = np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j , : , : ] ) return data","title":"estimate_ltr"},{"location":"reference/sarra_py/bilan_carbo/#estimate_reallocation","text":"def estimate_reallocation ( j , data , paramVariete ) Estimate the daily biomass reallocation between stem and leaves. This function computes the daily biomass reallocation between stem and leaves for the plant. The computation only occurs when the plant is in phase 5. The amount of biomass that can be reallocated is estimated as follows: The difference between the potential yield delta and the aboveground biomass delta, bound by 0, is calculated and referred to as manqueAssim. manqueAssim represents the daily variation in biomass that remains after the plant has built its aboveground biomass. The reallocation is computed as the minimum of the product of manqueAssim and the reallocation rate and the difference between the leaf biomass and 30, also bound by 0. The value of 30 is an arbitrary threshold which ensures that reallocation is 0 if the leaf biomass is below 30. If the leaf biomass is above 30, reallocation is bounded by biomasseFeuille - 30. If the plant is not in phase 5, reallocation is set to 0. This function is based on the EvalReallocationSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Parameters: Name Type Description Default j int Current time step of the simulation. None data xarray.Dataset The dataset containing all the simulation data. None paramVariete dict A dictionary containing the parameters for the simulation. None Returns: Type Description xarray.Dataset The updated dataset with the reallocation values. View Source def estimate_reallocation ( j , data , paramVariete ): \"\"\" Estimate the daily biomass reallocation between stem and leaves. This function computes the daily biomass reallocation between stem and leaves for the plant. The computation only occurs when the plant is in phase 5. The amount of biomass that can be reallocated is estimated as follows: 1. The difference between the potential yield delta and the aboveground biomass delta, bound by 0, is calculated and referred to as manqueAssim. manqueAssim represents the daily variation in biomass that remains after the plant has built its aboveground biomass. 2. The reallocation is computed as the minimum of the product of manqueAssim and the reallocation rate and the difference between the leaf biomass and 30, also bound by 0. The value of 30 is an arbitrary threshold which ensures that reallocation is 0 if the leaf biomass is below 30. If the leaf biomass is above 30, reallocation is bounded by biomasseFeuille - 30. If the plant is not in phase 5, reallocation is set to 0. This function is based on the EvalReallocationSarrahV3 procedure from the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Args: j (int): Current time step of the simulation. data (xarray.Dataset): The dataset containing all the simulation data. paramVariete (dict): A dictionary containing the parameters for the simulation. Returns: xarray.Dataset: The updated dataset with the reallocation values. \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] == 5 ) data [ \"manqueAssim\" ][ j :,:,:] = np . where ( condition , np . maximum ( 0 , ( data [ \"dRdtPot\" ][ j ,:,:] - np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j ,:,:]))), 0 , ) data [ \"reallocation\" ][ j :,:,:] = np . where ( condition , np . minimum ( data [ \"manqueAssim\" ][ j ,:,:] * paramVariete [ \"txRealloc\" ], np . maximum ( 0.0 , data [ \"biomasseFeuille\" ][ j ,:,:] - 30 ), ), 0 , ) return data","title":"estimate_reallocation"},{"location":"reference/sarra_py/bilan_carbo/#initialize_simulation","text":"def initialize_simulation ( data , grid_width , grid_height , duration , paramVariete , paramITK , date_start ) This function initializes variables related to crop growth in the data xarray dataset. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. This code has been adapted from the original InitiationCulture procedure, from the MilBilanCarbone.pas code of the SARRA model. Parameters: Name Type Description Default data type description grid_width ( type ): description None grid_height type description duration ( type ): description None paramVariete type description None Returns: Type Description type description View Source def initialize_simulation ( data , grid_width , grid_height , duration , paramVariete , paramITK , date_start ) : \"\"\" This function initializes variables related to crop growth in the data xarray dataset . As the rain is the first variable to be initialized in the data xarray dataset , its dimensions are used to initialize the other variables . ! [ no caption ](.. / .. / docs / images / sla . png ) This code has been adapted from the original InitiationCulture procedure , from the ` MilBilanCarbone . pas ` code of the SARRA model . Args : data ( _type_ ) : _description_ grid_width ( _type_ ) : _description_ grid_height ( _type_ ) : _description_ duration ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" ### variables to be initialized with values from parameters # from paramVariete : maximum daily thermal time (\u00b0C.j) -> #? unused ? # // data[\"sommeDegresJourMaximale\"] = (data[\"rain\"].dims, np.full( # // (duration, grid_width, grid_height), # // (paramVariete[\"SDJLevee\"] + paramVariete[\"SDJBVP\"] + paramVariete[\"SDJRPR\"] + paramVariete[\"SDJMatu1\"] + paramVariete[\"SDJMatu2\"]) # // )) #// data[\"sommeDegresJourMaximale\"].attrs = { \"units\" : \"\u00b0C.j\" , \"long_name\" : \"Maximum thermal time\" } # from paramITK : sowing date data [ \"sowing_date\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), ( paramITK [ \"DateSemis\" ] - date_start ). days )) # from paramITK : automatic irrigation indicator data [ \"irrigAuto\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"irrigAuto\" ])) data [ \"irrigAuto\" ]. attrs = { \"units\" : \"binary\" , \"long_name\" : \"automatic irrigation indicator\" } ####### variables qui viennent de initplotMc # Initial biomass of crop residues (mulch) (kg/ha) # Biomasse initiale des r\u00e9sidus de culture (mulch) (kg/ha) # BiomMc := BiomIniMc; data [ \"biomMc\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"biomMc\" ]. attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of crop residues (mulch)\" } # ? # StSurf := StockIniSurf; # data[\"stSurf\"] = np.full((grid_width, grid_height, duration), paramTypeSol[\"stockIniSurf\"]) # ? # Ltr := 1; data [ \"ltr\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), 1.0 )) # Initial biomass of stem residues as litter (kg/ha) # Biomasse initiale des r\u00e9sidus de tiges sous forme de liti\u00e8re (kg/ha) # LitTiges := BiomIniMc; data [ \"LitTige\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), paramITK [ \"biomIniMc\" ])) data [ \"LitTige\" ]. attrs = { \"units\" : \"kg/ha\" , \"long_name\" : \"Initial biomass of stem residues as litter\" } ####### fin variables qui viennent de initplotMc ####### variables eau depuis InitPlotMc # Initializes variables related to crop residues boimass (mulch) in the data # xarray dataset. This code has been adapted from the original InitPlotMc # procedure, Bileau.pas code. Comments with tab indentation are from the # original code. As the rain is the first variable to be initialized in the # data xarray dataset, its dimensions are used to initialize the other # variables. # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity # // data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ]. dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis , : , : ], duration , axis = 0 )) # // data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity # // data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] # // data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock # // data[\"stTot\"] = data[\"stockIniProf\"] # //data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ]. dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis , : , : ], duration , axis = 0 )) # // data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ]. dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity # // data[\"ruSurf\"], data [ \"surface_tank_capacity\" ]. expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity # // data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock # // data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ]. attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] ####### fin variables eau depuis InitPlotMc # depuis meteo.pas kpar = 0.5 data [ \"par\" ] = kpar * data [ \"rg\" ] data [ \"par\" ]. attrs = { \"units\" : \"MJ/m2\" , \"long_name\" : \"par\" } # crop density if ~ np . isnan ( paramVariete [ \"densOpti\" ]) : data [ \"rapDensite\" ] = data [ \"rain\" ] * 0 + compute_rapDensite ( paramITK , paramVariete ) data [ \"rapDensite\" ]. attrs = { \"units\" : \"none\" , \"long_name\" : \"sowing density adjustement factor\" } # initialize variables with values at 0 variables = variable_dict () for variable in variables : data [ variable ] = ( data [ \"rain\" ]. dims , np . zeros ( shape = ( duration , grid_width , grid_height ))) data [ variable ]. attrs = { \"units\" : variables [ variable ][ 1 ], \"long_name\" : variables [ variable ][ 0 ]} return data","title":"initialize_simulation"},{"location":"reference/sarra_py/bilan_carbo/#update_aboveground_biomass","text":"def update_aboveground_biomass ( j , data , paramVariete ) Update the aboveground biomass of the plant. The aboveground biomass is either updated based on a linear function of the total biomass, if the plant is in phase 2, 3, or 4, or incremented with the total biomass delta if the plant is in any other phase. This function is based on the EvolBiomAeroSarrahV3 procedure, of the bilancarbonsarra , exmodules 1 & 2.pas file from the original Pascal code. Parameters: Name Type Description Default j int The current iteration step in the simulation. None data xarray.Dataset The simulation data, including the current phase of the plant and various biomass values. None paramVariete dict The parameters of the plant variety. None Returns: Type Description xarray.Dataset The updated simulation data, including the updated aboveground biomass and delta aboveground biomass. View Source def update_aboveground_biomass ( j , data , paramVariete ): \"\"\" Update the aboveground biomass of the plant. The aboveground biomass is either updated based on a linear function of the total biomass, if the plant is in phase 2, 3, or 4, or incremented with the total biomass delta if the plant is in any other phase. This function is based on the EvolBiomAeroSarrahV3 procedure, of the ***bilancarbonsarra***, exmodules 1 & 2.pas file from the original Pascal code. Args: j (int): The current iteration step in the simulation. data (xarray.Dataset): The simulation data, including the current phase of the plant and various biomass values. paramVariete (dict): The parameters of the plant variety. Returns: xarray.Dataset: The updated simulation data, including the updated aboveground biomass and delta aboveground biomass. \"\"\" #// data[\"deltaBiomasseAerienne\"][j:,:,:] = np.copy(data[\"biomasseAerienne\"][j,:,:]) data [ \"biomasseAerienne\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & ( data [ \"numPhase\" ][ j ,:,:] <= 4 ), np . minimum ( 0.9 , paramVariete [ \"aeroTotPente\" ] * data [ \"biomasseTotale\" ][ j ,:,:] + paramVariete [ \"aeroTotBase\" ]) * data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomasseAerienne\" ][ j ,:,:] + data [ \"deltaBiomasseTotale\" ][ j ,:,:], ) #//data[\"deltaBiomasseAerienne\"][j:,:,:] = (data[\"biomasseAerienne\"][j,:,:] - data[\"deltaBiomasseAerienne\"][j,:,:])#[...,np.newaxis] data [ \"deltaBiomasseAerienne\" ][ j :,:,:] = data [ \"biomasseAerienne\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j - 1 ,:,:] return data","title":"update_aboveground_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_aboveground_biomass_step_2","text":"def update_aboveground_biomass_step_2 ( j , data ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_aboveground_biomass_step_2 ( j , data ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseAerienne \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) , data [ \" biomasseTige \" ][ j ,:,:] + data [ \" biomasseFeuille \" ][ j ,:,:] + data [ \" rdt \" ][ j ,:,:], data [ \" biomasseAerienne \" ][ j ,:,:], ) return data","title":"update_aboveground_biomass_step_2"},{"location":"reference/sarra_py/bilan_carbo/#update_assim","text":"def update_assim ( j , data ) This function updates assim. If trPot (potential transpiration from the plant, mm) is greater than 0, then assim equals assimPot, multiplied by the ratio of effective transpiration over potential transpiration. If potential transpiration is null, then assim is null as well. Is it adapted from the EvalAssimSarraV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_assim ( j , data ) : \"\"\" This function updates assim . If trPot ( potential transpiration from the plant , mm ) is greater than 0 , then assim equals assimPot , multiplied by the ratio of effective transpiration over potential transpiration . If potential transpiration is null , then assim is null as well . Is it adapted from the EvalAssimSarraV42 procedure , of the bilancarbonsarra . pas file from the original Pascal code Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" assim \" ][ j ,:,:] = np . where ( data [ \" trPot \" ][ j ,:,:] > 0 , data [ \" assimPot \" ][ j ,:,:] * data [ \" tr \" ][ j ,:,:] / data [ \" trPot \" ][ j ,:,:], 0 , ) return data","title":"update_assim"},{"location":"reference/sarra_py/bilan_carbo/#update_assimpot","text":"def update_assimPot ( j , data , paramVariete , paramITK ) Update the assimPot value based on the intensification level (NI). If the intensification level NI is defined in paramITK , the conversion rate txConversion is computed using a formula based on NIYo , NIp , LGauss , and AGauss . If NI is not defined, assimPot is updated using conv , which is updated in the estimate_conv function using the variables KAssim and txConversion . When NI parameter is used (from to 4), conversion rate txConversion is computed using the following formula : NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5 ((NI - LGauss)/AGauss) (NI- LGauss)/AGauss))/(AGauss*2.506628274631) This function is adapted from the EvalAssimSarraV42 procedure in the bilancarbonsarra.pas file of the original Pascal code. Note from CB : correction of the conversion rate depending on the intensification level notes from CB reharding the EvalAssimSarraV42 procedure : Modif du 04/03/2021 : Prise en compte en plus de la densit\ufffd de semis de l'effet niveau d'intensification NI NI = 1 quand on est \ufffd l'optimum du niveau d'intensification. Dans le cas de situation contr\ufffdl\ufffd c'est la fertilit\ufffd qui est la clef principale en prenant en r\ufffdf\ufffdrence la qt\ufffd d'azote (\ufffdquivalent phosphore...) optimum Il peut aller \ufffd 0 ou \ufffdtre sup\ufffdrieur \ufffd 1 si situation sur optimum, ie un peu plus de rdt mais \ufffd cout trop \ufffdlev\ufffd... On \ufffdvalue un nouveau tx de conversion en fn du Ni au travers d'une double \ufffdquation : asympote x gaussienne invers\ufffde Et d'un NI d\ufffdfini en fn du sc\ufffdnario de simulation ou des donn\ufffdes observ\ufffdes. NIYo = D\ufffdcalage en Y de l'asymptote NIp = pente de l'asymptote LGauss = Largeur de la Guaussienne AGauss = Amplitude de la Guaussienne Conversion qui est la valeur du taux de conversion en situation optimum n'a plus besoin d'\ufffdtre utilis\ufffd sinon dans la calibration des param\ufffdtres de cette \ufffdquation en absence de donn\ufffdes sur ces param\ufffdtres on ne met aucune valeur \ufffd NI CF fichier ex IndIntensite_txConv_eq.xls} Args: - j (int): An index that represents the current iteration. - data (dict): A dictionary containing data arrays with the following keys: - \"assimPot\" (np.ndarray): An array representing the potential assimilation rate. - \"par\" (np.ndarray): An array representing photosynthetically active radiation. - \"lai\" (np.ndarray): An array representing the leaf area index. - \"conv\" (np.ndarray): An array representing the conversion rate. - paramVariete (dict): A dictionary containing parameters for the computation of the conversion rate, including: - \"txConversion\" (float): The conversion rate. - \"NIYo\" (float): The shift in the Y-axis of the asymptote. - \"NIp\" (float): The slope of the asymptote. - \"LGauss\" (float): The width of the Gaussian curve. - \"AGauss\" (float): The amplitude of the Gaussian curve. - \"kdf\" (float): The constant used in the computation of assimPot . - paramITK (dict): A dictionary containing the intensification level NI (float). Returns: - data (dict): The input data dictionary with the updated \"assimPot\" array. View Source def update_assimPot ( j , data , paramVariete , paramITK ) : \" \"\" Update the assimPot value based on the intensification level (NI). If the intensification level `NI` is defined in `paramITK`, the conversion rate `txConversion` is computed using a formula based on `NIYo`, `NIp`, `LGauss`, and `AGauss`. If `NI` is not defined, `assimPot` is updated using `conv`, which is updated in the `estimate_conv` function using the variables `KAssim` and `txConversion`. When NI parameter is used (from to 4), conversion rate txConversion is computed using the following formula : NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) This function is adapted from the `EvalAssimSarraV42` procedure in the `bilancarbonsarra.pas` file of the original Pascal code. Note from CB : correction of the conversion rate depending on the intensification level notes from CB reharding the EvalAssimSarraV42 procedure : Modif du 04/03/2021 : Prise en compte en plus de la densit\ufffd de semis de l'effet niveau d'intensification NI NI = 1 quand on est \ufffd l'optimum du niveau d'intensification. Dans le cas de situation contr\ufffdl\ufffd c'est la fertilit\ufffd qui est la clef principale en prenant en r\ufffdf\ufffdrence la qt\ufffd d'azote (\ufffdquivalent phosphore...) optimum Il peut aller \ufffd 0 ou \ufffdtre sup\ufffdrieur \ufffd 1 si situation sur optimum, ie un peu plus de rdt mais \ufffd cout trop \ufffdlev\ufffd... On \ufffdvalue un nouveau tx de conversion en fn du Ni au travers d'une double \ufffdquation : asympote x gaussienne invers\ufffde Et d'un NI d\ufffdfini en fn du sc\ufffdnario de simulation ou des donn\ufffdes observ\ufffdes. NIYo = D\ufffdcalage en Y de l'asymptote NIp = pente de l'asymptote LGauss = Largeur de la Guaussienne AGauss = Amplitude de la Guaussienne Conversion qui est la valeur du taux de conversion en situation optimum n'a plus besoin d'\ufffdtre utilis\ufffd sinon dans la calibration des param\ufffdtres de cette \ufffdquation en absence de donn\ufffdes sur ces param\ufffdtres on ne met aucune valeur \ufffd NI CF fichier ex IndIntensite_txConv_eq.xls} Args: - j (int): An index that represents the current iteration. - data (dict): A dictionary containing data arrays with the following keys: - \" assimPot \" (np.ndarray): An array representing the potential assimilation rate. - \" par \" (np.ndarray): An array representing photosynthetically active radiation. - \" lai \" (np.ndarray): An array representing the leaf area index. - \" conv \" (np.ndarray): An array representing the conversion rate. - paramVariete (dict): A dictionary containing parameters for the computation of the conversion rate, including: - \" txConversion \" (float): The conversion rate. - \" NIYo \" (float): The shift in the Y-axis of the asymptote. - \" NIp \" (float): The slope of the asymptote. - \" LGauss \" (float): The width of the Gaussian curve. - \" AGauss \" (float): The amplitude of the Gaussian curve. - \" kdf \" (float): The constant used in the computation of `assimPot`. - paramITK (dict): A dictionary containing the intensification level `NI` (float). Returns: - data (dict): The input `data` dictionary with the updated \" assimPot \" array. \"\" \" if ~ np . isnan ( paramITK [ \"NI\" ] ) : #? the following (stupidly long) line was found commented, need to check why and if this is correct paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ] )) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ] ) / paramVariete [ \"AGauss\" ] ) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ] ) / paramVariete [ \"AGauss\" ] )) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) # NIYo + NIp * (1-exp(-NIp * NI)) - (exp(-0.5*((NI - LGauss)/AGauss)* (NI- LGauss)/AGauss))/(AGauss*2.506628274631) data [ \"assimPot\" ][ j , : , : ] = data [ \"par\" ][ j , : , : ] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j , : , : ] )) * \\ paramVariete [ \"txConversion\" ] * 10 else : data [ \"assimPot\" ][ j , : , : ] = data [ \"par\" ][ j , : , : ] * \\ ( 1 - np . exp ( - paramVariete [ \"kdf\" ] * data [ \"lai\" ][ j , : , : ] )) * \\ data [ \"conv\" ][ j , : , : ] * 10 return data","title":"update_assimPot"},{"location":"reference/sarra_py/bilan_carbo/#update_bm_and_cm","text":"def update_bM_and_cM ( j , data , paramVariete ) This function returns the updated values of bM and cM. bM and cM are updated if the delta of aerial biomass is positive, meaning that the plant is gaining aerial biomass, and if the phase is above 1 and below 4 or the phase is below the vegetative phase. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas files from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_bM_and_cM ( j , data , paramVariete ) : \"\"\" This function returns the updated values of bM and cM . bM and cM are updated if the delta of aerial biomass is positive , meaning that the plant is gaining aerial biomass , and if the phase is above 1 and below 4 or the phase is below the vegetative phase . This function is adapted from the EvalFeuilleTigeSarrahV4 procedure , of the bilancarbonsarra . pas files from the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" bM \" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , paramVariete [ \" feuilAeroBase \" ] - 0 . 1 , data [ \" bM \" ][ j ,:,:], ) data [ \" cM \" ][ j ,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , (( paramVariete [ \" feuilAeroPente \" ] * 1000 ) / data [ \" bM \" ][ j ,:,:] + 0 . 78 ) / 0 . 75 , data [ \" cM \" ][ j ,:,:], ) return data","title":"update_bM_and_cM"},{"location":"reference/sarra_py/bilan_carbo/#update_leaf_biomass","text":"def update_leaf_biomass ( j , data , paramVariete ) For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the leaf biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by the reallocation rate in leaves. This value is bound in 0.00000001. Otherwise, the leaf biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_leaf_biomass ( j , data , paramVariete ) : \"\"\" For phase above 1 and if the delta of aerial biomass is negative , meaning that the plant is losing aerial biomass , the leaf biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by the reallocation rate in leaves . This value is bound in 0 . 00000001 . Otherwise , the leaf biomass is not updated . This function is adapted from the EvalFeuilleTigeSarrahV4 procedure , of the bilancarbonsarra . pas and exmodules 1 & 2 . pas files from the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseFeuille \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] < 0 ) , np . maximum ( 0 . 00000001 , data [ \" biomasseFeuille \" ][ j ,:,:] - ( data [ \" reallocation \" ][ j ,:,:] - data [ \" deltaBiomasseAerienne \" ][ j ,:,:] ) * paramVariete [ \" pcReallocFeuille \" ] ) , data [ \" biomasseFeuille \" ][ j ,:,:], ) return data","title":"update_leaf_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_leaf_biomass_all_phases","text":"def update_leaf_biomass_all_phases ( j , data , paramVariete ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_leaf_biomass_all_phases ( j , data , paramVariete ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseFeuille \" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ) , data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" reallocation \" ][ j ,:,:] * paramVariete [ \" pcReallocFeuille \" ], data [ \" biomasseFeuille \" ][ j ,:,:], ) return data","title":"update_leaf_biomass_all_phases"},{"location":"reference/sarra_py/bilan_carbo/#update_leaf_biomass_positive_delta_aboveground_biomass","text":"def update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_leaf_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) : \"\"\" Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseFeuille \" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , ( 0 . 1 + data [ \" bM \" ][ j ,:,:] * data [ \" cM \" ][ j ,:,:] ** (( data [ \" biomasseAerienne \" ][ j ,:,:] - data [ \" rdt \" ][ j ,:,:] ) / 1000 )) \\ * ( data [ \" biomasseAerienne \" ][ j ,:,:] - data [ \" rdt \" ][ j ,:,:] ) , data [ \" biomasseFeuille \" ][ j ,:,:], ) return data","title":"update_leaf_biomass_positive_delta_aboveground_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_potential_yield","text":"def update_potential_yield ( j , data , paramVariete ) Update the potential yield of the plant. The potential yield is initialized as an affine function of the delta between the end of the vegetative phase and the end of the flowering stage, plus a linear function of the total biomass at the end of the flowering stage. The potential yield is capped to twice the biomass of the stem to avoid unrealistic values. The update occurs if the plant is in phase 5 and its phase has changed This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Parameters: Name Type Description Default j int An index representing the current time step. None data xarray.Dataset A dataset containing plant data. None paramVariete dict A dictionary containing parameters for the plant variety. None Returns: Type Description xarray.Dataset The input data with the potential yield updated. View Source def update_potential_yield ( j , data , paramVariete ) : \" \"\" Update the potential yield of the plant. The potential yield is initialized as an affine function of the delta between the end of the vegetative phase and the end of the flowering stage, plus a linear function of the total biomass at the end of the flowering stage. The potential yield is capped to twice the biomass of the stem to avoid unrealistic values. The update occurs if the plant is in phase 5 and its phase has changed This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): An index representing the current time step. data (xarray.Dataset): A dataset containing plant data. paramVariete (dict): A dictionary containing parameters for the plant variety. Returns: xarray.Dataset: The input `data` with the potential yield updated. \"\" \" delta_biomass_flowering_ip = data [ \"biomTotStadeFloraison\" ][ j , : , : ] - data [ \"biomTotStadeIp\" ][ j , : , : ] data [ \"rdtPot\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] == 5 ) & ( data [ \"changePhase\" ][ j , : , : ] == 1 ), ( paramVariete [ \"KRdtPotA\" ] * delta_biomass_flowering_ip + paramVariete [ \"KRdtPotB\" ] ) + paramVariete [ \"KRdtBiom\" ] * data [ \"biomTotStadeFloraison\" ][ j , : , : ] , data [ \"rdtPot\" ][ j , : , : ] , ) #! phaseDevVeg pas utilis\u00e9 ? attention c'est un param\u00e8tre vari\u00e9tal et pas un jeu de don\u00e9es data [ \"rdtPot\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] == 5 ) & ( data [ \"changePhase\" ][ j , : , : ] == 1 ) & ( data [ \"rdtPot\" ][ j , : , : ] > data [ \"biomasseTige\" ][ j , : , : ] * 2 ) & ( paramVariete [ \"phaseDevVeg\" ] < 6 ), data [ \"biomasseTige\" ][ j , : , : ] * 2 , data [ \"rdtPot\" ][ j , : , : ] , ) return data","title":"update_potential_yield"},{"location":"reference/sarra_py/bilan_carbo/#update_potential_yield_delta","text":"def update_potential_yield_delta ( j , data , paramVariete ) This function updates the delta potential yield (dRdtPot) of the plant, which is the rate at which the plant's yield is changing over time. The delta potential yield is calculated as the product of the potential yield, the ratio of actual degree days to maturity, and the ratio of actual transpiration to potential transpiration. The calculation is only done if the plant is in phase 5 and the potential transpiration is above 0. If the potential transpiration is not above 0, the delta potential yield is set to 0. For all other phases, the delta potential yield is unchanged. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: - j (int): an integer index, representing the current step of the simulation - data (xarray dataset): the simulation data, including the current state of the plant - paramVariete (dict): the variety-specific parameters used in the simulation Returns: - data (xarray dataset): the updated simulation data, including the updated delta potential yield View Source def update_potential_yield_delta ( j , data , paramVariete ): \"\"\" This function updates the delta potential yield (dRdtPot) of the plant, which is the rate at which the plant's yield is changing over time. The delta potential yield is calculated as the product of the potential yield, the ratio of actual degree days to maturity, and the ratio of actual transpiration to potential transpiration. The calculation is only done if the plant is in phase 5 and the potential transpiration is above 0. If the potential transpiration is not above 0, the delta potential yield is set to 0. For all other phases, the delta potential yield is unchanged. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: - j (int): an integer index, representing the current step of the simulation - data (xarray dataset): the simulation data, including the current state of the plant - paramVariete (dict): the variety-specific parameters used in the simulation Returns: - data (xarray dataset): the updated simulation data, including the updated delta potential yield \"\"\" data [ \"dRdtPot\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ), np . where ( ( data [ \"trPot\" ][ j ,:,:] > 0 ), np . maximum ( data [ \"rdtPot\" ][ j ,:,:] * ( data [ \"ddj\" ][ j ,:,:] / paramVariete [ \"SDJMatu1\" ]) * ( data [ \"tr\" ][ j ,:,:] / data [ \"trPot\" ][ j ,:,:]), data [ \"respMaint\" ][ j ,:,:] * 0.15 , ), 0 , ), data [ \"dRdtPot\" ][ j ,:,:], ) return data","title":"update_potential_yield_delta"},{"location":"reference/sarra_py/bilan_carbo/#update_root_biomass","text":"def update_root_biomass ( j , data ) Update the root biomass (biomasseRacinaire) for a given time step. The root biomass is computed as the difference between the total biomass and the aboveground biomass. This function is based on the EvalBiomasseRacinaire procedure, of the milbilancarbone, exmodules 1 & 2, milbilancarbone .pas file from the original Pascal code Parameters: Name Type Description Default j int Time step index. None data xarray.Dataset Input dataset containing relevant variables. None Returns: Type Description xarray.Dataset Updated dataset with the root biomass variable. View Source def update_root_biomass ( j , data ): \"\"\" Update the root biomass (biomasseRacinaire) for a given time step. The root biomass is computed as the difference between the total biomass and the aboveground biomass. This function is based on the EvalBiomasseRacinaire procedure, of the milbilancarbone, exmodules 1 & 2, ***milbilancarbone***.pas file from the original Pascal code Args: j (int): Time step index. data (xarray.Dataset): Input dataset containing relevant variables. Returns: xarray.Dataset: Updated dataset with the root biomass variable. \"\"\" data [ \"biomasseRacinaire\" ][ j ,:,:] = data [ \"biomasseTotale\" ][ j ,:,:] - data [ \"biomasseAerienne\" ][ j ,:,:] return data","title":"update_root_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_stem_biomass","text":"def update_stem_biomass ( j , data , paramVariete ) For phase above 1 and if the delta of aerial biomass is negative, meaning that the plant is losing aerial biomass, the stem biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by (1-reallocation rate in leaves) (if it's not leaves, it's stems...). This value is bound in 0.00000001. Otherwise, the stem biomass is not updated. This function is adapted from the EvalFeuilleTigeSarrahV4 procedure, of the bilancarbonsarra.pas and exmodules 1 & 2.pas files from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stem_biomass ( j , data , paramVariete ) : \"\"\" For phase above 1 and if the delta of aerial biomass is negative , meaning that the plant is losing aerial biomass , the stem biomass is updated as the difference between the leaf biomass and the reallocation minus the delta of aerial biomass multiplied by ( 1 - reallocation rate in leaves ) ( if it ' s not leaves, it ' s stems ... ) . This value is bound in 0 . 00000001 . Otherwise , the stem biomass is not updated . This function is adapted from the EvalFeuilleTigeSarrahV4 procedure , of the bilancarbonsarra . pas and exmodules 1 & 2 . pas files from the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 122 data [ \" biomasseTige \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" deltaBiomasseAerienne \" ][ j ,:,:] < 0 ) , np . maximum ( 0 . 00000001 , data [ \" biomasseTige \" ][ j ,:,:] - ( data [ \" reallocation \" ][ j ,:,:] - data [ \" deltaBiomasseAerienne \" ][ j ,:,:] ) * ( 1 - paramVariete [ \" pcReallocFeuille \" ] ) , ) , data [ \" biomasseTige \" ][ j ,:,:], ) return data","title":"update_stem_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_stem_biomass_all_phases","text":"def update_stem_biomass_all_phases ( j , data , paramVariete ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stem_biomass_all_phases ( j , data , paramVariete ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseTige \" ][ j :,:,:] = np . where ( condition_positive_delta_aboveground_biomass_all_phases ( j , data ) , data [ \" biomasseTige \" ][ j ,:,:] - ( data [ \" reallocation \" ][ j ,:,:] * ( 1 - paramVariete [ \" pcReallocFeuille \" ] )) , data [ \" biomasseTige \" ][ j ,:,:], ) return data","title":"update_stem_biomass_all_phases"},{"location":"reference/sarra_py/bilan_carbo/#update_stem_biomass_positive_delta_aboveground_biomass","text":"def update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stem_biomass_positive_delta_aboveground_biomass ( j , data , paramVariete ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseTige \" ][ j :,:,:] = np . where ( condition_positive_delta_biomass ( j , data , paramVariete ) , data [ \" biomasseAerienne \" ][ j ,:,:] - data [ \" biomasseFeuille \" ][ j ,:,:] - data [ \" rdt \" ][ j ,:,:], data [ \" biomasseTige \" ][ j ,:,:], ) return data","title":"update_stem_biomass_positive_delta_aboveground_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_total_biomass","text":"def update_total_biomass ( j , data , paramVariete , paramITK ) Update the Total Biomass of the Plant. The total biomass is updated based on the plant's current phase and other parameters. If the plant is in phase 2 and there's a change in phase, the total biomass is initialized using crop density, grain yield per plant, and the dry weight of the grain. If the plant is not in phase 2 or there's no change in phase, the total biomass is incremented with the difference between the plant's assimilation and maintenance respiration. When passing from phase 1 to phase 2, total biomass is initialized. Initialization value is computed from crop density (plants/ha), txResGrain (grain yield per plant), and poidsSecGrain. Otherwise, total biomass is incremented with the difference between plant assimilation assim and maintainance respiration respMaint. This function is adapted from the EvolBiomTotSarrahV4 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Parameters: Name Type Description Default j int The current time step. None data xarray.Dataset The data for the plant, including variables like \"biomasseTotale\", \"assim\", \"respMaint\", \"numPhase\", and \"changePhase\". None paramVariete dict A dictionary of parameters specific to the plant variety. None paramITK dict A dictionary of inter-tropical convergence zone parameters. None Returns: Type Description xarray.Dataset The updated data for the plant, including the updated \"biomasseTotale\" and \"deltaBiomasseTotale\" variables. View Source def update_total_biomass ( j , data , paramVariete , paramITK ): \"\"\" Update the Total Biomass of the Plant. The total biomass is updated based on the plant's current phase and other parameters. If the plant is in phase 2 and there's a change in phase, the total biomass is initialized using crop density, grain yield per plant, and the dry weight of the grain. If the plant is not in phase 2 or there's no change in phase, the total biomass is incremented with the difference between the plant's assimilation and maintenance respiration. When passing from phase 1 to phase 2, total biomass is initialized. Initialization value is computed from crop density (plants/ha), txResGrain (grain yield per plant), and poidsSecGrain. Otherwise, total biomass is incremented with the difference between plant assimilation assim and maintainance respiration respMaint. This function is adapted from the EvolBiomTotSarrahV4 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): The current time step. data (xarray.Dataset): The data for the plant, including variables like \"biomasseTotale\", \"assim\", \"respMaint\", \"numPhase\", and \"changePhase\". paramVariete (dict): A dictionary of parameters specific to the plant variety. paramITK (dict): A dictionary of inter-tropical convergence zone parameters. Returns: xarray.Dataset: The updated data for the plant, including the updated \"biomasseTotale\" and \"deltaBiomasseTotale\" variables. \"\"\" data [ \"biomasseTotale\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), paramITK [ \"densite\" ] * np . maximum ( 1 , paramVariete [ 'densOpti' ] / paramITK [ 'densite' ]) * paramVariete [ \"txResGrain\" ] * paramVariete [ \"poidsSecGrain\" ] / 1000 , data [ \"biomasseTotale\" ][ j ,:,:] + ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]), ) # we may want to drop this variable and use the raw computation instead data [ \"deltaBiomasseTotale\" ][ j :,:,:] = ( data [ \"assim\" ][ j ,:,:] - data [ \"respMaint\" ][ j ,:,:]) return data","title":"update_total_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_total_biomass_at_flowering_stage","text":"def update_total_biomass_at_flowering_stage ( j , data ) This function updates the total biomass of the plant at the end of the flowering stage (biomTotStadeFloraison). If the plant is in phase 5, and the phase has changed, then the total biomass is copied to the biomTotStadeFloraison variable. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_biomass_at_flowering_stage ( j , data ): \"\"\" This function updates the total biomass of the plant at the end of the flowering stage (biomTotStadeFloraison). If the plant is in phase 5, and the phase has changed, then the total biomass is copied to the biomTotStadeFloraison variable. This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"biomTotStadeFloraison\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 5 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeFloraison\" ][ j ,:,:], ) return data","title":"update_total_biomass_at_flowering_stage"},{"location":"reference/sarra_py/bilan_carbo/#update_total_biomass_stade_ip","text":"def update_total_biomass_stade_ip ( j , data ) Update the total biomass of the plant at the end of the vegetative phase (ip = \"initiation paniculaire\"). If the plant has reached phase 4 and has just changed phase, the current total biomass will be copied to the \"biomTotStadeIp\" variable, which represents the total biomass at the end of the vegetative phase (initiation paniculaire). This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): Timestep index. data (xarray.Dataset): Input dataset. Returns: xarray.Dataset: The updated dataset with the \"biomTotStadeIp\" variable updated. View Source def update_total_biomass_stade_ip ( j , data ): \"\"\" Update the total biomass of the plant at the end of the vegetative phase (ip = \"initiation paniculaire\"). If the plant has reached phase 4 and has just changed phase, the current total biomass will be copied to the \"biomTotStadeIp\" variable, which represents the total biomass at the end of the vegetative phase (initiation paniculaire). This function is adapted from the EvalRdtPotRespSarV42 procedure, of the bilancarbonsarra.pas file from the original Pascal code. Args: j (int): Timestep index. data (xarray.Dataset): Input dataset. Returns: xarray.Dataset: The updated dataset with the \"biomTotStadeIp\" variable updated. \"\"\" data [ \"biomTotStadeIp\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 4 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), data [ \"biomasseTotale\" ][ j ,:,:], data [ \"biomTotStadeIp\" ][ j ,:,:], ) return data","title":"update_total_biomass_stade_ip"},{"location":"reference/sarra_py/bilan_carbo/#update_vegetative_biomass","text":"def update_vegetative_biomass ( j , data ) summary This function is adapted from the EvalBiomasseVegetati procedure from the copie milbilancarbon, exmodules 1 & 2, milbilancarbone file of the original Pascal code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_vegetative_biomass ( j , data ) : \"\"\" _summary_ This function is adapted from the EvalBiomasseVegetati procedure from the copie milbilancarbon , exmodules 1 & 2 , *** milbilancarbone *** file of the original Pascal code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" biomasseVegetative \" ][ j :,:,:] = ( data [ \" biomasseTige \" ][ j ,:,:] + data [ \" biomasseFeuille \" ][ j ,:,:] ) return data","title":"update_vegetative_biomass"},{"location":"reference/sarra_py/bilan_carbo/#update_yield_during_filling_phase","text":"def update_yield_during_filling_phase ( j , data ) This function updates the yield value during the filling phase. During the filling phase (numPhase == 5), the yield is updated by incrementing it with the sum of deltaBiomasseAerienne and reallocation , bounded by 0 and dRdtPot (daily potential yield). The construction of yield is done during phase 5 only, from the variation of aerial biomass and reallocation, with a maximum of dRdtPot . This function is adapted from the EvolDayRdtSarraV3 procedure from the bilancarbonesarra , exmodules 1 & 2.pas file of the original Pascal code. Notes : On tend vers le potentiel en fn du rapport des degresJours/sumDegresJours pour la phase de remplissage. Frein sup fn du flux de s\u00e8ve estim\u00e9 par le rapport Tr/TrPot. dRdtPot = RdtPotDuJour Parameters: Name Type Description Default j int The time step at which the calculation starts. None data xarray.Dataset The data that contains all variables. None Returns: Type Description xarray.Dataset The input data with updated yield values. View Source def update_yield_during_filling_phase ( j , data ) : \" \"\" This function updates the yield value during the filling phase. During the filling phase (numPhase == 5), the yield is updated by incrementing it with the sum of `deltaBiomasseAerienne` and `reallocation`, bounded by 0 and `dRdtPot` (daily potential yield). The construction of yield is done during phase 5 only, from the variation of aerial biomass and reallocation, with a maximum of `dRdtPot`. This function is adapted from the EvolDayRdtSarraV3 procedure from the ***bilancarbonesarra***, exmodules 1 & 2.pas file of the original Pascal code. Notes : On tend vers le potentiel en fn du rapport des degresJours/sumDegresJours pour la phase de remplissage. Frein sup fn du flux de s\u00e8ve estim\u00e9 par le rapport Tr/TrPot. dRdtPot = RdtPotDuJour Args: j (int): The time step at which the calculation starts. data (xarray.Dataset): The data that contains all variables. Returns: xarray.Dataset: The input data with updated yield values. \"\" \" data [ \"rdt\" ][ j : , : , : ] = np . where ( ( data [ \"numPhase\" ][ j , : , : ] == 5 ), data [ \"rdt\" ][ j , : , : ] + np . minimum ( data [ \"dRdtPot\" ][ j , : , : ] , np . maximum ( 0.0 , data [ \"deltaBiomasseAerienne\" ][ j , : , : ] ) + data [ 'reallocation' ][ j , : , : ] ), data [ \"rdt\" ][ j , : , : ] , ) return data","title":"update_yield_during_filling_phase"},{"location":"reference/sarra_py/bilan_carbo/#variable_dict","text":"def variable_dict ( ) Retrieve the dictionary of variables in the dataset with their respective units. Returns: Type Description dict A dictionary containing the variables and their units, where the keys are the variable names and the values are the respective units. View Source def variable_dict (): \"\"\" Retrieve the dictionary of variables in the dataset with their respective units. Returns: dict: A dictionary containing the variables and their units, where the keys are the variable names and the values are the respective units. \"\"\" variables = { # climate \"ddj\" : [ \"daily thermal time\" , \"\u00b0C.j\" ], \"sdj\" : [ \"sum of thermal time since beginning of emergence\" , \"\u00b0C.j\" ], # phenology \"changePhase\" : [ \"indicator of phase transition day\" , \"binary\" ], \"numPhase\" : [ \"number of phenological stage\" , \"arbitrary units\" ], \"initPhase\" : [ \"indicator of performed phase transition\" , \"binary\" ], \"phasePhotoper\" : [ \"photoperiodic phase indicator\" , \"binary\" ], \"seuilTempPhaseSuivante\" : [ \"sum of thermal time needed to reach the next phenological phase\" , \"\u00b0C.j\" ], \"sommeDegresJourPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], \"seuilTempPhasePrec\" : [ \"sum of thermal time needed to reach the previous phenological phase\" , \"\u00b0C.j\" ], # carbon balance \"assim\" : [ \"plant biomass assimilation\" , \"kg/ha\" ], \"assimPot\" : [ \"plant potential biomass assimilation\" , \"kg/ha\" ], \"bM\" : [ \"net growth rate of living biomass\" , \"kg/(m\u00b2.d)\" ], \"cM\" : [ \"net growth rate of dead biomass\" , \"kg/(m\u00b2.d)\" ], \"rdt\" : [ \"grain yield\" , \"kg/ha\" ], \"rdtPot\" : [ \"potential grain yield\" , \"kg/ha\" ], \"reallocation\" : [ \"amount of assimilates reallocated to the yield (supply < demand)\" , \"kg/ha\" ], \"respMaint\" : [ \"amount of assimilates consumed by maintainance respiration\" , \"kg/ha\" ], \"manqueAssim\" : [ \"deficit in assimilates (demand - supply)\" , \"kg/ha\" ], # biomass \"biomTotStadeFloraison\" : [ \"total biomass of the plant at the end of the flowering stage\" , \"kg/ha\" ], \"biomTotStadeIp\" : [ \"total biomass at the panicle initiation stage\" , \"kg/ha\" ], \"deltaBiomasseAerienne\" : [ \"increment of aerial biomass in one day\" , \"kg/(ha.d)\" ], \"deltaBiomasseFeuilles\" : [ \"increment of leaf biomass in one day\" , \"kg/(ha.d)\" ], \"biomasseAerienne\" : [ \"total aerial biomass\" , \"kg/ha\" ], \"biomasseVegetative\" : [ \"total vegetative biomass\" , \"kg/ha\" ], \"biomasseTotale\" : [ \"total biomass\" , \"kg/ha\" ], \"biomasseTige\" : [ \"total stem biomass\" , \"kg/ha\" ], \"biomasseRacinaire\" : [ \"total root biomass\" , \"kg/ha\" ], \"biomasseFeuille\" : [ \"total leaf biomass\" , \"kg/ha\" ], \"deltaBiomasseTotale\" : [ \"increment of total biomass in one day\" , \"kg/(ha.d)\" ], # evapotranspiration \"kce\" : [ \"fraction of kc attributable to soil evaporation\" , \"decimal percentage\" ], \"kcp\" : [ \"fraction of kc attributable to plant transpiration\" , \"decimal percentage\" ], \"kcTot\" : [ \"total crop coefficient\" , \"\" ], \"tr\" : [ \"actual crop transpiration\" , \"mm/d\" ], \"trPot\" : [ \"potential crop transpiration\" , \"mm/d\" ], \"trSurf\" : [ \"\" , \"\" ], # water balance \"consoRur\" : [ \"consumption of water stored in the root system\" , \"mm\" ], \"water_gathered_by_mulch\" : [ \"water captured by the mulch in one day\" , \"mm\" ], \"eauDispo\" : [ \"available water, sum of rainfall and total irrigation for the day\" , \"mm\" ], \"eauTranspi\" : [ \"water available for transpiration from the surface reservoir\" , \"mm\" ], \"correctedIrrigation\" : [ \"corrected irrigation amount\" , \"mm/d\" ], \"cstr\" : [ \"drought stress coefficient\" , \"arbitrary unit\" ], \"dayVrac\" : [ \"modulated daily root growth\" , \"mm/day\" ], \"delta_root_tank_capacity\" : [ \"change in root system water reserve\" , \"mm\" ], \"dr\" : [ \"drainage\" , \"mm\" ], \"etm\" : [ \"evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etp\" : [ \"potential evapotranspiration from the soil moisture\" , \"mm/d\" ], \"etr\" : [ \"reference evapotranspiration\" , \"mm/d\" ], \"evap\" : [ \"evaporation from the soil moisture\" , \"mm/d\" ], \"evapPot\" : [ \"potential evaporation from the soil moisture\" , \"mm/d\" ], \"FEMcW\" : [ \"water fraction in soil volume explored by the root system\" , \"none\" ], \"fesw\" : [ \"fraction of available surface water\" , \"decimal percentage\" ], \"irrigTotDay\" : [ \"total irrigation for the day\" , \"mm\" ], \"vRac\" : [ \"reference daily root growth\" , \"mm/day\" ], \"ftsw\" : [ \"fraction of transpirable surface water\" , \"decimal percentage\" ], \"lr\" : [ \"daily water runoff\" , \"mm/d\" ], \"pFact\" : [ \"FAO reference for critical FTSW value for transpiration response\" , \"none\" ], # water tanks \"irrigation_tank_stock\" : [ \"current stock of water in the irrigation tank\" , \"mm\" ], #! renaming stockIrr to irrigation_tank_stock \"mulch_water_stock\" : [ \"water stored in crop residues (mulch)\" , \"mm\" ], #! renaming stockMc to mulch_water_stock \"root_tank_stock\" : [ \"current stock of water in the root system tank\" , \"mm\" ], #! renaming stRu to root_tank_stock \"total_tank_capacity\" : [ \"total capacity of the root system tank\" , \"mm\" ], #! renaming stRuMax to total_tank_capacity \"stRur\" : [ \"\" , \"\" ], # [\"previous season's root system tank stock\",\"mm\"], \"root_tank_capacity_previous_season\" : [ \"previous season's root system tank capacity\" , \"mm\" ], #! renaming stRurMaxPrec to root_tank_capacity_previous_season \"stRurPrec\" : [ \"previous day's root system tank stock\" , \"mm\" ], \"stRurSurf\" : [ \"surface root system tank stock\" , \"mm\" ], \"surface_tank_stock\" : [ \"current stock of water in the surface root system tank\" , \"mm\" ], #! renaming stRuSurf to surface_tank_stock \"stRuSurfPrec\" : [ \"previous day's surface root system tank stock\" , \"mm\" ], \"delta_total_tank_stock\" : [ \"change in the total root system tank stock\" , \"mm\" ], #! renaming stRuVar to delta_total_tank_stock \"irrigation_tank_capacity\" : [ \"irrigation tank capacity\" , \"mm\" ], #! renaming ruIrr to irrigation_tank_capacity \"ruRac\" : [ \"Water column that can potentially be strored in soil volume explored by root system\" , \"mm\" ], \"conv\" : [ \"\" , \"\" ], \"KAssim\" : [ \"\" , \"\" ], \"dayBiomLeaf\" : [ \"daily growth of leaf biomass\" , \"kg/ha/d\" ], \"dRdtPot\" : [ \"daily potential demand from yield\" , \"kg/ha/d\" ], \"FeuilleUp\" : [ \"\" , \"\" ], \"kRespMaint\" : [ \"\" , \"\" ], \"LitFeuille\" : [ \"\" , \"\" ], \"nbJourCompte\" : [ \"\" , \"\" ], \"nbjStress\" : [ \"\" , \"\" ], \"NbUBT\" : [ \"\" , \"\" ], \"sla\" : [ \"\" , \"\" ], \"stockRac\" : [ \"\" , \"\" ], \"sumPP\" : [ \"\" , \"\" ], \"TigeUp\" : [ \"\" , \"\" ], \"UBTCulture\" : [ \"\" , \"\" ], \"lai\" :[ \"leaf area index\" , \"m2/m2\" ], # experimental \"Ncrit\" : [ \"\" , \"\" ], } return variables","title":"variable_dict"},{"location":"reference/sarra_py/bilan_hydro/","text":"Module sarra_py.bilan_hydro View Source import numpy as np import xarray as xr from sarra_py.bilan_carbo import estimate_kcp def InitPlotMc ( data , grid_width , grid_height , paramITK , paramTypeSol , duration ): \"\"\" Initializes variables related to crop residues boimass (mulch) in the data xarray dataset. This code has been adapted from the original InitPlotMc procedure, Bileau.pas code. Comments with tab indentation are from the original code. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. \"\"\" # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] #// data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock #// data[\"stTot\"] = data[\"stockIniProf\"] #//data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ] . expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock #// data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] return data def update_irrigation_tank_stock ( j , data ): \"\"\" Update the Irrigation Tank Stock In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged. Args: j (int): Index of time step in data data (xarray Dataset): Dataset that contains various data fields Returns: xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions. \"\"\" condition = ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) # group 1 #! renaming stockIrr with irrigation_tank_stock #//data[\"stockIrr\"][j, :, :] = np.where( data [ \"irrigation_tank_stock\" ][ j , :, :] = np . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// (data[\"stRurMax\"] < data[\"ruSurf\"]), ( data [ \"root_tank_capacity\" ] < data [ \"surface_tank_capacity\" ])[ j , :, :], #! renaming stRuSurf to surface_tank_stock #// data[\"stRuSurf\"][j, :, :], data [ \"surface_tank_stock\" ][ j , :, :], #! renaming stRur to root_tank_stock #// data[\"stRur\"][j, :, :], data [ \"root_tank_stock\" ][ j , :, :], ), data [ \"irrigation_tank_stock\" ][ j , :, :], ) return data def update_irrigation_tank_capacity ( j , data ): \"\"\" Update Irrigation Tank Capacity The function updates the maximum water capacity of irrigation tank based on the conditions specified in the function. If the automatic irrigation mode is ON, and if the current phase is between 0 and 6, and if the root tank capacity is less than the surface tank capacity, meaning that the roots have not reached the limit between the surface compartment and deep compartment, then the irrigation tank capacity is set to the surface tank capacity, which is given a minimum value equal to the surface tank capacity. Otherwise, the irrigation tank capacity remains unchanged. If we are in automatic irrigation mode, and between phases 0 and 6, and if root_tank_capacity is less than surface_tank_capacity, meaning that roots haven't reached the limit between the surface compartment and deep compartment, then we define irrigation_tank_capacity as equal to surface_tank_capacity, that is to say, we give to irrigation_tank_capacity a minimum value that equals surface_tank_capacity. else, we do not modify irrigation_tank_capacity value Args: j (int): Index of the time step being processed. data (xarray dataset): The input dataset containing all the information necessary to run the model. Returns: xarray dataset: The input dataset with updated values of the irrigation tank capacity. \"\"\" # group 2 condition = \\ ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) # renaming ruIrr with irrigation_tank_capacity #// data[\"ruIrr\"][j, :, :] = np.where( data [ \"irrigation_tank_capacity\" ][ j , :, :] = np . where ( condition , np . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// (data[\"stRurMax\"] < data[\"ruSurf\"]), data [ \"root_tank_capacity\" ][ j ,:,:] < data [ \"surface_tank_capacity\" ], #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ], #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ][ j ,:,:], ), data [ \"irrigation_tank_capacity\" ][ j , :, :], ) return data def compute_daily_irrigation ( j , data , paramITK ): \"\"\" Computes the Total Daily Irrigation (mm) If we are in the automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between the current volume of water in the irrigation tank (irrigation_tank_stock) and the total capacity of the irrigation tank (irrigation_tank_capacity), bounded by a minimum of 0 and a maximum of maxIrrig. This computed value represents the amount of water to be added to the irrigation tank. If the above conditions are not met, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need (irrigation) with the previous irrigation history of the day (irrigTotDay). irrigTotDay : \"total irrigation of the day, both from the irrigation history and the estimated irrigation need\" (mm) // irrigation_total_day if we are in automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between irrigation_tank_stock and irrigation_tank_capacity (that is to say, 90% of the volume needed to fill the irrigation tank), bounded by a minimum of 0 and a maximum of maxIrrig. Else, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need with the irrigation history of the day. Args: j: An integer representing the current day. data: A xarray dataset. paramITK: A dictionary of parameters. Returns: data: A xarray dataset with the updated irrigationTotDay field. \"\"\" #! renaming stockIrr with irrigation_tank_stock #! renaming ruIrr with irrigation_tank_capacity condition = ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) & \\ ( data [ \"irrigation_tank_stock\" ][ j , :, :] / data [ \"irrigation_tank_capacity\" ][ j ,:,:] \\ < paramITK [ \"irrigAutoTarget\" ]) # group 3 data [ \"irrigTotDay\" ][ j , :, :] = xr . where ( condition , np . minimum ( np . maximum ( 0 , # ! replacing correctedIrrigation by irrigation #! renaming stockIrr with irrigation_tank_stock #! renaming ruIrr with irrigation_tank_capacity # // ((data[\"ruIrr\"][j, :, :] - data[\"stockIrr\"][j, :, :]) * 0.9) - data[\"correctedIrrigation\"][j, :, :]), (( data [ \"irrigation_tank_capacity\" ][ j , :, :] - data [ \"irrigation_tank_stock\" ][ j , :, :]) * 0.9 ) \\ - data [ \"irrigation\" ][ j , :, :] ), paramITK [ \"maxIrrig\" ] ), 0 , ) # group 4 data [ \"irrigTotDay\" ][ j , :, :] = ( # ! replacing correctedIrrigation by irrigation # // data[\"correctedIrrigation\"][j, :, :] + data[\"irrigTotDay\"][j, :, :]).copy() data [ \"irrigation\" ][ j , :, :] + data [ \"irrigTotDay\" ][ j , :, :]) return data def EvalIrrigPhase ( j , data , paramITK ): \"\"\" Computes the irrigation state for a given day, including the size and filling of the irrigation tank and the irrigation demand. The computation of the irrigation state is based on the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). The water stock in the irrigation tank (stockIrr) and the maximum water capacity of the irrigation tank (ruIrr) are first calculated, with minimum boundaries determined by properties of the surface reservoir. The irrigation demand (irrigTotDay) is then computed. The irrigation tank stock and capacity are only computed to avoid issues with very shallow rooting, where the calculation of the filling of root_tank_capacity by root_tank_stock can be inappropriate and result in inadapted results for automatic irrigation. Note: In this irrigation management, the daily rainfall is not taken into account. Translated from the procedure EvalIrrigPhase, of the original Pascal codes bileau.pas and exmodules2.pas. In irrigAuto mode, this function computes the size and filling of the irrigation tank, and the irrigation demand, according to the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), and the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). It first calculates stockIrr, the water stock in the irrigation tank, and ruIrr, the maximum water capacity of irrigation tank. Both stockIrr and ruIrr are given minimum boundaries related to properties of the surface reservoir. Then, it calculates the irrigation demand, irrigTotDay. irrigation_tank_stock and irrigation_tank_capacity are only computed in order to avoid issues with very shallow rooting, where calculation of filling of root_tank_capacity by root_tank_stock can be inappropriate and lead to inadapted results for automatic irrigation Notes from CB, 2014 : Modification due \u00e0 la prise en compte effet Mulch Soit on a une irrigation observ\u00e9e, soit on calcul la dose d'irrigation Elle est calcul\u00e9e en fonction d'un seuil d'humidit\u00e9 (IrrigAutoTarget) et de possibilit\u00e9 technique ou choix (MaxIrrig, Precision) Dans cette gestion d'irrigation la pluie du jour n'est pas prise en compte N.B.: here, precision is not taken into account anymore Args: j (int): Index of the day for which the irrigation state is being computed. data (xarray.Dataset): The input data, including the arrays for irrigation and correctedIrrigation. paramITK (dict): The parameters for the ITK model. Returns: xarray.Dataset: The updated data, including the computed values for the irrigation state. \"\"\" # First, we store initial irrigation value of the day in the # correctedIrrigation array # ! it does not seem definition and use of correctedIrrigation is useful # ! instead we will just use the already defined irrigation array # // data[\"correctedIrrigation\"][j, :, :] = data[\"irrigation\"][j, :, :].copy(deep=True) data = update_irrigation_tank_stock ( j , data ) data = update_irrigation_tank_capacity ( j , data ) data = compute_daily_irrigation ( j , data , paramITK ) return data def calculate_total_water_availability ( j , data ): \"\"\" Calculates the total water available for a day by adding the rainfall and the irrigation. The total water available is computed by adding the rainfall for the day, which is stored in the \"rain\" array, and the total daily irrigation, which is stored in the \"irrigTotDay\" array. This calculation is performed to allow for subsequent calculations of the mulch filling and runoff. The mulch layer is considered to be directly under the rainfall and irrigation, which is represented by the \"irrigTotDay\" value. Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas This function computes the total water available for the day, by summing the rain and the irrigation. Notes from CB, 2014 : Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig, ici irrigTotDay qui est l'irrigation observ\u00e9e ou calcul\u00e9e, d'o\u00f9 on regroupe les deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement. Args: j (int): The index of the current day. data (xarray.Dataset): The data set containing information about the rainfall, irrigation, and water availability. Returns: xarray.Dataset: The data set with updated information about the total water availability for the current day. \"\"\" data [ \"eauDispo\" ][ j ,:,:] = data [ \"rain\" ][ j ,:,:] + data [ \"irrigTotDay\" ][ j ,:,:] return data def estimate_water_captured_by_mulch ( j , data , paramITK ): \"\"\" Determination of water gathered by the mulch (eauCaptee, mm): We determine the quantity of water gathered by mulch by multiplying the available water (eauDispo, from rain and irrigation, mm) with a exponential function of covering capacity of the considered mulch (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the fraction of soil covered by mulch. The value of eauCaptee is bounded by the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of water already present in it (stockMc, mm). Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 7 #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"eauCaptee\"][j,:,:] = np.minimum( data [ \"water_gathered_by_mulch\" ][ j ,:,:] = np . minimum ( data [ \"eauDispo\" ][ j ,:,:] * ( 1 - np . exp ( - paramITK [ \"surfMc\" ] / 1000 * data [ \"biomMc\" ][ j ,:,:])), #// (paramITK[\"humSatMc\"] * data[\"biomMc\"][j,:,:] / 10000) - data[\"stockMc\"][j,:,:], ( paramITK [ \"humSatMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 10000 ) - data [ \"mulch_water_stock\" ][ j ,:,:], ) return data def update_available_water_after_mulch_filling ( j , data ): \"\"\" Updating available water (eauDispo, mm) : As some water is gathered by the mulch, the available water is updated by subtracting the gathered water (eauCaptee, mm) from the total available water (eauDispo, mm). This value is bounded by 0, as the available water cannot be negative. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch # group 8 #// data[\"eauDispo\"][j:,:,:] = np.maximum(data[\"eauDispo\"][j,:,:] - data[\"eauCaptee\"][j,:,:], 0) # //[...,np.newaxis] data [ \"eauDispo\" ][ j :,:,:] = np . maximum ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"water_gathered_by_mulch\" ][ j ,:,:], 0 ) # //[...,np.newaxis] return data def update_mulch_water_stock ( j , data ): \"\"\" Updating water stock in mulch (stockMc, mm) : The water stock in mulch is updated by adding the gathered water (eauCaptee, mm) Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy # group 9 #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"stockMc\"][j:,:,:] = (data[\"stockMc\"][j,:,:] + data[\"eauCaptee\"][j,:,:]) # //[...,np.newaxis] data [ \"mulch_water_stock\" ][ j :,:,:] = ( data [ \"mulch_water_stock\" ][ j ,:,:] + data [ \"water_gathered_by_mulch\" ][ j ,:,:]) # //[...,np.newaxis] return data def RempliMc ( j , data , paramITK ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas wrapper function, updates water_gathered_by_mulch, eauDispo, and mulch_water_stock For more details, it is advised to refer to the works of Eric Scopel (UR AIDA), and the PhD dissertation of Fernando Maceina. Notes from CB, 2014 : Hypotheses : A chaque pluie, on estime la quantit\u00e9 d'eau pour saturer le couvert. On la retire \u00e0 l'eauDispo (pluie + irrig). On calcule la capacit\u00e9 maximum de stockage fonction de la biomasse et du taux de saturation rapport\u00e9e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1 mm = 1 litre d'eau / m2 1 mm = 10 tonnes d'eau / hectare = 10 000 kg/ha La biomasse est en kg/ha pour se rapporter \u00e0 la quantit\u00e9 de pluie capt\u00e9e en mm Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha \u00e0 humSat 2.8 kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit\u00e9 \u00e0 capter est fonction du taux de couverture du sol calcul\u00e9 comme le LTR SurfMc est sp\u00e9cifi\u00e9 en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On retire alors les mm d'eau capt\u00e9es \u00e0 la pluie incidente. Le ruisselement est ensuite calcul\u00e9 avec l'effet de contrainte du mulch group 10 \"\"\" data = estimate_water_captured_by_mulch ( j , data , paramITK ) data = update_available_water_after_mulch_filling ( j , data ) data = update_mulch_water_stock ( j , data ) return data def estimate_runoff ( j , data ): \"\"\" Evaluation of runoff (\"lame de ruissellement\", lr, mm) : If the quantity of rain (mm) is above the runoff threshold (seuilRuiss, mm), runoff is computed as the difference between the available water (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0. seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data Question : should runoff be computed taking in consideration water captured by mulch to account for mulch effect on runoff mitigation ? Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 11 data [ \"lr\" ][ j ,:,:] = xr . where ( data [ \"rain\" ][ j ,:,:] > data [ \"seuilRuiss\" ], ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"seuilRuiss\" ]) * data [ \"pourcRuiss\" ], 0 , ) return data def update_available_water_after_runoff ( j , data ): \"\"\" Updating available water (eauDispo, mm) : The available water is updated by subtracting the runoff (lr, mm) from the total available water (eauDispo, mm). This value is broadcasted onto the days axis. Args: j (_type_): _description_ data (_type_): _description_ \"\"\" # group 12 data [ \"eauDispo\" ][ j :,:,:] = ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"lr\" ][ j ,:,:]) return data def EvalRunOff ( j , data , paramTypeSol ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas, exmodules1.pas and exmodules2.pas Notes from CB, 2014 : On a regroup\u00e9 avant la pluie et l'irrigation (a cause de l'effet Mulch) si mulch on a enlev\u00e9 l'eau capt\u00e9e oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS Args: j (_type_): _description_ data (_type_): _description_ paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" data = estimate_runoff ( j , data ) data = update_available_water_after_runoff ( j , data ) return data def initialize_root_tank_capacity ( j , data , paramITK ): \"\"\" updating stRurMax/root_tank_capacity, step 1 : stRurMax, also called ruRac in some versions of the model, is the root_tank_capacity. At the phase change between phases 0 and 1 (initialisation), the maximum root water storage is initialised by multiplying the initial root depth (profRacIni, mm) with the soil water storage capacity (ru, mm/m). This value is broadcasted on the time series. For every other day in the cycle, the value remains unchanged. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 14 #! renaming stRurMax to root_tank_capacity #// data[\"stRurMax\"][j:,:,:] = np.where( data [ \"root_tank_capacity\" ][ j :,:,:] = xr . where ( ( data [ \"changePhase\" ][ j ,:,:] == 1 ) & ( data [ \"numPhase\" ][ j ,:,:] == 1 ), paramITK [ \"profRacIni\" ] / 1000 * data [ \"ru\" ], #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) return data def estimate_delta_root_tank_capacity ( j , data ): \"\"\" Updates daily root capacity variation (delta_root_tank_capacity, in mm water/day) based on the current phase of the plant, the daily root growth speed, and the drought stress coefficient. The daily root capacity variation is calculated as the product of soil water storage capacity (ru), the daily root growth speed (vRac), and a coefficient (cstr + 0.3). This coefficient is capped at 1.0. The daily root capacity variation is modulated by drought stress only when the root tank capacity is greater than the surface tank capacity and the current phase is strictly greater than 1 and at the day of phase change. If the root tank capacity is lower than the surface tank capacity or if the current phase is 1 or below or not at the day of phase change, the daily root capacity variation remains unchanged. The drought stress coefficient, cstr, measures the level of drought stress with 0 being full stress. The root growth speed is assumed to still occur during a drought stress as a matter of survival, with a certain level of tolerance given by the [0.3, 1] bound of the coefficient. Updating delta_root_tank_capacity / dayVrac (daily variation in water height accessible to roots, mm water/day) : At the day of phase change, for phases strictly above 1, and for which root_tank_capacity is greater than surface_tank_capacity, the variation of root tank capacity delta_root_tank_capacity is computed as the product of soil water storage capacity (ru, mm/m), the daily root growth speed (vRac, mm/day), and a coefficient, the latter being equal to the drought stress coefficient (cstr) plus 0.3, with a maximum bound of 1.0. That is to say, when the root_tank_capacity is greater than surface_tank_capacity, the root growth speed is modulated by drought stress. When root_tank_capacity is lower than surface_tank_capacity, the root growth speed is not modulated by drought stress. When we are not at the day of phase change, or if we are at phase of 1 and below, delta_root_change_capacity is unchanged. cstr is the drought stress coefficient, with a value of 0 meaning full stress. Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian BARON, this is based on the hypothesis that during a drought stress (cstr = 0), the plant will still grow roots as a matter of survival. Furthermore, using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr interval, there is no effect of drought stress on the root growth speed, allowing for a certain level of tolerance of the plant. Args: j (int): The current iteration step of the process. data (xarray.Dataset): The input data containing relevant information. Returns: xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored. \"\"\" # group 15 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & \\ # // np.invert((data[\"numPhase\"][j,:,:] == 1) & (data[\"changePhase\"][j,:,:] == 1)) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) #! renaming dayVrac to delta_root_tank_capacity #// data[\"dayVrac\"][j,:,:] = np.where( data [ \"delta_root_tank_capacity\" ][ j ,:,:] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity #// (data[\"stRurMax\"][j,:,:] > data[\"ruSurf\"][j,:,:]), ( data [ \"root_tank_capacity\" ][ j ,:,:] > data [ \"surface_tank_capacity\" ]), ( data [ \"vRac\" ][ j ,:,:] * np . minimum ( data [ \"cstr\" ][ j ,:,:] + 0.3 , 1.0 )) / 1000 * data [ \"ru\" ], data [ \"vRac\" ][ j ,:,:] / 1000 * data [ \"ru\" ], ), #// data[\"dayVrac\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ) return data def update_delta_root_tank_capacity ( j , data ): \"\"\" updating delta_root_tank_capacity : At the day of phase change, for phases strictly above 1, and for which the difference between the water height to humectation front (hum, mm) and the root_tank_capacity is less than the delta_root_tank_capacity, delta_root_tank_capacity is updated to be equal to the difference between the water height to humectation front and the root_tank_capacity. In other words, the change in root tank capacity delta_root_tank_capacity is limited by the water height to humectation front. For any other day or if root_tank_capacity is above delta_root_tank_capacity, delta_root_tank_capacity value is unchanged. Args: j (_type_): _description_ data (_type_): _description_ \"\"\" # group 16 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & \\ # // np.invert((data[\"numPhase\"][j,:,:] == 1) & (data[\"changePhase\"][j,:,:] == 1)) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) #! renaming deltaRur with delta_root_tank_capacity #// data[\"deltaRur\"][j:,:,:] = np.where( data [ \"delta_root_tank_capacity\" ][ j :,:,:] = np . where ( condition , np . where ( #! renaming stRurMax to root_tank_capacity #! renaming dayVrac to delta_root_tank_capacity #// (data[\"hum\"][j,:,:] - data[\"stRurMax\"][j,:,:]) < data[\"dayVrac\"][j,:,:], ( data [ \"hum\" ][ j ,:,:] - data [ \"root_tank_capacity\" ][ j ,:,:]) < data [ \"delta_root_tank_capacity\" ][ j ,:,:], #// data[\"hum\"][j,:,:] - data[\"stRurMax\"][j,:,:], data [ \"hum\" ][ j ,:,:] - data [ \"root_tank_capacity\" ][ j ,:,:], #! renaming dayVrac to delta_root_tank_capacity #// data[\"dayVrac\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ), #// data[\"deltaRur\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ) return data def update_root_tank_capacity ( j , data ): \"\"\" updating root_tank_capacity/stRurMax/ruRac, step 2 : At the day of phase change, for phases strictly above 1, root_tank_capacity is updated to be summed with the change in root water storage capacity delta_root_tank_capacity. In other words, root_tank_capacity is incremented by the change in root water storage capacity linked to root growth. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 17 # ! simplified conditions # // data[\"stRurMax\"][j:,:,:] = np.where( # // (data[\"numPhase\"][j,:,:] > 0), # // np.where( # // np.invert((data[\"changePhase\"][j,:,:] == 1) & (data[\"numPhase\"][j,:,:] == 1)), # // data[\"stRurMax\"][j,:,:] + data[\"deltaRur\"][j,:,:], # // data[\"stRurMax\"][j,:,:], # // ), # // data[\"stRurMax\"][j,:,:], # // )#[...,np.newaxis] #! renaming stRurMax to root_tank_capacity #! renaming deltaRur to delta_root_tank_capacity #// data[\"stRurMax\"][j:,:,:] = np.where( data [ \"root_tank_capacity\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), #// data[\"stRurMax\"][j,:,:] + data[\"deltaRur\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:] + data [ \"delta_root_tank_capacity\" ][ j ,:,:], #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) return data def update_root_tank_stock ( j , data ): \"\"\" updating root_tank_stock/stRur/stockrac : At the day of phase change, for phases strictly above 1, and for which the root_tank_capacity is above surface_tank_capacity (meaning that roots go beyond the surface water storage capacity), root_tank_stock is incremented by delta_root_tank_capacity. However, if root_tank_capacity is BELOW surface_tank_capacity (meaning that roots do not plunge into the deep reservoir), root_tank_stock is updated to be equal to surface_tank_stock minus 1/10th of the surface_tank_capacity, multiplied by the ratio between root_tank_capacity and surface_tank_capacity. That is to say \"we take at the prorata of depth and surface stock\". For any other day, root_tank_stock is unchanged. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 18 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & np.invert((data[\"changePhase\"][j,:,:] == 1) & (data[\"numPhase\"][j,:,:] == 1)), condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), #! renaming stRur to root_tank_stock #// data[\"stRur\"][j:,:,:] = np.where( data [ \"root_tank_stock\" ][ j :,:,:] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity #// (data[\"stRurMax\"][j,:,:] > data[\"ruSurf\"][j,:,:]), ( data [ \"root_tank_capacity\" ][ j ,:,:] > data [ \"surface_tank_capacity\" ]), #! renaming stRur to root_tank_stock #! renaming deltaRur to delta_root_tank_capacity #// data[\"stRur\"][j,:,:] + data[\"deltaRur\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:] + data [ \"delta_root_tank_capacity\" ][ j ,:,:], #! renaming stRur to root_tank_stock #! renaming stRuSurf to surface_tank_stock #// np.maximum((data[\"stRuSurf\"][j,:,:] - data[\"ruSurf\"][j,:,:] * 1/10) * (data[\"stRurMax\"][j,:,:] / data[\"ruSurf\"][j,:,:]), 0), np . maximum (( data [ \"surface_tank_stock\" ][ j ,:,:] - data [ \"surface_tank_capacity\" ] * 1 / 10 ) * ( data [ \"root_tank_capacity\" ][ j ,:,:] / data [ \"surface_tank_capacity\" ]), 0 ), ) . expand_dims ( \"time\" , axis = 0 ), #! renaming stRur to root_tank_stock #// data[\"stRur\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:], ) return data def EvolRurCstr2 ( j , data , paramITK ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas Notes from CB, 10/06/2015 : Stress trop fort enracinement Trop d'effet de stress en tout d\u00e9but de croissance : 1) la plantule a des r\u00e9serves et favorise l'enracinement 2) dynamique sp\u00e9cifique sur le r\u00e9servoir de surface Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement est sup\u00e9rieur \u00e9 la profondeur du r\u00e9servoir de surface. Effet stres a un effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur la vitesse) La vitesse d'enracinement potentielle de la plante peut etre bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est convertie en quantite d'eau maximum equivalente IN: Vrac : mm (en mm/jour) : Vitesse racinaire journali\u00e8re \u00a7\u00a7 Daily root depth Hum : mm Quantit\u00e9 d'eau maximum jusqu'au front d'humectation \u00a7\u00a7 Maximum water capacity to humectation front StRuSurf : mm RU : mm/m RuSurf : mm/m INOUT: stRurMax : mm ==== ruRac stRur : mm ==== stockRac NB : on remet le nom de variables de CB plut\u00f4t que celles utilis\u00e9es par MC dans le code Java \"\"\" # ! dayvrac et deltarur reset \u00e0 chaque it\u00e9ration ; on traine donc le j sur les autres variables data = initialize_root_tank_capacity ( j , data , paramITK ) data = estimate_delta_root_tank_capacity ( j , data ) data = update_delta_root_tank_capacity ( j , data ) data = update_root_tank_capacity ( j , data ) data = update_root_tank_stock ( j , data ) return data ####################### list of functions for rempliRes ####################### def condition_end_of_cycle ( j , data ): \"\"\" Returns conditions needed to apply functions related to end of cycle. Returns: _type_: _description_ \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] == 7 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) return condition def update_humPrec_for_end_of_cycle ( j , data ): \"\"\" This function saves information about the humectation front depth at the end of a growth cycle so it can be used in the next cycle. humPrec is initialized in the function InitPlotMc, and set to be equal to hum, itself being initialized to take the maximum value between surface_tank_capacity, root_tank_capacity and total_tank_stock. At the harvest date (numPhase = 7), the humPrec variable is set to equal the highest value between hum (mm, humectation front depth) and surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (int): number of the day data (xarray dataset): _description_ Returns: xarray dataset: _description_ \"\"\" # group 20 condition = condition_end_of_cycle ( j , data ) data [ \"humPrec\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// np.maximum(data[\"hum\"][j,:,:], data[\"ruSurf\"][j,:,:]), np . maximum ( data [ \"hum\" ][ j ,:,:], data [ \"surface_tank_capacity\" ]), data [ \"humPrec\" ][ j ,:,:], ) return data def update_hum_for_end_of_cycle ( j , data ): \"\"\" This function updates information about the humectation front depth at the end of a growth cycle. At the harvest date (numPhase = 7), the hum variable is set to equal the surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 21 condition = condition_end_of_cycle ( j , data ) data [ \"hum\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// data[\"ruSurf\"][j,:,:], data [ \"surface_tank_capacity\" ], data [ \"hum\" ][ j ,:,:], ) return data def update_stRurMaxPrec_for_end_of_cycle ( j , data ): \"\"\" When the phase changes from 7 to 1, the stRurMaxPrec (mm, previous maximum water capacity to root front) is set to equal root_tank_capacity (mm). Value is broadcasted along time dimension. For every other day, it keeps its initial value of 0. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 22 condition = condition_end_of_cycle ( j , data ) #! renaming stRurMaxPrec to root_tank_capacity_previous_season #// data[\"stRurMaxPrec\"][j:,:,:] = np.where( data [ \"root_tank_capacity_previous_season\" ][ j :,:,:] = np . where ( condition , #! renaming stRurMax to root_tank_capacity #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], #! renaming stRurMaxPrec to root_tank_capacity_previous_season #// data[\"stRurMaxPrec\"][j,:,:], data [ \"root_tank_capacity_previous_season\" ][ j ,:,:], ) return data def update_stRurPrec_for_end_of_cycle ( j , data ): \"\"\" when the phase changes from 7 to 1, stRurPrec is set to equal stRur/stRurMax, that is to say the ratio of the water storage capacity of the root reservoir. Otherwise, it stays at its initial value of 0. Its value is broadcasted along j. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 23 condition = condition_end_of_cycle ( j , data ) data [ \"stRurPrec\" ][ j :,:,:] = np . where ( condition , #! renaming stRur to root_tank_stock #! renaming stRurMax to root_tank_capacity #// data[\"stRur\"][j,:,:]/data[\"stRurMax\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:] / data [ \"root_tank_capacity\" ][ j ,:,:], data [ \"stRurPrec\" ][ j ,:,:], ) return data def update_stRuPrec_for_end_of_cycle ( j , data ): \"\"\" when the phase changes from 7 to 1, the stRuPrec (mm, previous water storage capacity of the global reservoir) is set to equal the differe,ce between stTot (mm, total water storage capacity of the global reservoir) and stRurSurf (mm, water storage capacity of the surface reservoir) Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 24 #! stRurSurf is not defined... we may want to drop this group condition = condition_end_of_cycle ( j , data ) #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuPrec\"][j:,:,:] = np.where( data [ \"total_tank_stock_previous_value\" ][ j :,:,:] = np . where ( condition , #! renaming stTot to total_tank_stock #! renaming stRuSurf with surface_tank_stock #// data[\"stRu\"][j,:,:] - data[\"stRurSurf\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"surface_tank_stock\" ][ j ,:,:], # essai stTot #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j ,:,:], ) return data def reset_total_tank_capacity ( j , data ): \"\"\" This function resets the value total_tank_capacity/stRuMax at each loop. ? Why redfining stRuMax at each loop ? Neither ru, profRu ? nor total_tank_capacity are modified during the simulation. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 25 #! renaming stRuMax to total_tank_capacity #// data[\"stRuMax\"][j:,:,:] = (data[\"ru\"] * data[\"profRu\"] / 1000) #.copy()#[...,np.newaxis] data [ \"total_tank_capacity\" ][ j :,:,:] = ( data [ \"ru\" ] * data [ \"profRu\" ] / 1000 ) return data def update_surface_tank_stock ( j , data ): \"\"\" This function updates the value of surface_tank_stock. We update surface_tank_stock by adding the eauDispo, which as this point is the water available from 1) rain, 2) irrigation for the day after estimation of intake by mulch, and 3) runoff. However, we do not allow surface_tank_stock to exceed 110% of the surface_tank_capacity. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 27 #! renaming stRuSurf to surface_tank_stock #// data[\"stRuSurf\"][j:,:,:] = np.minimum( data [ \"surface_tank_stock\" ][ j :,:,:] = np . minimum ( #// data[\"stRuSurf\"][j,:,:] + data[\"eauDispo\"][j,:,:], data [ \"surface_tank_stock\" ][ j ,:,:] + data [ \"eauDispo\" ][ j ,:,:], #! renaming ruSurf to surface_tank_capacity #// 1.1 * data[\"ruSurf\"][j,:,:] 1.1 * data [ \"surface_tank_capacity\" ] ) return data def estimate_transpirable_water ( j , data ): \"\"\" This function estimates the daily volume of transpirable water. eauTranspi (mm, water transpirable) is the water available for transpiration from the surface reservoir. If surface_tank_stock at the end of the previous day (index j-1) is lower than 10% of the surface_tank_capacity, the water available for transpirable water equals the water available for the day (eauDispo), minus the difference between 1/10th of the surface_tank_capacity and surface_tank_stock. This transpirable water has a min bound at 0 mm. Said otherwise, a part of the water available for the day (eauDispo) is considered as bound to the surface reservoir and cannot be transpired. If surface_tank_stock at the end of the previous day (index j-1) is upper than 10% of the surface_tank_capacity, transpirable water equals eauDispo. Remark : if the use of j-1 indices is too problematic, it seems feasible to run this function just before update_surface_tank_stock. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 28 data [ \"eauTranspi\" ][ j ,:,:] = np . where ( # ! modifying to replace stRuSurfPrec by stRuSurf at undex j-1 #! renaming ruSurf to surface_tank_capacity #! renaming stRuSurfPrec to surface_tank_stock # // data[\"stRuSurfPrec\"][j,:,:] < data[\"ruSurf\"][j,:,:]/10, data [ \"surface_tank_stock\" ][ j - 1 ,:,:] < 0.1 * data [ \"surface_tank_capacity\" ], np . maximum ( 0 , # ! modifying to replace stRuSurfPrec by stRuSurf at iundex j-1 #! renaming ruSurf to surface_tank_capacity #! renaming stRuSurf to surface_tank_stock # //data[\"eauDispo\"][j,:,:] - (data[\"ruSurf\"][j,:,:]/10 - data[\"stRuSurfPrec\"][j,:,:]) data [ \"eauDispo\" ][ j ,:,:] - ( 0.1 * data [ \"surface_tank_capacity\" ] - data [ \"surface_tank_stock\" ][ j - 1 ,:,:]) ), data [ \"eauDispo\" ][ j ,:,:], ) return data def update_total_tank_stock ( j , data ): \"\"\" This functions updates the value of total_tank_stock with the value of transpirable water. ? why incrementing stTot by eauTranspi ? ? we then consider that transpirable water is the water that fills the total_tank_stock ? Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 29 #! renaming stTot with total_tank_stock #// data[\"stTot\"][j:,:,:] = (data[\"stTot\"][j,:,:] + data[\"eauTranspi\"][j,:,:]).copy()#[...,np.newaxis] data [ \"total_tank_stock\" ][ j :,:,:] = ( data [ \"total_tank_stock\" ][ j ,:,:] + data [ \"eauTranspi\" ][ j ,:,:]) return data def update_delta_total_tank_stock ( j , data ): \"\"\" This function estimates delta_total_tank_stock delta_total_tank_stock is the positive variation of transpirable water stock. It is computed as the difference between the total_tank_stock and stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is initialized to be equal to total_tank_stock at the beginning of the simulation. total_tank_stock is initialized with stockIrr parameter. Thus, simulations should start with a 0 value. stRuPrec is updated at each cycle with the update_struprec function. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 30 #! we propose a different version based on stTot #! renaming stTot to total_tank_stock #! renaming stRuVar to delta_total_tank_stock #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuVar\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"stRuPrec\"][j,:,:])[...,np.newaxis] data [ \"delta_total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"total_tank_stock_previous_value\" ][ j ,:,:]) return data def conditions_rempliRes ( j , data ): \"\"\"_summary_ Returns: _type_: _description_ \"\"\" #! renaming stRuVar with delta_total_tank_stock #//condition_1 = (data[\"stRuVar\"][j,:,:] > data[\"hum\"][j,:,:]) condition_1 = ( data [ \"delta_total_tank_stock\" ][ j ,:,:] > data [ \"hum\" ][ j ,:,:]) #! renaming stRurMaxPrec to root_tank_capacity_previous_season #// condition_2 = (data[\"hum\"][j,:,:] <= data[\"stRurMaxPrec\"][j,:,:]) condition_2 = ( data [ \"hum\" ][ j ,:,:] <= data [ \"root_tank_capacity_previous_season\" ][ j ,:,:]) #! we replace humPrec by hum with indice j-1 #// condition_3 = (data[\"hum\"][j,:,:] < data[\"humPrec\"][j,:,:]) condition_3 = ( data [ \"hum\" ][ j ,:,:] < data [ \"humPrec\" ][ j ,:,:]) return condition_1 , condition_2 , condition_3 def update_total_tank_stock_step_2 ( j , data ): \"\"\" This function performs the second update of total_tank_stock/stTot/stRu in the reservoir filling wrapper function. It will increase the total_tank_stock depending on the variation of transpirable water and height of humectation front. test image markdown ![Drag Racing](Dragster.jpg) In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day, then total_tank_stock takes delta_total_tank_stock as value. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we increase the value of total_tank_stock by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock will remain unchanged, and if the root tank is full, total_tank_stock will be increased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) #! renaming stTot to total_tank_stock #// data[\"stTot\"][j:,:,:] = np.where( data [ \"total_tank_stock\" ][ j :,:,:] = np . where ( condition_1 , np . where ( #! condition_2 , #! we replace stRurPrec with stRur at indice j-1 #! renaming stRur to root_tank_stock #! renaming stTot to total_tank_stock #! renaming stRuVar with delta_total_tank_stock #// data[\"stTot\"][j,:,:] + (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:] + ( data [ \"delta_total_tank_stock\" ][ j ,:,:] - data [ \"hum\" ][ j ,:,:]) * data [ \"stRurPrec\" ][ j ,:,:], np . where ( condition_3 , #! renaming stRuVar with delta_total_tank_stock #//data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:], #! renaming stTot to total_tank_stock #// data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:], ), ), #! renaming stTot to total_tank_stock #// data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:], ) return data def update_stRuPrec ( j , data ): \"\"\" This function performs the update of total_tank_stock_previous_value/stRuPrec in the reservoir filling wrapper function. It will decrease the total_tank_stock_previous_value depending on the variation of transpirable water and height of humectation front. test image markdown ![Drag Racing](Dragster.jpg) In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day (condition 3 passed), then total_tank_stock_previous_value equals 0. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock_previous_value is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we decrease the value of total_tank_stock_previous_value by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock_previous_value will remain unchanged, and if the root tank is full, total_tank_stock_previous_value will be decreased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # group 32 #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"][j:,:,:] = np.where( data [ \"total_tank_stock_previous_value\" ][ j :,:,:] = np . where ( condition_1 , np . where ( condition_2 , #! replacing stRurPrec with ratio formula #! renaming stRuVar with delta_total_tank_stock #! renaming stRuPrec with total_tank_stock_previous_value #//np.maximum(0, data[\"stRuPrec\"][j,:,:] - (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:]), np . maximum ( 0 , data [ \"total_tank_stock_previous_value\" ][ j ,:,:] - ( data [ \"delta_total_tank_stock\" ][ j ,:,:] - data [ \"hum\" ][ j ,:,:]) * data [ \"stRurPrec\" ][ j ,:,:]), np . where ( condition_3 , 0 , #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j ,:,:], ), ), #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j ,:,:], ) return data def update_delta_total_tank_stock_step_2 ( j , data ): \"\"\" Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # groupe 33 #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j:,:,:] = np.where( data [ \"delta_total_tank_stock\" ][ j :,:,:] = np . where ( condition_1 , np . where ( condition_2 , #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j,:,:] + (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:] + ( data [ \"delta_total_tank_stock\" ][ j ,:,:] - data [ \"hum\" ][ j ,:,:]) * data [ \"stRurPrec\" ][ j ,:,:], np . where ( condition_3 , #! renaming stRuVar with delta_total_tank_stock #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuVar\"][j,:,:] + data[\"stRuPrec\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:] + data [ \"total_tank_stock_previous_value\" ][ j ,:,:], #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:], ), ), #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:], ) return data def update_hum ( j , data ): \"\"\" This function updates the depth to humectation front (hum) to be the maximum value between the depth to humectation front (hum) and delta_total_tank_stock (that is to say depth of humectation front can only increase), bounded by total_tank_capacity (that is to say humectation front can not go deep indefinitely). Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 34 #! renaming stRuVar with delta_total_tank_stock #// data[\"hum\"][j:,:,:] = np.maximum(data[\"stRuVar\"][j,:,:], data[\"hum\"][j,:,:])#[...,np.newaxis] data [ \"hum\" ][ j :,:,:] = np . maximum ( data [ \"delta_total_tank_stock\" ][ j ,:,:], data [ \"hum\" ][ j ,:,:]) # groupe 35 #! renaming stRuMax to total_tank_capacity #// data[\"hum\"][j:,:,:] = np.minimum(data[\"stRuMax\"][j,:,:], data[\"hum\"][j,:,:])#[...,np.newaxis] data [ \"hum\" ][ j :,:,:] = np . minimum ( data [ \"total_tank_capacity\" ][ j ,:,:], data [ \"hum\" ][ j ,:,:]) return data def condition_total_tank_overflow ( j , data ): \"\"\"_summary_ Returns: _type_: _description_ \"\"\" condition = ( data [ \"total_tank_stock\" ][ j ,:,:] > data [ \"total_tank_capacity\" ][ j ,:,:]) return condition def update_dr ( j , data ): \"\"\" This function estimates the daily drainage (dr). When total tank overflows, it computes drainage from the differences between the total_tank_stock (that is to say the total and total_tank_capacity. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// condition = (data[\"stTot\"][j,:,:] > data[\"stRuMax\"][j,:,:]) condition = condition_total_tank_overflow ( j , data ) # groupe 36 # essais stTot data [ \"dr\" ][ j ,:,:] = np . where ( condition , #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// data[\"stRu\"][j,:,:] - data[\"stRuMax\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"total_tank_capacity\" ][ j ,:,:], 0 , ) return data def update_total_tank_stock_step_3 ( j , data ): \"\"\" This function updates the total tank stock where these is overflow occuring. When capacity of total tank is exceeded, it corrects the stock value with maximum capacity of total tank. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// condition = (data[\"stTot\"][j,:,:] > data[\"stRuMax\"][j,:,:]) condition = condition_total_tank_overflow ( j , data ) # groupe 37 # essais stTot #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// data[\"stRu\"][j,:,:] = np.where( #// data[\"stTot\"][j:,:,:] = np.where( data [ \"total_tank_stock\" ][ j :,:,:] = np . where ( condition , #// data[\"stRuMax\"][j,:,:], data [ \"total_tank_capacity\" ][ j ,:,:], # data[\"stRu\"][j,:,:], #// data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:], ) #[...,np.newaxis] return data def update_hum_step_2 ( j , data ): \"\"\" We update the depth to humectation front (hum) again, to reflect eventual changes in total_tank_stock values. ? we could have placed the previous hum update function here Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 38 # // avant modif 10/06/2015 # data[\"hum\"][j:,:,:] = np.maximum(data[\"hum\"][j,:,:], data[\"stRu\"][j,:,:]) # essais stTot #! renaming stTot to total_tank_stock #// data[\"hum\"][j:,:,:] = np.maximum(data[\"hum\"][j,:,:], data[\"stTot\"][j,:,:])[...,np.newaxis] data [ \"hum\" ][ j :,:,:] = np . maximum ( data [ \"hum\" ][ j ,:,:], data [ \"total_tank_stock\" ][ j ,:,:]) #[...,np.newaxis] #! en conflit avec le calcul pr\u00e9c\u00e9dent de hum return data def update_root_tank_stock_step_2 ( j , data ): \"\"\" Finally, we update root tank stock (root_tank_stock) with the computed values First we increment root_tank_stock with transpirable water (eauTranspi), within the limits of root_tank_capacity. Then, we limit the value of root_tank_stock within total_tank_stock Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 39 # Rempli res racines #! renaming stRur to root_tank_stock #! renaming stRurMax to root_tank_capacity #// data[\"stRur\"][j:,:,:] = np.minimum(data[\"stRur\"][j,:,:] + data[\"eauTranspi\"][j,:,:], data[\"stRurMax\"][j,:,:])[...,np.newaxis] data [ \"root_tank_stock\" ][ j :,:,:] = np . minimum ( data [ \"root_tank_stock\" ][ j ,:,:] + data [ \"eauTranspi\" ][ j ,:,:], data [ \"root_tank_capacity\" ][ j ,:,:]) #[...,np.newaxis] # groupe 40 # essais stTot #! renaming stRur to root_tank_stock #! renaming stTot to total_tank_stock #// data[\"stRur\"][j,:,:] = np.minimum(data[\"stRur\"][j,:,:], data[\"stRu\"][j,:,:]) data [ \"root_tank_stock\" ][ j :,:,:] = np . minimum ( data [ \"root_tank_stock\" ][ j ,:,:], data [ \"total_tank_stock\" ][ j ,:,:]) #[...,np.newaxis] return data def rempliRes ( j , data ): \"\"\" Translated from the procedure rempliRes, of the original Pascal codes bileau.pas Main hypotheses : - the water dynamics is represented by a filling from the top and an evolution of the reservoirs sizes when the filling is above the maximum quantity of the current size (humectation front). - when the maximum size is reached by filling, it is considered as drainage. - inside a reservoir, water is distributed homogeneously (may be considered valid up to 2m depth, according to CB, from other sources). 3 reservoirs are represented: 1) a global reservoir, evolving in depth according to the humectation front 2) a surface reservoir (fixed size) where evaporation and a part of the transpiration occurs when roots are present 3) a root reservoir, evolving according to the root front (when roots are present) REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks Notes from CB, 10/06/2015 : prise en compte de stock d'eau r\u00e9silient pour les simulation continues Hypoth\u00e8se de la MAJ des stock en fn de l'eau r\ufffdsiliente de l'ann\ufffde pr\ufffdc\ufffddente dans le cas des simulations pluri annuelle en continue (NbAn = 1): A la r\ufffdcolte on recup\ufffdre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec) et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien. On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf) Si le StRu avec l'apport d'eau devinet sup au Hum alors on tient compte dans cette augmentation du stock r\ufffdsilient avec deux cas possible : Si StRu est < \ufffd stRurMaxprec alors on ajoute l'eau r\ufffdsiliente contenue dans l'ancienne zone racinaire en fn de la diff\ufffdrence de stock Sinon on a de l'eau r\ufffdsiliente au maximum de la CC jusqu'\ufffd l'ancienne HumPrec, on rempli alors StRu de la diff\ufffdrence etre ces deux valeurs puis on fait la MAJ des Dr, StRur, Hum etc... \"\"\" # section 1 : updating the end_of_cycle memory variables data = update_humPrec_for_end_of_cycle ( j , data ) data = update_hum_for_end_of_cycle ( j , data ) data = update_stRurMaxPrec_for_end_of_cycle ( j , data ) data = update_stRurPrec_for_end_of_cycle ( j , data ) data = update_stRuPrec_for_end_of_cycle ( j , data ) data = reset_total_tank_capacity ( j , data ) # verif ok # # filling the surface tank with available water data = update_surface_tank_stock ( j , data ) # verif ok # # estimates transpirable water data = estimate_transpirable_water ( j , data ) # verif ok # # increments total tank stock with transpirable water # # (meaning that total tank stock may represent a transpirable water tank) data = update_total_tank_stock ( j , data ) # verif ok # # estimating positive delta between total_root_tank and stRuPrec data = update_delta_total_tank_stock ( j , data ) # verif ok # # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged data = update_total_tank_stock_step_2 ( j , data ) # verif ok # # then total_tank_stock_previous_value can 1) take 0 or 2) be unchanged data = update_stRuPrec ( j , data ) #???? # # delta_total_tank_stock can 1) be incremented of total_tank_stock_previous_value or 2) be unchanged data = update_delta_total_tank_stock_step_2 ( j , data ) # # # here, in case 1, In this function, if the variation of transpirable water # # (delta_total_tank_stock) increases above the depth of humectation front # # (hum), if the depth of humectation front (hum) is above the # # root_tank_capacity_previous_season (condition 1 passed, and 2 failed, # # which should be the case for most of the simulations that will be # # single-season), and if the depth of humectation front (hum) has decreased # # since the previous day (condition 3 passed), then total_tank_stock takes the value of # # delta_total_tank_stock, total_tank_stock_previous_value equals 0, and # # delta_total_tank_stock is incremented by total_tank_stock_previous_value. # # # # in case 2, nothing happens. # # update_hum manages increase in hum data = update_hum ( j , data ) # # in case of overflowing... # # calculating drainage data = update_dr ( j , data ) # # limiting the total_tank_stock to the total_tank_capacity (when overflowing) data = update_total_tank_stock_step_3 ( j , data ) # # update again hum value, but we could merge functions with update_hum data = update_hum_step_2 ( j , data ) # # filling root_tank_stock with transpirable water, within the limits of total_tank_stock data = update_root_tank_stock_step_2 ( j , data ) return data ######################################################################################## def estimate_fesw ( j , data ): \"\"\" This function estimates the fraction of evaporable soil water (fesw, mm). fesw is defined as the ratio of water stock in the surface tank over 110% of the surface tank capacity. It is adapted from the EvalFESW procedure, from bileau.pas and bhytypeFAO.pas files from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! renaming stRuSurf to surface_tank_stock #! renaming ruSurf with surface_tank_capacity #// data[\"fesw\"][j,:,:] = data[\"stRuSurf\"][j,:,:] / (data[\"ruSurf\"][j,:,:] + data[\"ruSurf\"][j,:,:] / 10) data [ \"fesw\" ][ j ,:,:] = data [ \"surface_tank_stock\" ][ j ,:,:] / ( data [ \"surface_tank_capacity\" ] + 0.1 * data [ \"surface_tank_capacity\" ]) return data def estimate_kce ( j , data , paramITK ): \"\"\" This function estimates the coefficient of evaporation from the soil (kce). This approach takes into consideration three factors acting on limitation of kce : 1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover 2) Mulch - permanent covering effect : we consider a value of 1.0 for no covering, and 0.0 is full covering with plastic sheet ; this mulch parameter has been used in previous versions of the model where evolution of mulch biomass was not explicitely taken into consideration, can be used in the case of crops with self-mulching phenomena, where a standard mulch parameter value of 0.7 can be applied. 3) Mulch - evolutive covering effect BiomMc : biomass of mulch This function has been adapted from EvalKceMC procedure, bileau.pas and exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like it has been adapted from the dual crop coefficient from the FAO56 paper. But this is still to confirm on a point of view of the history of the model. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"kce\" ][ j ,:,:] = data [ \"ltr\" ][ j ,:,:] * paramITK [ \"mulch\" ] / 100 * \\ np . exp ( - paramITK [ \"coefMc\" ] * paramITK [ \"surfMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 1000 ) return data def estimate_soil_potential_evaporation ( j , data ): \"\"\" This function computes estimation of potential soil evaporation (mm, evapPot). It performs its computations solely from the evaporation forcing driven by climatic demand, limited by the coefficient of evaporation from the soil (kce). Note : difference in humectation of the top and bottom tanks is not taken into consideration in this approach. The This function has been adapted from DemandeSol procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 44 data [ \"evapPot\" ][ j ,:,:] = data [ \"ET0\" ][ j ,:,:] * data [ \"kce\" ][ j ,:,:] return data def estimate_soil_evaporation ( j , data ): \"\"\" This function computes estimation of soil evaporation (mm, evap). It uses the potential soil evaporation (evapPot) and the fraction of evaporable soil water (fesw), bounded by the surface tank stock. It has been adapted from the EvapRuSurf procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! replacing stRuSurf by surface_tank_stock #// data[\"evap\"][j:,:,:] = np.minimum(data[\"evapPot\"][j,:,:] * data[\"fesw\"][j,:,:]**2, data[\"stRuSurf\"][j,:,:])[...,np.newaxis] data [ \"evap\" ][ j :,:,:] = np . minimum ( data [ \"evapPot\" ][ j ,:,:] * data [ \"fesw\" ][ j ,:,:] ** 2 , data [ \"surface_tank_stock\" ][ j ,:,:] ) return data def estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ): \"\"\" This function calculates the fraction of evaporable water from the mulch (FEMcW). If the mulch water stock is greater than 0, then we compute FEMcW, which we consider to be equal to the filling ratio of the mulch water capacity. We then update the mulch water stock by removing the water height equivalent to the climate forcing demand, modulated by FEMcW and the plant cover (ltr). This function is adapted from the procedure EvapMC, from bileau.pas and exmodules 2.pas file from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 45 data [ \"FEMcW\" ][ j ,:,:] = np . where ( #! replacing stockMc with mulch_water_stock #// data[\"stockMc\"][j,:,:] > 0, data [ \"mulch_water_stock\" ][ j ,:,:] > 0 , #! inverting the fraction to get stock over capacity, and not the other way round #// (paramITK[\"humSatMc\"] * data[\"biomMc\"][j,:,:] * 0.001) / data[\"stockMc\"][j,:,:], data [ \"mulch_water_stock\" ][ j ,:,:] / ( paramITK [ \"humSatMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 1000 ), data [ \"FEMcW\" ][ j ,:,:], ) # group 46 #! replacing stockMc with mulch_water_stock #// data[\"stockMc\"][j:,:,:] = np.maximum( data [ \"mulch_water_stock\" ][ j :,:,:] = np . maximum ( 0 , #! removing the power of 2 in the equation #// data[\"stockMc\"][j,:,:] - data[\"ltr\"][j,:,:] * data[\"ET0\"][j,:,:] * data[\"FEMcW\"][j,:,:]**2, data [ \"mulch_water_stock\" ][ j ,:,:] - ( data [ \"ltr\" ][ j ,:,:] * data [ \"ET0\" ][ j ,:,:] * data [ \"FEMcW\" ][ j ,:,:] ** 2 ), ) return data def estimate_ftsw ( j , data ): \"\"\" This function estimates the fraction of evaporable soil water (fesw) from the root reservoir. It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 & 2.pas, risocas.pas, riz.pas files from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"ftsw\" ][ j :,:,:] = np . where ( #! renaming stRurMax to root_tank_capacity #// data[\"stRurMax\"][j,:,:] > 0, data [ \"root_tank_capacity\" ][ j ,:,:] > 0 , #! renaming stRur to root_tank_stock #! renaming stRurMax to root_tank_capacity #// data[\"stRur\"][j,:,:] / data[\"stRurMax\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:] / data [ \"root_tank_capacity\" ][ j ,:,:], 0 , ) return data def estimate_potential_plant_transpiration ( j , data ): \"\"\" This function computes the potential transpiration from the plant. Computation is based on the climate forcing (ET0), as well as the kcp coefficient. This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and exmodules 1 & 2.pas files from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ggroup 51 data [ \"trPot\" ][ j ,:,:] = ( data [ \"kcp\" ][ j ,:,:] * data [ \"ET0\" ][ j ,:,:]) return data def estimate_kcTot ( j , data ): \"\"\" This function computes the total kc coefficient. Computation is based on the kcp (transpiration coefficient) and kce (evaporation from the soil) coefficients. Where the crop coefficient is 0 (meaning that there was no emergence yet), kcTot takes the value of kce. This function is based on the EvalKcTot procedure, from the bileau.pas and exmodules 1 & 2.pas files, from the original FORTRAN code. #! Note : code has been modified to match the original SARRA-H behavior. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # added a condition on 19/08/22 to match SARRA-H original behavior data [ \"kcTot\" ][ j ,:,:] = np . where ( data [ \"kcp\" ][ j ,:,:] == 0.0 , data [ \"kce\" ][ j ,:,:], data [ \"kce\" ][ j ,:,:] + data [ \"kcp\" ][ j ,:,:], ) return data def estimate_pFact ( j , data , paramVariete ): \"\"\"_summary_ This function computes the pFactor, which is a bound coefficient used in the computation of cstr from ftsw. This coefficient delimits the portion of the FTSW below which water stress starts to influence the transpiration. FAO reference for critical FTSW value for transpiration response (0 = stomata respond immediately if FTSW<1; 0.5 for most of the crops) pFact is bounded in [0.1, 0.8]. For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 53 data [ \"pFact\" ][ j :,:,:] = paramVariete [ \"PFactor\" ] + \\ 0.04 * ( 5 - np . maximum ( data [ \"kcp\" ][ j ,:,:], 1 ) * data [ \"ET0\" ][ j ,:,:]) # group 54 data [ \"pFact\" ][ j :,:,:] = np . minimum ( np . maximum ( 0.1 , data [ \"pFact\" ][ j ,:,:], ), 0.8 , ) return data def estimate_cstr ( j , data ): \"\"\" This function computes the water stress coefficient cstr. It uses ftsw and pFact. cstr is bounded in [0, 1]. This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #group 55 data [ \"cstr\" ][ j :,:,:] = np . minimum (( data [ \"ftsw\" ][ j ,:,:] / ( 1 - data [ \"pFact\" ][ j ,:,:])), 1 ) # group 56 data [ \"cstr\" ][ j :,:,:] = np . maximum ( 0 , data [ \"cstr\" ][ j ,:,:]) return data def estimate_plant_transpiration ( j , data ): \"\"\" This function computes the transpiration from the plant. This function is based on the EvalTranspi procedure, from bileau.pas, bhytypeFAO.pas, exmodules 1 & 2.pas, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 58 data [ \"tr\" ][ j :,:,:] = ( data [ \"trPot\" ][ j ,:,:] * data [ \"cstr\" ][ j ,:,:]) return data def compute_evapotranspiration ( j , data , paramITK , paramVariete ): data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) return data def estimate_transpirable_surface_water ( j , data ): \"\"\" This function estimates the transpirable surface water. It removes 1/10th of surface tank capacity as water is condidered as bound. This function is based on the ConsoResSep procedure, from bileau.pas, exmodules 1 & 2.pas files, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 59 #! replacing stRuSurf by surface_tank_stock #! renaming ruSurf with surface_tank_capacity #// data[\"trSurf\"][j:,:,:] = np.maximum(0, data[\"stRuSurf\"][j,:,:] - data[\"ruSurf\"][j,:,:] / 10)[...,np.newaxis] data [ \"trSurf\" ][ j :,:,:] = np . maximum ( 0 , data [ \"surface_tank_stock\" ][ j ,:,:] - data [ \"surface_tank_capacity\" ] * 0.1 , ) return data def apply_evaporation_on_surface_tank_stock ( j , data ): # qte d'eau evapore a consommer sur le reservoir de surface # group 60 #! replacing stRuSurf by surface_tank_stock #// data[\"stRuSurf\"][j:,:,:] = np.maximum(0, data[\"stRuSurf\"][j,:,:] - data[\"evap\"][j,:,:])[...,np.newaxis] data [ \"surface_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"surface_tank_stock\" ][ j ,:,:] - data [ \"evap\" ][ j ,:,:]) return data def estimate_water_consumption_from_root_tank_stock ( j , data ): \"\"\" This function estimates consoRur, which is the water to be consumed from the root tank stock. If soil evaporation (evap) is higher than transpirable surface water (trSurf), then consumption from root tank stock equals trSurf. Else, it equals evap. #? how to interpret this ? Args: j (_type_): _description_ data (_type_): _description_ \"\"\" data [ \"consoRur\" ][ j :,:,:] = np . where ( data [ \"evap\" ][ j ,:,:] > data [ \"trSurf\" ][ j ,:,:], data [ \"trSurf\" ][ j ,:,:], data [ \"evap\" ][ j ,:,:], ) return data def update_total_tank_stock_with_water_consumption ( j , data ): \"\"\" This function updates the total tank stock by subtracting the lower water consumption value from estimate_water_consumption_from_root_tank_stock Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 62 #! renaming stTot to total_tank_stock #// data[\"stTot\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"consoRur\"][j,:,:])[...,np.newaxis] data [ \"total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"consoRur\" ][ j ,:,:]) #[...,np.newaxis] return data def update_water_consumption_according_to_rooting ( j , data ): \"\"\" This function updates the water consumption consoRur according to rooting depth. If the root tank capacity is lower than the surface tank capacity, meaning than the roots did not dive into the deep tank yet, then the water consumption is updated to equal the evaporation at the prorata of the exploration of surface tank by the roots. Else, consoRur keeps it value, which was previously computed by estimate_water_consumption_from_root_tank_stock. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # fraction d'eau evapore sur la part transpirable qd les racines sont moins # profondes que le reservoir de surface, mise a jour des stocks transpirables # group 63 data [ \"consoRur\" ][ j :,:,:] = np . where ( #! renaming stRurMax with root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// data[\"stRurMax\"][j,:,:] < data[\"ruSurf\"][j,:,:], data [ \"root_tank_capacity\" ][ j :,:,:] < data [ \"surface_tank_capacity\" ], #! renaming stRur to root_tank_stock #! renaming ruSurf with surface_tank_capacity #// data[\"evap\"][j,:,:] * data[\"stRur\"][j,:,:] / data[\"ruSurf\"][j,:,:], data [ \"evap\" ][ j ,:,:] * data [ \"root_tank_stock\" ][ j ,:,:] / data [ \"surface_tank_capacity\" ], data [ \"consoRur\" ][ j ,:,:], ) return data def update_root_tank_stock_with_water_consumption ( j , data ): \"\"\" This function updates root tank stock according to water consumption. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 64 #! renaming stRur to root_tank_stock #// data[\"stRur\"][j:,:,:] = np.maximum(0, data[\"stRur\"][j,:,:] - data[\"consoRur\"][j,:,:])#[...,np.newaxis] data [ \"root_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"root_tank_stock\" ][ j ,:,:] - data [ \"consoRur\" ][ j ,:,:]) return data def update_plant_transpiration ( j , data ): \"\"\" reajustement de la qte transpirable considerant que l'evap a eu lieu avant mise a jour des stocks transpirables if plant transpiration is higher than the root tank stock, then plant transpiration is updated to be equal to the difference between the root tank stock and the plant transpiration. Else, its value is unmodified. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 65 data [ \"tr\" ][ j :,:,:] = np . where ( #! renaming stRur to root_tank_stock #// data[\"tr\"][j,:,:] > data[\"stRur\"][j,:,:], data [ \"tr\" ][ j ,:,:] > data [ \"root_tank_stock\" ][ j ,:,:], #// np.maximum(data[\"stRur\"][j,:,:] - data[\"tr\"][j,:,:], 0), np . maximum ( data [ \"root_tank_stock\" ][ j ,:,:] - data [ \"tr\" ][ j ,:,:], 0 ), data [ \"tr\" ][ j ,:,:], ) return data def update_surface_tank_stock_according_to_transpiration ( j , data ): \"\"\" This function updates the surface tank stock to reflect plant transpiration. if the root tank stock is above 0, then surface tank stock is updated by subtracting the plant transpiration modulated by the ratio between the transpirable water and the root tank stock. That is to say, the more transpirable water is close to the root tank stock, the more of transpirated water by plant will be removed from surface tank stock. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 66 #! renaming stRuSurf with surface_tank_stock #// data[\"stRuSurf\"][j:,:,:] = np.where( data [ \"surface_tank_stock\" ][ j :,:,:] = np . where ( #! renaming stRur to surface_tank_stock #// data[\"stRur\"][j,:,:] > 0, data [ \"root_tank_stock\" ][ j ,:,:] > 0 , #// np.maximum(data[\"stRuSurf\"][j,:,:] - (data[\"tr\"][j,:,:] * np.minimum(data[\"trSurf\"][j,:,:]/data[\"stRur\"][j,:,:], 1)), 0), #! renaming stRuSurf with surface_tank_stock #// np.maximum(data[\"stRuSurf\"][j,:,:] - (data[\"tr\"][j,:,:] * np.minimum(data[\"trSurf\"][j,:,:]/data[\"root_tank_stock\"][j,:,:], 1)), 0), np . maximum ( data [ \"surface_tank_stock\" ][ j ,:,:] - \\ ( data [ \"tr\" ][ j ,:,:] * np . minimum ( data [ \"trSurf\" ][ j ,:,:] / data [ \"root_tank_stock\" ][ j ,:,:], 1 )), 0 , ), #// data[\"stRuSurf\"][j,:,:], data [ \"surface_tank_stock\" ][ j ,:,:], ) return data def update_root_tank_stock_with_transpiration ( j , data ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 67 #! renaming stRur to root_tank_stock #// data[\"stRur\"][j:,:,:] = np.maximum(0, data[\"stRur\"][j,:,:] - data[\"tr\"][j,:,:])#[...,np.newaxis] data [ \"root_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"root_tank_stock\" ][ j ,:,:] - data [ \"tr\" ][ j ,:,:]) #[...,np.newaxis] return data def update_total_tank_stock_with_transpiration ( j , data ): # data[\"stRu\"][j:,:,:] = np.maximum(0, data[\"stRu\"][j,:,:] - data[\"tr\"][j,:,:]) # essais stTot # group 68 #! renaming stTot to total_tank_stock #// data[\"stTot\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"tr\"][j,:,:])#[...,np.newaxis] data [ \"total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"tr\" ][ j ,:,:]) #[...,np.newaxis] ## ok return data def update_etr_etm ( j , data ): # group 69 data [ \"etr\" ][ j :,:,:] = ( data [ \"tr\" ][ j ,:,:] + data [ \"evap\" ][ j ,:,:]) . copy () #[...,np.newaxis] # group 70 data [ \"etm\" ][ j :,:,:] = ( data [ \"trPot\" ][ j ,:,:] + data [ \"evapPot\" ][ j ,:,:]) . copy () #[...,np.newaxis] return data def ConsoResSep ( j , data ): \"\"\" d'apr\u00e8s bileau.pas group 71 Separation de tr et evap. Consommation de l'eau sur les reservoirs Hypothese : l'evaporation est le processus le plus rapide, retranche en premier sur le reservoir de surface. Comme reservoir de surface et reservoirs racinaires se chevauchent, il nous faut aussi calcule sur le reservoir ayant des racines la part deja extraite pour l'evaporation. Quand la profondeur des racines est inferieur au reservoir de surface on ne consomme en evaporation que la fraction correspondant a cette profondeur sur celle du reservoir de surface (consoRur). Les estimations d'evaporation et de transpirations sont effectues separemment, on peut ainsi avoir une consommation legerement superieure a l'eau disponible. On diminuera donc la transpiration en consequence. Modif : Pour les stock d'eau on tient compte de la partie rajoutee au reservoir de surface qui ne peut etre que evapore (air dry) // Parametres IN: stRurMax : mm RuSurf : mm evap : mm trPot : mm evaPot : mm INOUT : stRuSurf : mm tr : mm stRur : mm stRu : mm OUT: etr : mm etm : mm \"\"\" data = estimate_transpirable_surface_water ( j , data ) data = apply_evaporation_on_surface_tank_stock ( j , data ) data = estimate_water_consumption_from_root_tank_stock ( j , data ) data = update_total_tank_stock_with_water_consumption ( j , data ) data = update_water_consumption_according_to_rooting ( j , data ) data = update_root_tank_stock_with_water_consumption ( j , data ) data = update_plant_transpiration ( j , data ) data = update_surface_tank_stock_according_to_transpiration ( j , data ) data = update_root_tank_stock_with_transpiration ( j , data ) data = update_total_tank_stock_with_transpiration ( j , data ) data = update_etr_etm ( j , data ) return data Functions ConsoResSep def ConsoResSep ( j , data ) d'apr\u00e8s bileau.pas group 71 Separation de tr et evap. Consommation de l'eau sur les reservoirs Hypothese : l'evaporation est le processus le plus rapide, retranche en premier sur le reservoir de surface. Comme reservoir de surface et reservoirs racinaires se chevauchent, il nous faut aussi calcule sur le reservoir ayant des racines la part deja extraite pour l'evaporation. Quand la profondeur des racines est inferieur au reservoir de surface on ne consomme en evaporation que la fraction correspondant a cette profondeur sur celle du reservoir de surface (consoRur). Les estimations d'evaporation et de transpirations sont effectues separemment, on peut ainsi avoir une consommation legerement superieure a l'eau disponible. On diminuera donc la transpiration en consequence. Modif : Pour les stock d'eau on tient compte de la partie rajoutee au reservoir de surface qui ne peut etre que evapore (air dry) // Parametres IN: stRurMax : mm RuSurf : mm evap : mm trPot : mm evaPot : mm INOUT : stRuSurf : mm tr : mm stRur : mm stRu : mm OUT: etr : mm etm : mm View Source def ConsoResSep ( j , data ) : \"\"\" d ' apr\u00e8s bileau.pas group 71 Separation de tr et evap . Consommation de l ' eau sur les reservoirs Hypothese : l ' evaporation est le processus le plus rapide, retranche en premier sur le reservoir de surface . Comme reservoir de surface et reservoirs racinaires se chevauchent , il nous faut aussi calcule sur le reservoir ayant des racines la part deja extraite pour l ' evaporation. Quand la profondeur des racines est inferieur au reservoir de surface on ne consomme en evaporation que la fraction correspondant a cette profondeur sur celle du reservoir de surface ( consoRur ) . Les estimations d ' evaporation et de transpirations sont effectues separemment , on peut ainsi avoir une consommation legerement superieure a l ' eau disponible. On diminuera donc la transpiration en consequence. Modif : Pour les stock d ' eau on tient compte de la partie rajoutee au reservoir de surface qui ne peut etre que evapore ( air dry ) // Parametres IN : stRurMax : mm RuSurf : mm evap : mm trPot : mm evaPot : mm INOUT : stRuSurf : mm tr : mm stRur : mm stRu : mm OUT : etr : mm etm : mm \"\"\" data = estimate_transpirable_surface_water ( j , data ) data = apply_evaporation_on_surface_tank_stock ( j , data ) data = estimate_water_consumption_from_root_tank_stock ( j , data ) data = update_total_tank_stock_with_water_consumption ( j , data ) data = update_water_consumption_according_to_rooting ( j , data ) data = update_root_tank_stock_with_water_consumption ( j , data ) data = update_plant_transpiration ( j , data ) data = update_surface_tank_stock_according_to_transpiration ( j , data ) data = update_root_tank_stock_with_transpiration ( j , data ) data = update_total_tank_stock_with_transpiration ( j , data ) data = update_etr_etm ( j , data ) return data EvalIrrigPhase def EvalIrrigPhase ( j , data , paramITK ) Computes the irrigation state for a given day, including the size and filling of the irrigation tank and the irrigation demand. The computation of the irrigation state is based on the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). The water stock in the irrigation tank (stockIrr) and the maximum water capacity of the irrigation tank (ruIrr) are first calculated, with minimum boundaries determined by properties of the surface reservoir. The irrigation demand (irrigTotDay) is then computed. The irrigation tank stock and capacity are only computed to avoid issues with very shallow rooting, where the calculation of the filling of root_tank_capacity by root_tank_stock can be inappropriate and result in inadapted results for automatic irrigation. Note: In this irrigation management, the daily rainfall is not taken into account. Translated from the procedure EvalIrrigPhase, of the original Pascal codes bileau.pas and exmodules2.pas. In irrigAuto mode, this function computes the size and filling of the irrigation tank, and the irrigation demand, according to the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), and the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). It first calculates stockIrr, the water stock in the irrigation tank, and ruIrr, the maximum water capacity of irrigation tank. Both stockIrr and ruIrr are given minimum boundaries related to properties of the surface reservoir. Then, it calculates the irrigation demand, irrigTotDay. irrigation_tank_stock and irrigation_tank_capacity are only computed in order to avoid issues with very shallow rooting, where calculation of filling of root_tank_capacity by root_tank_stock can be inappropriate and lead to inadapted results for automatic irrigation Notes from CB, 2014 : Modification due \u00e0 la prise en compte effet Mulch Soit on a une irrigation observ\u00e9e, soit on calcul la dose d'irrigation Elle est calcul\u00e9e en fonction d'un seuil d'humidit\u00e9 (IrrigAutoTarget) et de possibilit\u00e9 technique ou choix (MaxIrrig, Precision) Dans cette gestion d'irrigation la pluie du jour n'est pas prise en compte N.B.: here, precision is not taken into account anymore Parameters: Name Type Description Default j int Index of the day for which the irrigation state is being computed. None data xarray.Dataset The input data, including the arrays for irrigation and correctedIrrigation. None paramITK dict The parameters for the ITK model. None Returns: Type Description xarray.Dataset The updated data, including the computed values for the irrigation state. View Source def EvalIrrigPhase ( j , data , paramITK ) : \"\"\" Computes the irrigation state for a given day , including the size and filling of the irrigation tank and the irrigation demand . The computation of the irrigation state is based on the irrigation target ( irrigAutoTarget ) , the maximum irrigation capacity ( maxIrrig ) , the size and filling of the root zone ( stRurMax , stRur ) and the surface reservoir ( stRuSurf , ruSurf ) . The water stock in the irrigation tank ( stockIrr ) and the maximum water capacity of the irrigation tank ( ruIrr ) are first calculated , with minimum boundaries determined by properties of the surface reservoir . The irrigation demand ( irrigTotDay ) is then computed . The irrigation tank stock and capacity are only computed to avoid issues with very shallow rooting , where the calculation of the filling of root_tank_capacity by root_tank_stock can be inappropriate and result in inadapted results for automatic irrigation . Note : In this irrigation management , the daily rainfall is not taken into account . Translated from the procedure EvalIrrigPhase , of the original Pascal codes bileau . pas and exmodules2 . pas . In irrigAuto mode , this function computes the size and filling of the irrigation tank , and the irrigation demand , according to the irrigation target ( irrigAutoTarget ) , the maximum irrigation capacity ( maxIrrig ) , and the size and filling of the root zone ( stRurMax , stRur ) and the surface reservoir ( stRuSurf , ruSurf ) . It first calculates stockIrr , the water stock in the irrigation tank , and ruIrr , the maximum water capacity of irrigation tank . Both stockIrr and ruIrr are given minimum boundaries related to properties of the surface reservoir . Then , it calculates the irrigation demand , irrigTotDay . irrigation_tank_stock and irrigation_tank_capacity are only computed in order to avoid issues with very shallow rooting , where calculation of filling of root_tank_capacity by root_tank_stock can be inappropriate and lead to inadapted results for automatic irrigation Notes from CB , 2014 : Modification due \u00e0 la prise en compte effet Mulch Soit on a une irrigation observ \u00e9 e , soit on calcul la dose d ' irrigation Elle est calcul\u00e9e en fonction d ' un seuil d ' humidit \u00e9 ( IrrigAutoTarget ) et de possibilit \u00e9 technique ou choix ( MaxIrrig , Precision ) Dans cette gestion d ' irrigation la pluie du jour n ' est pas prise en compte N . B .: here , precision is not taken into account anymore Args : j ( int ) : Index of the day for which the irrigation state is being computed . data ( xarray . Dataset ) : The input data , including the arrays for irrigation and correctedIrrigation . paramITK ( dict ) : The parameters for the ITK model . Returns : xarray . Dataset : The updated data , including the computed values for the irrigation state . \"\"\" # First , we store initial irrigation value of the day in the # correctedIrrigation array # ! it does not seem definition and use of correctedIrrigation is useful # ! instead we will just use the already defined irrigation array # // data [ \" correctedIrrigation \" ][ j , :, :] = data [ \" irrigation \" ][ j , :, :]. copy ( deep = True ) data = update_irrigation_tank_stock ( j , data ) data = update_irrigation_tank_capacity ( j , data ) data = compute_daily_irrigation ( j , data , paramITK ) return data EvalRunOff def EvalRunOff ( j , data , paramTypeSol ) Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas, exmodules1.pas and exmodules2.pas Notes from CB, 2014 : On a regroup\u00e9 avant la pluie et l'irrigation (a cause de l'effet Mulch) si mulch on a enlev\u00e9 l'eau capt\u00e9e oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS Parameters: Name Type Description Default j type description None data type description None paramTypeSol type description None Returns: Type Description type description View Source def EvalRunOff ( j , data , paramTypeSol ) : \"\"\" Translated from the procedure PluieIrrig , of the original Pascal codes bileau . pas , exmodules1 . pas and exmodules2 . pas Notes from CB , 2014 : On a regroup\u00e9 avant la pluie et l ' irrigation ( a cause de l ' effet Mulch ) si mulch on a enlev\u00e9 l ' eau capt\u00e9e oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS Args: j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramTypeSol ( _type_ ) : _description_ Returns: _type_: _description_ \"\"\" data = estimate_runoff ( j , data ) data = update_available_water_after_runoff ( j , data ) return data EvolRurCstr2 def EvolRurCstr2 ( j , data , paramITK ) Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas Notes from CB, 10/06/2015 : Stress trop fort enracinement Trop d'effet de stress en tout d\u00e9but de croissance : 1) la plantule a des r\u00e9serves et favorise l'enracinement 2) dynamique sp\u00e9cifique sur le r\u00e9servoir de surface Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement est sup\u00e9rieur \u00e9 la profondeur du r\u00e9servoir de surface. Effet stres a un effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur la vitesse) La vitesse d'enracinement potentielle de la plante peut etre bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est convertie en quantite d'eau maximum equivalente IN: Vrac : mm (en mm/jour) : Vitesse racinaire journali\u00e8re \u00a7\u00a7 Daily root depth Hum : mm Quantit\u00e9 d'eau maximum jusqu'au front d'humectation \u00a7\u00a7 Maximum water capacity to humectation front StRuSurf : mm RU : mm/m RuSurf : mm/m INOUT: stRurMax : mm ==== ruRac stRur : mm ==== stockRac NB : on remet le nom de variables de CB plut\u00f4t que celles utilis\u00e9es par MC dans le code Java View Source def EvolRurCstr2 ( j , data , paramITK ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas Notes from CB, 10/06/2015 : Stress trop fort enracinement Trop d'effet de stress en tout d\u00e9but de croissance : 1) la plantule a des r\u00e9serves et favorise l'enracinement 2) dynamique sp\u00e9cifique sur le r\u00e9servoir de surface Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement est sup\u00e9rieur \u00e9 la profondeur du r\u00e9servoir de surface. Effet stres a un effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur la vitesse) La vitesse d'enracinement potentielle de la plante peut etre bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est convertie en quantite d'eau maximum equivalente IN: Vrac : mm (en mm/jour) : Vitesse racinaire journali\u00e8re \u00a7\u00a7 Daily root depth Hum : mm Quantit\u00e9 d'eau maximum jusqu'au front d'humectation \u00a7\u00a7 Maximum water capacity to humectation front StRuSurf : mm RU : mm/m RuSurf : mm/m INOUT: stRurMax : mm ==== ruRac stRur : mm ==== stockRac NB : on remet le nom de variables de CB plut\u00f4t que celles utilis\u00e9es par MC dans le code Java \"\"\" # ! dayvrac et deltarur reset \u00e0 chaque it\u00e9ration ; on traine donc le j sur les autres variables data = initialize_root_tank_capacity ( j , data , paramITK ) data = estimate_delta_root_tank_capacity ( j , data ) data = update_delta_root_tank_capacity ( j , data ) data = update_root_tank_capacity ( j , data ) data = update_root_tank_stock ( j , data ) return data InitPlotMc def InitPlotMc ( data , grid_width , grid_height , paramITK , paramTypeSol , duration ) Initializes variables related to crop residues boimass (mulch) in the data xarray dataset. This code has been adapted from the original InitPlotMc procedure, Bileau.pas code. Comments with tab indentation are from the original code. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. View Source def InitPlotMc ( data , grid_width , grid_height , paramITK , paramTypeSol , duration ): \"\"\" Initializes variables related to crop residues boimass (mulch) in the data xarray dataset. This code has been adapted from the original InitPlotMc procedure, Bileau.pas code. Comments with tab indentation are from the original code. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. \"\"\" # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] #// data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock #// data[\"stTot\"] = data[\"stockIniProf\"] #//data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ] . expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock #// data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] return data RempliMc def RempliMc ( j , data , paramITK ) Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas wrapper function, updates water_gathered_by_mulch, eauDispo, and mulch_water_stock For more details, it is advised to refer to the works of Eric Scopel (UR AIDA), and the PhD dissertation of Fernando Maceina. Notes from CB, 2014 : Hypotheses : A chaque pluie, on estime la quantit\u00e9 d'eau pour saturer le couvert. On la retire \u00e0 l'eauDispo (pluie + irrig). On calcule la capacit\u00e9 maximum de stockage fonction de la biomasse et du taux de saturation rapport\u00e9e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1 mm = 1 litre d'eau / m2 1 mm = 10 tonnes d'eau / hectare = 10 000 kg/ha La biomasse est en kg/ha pour se rapporter \u00e0 la quantit\u00e9 de pluie capt\u00e9e en mm Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha \u00e0 humSat 2.8 kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit\u00e9 \u00e0 capter est fonction du taux de couverture du sol calcul\u00e9 comme le LTR SurfMc est sp\u00e9cifi\u00e9 en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On retire alors les mm d'eau capt\u00e9es \u00e0 la pluie incidente. Le ruisselement est ensuite calcul\u00e9 avec l'effet de contrainte du mulch group 10 View Source def RempliMc ( j , data , paramITK ) : \"\"\" Translated from the procedure PluieIrrig , of the original Pascal codes bileau . pas and exmodules2 . pas wrapper function , updates water_gathered_by_mulch , eauDispo , and mulch_water_stock For more details , it is advised to refer to the works of Eric Scopel ( UR AIDA ) , and the PhD dissertation of Fernando Maceina . Notes from CB , 2014 : Hypotheses : A chaque pluie , on estime la quantit \u00e9 d ' eau pour saturer le couvert. On la retire \u00e0 l ' eauDispo (pluie + irrig). On calcule la capacit\u00e9 maximum de stockage fonction de la biomasse et du taux de saturation rapport \u00e9 e en mm ( humSatMc en kg H2O / kg de biomasse ) . La pluie est en mm : 1 mm = 1 litre d ' eau / m2 1 mm = 10 tonnes d ' eau / hectare = 10 000 kg/ha La biomasse est en kg / ha pour se rapporter \u00e0 la quantit \u00e9 de pluie capt \u00e9 e en mm Kg H2O / kg Kg / ha et kg / m2 on divise par 10 000 ( pour 3000 kg / ha \u00e0 humSat 2 . 8 kg H2O / kg on a un stockage max de 0 . 84 mm de pluie ! ? ) Cette capacit \u00e9 \u00e0 capter est fonction du taux de couverture du sol calcul \u00e9 comme le LTR SurfMc est sp \u00e9 cifi \u00e9 en ha / t ( 0 . 39 ) , on rapporte en ha / kg en divisant par 1000 On retire alors les mm d ' eau capt\u00e9es \u00e0 la pluie incidente. Le ruisselement est ensuite calcul \u00e9 avec l ' effet de contrainte du mulch group 10 \"\"\" data = estimate_water_captured_by_mulch ( j , data , paramITK ) data = update_available_water_after_mulch_filling ( j , data ) data = update_mulch_water_stock ( j , data ) return data apply_evaporation_on_surface_tank_stock def apply_evaporation_on_surface_tank_stock ( j , data ) View Source def apply_evaporation_on_surface_tank_stock ( j , data ) : # qte d ' eau evapore a consommer sur le reservoir de surface # group 60 # ! replacing stRuSurf by surface_tank_stock # // data [ \" stRuSurf \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRuSurf \" ][ j ,:,:] - data [ \" evap \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" surface_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" surface_tank_stock \" ][ j ,:,:] - data [ \" evap \" ][ j ,:,:] ) return data calculate_total_water_availability def calculate_total_water_availability ( j , data ) Calculates the total water available for a day by adding the rainfall and the irrigation. The total water available is computed by adding the rainfall for the day, which is stored in the \"rain\" array, and the total daily irrigation, which is stored in the \"irrigTotDay\" array. This calculation is performed to allow for subsequent calculations of the mulch filling and runoff. The mulch layer is considered to be directly under the rainfall and irrigation, which is represented by the \"irrigTotDay\" value. Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas This function computes the total water available for the day, by summing the rain and the irrigation. Notes from CB, 2014 : Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig, ici irrigTotDay qui est l'irrigation observ\u00e9e ou calcul\u00e9e, d'o\u00f9 on regroupe les deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement. Parameters: Name Type Description Default j int The index of the current day. None data xarray.Dataset The data set containing information about the rainfall, irrigation, and water availability. None Returns: Type Description xarray.Dataset The data set with updated information about the total water availability for the current day. View Source def calculate_total_water_availability ( j , data ) : \"\"\" Calculates the total water available for a day by adding the rainfall and the irrigation . The total water available is computed by adding the rainfall for the day , which is stored in the \"rain\" array , and the total daily irrigation , which is stored in the \"irrigTotDay\" array . This calculation is performed to allow for subsequent calculations of the mulch filling and runoff . The mulch layer is considered to be directly under the rainfall and irrigation , which is represented by the \"irrigTotDay\" value . Translated from the procedure PluieIrrig , of the original Pascal codes bileau . pas and exmodules2 . pas This function computes the total water available for the day , by summing the rain and the irrigation . Notes from CB , 2014 : Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig , ici irrigTotDay qui est l ' irrigation observ\u00e9e ou calcul\u00e9e , d ' o\u00f9 on regroupe les deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement . Args: j ( int ) : The index of the current day . data ( xarray . Dataset ) : The data set containing information about the rainfall , irrigation , and water availability . Returns: xarray . Dataset: The data set with updated information about the total water availability for the current day . \"\"\" data [ \"eauDispo\" ][ j , : , : ] = data [ \"rain\" ][ j , : , : ] + data [ \"irrigTotDay\" ][ j , : , : ] return data compute_daily_irrigation def compute_daily_irrigation ( j , data , paramITK ) Computes the Total Daily Irrigation (mm) If we are in the automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between the current volume of water in the irrigation tank (irrigation_tank_stock) and the total capacity of the irrigation tank (irrigation_tank_capacity), bounded by a minimum of 0 and a maximum of maxIrrig. This computed value represents the amount of water to be added to the irrigation tank. If the above conditions are not met, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need (irrigation) with the previous irrigation history of the day (irrigTotDay). irrigTotDay : \"total irrigation of the day, both from the irrigation history and the estimated irrigation need\" (mm) // irrigation_total_day if we are in automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between irrigation_tank_stock and irrigation_tank_capacity (that is to say, 90% of the volume needed to fill the irrigation tank), bounded by a minimum of 0 and a maximum of maxIrrig. Else, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need with the irrigation history of the day. Parameters: Name Type Description Default j None An integer representing the current day. None data None A xarray dataset. None paramITK None A dictionary of parameters. None Returns: Type Description data A xarray dataset with the updated irrigationTotDay field. View Source def compute_daily_irrigation ( j , data , paramITK ) : \"\"\" Computes the Total Daily Irrigation ( mm ) If we are in the automatic irrigation mode , and between phases 0 and 6 , and if the filling of the irrigation tank is below the target filling value ( irrigAutoTarget , decimal percentage ) , we first compute 90 % of the difference between the current volume of water in the irrigation tank ( irrigation_tank_stock ) and the total capacity of the irrigation tank ( irrigation_tank_capacity ) , bounded by a minimum of 0 and a maximum of maxIrrig . This computed value represents the amount of water to be added to the irrigation tank . If the above conditions are not met , the computed value is 0 . Then , we calculate the total irrigation of the day by summing the estimated irrigation need ( irrigation ) with the previous irrigation history of the day ( irrigTotDay ) . irrigTotDay : \" total irrigation of the day, both from the irrigation history and the estimated irrigation need \" (mm) // irrigation_total_day if we are in automatic irrigation mode , and between phases 0 and 6 , and if the filling of the irrigation tank is below the target filling value ( irrigAutoTarget , decimal percentage ) , we first compute 90 % of the difference between irrigation_tank_stock and irrigation_tank_capacity ( that is to say , 90 % of the volume needed to fill the irrigation tank ) , bounded by a minimum of 0 and a maximum of maxIrrig . Else , the computed value is 0 . Then , we calculate the total irrigation of the day by summing the estimated irrigation need with the irrigation history of the day . Args : j : An integer representing the current day . data : A xarray dataset . paramITK : A dictionary of parameters . Returns : data : A xarray dataset with the updated irrigationTotDay field . \"\"\" # ! renaming stockIrr with irrigation_tank_stock # ! renaming ruIrr with irrigation_tank_capacity condition = ( data [ \" irrigAuto \" ][ j , :, :] == True ) & \\ ( data [ \" numPhase \" ][ j , :, :] > 0 ) & \\ ( data [ \" numPhase \" ][ j , :, :] < 6 ) & \\ ( data [ \" irrigation_tank_stock \" ][ j , :, :] / data [ \" irrigation_tank_capacity \" ][ j ,:,:] \\ < paramITK [ \" irrigAutoTarget \" ] ) # group 3 data [ \" irrigTotDay \" ][ j , :, :] = xr . where ( condition , np . minimum ( np . maximum ( 0 , # ! replacing correctedIrrigation by irrigation # ! renaming stockIrr with irrigation_tank_stock # ! renaming ruIrr with irrigation_tank_capacity # // (( data [ \" ruIrr \" ][ j , :, :] - data [ \" stockIrr \" ][ j , :, :] ) * 0 . 9 ) - data [ \" correctedIrrigation \" ][ j , :, :] ) , (( data [ \" irrigation_tank_capacity \" ][ j , :, :] - data [ \" irrigation_tank_stock \" ][ j , :, :] ) * 0 . 9 ) \\ - data [ \" irrigation \" ][ j , :, :] ) , paramITK [ \" maxIrrig \" ] ) , 0 , ) # group 4 data [ \" irrigTotDay \" ][ j , :, :] = ( # ! replacing correctedIrrigation by irrigation # // data [ \" correctedIrrigation \" ][ j , :, :] + data [ \" irrigTotDay \" ][ j , :, :] ) . copy () data [ \" irrigation \" ][ j , :, :] + data [ \" irrigTotDay \" ][ j , :, :] ) return data compute_evapotranspiration def compute_evapotranspiration ( j , data , paramITK , paramVariete ) View Source def compute_evapotranspiration ( j , data , paramITK , paramVariete ) : data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) return data condition_end_of_cycle def condition_end_of_cycle ( j , data ) Returns conditions needed to apply functions related to end of cycle. Returns: Type Description type description View Source def condition_end_of_cycle ( j , data ) : \"\"\" Returns conditions needed to apply functions related to end of cycle . Returns : _type_ : _description_ \"\"\" condition = ( data [ \" numPhase \" ][ j ,:,:] == 7 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 ) return condition condition_total_tank_overflow def condition_total_tank_overflow ( j , data ) summary Returns: Type Description type description View Source def condition_total_tank_overflow ( j , data ) : \"\"\" _summary_ Returns : _type_ : _description_ \"\"\" condition = ( data [ \" total_tank_stock \" ][ j ,:,:] > data [ \" total_tank_capacity \" ][ j ,:,:] ) return condition conditions_rempliRes def conditions_rempliRes ( j , data ) summary Returns: Type Description type description View Source def conditions_rempliRes ( j , data ) : \"\"\" _summary_ Returns : _type_ : _description_ \"\"\" # ! renaming stRuVar with delta_total_tank_stock # // condition_1 = ( data [ \" stRuVar \" ][ j ,:,:] > data [ \" hum \" ][ j ,:,:] ) condition_1 = ( data [ \" delta_total_tank_stock \" ][ j ,:,:] > data [ \" hum \" ][ j ,:,:] ) # ! renaming stRurMaxPrec to root_tank_capacity_previous_season # // condition_2 = ( data [ \" hum \" ][ j ,:,:] <= data [ \" stRurMaxPrec \" ][ j ,:,:] ) condition_2 = ( data [ \" hum \" ][ j ,:,:] <= data [ \" root_tank_capacity_previous_season \" ][ j ,:,:] ) # ! we replace humPrec by hum with indice j - 1 # // condition_3 = ( data [ \" hum \" ][ j ,:,:] < data [ \" humPrec \" ][ j ,:,:] ) condition_3 = ( data [ \" hum \" ][ j ,:,:] < data [ \" humPrec \" ][ j ,:,:] ) return condition_1 , condition_2 , condition_3 estimate_FEMcW_and_update_mulch_water_stock def estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) This function calculates the fraction of evaporable water from the mulch (FEMcW). If the mulch water stock is greater than 0, then we compute FEMcW, which we consider to be equal to the filling ratio of the mulch water capacity. We then update the mulch water stock by removing the water height equivalent to the climate forcing demand, modulated by FEMcW and the plant cover (ltr). This function is adapted from the procedure EvapMC, from bileau.pas and exmodules 2.pas file from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) : \"\"\" This function calculates the fraction of evaporable water from the mulch ( FEMcW ) . If the mulch water stock is greater than 0 , then we compute FEMcW , which we consider to be equal to the filling ratio of the mulch water capacity . We then update the mulch water stock by removing the water height equivalent to the climate forcing demand , modulated by FEMcW and the plant cover ( ltr ) . This function is adapted from the procedure EvapMC , from bileau . pas and exmodules 2 . pas file from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 45 data [ \" FEMcW \" ][ j ,:,:] = np . where ( # ! replacing stockMc with mulch_water_stock # // data [ \" stockMc \" ][ j ,:,:] > 0 , data [ \" mulch_water_stock \" ][ j ,:,:] > 0 , # ! inverting the fraction to get stock over capacity , and not the other way round # // ( paramITK [ \" humSatMc \" ] * data [ \" biomMc \" ][ j ,:,:] * 0 . 001 ) / data [ \" stockMc \" ][ j ,:,:], data [ \" mulch_water_stock \" ][ j ,:,:] / ( paramITK [ \" humSatMc \" ] * data [ \" biomMc \" ][ j ,:,:] / 1000 ) , data [ \" FEMcW \" ][ j ,:,:], ) # group 46 # ! replacing stockMc with mulch_water_stock # // data [ \" stockMc \" ][ j :,:,:] = np . maximum ( data [ \" mulch_water_stock \" ][ j :,:,:] = np . maximum ( 0 , # ! removing the power of 2 in the equation # // data [ \" stockMc \" ][ j ,:,:] - data [ \" ltr \" ][ j ,:,:] * data [ \" ET0 \" ][ j ,:,:] * data [ \" FEMcW \" ][ j ,:,:] ** 2 , data [ \" mulch_water_stock \" ][ j ,:,:] - ( data [ \" ltr \" ][ j ,:,:] * data [ \" ET0 \" ][ j ,:,:] * data [ \" FEMcW \" ][ j ,:,:] ** 2 ) , ) return data estimate_cstr def estimate_cstr ( j , data ) This function computes the water stress coefficient cstr. It uses ftsw and pFact. cstr is bounded in [0, 1]. This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_cstr ( j , data ) : \"\"\" This function computes the water stress coefficient cstr . It uses ftsw and pFact . cstr is bounded in [ 0 , 1 ]. This function is based on the CstrPFactor procedure , from bileau . pas , exmodules 1 & 2 . pas , risocas . pas files , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 55 data [ \" cstr \" ][ j :,:,:] = np . minimum (( data [ \" ftsw \" ][ j ,:,:] / ( 1 - data [ \" pFact \" ][ j ,:,:] )) , 1 ) # group 56 data [ \" cstr \" ][ j :,:,:] = np . maximum ( 0 , data [ \" cstr \" ][ j ,:,:] ) return data estimate_delta_root_tank_capacity def estimate_delta_root_tank_capacity ( j , data ) Updates daily root capacity variation (delta_root_tank_capacity, in mm water/day) based on the current phase of the plant, the daily root growth speed, and the drought stress coefficient. The daily root capacity variation is calculated as the product of soil water storage capacity (ru), the daily root growth speed (vRac), and a coefficient (cstr + 0.3). This coefficient is capped at 1.0. The daily root capacity variation is modulated by drought stress only when the root tank capacity is greater than the surface tank capacity and the current phase is strictly greater than 1 and at the day of phase change. If the root tank capacity is lower than the surface tank capacity or if the current phase is 1 or below or not at the day of phase change, the daily root capacity variation remains unchanged. The drought stress coefficient, cstr, measures the level of drought stress with 0 being full stress. The root growth speed is assumed to still occur during a drought stress as a matter of survival, with a certain level of tolerance given by the [0.3, 1] bound of the coefficient. Updating delta_root_tank_capacity / dayVrac (daily variation in water height accessible to roots, mm water/day) : At the day of phase change, for phases strictly above 1, and for which root_tank_capacity is greater than surface_tank_capacity, the variation of root tank capacity delta_root_tank_capacity is computed as the product of soil water storage capacity (ru, mm/m), the daily root growth speed (vRac, mm/day), and a coefficient, the latter being equal to the drought stress coefficient (cstr) plus 0.3, with a maximum bound of 1.0. That is to say, when the root_tank_capacity is greater than surface_tank_capacity, the root growth speed is modulated by drought stress. When root_tank_capacity is lower than surface_tank_capacity, the root growth speed is not modulated by drought stress. When we are not at the day of phase change, or if we are at phase of 1 and below, delta_root_change_capacity is unchanged. cstr is the drought stress coefficient, with a value of 0 meaning full stress. Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian BARON, this is based on the hypothesis that during a drought stress (cstr = 0), the plant will still grow roots as a matter of survival. Furthermore, using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr interval, there is no effect of drought stress on the root growth speed, allowing for a certain level of tolerance of the plant. Parameters: Name Type Description Default j int The current iteration step of the process. None data xarray.Dataset The input data containing relevant information. None Returns: Type Description xarray.Dataset The updated input data with the daily root capacity variation calculated and stored. View Source def estimate_delta_root_tank_capacity ( j , data ): \"\"\" Updates daily root capacity variation (delta_root_tank_capacity, in mm water/day) based on the current phase of the plant, the daily root growth speed, and the drought stress coefficient. The daily root capacity variation is calculated as the product of soil water storage capacity (ru), the daily root growth speed (vRac), and a coefficient (cstr + 0.3). This coefficient is capped at 1.0. The daily root capacity variation is modulated by drought stress only when the root tank capacity is greater than the surface tank capacity and the current phase is strictly greater than 1 and at the day of phase change. If the root tank capacity is lower than the surface tank capacity or if the current phase is 1 or below or not at the day of phase change, the daily root capacity variation remains unchanged. The drought stress coefficient, cstr, measures the level of drought stress with 0 being full stress. The root growth speed is assumed to still occur during a drought stress as a matter of survival, with a certain level of tolerance given by the [0.3, 1] bound of the coefficient. Updating delta_root_tank_capacity / dayVrac (daily variation in water height accessible to roots, mm water/day) : At the day of phase change, for phases strictly above 1, and for which root_tank_capacity is greater than surface_tank_capacity, the variation of root tank capacity delta_root_tank_capacity is computed as the product of soil water storage capacity (ru, mm/m), the daily root growth speed (vRac, mm/day), and a coefficient, the latter being equal to the drought stress coefficient (cstr) plus 0.3, with a maximum bound of 1.0. That is to say, when the root_tank_capacity is greater than surface_tank_capacity, the root growth speed is modulated by drought stress. When root_tank_capacity is lower than surface_tank_capacity, the root growth speed is not modulated by drought stress. When we are not at the day of phase change, or if we are at phase of 1 and below, delta_root_change_capacity is unchanged. cstr is the drought stress coefficient, with a value of 0 meaning full stress. Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian BARON, this is based on the hypothesis that during a drought stress (cstr = 0), the plant will still grow roots as a matter of survival. Furthermore, using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr interval, there is no effect of drought stress on the root growth speed, allowing for a certain level of tolerance of the plant. Args: j (int): The current iteration step of the process. data (xarray.Dataset): The input data containing relevant information. Returns: xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored. \"\"\" # group 15 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & \\ # // np.invert((data[\"numPhase\"][j,:,:] == 1) & (data[\"changePhase\"][j,:,:] == 1)) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) #! renaming dayVrac to delta_root_tank_capacity #// data[\"dayVrac\"][j,:,:] = np.where( data [ \"delta_root_tank_capacity\" ][ j ,:,:] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity #// (data[\"stRurMax\"][j,:,:] > data[\"ruSurf\"][j,:,:]), ( data [ \"root_tank_capacity\" ][ j ,:,:] > data [ \"surface_tank_capacity\" ]), ( data [ \"vRac\" ][ j ,:,:] * np . minimum ( data [ \"cstr\" ][ j ,:,:] + 0.3 , 1.0 )) / 1000 * data [ \"ru\" ], data [ \"vRac\" ][ j ,:,:] / 1000 * data [ \"ru\" ], ), #// data[\"dayVrac\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ) return data estimate_fesw def estimate_fesw ( j , data ) This function estimates the fraction of evaporable soil water (fesw, mm). fesw is defined as the ratio of water stock in the surface tank over 110% of the surface tank capacity. It is adapted from the EvalFESW procedure, from bileau.pas and bhytypeFAO.pas files from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_fesw ( j , data ) : \"\"\" This function estimates the fraction of evaporable soil water ( fesw , mm ) . fesw is defined as the ratio of water stock in the surface tank over 110 % of the surface tank capacity . It is adapted from the EvalFESW procedure , from bileau . pas and bhytypeFAO . pas files from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! renaming stRuSurf to surface_tank_stock # ! renaming ruSurf with surface_tank_capacity # // data [ \" fesw \" ][ j ,:,:] = data [ \" stRuSurf \" ][ j ,:,:] / ( data [ \" ruSurf \" ][ j ,:,:] + data [ \" ruSurf \" ][ j ,:,:] / 10 ) data [ \" fesw \" ][ j ,:,:] = data [ \" surface_tank_stock \" ][ j ,:,:] / ( data [ \" surface_tank_capacity \" ] + 0 . 1 * data [ \" surface_tank_capacity \" ] ) return data estimate_ftsw def estimate_ftsw ( j , data ) This function estimates the fraction of evaporable soil water (fesw) from the root reservoir. It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 & 2.pas, risocas.pas, riz.pas files from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_ftsw ( j , data ) : \"\"\" This function estimates the fraction of evaporable soil water ( fesw ) from the root reservoir . It is based on the EvalFTSW procedure , from the bileau . pas , exmodules 1 & 2 . pas , risocas . pas , riz . pas files from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" ftsw \" ][ j :,:,:] = np . where ( # ! renaming stRurMax to root_tank_capacity # // data [ \" stRurMax \" ][ j ,:,:] > 0 , data [ \" root_tank_capacity \" ][ j ,:,:] > 0 , # ! renaming stRur to root_tank_stock # ! renaming stRurMax to root_tank_capacity # // data [ \" stRur \" ][ j ,:,:] / data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_stock \" ][ j ,:,:] / data [ \" root_tank_capacity \" ][ j ,:,:], 0 , ) return data estimate_kcTot def estimate_kcTot ( j , data ) This function computes the total kc coefficient. Computation is based on the kcp (transpiration coefficient) and kce (evaporation from the soil) coefficients. Where the crop coefficient is 0 (meaning that there was no emergence yet), kcTot takes the value of kce. This function is based on the EvalKcTot procedure, from the bileau.pas and exmodules 1 & 2.pas files, from the original FORTRAN code. ! Note : code has been modified to match the original SARRA-H behavior. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_kcTot ( j , data ) : \"\"\" This function computes the total kc coefficient . Computation is based on the kcp ( transpiration coefficient ) and kce ( evaporation from the soil ) coefficients . Where the crop coefficient is 0 ( meaning that there was no emergence yet ) , kcTot takes the value of kce . This function is based on the EvalKcTot procedure , from the bileau . pas and exmodules 1 & 2 . pas files , from the original FORTRAN code . # ! Note : code has been modified to match the original SARRA - H behavior . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # added a condition on 19 / 08 / 22 to match SARRA - H original behavior data [ \" kcTot \" ][ j ,:,:] = np . where ( data [ \" kcp \" ][ j ,:,:] == 0 . 0 , data [ \" kce \" ][ j ,:,:], data [ \" kce \" ][ j ,:,:] + data [ \" kcp \" ][ j ,:,:], ) return data estimate_kce def estimate_kce ( j , data , paramITK ) This function estimates the coefficient of evaporation from the soil (kce). This approach takes into consideration three factors acting on limitation of kce : 1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover 2) Mulch - permanent covering effect : we consider a value of 1.0 for no covering, and 0.0 is full covering with plastic sheet ; this mulch parameter has been used in previous versions of the model where evolution of mulch biomass was not explicitely taken into consideration, can be used in the case of crops with self-mulching phenomena, where a standard mulch parameter value of 0.7 can be applied. 3) Mulch - evolutive covering effect BiomMc : biomass of mulch This function has been adapted from EvalKceMC procedure, bileau.pas and exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like it has been adapted from the dual crop coefficient from the FAO56 paper. But this is still to confirm on a point of view of the history of the model. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def estimate_kce ( j , data , paramITK ) : \"\"\" This function estimates the coefficient of evaporation from the soil ( kce ) . This approach takes into consideration three factors acting on limitation of kce : 1 ) ltr : plant cover , 1 = no plant cover , 0 = full plant cover 2 ) Mulch - permanent covering effect : we consider a value of 1 . 0 for no covering , and 0 . 0 is full covering with plastic sheet ; this mulch parameter has been used in previous versions of the model where evolution of mulch biomass was not explicitely taken into consideration , can be used in the case of crops with self - mulching phenomena , where a standard mulch parameter value of 0 . 7 can be applied . 3 ) Mulch - evolutive covering effect BiomMc : biomass of mulch This function has been adapted from EvalKceMC procedure , bileau . pas and exmodules 2 . pas from the original FORTRAN code . In its spirit , it looks like it has been adapted from the dual crop coefficient from the FAO56 paper . But this is still to confirm on a point of view of the history of the model . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" kce \" ][ j ,:,:] = data [ \" ltr \" ][ j ,:,:] * paramITK [ \" mulch \" ] / 100 * \\ np . exp ( - paramITK [ \" coefMc \" ] * paramITK [ \" surfMc \" ] * data [ \" biomMc \" ][ j ,:,:] / 1000 ) return data estimate_pFact def estimate_pFact ( j , data , paramVariete ) summary This function computes the pFactor, which is a bound coefficient used in the computation of cstr from ftsw. This coefficient delimits the portion of the FTSW below which water stress starts to influence the transpiration. FAO reference for critical FTSW value for transpiration response (0 = stomata respond immediately if FTSW<1; 0.5 for most of the crops) pFact is bounded in [0.1, 0.8]. For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def estimate_pFact ( j , data , paramVariete ) : \"\"\" _summary_ This function computes the pFactor , which is a bound coefficient used in the computation of cstr from ftsw . This coefficient delimits the portion of the FTSW below which water stress starts to influence the transpiration . FAO reference for critical FTSW value for transpiration response ( 0 = stomata respond immediately if FTSW < 1 ; 0.5 for most of the crops) pFact is bounded in [ 0 . 1 , 0 . 8 ]. For details see https : // agritrop . cirad . fr / 556855 / 1 / document_556855 . pdf This function is based on the CstrPFactor procedure , from bileau . pas , exmodules 1 & 2 . pas , risocas . pas files , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 53 data [ \" pFact \" ][ j :,:,:] = paramVariete [ \" PFactor \" ] + \\ 0 . 04 * ( 5 - np . maximum ( data [ \" kcp \" ][ j ,:,:], 1 ) * data [ \" ET0 \" ][ j ,:,:] ) # group 54 data [ \" pFact \" ][ j :,:,:] = np . minimum ( np . maximum ( 0 . 1 , data [ \" pFact \" ][ j ,:,:], ) , 0 . 8 , ) return data estimate_plant_transpiration def estimate_plant_transpiration ( j , data ) This function computes the transpiration from the plant. This function is based on the EvalTranspi procedure, from bileau.pas, bhytypeFAO.pas, exmodules 1 & 2.pas, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_plant_transpiration ( j , data ) : \"\"\" This function computes the transpiration from the plant . This function is based on the EvalTranspi procedure , from bileau . pas , bhytypeFAO . pas , exmodules 1 & 2 . pas , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 58 data [ \" tr \" ][ j :,:,:] = ( data [ \" trPot \" ][ j ,:,:] * data [ \" cstr \" ][ j ,:,:] ) return data estimate_potential_plant_transpiration def estimate_potential_plant_transpiration ( j , data ) This function computes the potential transpiration from the plant. Computation is based on the climate forcing (ET0), as well as the kcp coefficient. This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and exmodules 1 & 2.pas files from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_potential_plant_transpiration ( j , data ) : \"\"\" This function computes the potential transpiration from the plant . Computation is based on the climate forcing ( ET0 ) , as well as the kcp coefficient . This code is based on the DemandePlante procedure , from the bileau . pas , bhytypeFAO . pas , and exmodules 1 & 2 . pas files from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ggroup 51 data [ \" trPot \" ][ j ,:,:] = ( data [ \" kcp \" ][ j ,:,:] * data [ \" ET0 \" ][ j ,:,:] ) return data estimate_runoff def estimate_runoff ( j , data ) Evaluation of runoff (\"lame de ruissellement\", lr, mm) : If the quantity of rain (mm) is above the runoff threshold (seuilRuiss, mm), runoff is computed as the difference between the available water (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0. seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data Question : should runoff be computed taking in consideration water captured by mulch to account for mulch effect on runoff mitigation ? Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_runoff ( j , data ): \"\"\" Evaluation of runoff (\"lame de ruissellement\", lr, mm) : If the quantity of rain (mm) is above the runoff threshold (seuilRuiss, mm), runoff is computed as the difference between the available water (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0. seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data Question : should runoff be computed taking in consideration water captured by mulch to account for mulch effect on runoff mitigation ? Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 11 data [ \"lr\" ][ j ,:,:] = xr . where ( data [ \"rain\" ][ j ,:,:] > data [ \"seuilRuiss\" ], ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"seuilRuiss\" ]) * data [ \"pourcRuiss\" ], 0 , ) return data estimate_soil_evaporation def estimate_soil_evaporation ( j , data ) This function computes estimation of soil evaporation (mm, evap). It uses the potential soil evaporation (evapPot) and the fraction of evaporable soil water (fesw), bounded by the surface tank stock. It has been adapted from the EvapRuSurf procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_soil_evaporation ( j , data ) : \"\"\" This function computes estimation of soil evaporation ( mm , evap ) . It uses the potential soil evaporation ( evapPot ) and the fraction of evaporable soil water ( fesw ) , bounded by the surface tank stock . It has been adapted from the EvapRuSurf procedure , from bileau . pas and exmodules 1 & 2 . pas file from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! replacing stRuSurf by surface_tank_stock # // data [ \" evap \" ][ j :,:,:] = np . minimum ( data [ \" evapPot \" ][ j ,:,:] * data [ \" fesw \" ][ j ,:,:] ** 2 , data [ \" stRuSurf \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" evap \" ][ j :,:,:] = np . minimum ( data [ \" evapPot \" ][ j ,:,:] * data [ \" fesw \" ][ j ,:,:] ** 2 , data [ \" surface_tank_stock \" ][ j ,:,:] ) return data estimate_soil_potential_evaporation def estimate_soil_potential_evaporation ( j , data ) This function computes estimation of potential soil evaporation (mm, evapPot). It performs its computations solely from the evaporation forcing driven by climatic demand, limited by the coefficient of evaporation from the soil (kce). Note : difference in humectation of the top and bottom tanks is not taken into consideration in this approach. The This function has been adapted from DemandeSol procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_soil_potential_evaporation ( j , data ) : \"\"\" This function computes estimation of potential soil evaporation ( mm , evapPot ) . It performs its computations solely from the evaporation forcing driven by climatic demand , limited by the coefficient of evaporation from the soil ( kce ) . Note : difference in humectation of the top and bottom tanks is not taken into consideration in this approach . The This function has been adapted from DemandeSol procedure , from bileau . pas and exmodules 1 & 2 . pas file from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 44 data [ \" evapPot \" ][ j ,:,:] = data [ \" ET0 \" ][ j ,:,:] * data [ \" kce \" ][ j ,:,:] return data estimate_transpirable_surface_water def estimate_transpirable_surface_water ( j , data ) This function estimates the transpirable surface water. It removes 1/10th of surface tank capacity as water is condidered as bound. This function is based on the ConsoResSep procedure, from bileau.pas, exmodules 1 & 2.pas files, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_transpirable_surface_water ( j , data ) : \"\"\" This function estimates the transpirable surface water . It removes 1 / 10 th of surface tank capacity as water is condidered as bound . This function is based on the ConsoResSep procedure , from bileau . pas , exmodules 1 & 2 . pas files , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 59 # ! replacing stRuSurf by surface_tank_stock # ! renaming ruSurf with surface_tank_capacity # // data [ \" trSurf \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRuSurf \" ][ j ,:,:] - data [ \" ruSurf \" ][ j ,:,:] / 10 ) [..., np . newaxis ] data [ \" trSurf \" ][ j :,:,:] = np . maximum ( 0 , data [ \" surface_tank_stock \" ][ j ,:,:] - data [ \" surface_tank_capacity \" ] * 0 . 1 , ) return data estimate_transpirable_water def estimate_transpirable_water ( j , data ) This function estimates the daily volume of transpirable water. eauTranspi (mm, water transpirable) is the water available for transpiration from the surface reservoir. If surface_tank_stock at the end of the previous day (index j-1) is lower than 10% of the surface_tank_capacity, the water available for transpirable water equals the water available for the day (eauDispo), minus the difference between 1/10th of the surface_tank_capacity and surface_tank_stock. This transpirable water has a min bound at 0 mm. Said otherwise, a part of the water available for the day (eauDispo) is considered as bound to the surface reservoir and cannot be transpired. If surface_tank_stock at the end of the previous day (index j-1) is upper than 10% of the surface_tank_capacity, transpirable water equals eauDispo. Remark : if the use of j-1 indices is too problematic, it seems feasible to run this function just before update_surface_tank_stock. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_transpirable_water ( j , data ) : \"\"\" This function estimates the daily volume of transpirable water . eauTranspi ( mm , water transpirable ) is the water available for transpiration from the surface reservoir . If surface_tank_stock at the end of the previous day ( index j - 1 ) is lower than 10 % of the surface_tank_capacity , the water available for transpirable water equals the water available for the day ( eauDispo ) , minus the difference between 1 / 10 th of the surface_tank_capacity and surface_tank_stock . This transpirable water has a min bound at 0 mm . Said otherwise , a part of the water available for the day ( eauDispo ) is considered as bound to the surface reservoir and cannot be transpired . If surface_tank_stock at the end of the previous day ( index j - 1 ) is upper than 10 % of the surface_tank_capacity , transpirable water equals eauDispo . Remark : if the use of j - 1 indices is too problematic , it seems feasible to run this function just before update_surface_tank_stock . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 28 data [ \" eauTranspi \" ][ j ,:,:] = np . where ( # ! modifying to replace stRuSurfPrec by stRuSurf at undex j - 1 # ! renaming ruSurf to surface_tank_capacity # ! renaming stRuSurfPrec to surface_tank_stock # // data [ \" stRuSurfPrec \" ][ j ,:,:] < data [ \" ruSurf \" ][ j ,:,:] / 10 , data [ \" surface_tank_stock \" ][ j - 1 ,:,:] < 0 . 1 * data [ \" surface_tank_capacity \" ], np . maximum ( 0 , # ! modifying to replace stRuSurfPrec by stRuSurf at iundex j - 1 # ! renaming ruSurf to surface_tank_capacity # ! renaming stRuSurf to surface_tank_stock # // data [ \" eauDispo \" ][ j ,:,:] - ( data [ \" ruSurf \" ][ j ,:,:] / 10 - data [ \" stRuSurfPrec \" ][ j ,:,:] ) data [ \" eauDispo \" ][ j ,:,:] - ( 0 . 1 * data [ \" surface_tank_capacity \" ] - data [ \" surface_tank_stock \" ][ j - 1 ,:,:] ) ) , data [ \" eauDispo \" ][ j ,:,:], ) return data estimate_water_captured_by_mulch def estimate_water_captured_by_mulch ( j , data , paramITK ) Determination of water gathered by the mulch (eauCaptee, mm): We determine the quantity of water gathered by mulch by multiplying the available water (eauDispo, from rain and irrigation, mm) with a exponential function of covering capacity of the considered mulch (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the fraction of soil covered by mulch. The value of eauCaptee is bounded by the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of water already present in it (stockMc, mm). Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def estimate_water_captured_by_mulch ( j , data , paramITK ): \"\"\" Determination of water gathered by the mulch (eauCaptee, mm): We determine the quantity of water gathered by mulch by multiplying the available water (eauDispo, from rain and irrigation, mm) with a exponential function of covering capacity of the considered mulch (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the fraction of soil covered by mulch. The value of eauCaptee is bounded by the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of water already present in it (stockMc, mm). Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 7 #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"eauCaptee\"][j,:,:] = np.minimum( data [ \"water_gathered_by_mulch\" ][ j ,:,:] = np . minimum ( data [ \"eauDispo\" ][ j ,:,:] * ( 1 - np . exp ( - paramITK [ \"surfMc\" ] / 1000 * data [ \"biomMc\" ][ j ,:,:])), #// (paramITK[\"humSatMc\"] * data[\"biomMc\"][j,:,:] / 10000) - data[\"stockMc\"][j,:,:], ( paramITK [ \"humSatMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 10000 ) - data [ \"mulch_water_stock\" ][ j ,:,:], ) return data estimate_water_consumption_from_root_tank_stock def estimate_water_consumption_from_root_tank_stock ( j , data ) This function estimates consoRur, which is the water to be consumed from the root tank stock. If soil evaporation (evap) is higher than transpirable surface water (trSurf), then consumption from root tank stock equals trSurf. Else, it equals evap. ? how to interpret this ? Parameters: Name Type Description Default j type description None data type description None View Source def estimate_water_consumption_from_root_tank_stock ( j , data ) : \"\"\" This function estimates consoRur , which is the water to be consumed from the root tank stock . If soil evaporation ( evap ) is higher than transpirable surface water ( trSurf ) , then consumption from root tank stock equals trSurf . Else , it equals evap . #? how to interpret this ? Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ \"\"\" data [ \" consoRur \" ][ j :,:,:] = np . where ( data [ \" evap \" ][ j ,:,:] > data [ \" trSurf \" ][ j ,:,:], data [ \" trSurf \" ][ j ,:,:], data [ \" evap \" ][ j ,:,:], ) return data initialize_root_tank_capacity def initialize_root_tank_capacity ( j , data , paramITK ) updating stRurMax/root_tank_capacity, step 1 : stRurMax, also called ruRac in some versions of the model, is the root_tank_capacity. At the phase change between phases 0 and 1 (initialisation), the maximum root water storage is initialised by multiplying the initial root depth (profRacIni, mm) with the soil water storage capacity (ru, mm/m). This value is broadcasted on the time series. For every other day in the cycle, the value remains unchanged. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def initialize_root_tank_capacity ( j , data , paramITK ) : \"\"\" updating stRurMax / root_tank_capacity , step 1 : stRurMax , also called ruRac in some versions of the model , is the root_tank_capacity . At the phase change between phases 0 and 1 ( initialisation ) , the maximum root water storage is initialised by multiplying the initial root depth ( profRacIni , mm ) with the soil water storage capacity ( ru , mm / m ) . This value is broadcasted on the time series . For every other day in the cycle , the value remains unchanged . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 14 # ! renaming stRurMax to root_tank_capacity # // data [ \" stRurMax \" ][ j :,:,:] = np . where ( data [ \" root_tank_capacity \" ][ j :,:,:] = xr . where ( ( data [ \" changePhase \" ][ j ,:,:] == 1 ) & ( data [ \" numPhase \" ][ j ,:,:] == 1 ) , paramITK [ \" profRacIni \" ] / 1000 * data [ \" ru \" ], # // data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:], ) return data rempliRes def rempliRes ( j , data ) Translated from the procedure rempliRes, of the original Pascal codes bileau.pas Main hypotheses : - the water dynamics is represented by a filling from the top and an evolution of the reservoirs sizes when the filling is above the maximum quantity of the current size (humectation front). - when the maximum size is reached by filling, it is considered as drainage. - inside a reservoir, water is distributed homogeneously (may be considered valid up to 2m depth, according to CB, from other sources). 3 reservoirs are represented: 1) a global reservoir, evolving in depth according to the humectation front 2) a surface reservoir (fixed size) where evaporation and a part of the transpiration occurs when roots are present 3) a root reservoir, evolving according to the root front (when roots are present) REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks Notes from CB, 10/06/2015 : prise en compte de stock d'eau r\u00e9silient pour les simulation continues Hypoth\u00e8se de la MAJ des stock en fn de l'eau r\ufffdsiliente de l'ann\ufffde pr\ufffdc\ufffddente dans le cas des simulations pluri annuelle en continue (NbAn = 1): A la r\ufffdcolte on recup\ufffdre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec) et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien. On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf) Si le StRu avec l'apport d'eau devinet sup au Hum alors on tient compte dans cette augmentation du stock r\ufffdsilient avec deux cas possible : Si StRu est < \ufffd stRurMaxprec alors on ajoute l'eau r\ufffdsiliente contenue dans l'ancienne zone racinaire en fn de la diff\ufffdrence de stock Sinon on a de l'eau r\ufffdsiliente au maximum de la CC jusqu'\ufffd l'ancienne HumPrec, on rempli alors StRu de la diff\ufffdrence etre ces deux valeurs puis on fait la MAJ des Dr, StRur, Hum etc... View Source def rempliRes ( j , data ): \"\"\" Translated from the procedure rempliRes, of the original Pascal codes bileau.pas Main hypotheses : - the water dynamics is represented by a filling from the top and an evolution of the reservoirs sizes when the filling is above the maximum quantity of the current size (humectation front). - when the maximum size is reached by filling, it is considered as drainage. - inside a reservoir, water is distributed homogeneously (may be considered valid up to 2m depth, according to CB, from other sources). 3 reservoirs are represented: 1) a global reservoir, evolving in depth according to the humectation front 2) a surface reservoir (fixed size) where evaporation and a part of the transpiration occurs when roots are present 3) a root reservoir, evolving according to the root front (when roots are present) REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks Notes from CB, 10/06/2015 : prise en compte de stock d'eau r\u00e9silient pour les simulation continues Hypoth\u00e8se de la MAJ des stock en fn de l'eau r\ufffdsiliente de l'ann\ufffde pr\ufffdc\ufffddente dans le cas des simulations pluri annuelle en continue (NbAn = 1): A la r\ufffdcolte on recup\ufffdre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec) et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien. On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf) Si le StRu avec l'apport d'eau devinet sup au Hum alors on tient compte dans cette augmentation du stock r\ufffdsilient avec deux cas possible : Si StRu est < \ufffd stRurMaxprec alors on ajoute l'eau r\ufffdsiliente contenue dans l'ancienne zone racinaire en fn de la diff\ufffdrence de stock Sinon on a de l'eau r\ufffdsiliente au maximum de la CC jusqu'\ufffd l'ancienne HumPrec, on rempli alors StRu de la diff\ufffdrence etre ces deux valeurs puis on fait la MAJ des Dr, StRur, Hum etc... \"\"\" # section 1 : updating the end_of_cycle memory variables data = update_humPrec_for_end_of_cycle ( j , data ) data = update_hum_for_end_of_cycle ( j , data ) data = update_stRurMaxPrec_for_end_of_cycle ( j , data ) data = update_stRurPrec_for_end_of_cycle ( j , data ) data = update_stRuPrec_for_end_of_cycle ( j , data ) data = reset_total_tank_capacity ( j , data ) # verif ok # # filling the surface tank with available water data = update_surface_tank_stock ( j , data ) # verif ok # # estimates transpirable water data = estimate_transpirable_water ( j , data ) # verif ok # # increments total tank stock with transpirable water # # (meaning that total tank stock may represent a transpirable water tank) data = update_total_tank_stock ( j , data ) # verif ok # # estimating positive delta between total_root_tank and stRuPrec data = update_delta_total_tank_stock ( j , data ) # verif ok # # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged data = update_total_tank_stock_step_2 ( j , data ) # verif ok # # then total_tank_stock_previous_value can 1) take 0 or 2) be unchanged data = update_stRuPrec ( j , data ) #???? # # delta_total_tank_stock can 1) be incremented of total_tank_stock_previous_value or 2) be unchanged data = update_delta_total_tank_stock_step_2 ( j , data ) # # # here, in case 1, In this function, if the variation of transpirable water # # (delta_total_tank_stock) increases above the depth of humectation front # # (hum), if the depth of humectation front (hum) is above the # # root_tank_capacity_previous_season (condition 1 passed, and 2 failed, # # which should be the case for most of the simulations that will be # # single-season), and if the depth of humectation front (hum) has decreased # # since the previous day (condition 3 passed), then total_tank_stock takes the value of # # delta_total_tank_stock, total_tank_stock_previous_value equals 0, and # # delta_total_tank_stock is incremented by total_tank_stock_previous_value. # # # # in case 2, nothing happens. # # update_hum manages increase in hum data = update_hum ( j , data ) # # in case of overflowing... # # calculating drainage data = update_dr ( j , data ) # # limiting the total_tank_stock to the total_tank_capacity (when overflowing) data = update_total_tank_stock_step_3 ( j , data ) # # update again hum value, but we could merge functions with update_hum data = update_hum_step_2 ( j , data ) # # filling root_tank_stock with transpirable water, within the limits of total_tank_stock data = update_root_tank_stock_step_2 ( j , data ) return data reset_total_tank_capacity def reset_total_tank_capacity ( j , data ) This function resets the value total_tank_capacity/stRuMax at each loop. ? Why redfining stRuMax at each loop ? Neither ru, profRu ? nor total_tank_capacity are modified during the simulation. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def reset_total_tank_capacity ( j , data ) : \"\"\" This function resets the value total_tank_capacity / stRuMax at each loop . ? Why redfining stRuMax at each loop ? Neither ru , profRu ? nor total_tank_capacity are modified during the simulation . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 25 # ! renaming stRuMax to total_tank_capacity # // data [ \" stRuMax \" ][ j :,:,:] = ( data [ \" ru \" ] * data [ \" profRu \" ] / 1000 ) #. copy () #[..., np . newaxis ] data [ \" total_tank_capacity \" ][ j :,:,:] = ( data [ \" ru \" ] * data [ \" profRu \" ] / 1000 ) return data update_available_water_after_mulch_filling def update_available_water_after_mulch_filling ( j , data ) Updating available water (eauDispo, mm) : As some water is gathered by the mulch, the available water is updated by subtracting the gathered water (eauCaptee, mm) from the total available water (eauDispo, mm). This value is bounded by 0, as the available water cannot be negative. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_available_water_after_mulch_filling ( j , data ): \"\"\" Updating available water (eauDispo, mm) : As some water is gathered by the mulch, the available water is updated by subtracting the gathered water (eauCaptee, mm) from the total available water (eauDispo, mm). This value is bounded by 0, as the available water cannot be negative. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch # group 8 #// data[\"eauDispo\"][j:,:,:] = np.maximum(data[\"eauDispo\"][j,:,:] - data[\"eauCaptee\"][j,:,:], 0) # //[...,np.newaxis] data [ \"eauDispo\" ][ j :,:,:] = np . maximum ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"water_gathered_by_mulch\" ][ j ,:,:], 0 ) # //[...,np.newaxis] return data update_available_water_after_runoff def update_available_water_after_runoff ( j , data ) Updating available water (eauDispo, mm) : The available water is updated by subtracting the runoff (lr, mm) from the total available water (eauDispo, mm). This value is broadcasted onto the days axis. Parameters: Name Type Description Default j type description None data type description None View Source def update_available_water_after_runoff ( j , data ) : \"\"\" Updating available water ( eauDispo , mm ) : The available water is updated by subtracting the runoff ( lr , mm ) from the total available water ( eauDispo , mm ) . This value is broadcasted onto the days axis . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ \"\"\" # group 12 data [ \" eauDispo \" ][ j :,:,:] = ( data [ \" eauDispo \" ][ j ,:,:] - data [ \" lr \" ][ j ,:,:] ) return data update_delta_root_tank_capacity def update_delta_root_tank_capacity ( j , data ) updating delta_root_tank_capacity : At the day of phase change, for phases strictly above 1, and for which the difference between the water height to humectation front (hum, mm) and the root_tank_capacity is less than the delta_root_tank_capacity, delta_root_tank_capacity is updated to be equal to the difference between the water height to humectation front and the root_tank_capacity. In other words, the change in root tank capacity delta_root_tank_capacity is limited by the water height to humectation front. For any other day or if root_tank_capacity is above delta_root_tank_capacity, delta_root_tank_capacity value is unchanged. Parameters: Name Type Description Default j type description None data type description None View Source def update_delta_root_tank_capacity ( j , data ) : \"\"\" updating delta_root_tank_capacity : At the day of phase change , for phases strictly above 1 , and for which the difference between the water height to humectation front ( hum , mm ) and the root_tank_capacity is less than the delta_root_tank_capacity , delta_root_tank_capacity is updated to be equal to the difference between the water height to humectation front and the root_tank_capacity . In other words , the change in root tank capacity delta_root_tank_capacity is limited by the water height to humectation front . For any other day or if root_tank_capacity is above delta_root_tank_capacity , delta_root_tank_capacity value is unchanged . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ \"\"\" # group 16 # ! simplified conditions # // condition = ( data [ \" numPhase \" ][ j ,:,:] > 0 ) & \\ # // np . invert (( data [ \" numPhase \" ][ j ,:,:] == 1 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 )) condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 ) # ! renaming deltaRur with delta_root_tank_capacity # // data [ \" deltaRur \" ][ j :,:,:] = np . where ( data [ \" delta_root_tank_capacity \" ][ j :,:,:] = np . where ( condition , np . where ( # ! renaming stRurMax to root_tank_capacity # ! renaming dayVrac to delta_root_tank_capacity # // ( data [ \" hum \" ][ j ,:,:] - data [ \" stRurMax \" ][ j ,:,:] ) < data [ \" dayVrac \" ][ j ,:,:], ( data [ \" hum \" ][ j ,:,:] - data [ \" root_tank_capacity \" ][ j ,:,:] ) < data [ \" delta_root_tank_capacity \" ][ j ,:,:], # // data [ \" hum \" ][ j ,:,:] - data [ \" stRurMax \" ][ j ,:,:], data [ \" hum \" ][ j ,:,:] - data [ \" root_tank_capacity \" ][ j ,:,:], # ! renaming dayVrac to delta_root_tank_capacity # // data [ \" dayVrac \" ][ j ,:,:], data [ \" delta_root_tank_capacity \" ][ j ,:,:], ) , # // data [ \" deltaRur \" ][ j ,:,:], data [ \" delta_root_tank_capacity \" ][ j ,:,:], ) return data update_delta_total_tank_stock def update_delta_total_tank_stock ( j , data ) This function estimates delta_total_tank_stock delta_total_tank_stock is the positive variation of transpirable water stock. It is computed as the difference between the total_tank_stock and stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is initialized to be equal to total_tank_stock at the beginning of the simulation. total_tank_stock is initialized with stockIrr parameter. Thus, simulations should start with a 0 value. stRuPrec is updated at each cycle with the update_struprec function. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_delta_total_tank_stock ( j , data ): \"\"\" This function estimates delta_total_tank_stock delta_total_tank_stock is the positive variation of transpirable water stock. It is computed as the difference between the total_tank_stock and stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is initialized to be equal to total_tank_stock at the beginning of the simulation. total_tank_stock is initialized with stockIrr parameter. Thus, simulations should start with a 0 value. stRuPrec is updated at each cycle with the update_struprec function. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 30 #! we propose a different version based on stTot #! renaming stTot to total_tank_stock #! renaming stRuVar to delta_total_tank_stock #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuVar\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"stRuPrec\"][j,:,:])[...,np.newaxis] data [ \"delta_total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"total_tank_stock_previous_value\" ][ j ,:,:]) return data update_delta_total_tank_stock_step_2 def update_delta_total_tank_stock_step_2 ( j , data ) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_delta_total_tank_stock_step_2 ( j , data ) : \"\"\" Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # groupe 33 # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j :,:,:] = np . where ( data [ \" delta_total_tank_stock \" ][ j :,:,:] = np . where ( condition_1 , np . where ( condition_2 , # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j ,:,:] + ( data [ \" stRuVar \" ][ j ,:,:] - data [ \" hum \" ][ j ,:,:] ) * data [ \" stRurPrec \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:] + ( data [ \" delta_total_tank_stock \" ][ j ,:,:] - data [ \" hum \" ][ j ,:,:] ) * data [ \" stRurPrec \" ][ j ,:,:], np . where ( condition_3 , # ! renaming stRuVar with delta_total_tank_stock # ! renaming stRuPrec with total_tank_stock_previous_value # // data [ \" stRuVar \" ][ j ,:,:] + data [ \" stRuPrec \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:] + data [ \" total_tank_stock_previous_value \" ][ j ,:,:], # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:], ) , ) , # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:], ) return data update_dr def update_dr ( j , data ) This function estimates the daily drainage (dr). When total tank overflows, it computes drainage from the differences between the total_tank_stock (that is to say the total and total_tank_capacity. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_dr ( j , data ) : \"\"\" This function estimates the daily drainage ( dr ) . When total tank overflows , it computes drainage from the differences between the total_tank_stock ( that is to say the total and total_tank_capacity . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // condition = ( data [ \" stTot \" ][ j ,:,:] > data [ \" stRuMax \" ][ j ,:,:] ) condition = condition_total_tank_overflow ( j , data ) # groupe 36 # essais stTot data [ \" dr \" ][ j ,:,:] = np . where ( condition , # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // data [ \" stRu \" ][ j ,:,:] - data [ \" stRuMax \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" total_tank_capacity \" ][ j ,:,:], 0 , ) return data update_etr_etm def update_etr_etm ( j , data ) View Source def update_etr_etm ( j , data ) : # group 69 data [ \" etr \" ][ j :,:,:] = ( data [ \" tr \" ][ j ,:,:] + data [ \" evap \" ][ j ,:,:] ) . copy () #[..., np . newaxis ] # group 70 data [ \" etm \" ][ j :,:,:] = ( data [ \" trPot \" ][ j ,:,:] + data [ \" evapPot \" ][ j ,:,:] ) . copy () #[..., np . newaxis ] return data update_hum def update_hum ( j , data ) This function updates the depth to humectation front (hum) to be the maximum value between the depth to humectation front (hum) and delta_total_tank_stock (that is to say depth of humectation front can only increase), bounded by total_tank_capacity (that is to say humectation front can not go deep indefinitely). Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_hum ( j , data ) : \"\"\" This function updates the depth to humectation front (hum) to be the maximum value between the depth to humectation front (hum) and delta_total_tank_stock (that is to say depth of humectation front can only increase), bounded by total_tank_capacity (that is to say humectation front can not go deep indefinitely). Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 34 #! renaming stRuVar with delta_total_tank_stock # // data [ \"hum\" ][ j:,:,: ] = np . maximum ( data [ \"stRuVar\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) # [ ...,np.newaxis ] data [ \"hum\" ][ j:,:,: ] = np . maximum ( data [ \"delta_total_tank_stock\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) # groupe 35 #! renaming stRuMax to total_tank_capacity # // data [ \"hum\" ][ j:,:,: ] = np . minimum ( data [ \"stRuMax\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) # [ ...,np.newaxis ] data [ \"hum\" ][ j:,:,: ] = np . minimum ( data [ \"total_tank_capacity\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) return data update_humPrec_for_end_of_cycle def update_humPrec_for_end_of_cycle ( j , data ) This function saves information about the humectation front depth at the end of a growth cycle so it can be used in the next cycle. humPrec is initialized in the function InitPlotMc, and set to be equal to hum, itself being initialized to take the maximum value between surface_tank_capacity, root_tank_capacity and total_tank_stock. At the harvest date (numPhase = 7), the humPrec variable is set to equal the highest value between hum (mm, humectation front depth) and surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Parameters: Name Type Description Default j int number of the day None data xarray dataset description None Returns: Type Description None xarray dataset: description View Source def update_humPrec_for_end_of_cycle ( j , data ): \"\"\" This function saves information about the humectation front depth at the end of a growth cycle so it can be used in the next cycle. humPrec is initialized in the function InitPlotMc, and set to be equal to hum, itself being initialized to take the maximum value between surface_tank_capacity, root_tank_capacity and total_tank_stock. At the harvest date (numPhase = 7), the humPrec variable is set to equal the highest value between hum (mm, humectation front depth) and surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (int): number of the day data (xarray dataset): _description_ Returns: xarray dataset: _description_ \"\"\" # group 20 condition = condition_end_of_cycle ( j , data ) data [ \"humPrec\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// np.maximum(data[\"hum\"][j,:,:], data[\"ruSurf\"][j,:,:]), np . maximum ( data [ \"hum\" ][ j ,:,:], data [ \"surface_tank_capacity\" ]), data [ \"humPrec\" ][ j ,:,:], ) return data update_hum_for_end_of_cycle def update_hum_for_end_of_cycle ( j , data ) This function updates information about the humectation front depth at the end of a growth cycle. At the harvest date (numPhase = 7), the hum variable is set to equal the surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_hum_for_end_of_cycle ( j , data ): \"\"\" This function updates information about the humectation front depth at the end of a growth cycle. At the harvest date (numPhase = 7), the hum variable is set to equal the surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 21 condition = condition_end_of_cycle ( j , data ) data [ \"hum\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// data[\"ruSurf\"][j,:,:], data [ \"surface_tank_capacity\" ], data [ \"hum\" ][ j ,:,:], ) return data update_hum_step_2 def update_hum_step_2 ( j , data ) We update the depth to humectation front (hum) again, to reflect eventual changes in total_tank_stock values. ? we could have placed the previous hum update function here Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_hum_step_2 ( j , data ) : \"\"\" We update the depth to humectation front ( hum ) again , to reflect eventual changes in total_tank_stock values . ? we could have placed the previous hum update function here Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # groupe 38 # // avant modif 10 / 06 / 2015 # data [ \" hum \" ][ j :,:,:] = np . maximum ( data [ \" hum \" ][ j ,:,:], data [ \" stRu \" ][ j ,:,:] ) # essais stTot # ! renaming stTot to total_tank_stock # // data [ \" hum \" ][ j :,:,:] = np . maximum ( data [ \" hum \" ][ j ,:,:], data [ \" stTot \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" hum \" ][ j :,:,:] = np . maximum ( data [ \" hum \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] ) #[..., np . newaxis ] # ! en conflit avec le calcul pr \u00e9 c \u00e9 dent de hum return data update_irrigation_tank_capacity def update_irrigation_tank_capacity ( j , data ) Update Irrigation Tank Capacity The function updates the maximum water capacity of irrigation tank based on the conditions specified in the function. If the automatic irrigation mode is ON, and if the current phase is between 0 and 6, and if the root tank capacity is less than the surface tank capacity, meaning that the roots have not reached the limit between the surface compartment and deep compartment, then the irrigation tank capacity is set to the surface tank capacity, which is given a minimum value equal to the surface tank capacity. Otherwise, the irrigation tank capacity remains unchanged. If we are in automatic irrigation mode, and between phases 0 and 6, and if root_tank_capacity is less than surface_tank_capacity, meaning that roots haven't reached the limit between the surface compartment and deep compartment, then we define irrigation_tank_capacity as equal to surface_tank_capacity, that is to say, we give to irrigation_tank_capacity a minimum value that equals surface_tank_capacity. else, we do not modify irrigation_tank_capacity value Parameters: Name Type Description Default j int Index of the time step being processed. None data xarray dataset The input dataset containing all the information necessary to run the model. None Returns: Type Description None xarray dataset: The input dataset with updated values of the irrigation tank capacity. View Source def update_irrigation_tank_capacity ( j , data ) : \"\"\" Update Irrigation Tank Capacity The function updates the maximum water capacity of irrigation tank based on the conditions specified in the function . If the automatic irrigation mode is ON , and if the current phase is between 0 and 6 , and if the root tank capacity is less than the surface tank capacity , meaning that the roots have not reached the limit between the surface compartment and deep compartment , then the irrigation tank capacity is set to the surface tank capacity , which is given a minimum value equal to the surface tank capacity . Otherwise , the irrigation tank capacity remains unchanged . If we are in automatic irrigation mode , and between phases 0 and 6 , and if root_tank_capacity is less than surface_tank_capacity , meaning that roots haven ' t reached the limit between the surface compartment and deep compartment , then we define irrigation_tank_capacity as equal to surface_tank_capacity , that is to say , we give to irrigation_tank_capacity a minimum value that equals surface_tank_capacity . else , we do not modify irrigation_tank_capacity value Args : j ( int ) : Index of the time step being processed . data ( xarray dataset ) : The input dataset containing all the information necessary to run the model . Returns : xarray dataset : The input dataset with updated values of the irrigation tank capacity . \"\"\" # group 2 condition = \\ ( data [ \" irrigAuto \" ][ j , :, :] == True ) & \\ ( data [ \" numPhase \" ][ j , :, :] > 0 ) & \\ ( data [ \" numPhase \" ][ j , :, :] < 6 ) # renaming ruIrr with irrigation_tank_capacity # // data [ \" ruIrr \" ][ j , :, :] = np . where ( data [ \" irrigation_tank_capacity \" ][ j , :, :] = np . where ( condition , np . where ( # ! renaming stRurMax to root_tank_capacity # ! renaming ruSurf with surface_tank_capacity # // ( data [ \" stRurMax \" ] < data [ \" ruSurf \" ] ) , data [ \" root_tank_capacity \" ][ j ,:,:] < data [ \" surface_tank_capacity \" ], # // data [ \" ruSurf \" ], data [ \" surface_tank_capacity \" ], # // data [ \" stRurMax \" ], data [ \" root_tank_capacity \" ][ j ,:,:], ) , data [ \" irrigation_tank_capacity \" ][ j , :, :], ) return data update_irrigation_tank_stock def update_irrigation_tank_stock ( j , data ) Update the Irrigation Tank Stock In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged. Parameters: Name Type Description Default j int Index of time step in data None data xarray Dataset Dataset that contains various data fields None Returns: Type Description None xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions. View Source def update_irrigation_tank_stock ( j , data ): \"\"\" Update the Irrigation Tank Stock In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged. Args: j (int): Index of time step in data data (xarray Dataset): Dataset that contains various data fields Returns: xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions. \"\"\" condition = ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) # group 1 #! renaming stockIrr with irrigation_tank_stock #//data[\"stockIrr\"][j, :, :] = np.where( data [ \"irrigation_tank_stock\" ][ j , :, :] = np . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// (data[\"stRurMax\"] < data[\"ruSurf\"]), ( data [ \"root_tank_capacity\" ] < data [ \"surface_tank_capacity\" ])[ j , :, :], #! renaming stRuSurf to surface_tank_stock #// data[\"stRuSurf\"][j, :, :], data [ \"surface_tank_stock\" ][ j , :, :], #! renaming stRur to root_tank_stock #// data[\"stRur\"][j, :, :], data [ \"root_tank_stock\" ][ j , :, :], ), data [ \"irrigation_tank_stock\" ][ j , :, :], ) return data update_mulch_water_stock def update_mulch_water_stock ( j , data ) Updating water stock in mulch (stockMc, mm) : The water stock in mulch is updated by adding the gathered water (eauCaptee, mm) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_mulch_water_stock ( j , data ): \"\"\" Updating water stock in mulch (stockMc, mm) : The water stock in mulch is updated by adding the gathered water (eauCaptee, mm) Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy # group 9 #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"stockMc\"][j:,:,:] = (data[\"stockMc\"][j,:,:] + data[\"eauCaptee\"][j,:,:]) # //[...,np.newaxis] data [ \"mulch_water_stock\" ][ j :,:,:] = ( data [ \"mulch_water_stock\" ][ j ,:,:] + data [ \"water_gathered_by_mulch\" ][ j ,:,:]) # //[...,np.newaxis] return data update_plant_transpiration def update_plant_transpiration ( j , data ) reajustement de la qte transpirable considerant que l'evap a eu lieu avant mise a jour des stocks transpirables if plant transpiration is higher than the root tank stock, then plant transpiration is updated to be equal to the difference between the root tank stock and the plant transpiration. Else, its value is unmodified. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_plant_transpiration ( j , data ) : \"\"\" reajustement de la qte transpirable considerant que l ' evap a eu lieu avant mise a jour des stocks transpirables if plant transpiration is higher than the root tank stock , then plant transpiration is updated to be equal to the difference between the root tank stock and the plant transpiration . Else , its value is unmodified . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 65 data [ \" tr \" ][ j :,:,:] = np . where ( # ! renaming stRur to root_tank_stock # // data [ \" tr \" ][ j ,:,:] > data [ \" stRur \" ][ j ,:,:], data [ \" tr \" ][ j ,:,:] > data [ \" root_tank_stock \" ][ j ,:,:], # // np . maximum ( data [ \" stRur \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:], 0 ) , np . maximum ( data [ \" root_tank_stock \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:], 0 ) , data [ \" tr \" ][ j ,:,:], ) return data update_root_tank_capacity def update_root_tank_capacity ( j , data ) updating root_tank_capacity/stRurMax/ruRac, step 2 : At the day of phase change, for phases strictly above 1, root_tank_capacity is updated to be summed with the change in root water storage capacity delta_root_tank_capacity. In other words, root_tank_capacity is incremented by the change in root water storage capacity linked to root growth. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_capacity ( j , data ) : \"\"\" updating root_tank_capacity / stRurMax / ruRac , step 2 : At the day of phase change , for phases strictly above 1 , root_tank_capacity is updated to be summed with the change in root water storage capacity delta_root_tank_capacity . In other words , root_tank_capacity is incremented by the change in root water storage capacity linked to root growth . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 17 # ! simplified conditions # // data [ \" stRurMax \" ][ j :,:,:] = np . where ( # // ( data [ \" numPhase \" ][ j ,:,:] > 0 ) , # // np . where ( # // np . invert (( data [ \" changePhase \" ][ j ,:,:] == 1 ) & ( data [ \" numPhase \" ][ j ,:,:] == 1 )) , # // data [ \" stRurMax \" ][ j ,:,:] + data [ \" deltaRur \" ][ j ,:,:], # // data [ \" stRurMax \" ][ j ,:,:], # // ) , # // data [ \" stRurMax \" ][ j ,:,:], # // ) #[..., np . newaxis ] # ! renaming stRurMax to root_tank_capacity # ! renaming deltaRur to delta_root_tank_capacity # // data [ \" stRurMax \" ][ j :,:,:] = np . where ( data [ \" root_tank_capacity \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 ) , # // data [ \" stRurMax \" ][ j ,:,:] + data [ \" deltaRur \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:] + data [ \" delta_root_tank_capacity \" ][ j ,:,:], # // data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:], ) return data update_root_tank_stock def update_root_tank_stock ( j , data ) updating root_tank_stock/stRur/stockrac : At the day of phase change, for phases strictly above 1, and for which the root_tank_capacity is above surface_tank_capacity (meaning that roots go beyond the surface water storage capacity), root_tank_stock is incremented by delta_root_tank_capacity. However, if root_tank_capacity is BELOW surface_tank_capacity (meaning that roots do not plunge into the deep reservoir), root_tank_stock is updated to be equal to surface_tank_stock minus 1/10th of the surface_tank_capacity, multiplied by the ratio between root_tank_capacity and surface_tank_capacity. That is to say \"we take at the prorata of depth and surface stock\". For any other day, root_tank_stock is unchanged. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock ( j , data ) : \"\"\" updating root_tank_stock/stRur/stockrac : At the day of phase change, for phases strictly above 1, and for which the root_tank_capacity is above surface_tank_capacity (meaning that roots go beyond the surface water storage capacity), root_tank_stock is incremented by delta_root_tank_capacity. However, if root_tank_capacity is BELOW surface_tank_capacity (meaning that roots do not plunge into the deep reservoir), root_tank_stock is updated to be equal to surface_tank_stock minus 1/10th of the surface_tank_capacity, multiplied by the ratio between root_tank_capacity and surface_tank_capacity. That is to say \" we take at the prorata of depth and surface stock \". For any other day, root_tank_stock is unchanged. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 18 # ! simplified conditions # // condition = ( data [ \"numPhase\" ][ j,:,: ] > 0 ) & np . invert (( data [ \"changePhase\" ][ j,:,: ] == 1 ) & ( data [ \"numPhase\" ][ j,:,: ] == 1 )), condition = ( data [ \"numPhase\" ][ j,:,: ] > 1 ) & ( data [ \"changePhase\" ][ j,:,: ] == 1 ), #! renaming stRur to root_tank_stock # // data [ \"stRur\" ][ j:,:,: ] = np . where ( data [ \"root_tank_stock\" ][ j:,:,: ] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity # // ( data [ \"stRurMax\" ][ j,:,: ] > data [ \"ruSurf\" ][ j,:,: ] ), ( data [ \"root_tank_capacity\" ][ j,:,: ] > data [ \"surface_tank_capacity\" ] ), #! renaming stRur to root_tank_stock #! renaming deltaRur to delta_root_tank_capacity # // data [ \"stRur\" ][ j,:,: ] + data [ \"deltaRur\" ][ j,:,: ] , data [ \"root_tank_stock\" ][ j,:,: ] + data [ \"delta_root_tank_capacity\" ][ j,:,: ] , #! renaming stRur to root_tank_stock #! renaming stRuSurf to surface_tank_stock # // np . maximum (( data [ \"stRuSurf\" ][ j,:,: ] - data [ \"ruSurf\" ][ j,:,: ] * 1 / 10 ) * ( data [ \"stRurMax\" ][ j,:,: ] / data [ \"ruSurf\" ][ j,:,: ] ), 0 ), np . maximum (( data [ \"surface_tank_stock\" ][ j,:,: ] - data [ \"surface_tank_capacity\" ] * 1 / 10 ) * ( data [ \"root_tank_capacity\" ][ j,:,: ] / data [ \"surface_tank_capacity\" ] ), 0 ), ). expand_dims ( \"time\" , axis = 0 ), #! renaming stRur to root_tank_stock # // data [ \"stRur\" ][ j,:,: ] , data [ \"root_tank_stock\" ][ j,:,: ] , ) return data update_root_tank_stock_step_2 def update_root_tank_stock_step_2 ( j , data ) Finally, we update root tank stock (root_tank_stock) with the computed values First we increment root_tank_stock with transpirable water (eauTranspi), within the limits of root_tank_capacity. Then, we limit the value of root_tank_stock within total_tank_stock Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock_step_2 ( j , data ) : \"\"\" Finally , we update root tank stock ( root_tank_stock ) with the computed values First we increment root_tank_stock with transpirable water ( eauTranspi ) , within the limits of root_tank_capacity . Then , we limit the value of root_tank_stock within total_tank_stock Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # groupe 39 # Rempli res racines # ! renaming stRur to root_tank_stock # ! renaming stRurMax to root_tank_capacity # // data [ \" stRur \" ][ j :,:,:] = np . minimum ( data [ \" stRur \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:], data [ \" stRurMax \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" root_tank_stock \" ][ j :,:,:] = np . minimum ( data [ \" root_tank_stock \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:] ) #[..., np . newaxis ] # groupe 40 # essais stTot # ! renaming stRur to root_tank_stock # ! renaming stTot to total_tank_stock # // data [ \" stRur \" ][ j ,:,:] = np . minimum ( data [ \" stRur \" ][ j ,:,:], data [ \" stRu \" ][ j ,:,:] ) data [ \" root_tank_stock \" ][ j :,:,:] = np . minimum ( data [ \" root_tank_stock \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] ) #[..., np . newaxis ] return data update_root_tank_stock_with_transpiration def update_root_tank_stock_with_transpiration ( j , data ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock_with_transpiration ( j , data ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 67 # ! renaming stRur to root_tank_stock # // data [ \" stRur \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRur \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] data [ \" root_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" root_tank_stock \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] return data update_root_tank_stock_with_water_consumption def update_root_tank_stock_with_water_consumption ( j , data ) This function updates root tank stock according to water consumption. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock_with_water_consumption ( j , data ) : \"\"\" This function updates root tank stock according to water consumption . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 64 # ! renaming stRur to root_tank_stock # // data [ \" stRur \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRur \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) #[..., np . newaxis ] data [ \" root_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" root_tank_stock \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) return data update_stRuPrec def update_stRuPrec ( j , data ) This function performs the update of total_tank_stock_previous_value/stRuPrec in the reservoir filling wrapper function. It will decrease the total_tank_stock_previous_value depending on the variation of transpirable water and height of humectation front. test image markdown In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day (condition 3 passed), then total_tank_stock_previous_value equals 0. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock_previous_value is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we decrease the value of total_tank_stock_previous_value by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock_previous_value will remain unchanged, and if the root tank is full, total_tank_stock_previous_value will be decreased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRuPrec ( j , data ) : \"\"\" This function performs the update of total_tank_stock_previous_value / stRuPrec in the reservoir filling wrapper function . It will decrease the total_tank_stock_previous_value depending on the variation of transpirable water and height of humectation front . test image markdown ! [ Drag Racing ]( Dragster . jpg ) In this function , if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), if the depth of humectation front ( hum ) is above the root_tank_capacity_previous_season ( condition 1 passed , and 2 failed , which should be the case for most of the simulations that will be single - season ), and if the depth of humectation front ( hum ) has decreased since the previous day ( condition 3 passed ), then total_tank_stock_previous_value equals 0. If the depth of humectation front did not change or increased since the previous day ( humPrec ), then total_tank_stock_previous_value is unchanged . Notably , root_tank_capacity_previous_season is initialized at 0 , and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity . humPrec is initialized with the same value as hum . However , in the update_humPrec_for_end_of_cycle function , at the day of transition between phase 7 and phase 0 , it takes hum as value , with a minimum bound of surface_tank_capacity . Starting from second simulation season ( root_tank_capacity_previous_season != 0 ), if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), and if the depth of humectation front stays below or equel to the total soil capacity ( conditions 1 and 2 passed ), then we decrease the value of total_tank_stock_previous_value by a the difference of water height between the variation of total tank stock ( delta_total_tank_stock ) and the depth of humectation front ( hum ), proportionally to the filling of the root tank capacity of previous season ( stRurPrec ). Thus , if the root tank is empty , total_tank_stock_previous_value will remain unchanged , and if the root tank is full , total_tank_stock_previous_value will be decreased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # group 32 #! renaming stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"][j:,:,:] = np.where( data [ \"total_tank_stock_previous_value\" ][ j : , : , : ] = np . where ( condition_1 , np . where ( condition_2 , #! replacing stRurPrec with ratio formula #! renaming stRuVar with delta_total_tank_stock #! renaming stRuPrec with total_tank_stock_previous_value # //np.maximum(0, data[\"stRuPrec\"][j,:,:] - (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:]), np . maximum ( 0 , data [ \"total_tank_stock_previous_value\" ][ j , : , : ] - ( data [ \"delta_total_tank_stock\" ][ j , : , : ] - data [ \"hum\" ][ j , : , : ]) * data [ \"stRurPrec\" ][ j , : , : ]), np . where ( condition_3 , 0 , #! renaming stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j , : , : ], ), ), #! renaming stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j , : , : ], ) return data update_stRuPrec_for_end_of_cycle def update_stRuPrec_for_end_of_cycle ( j , data ) when the phase changes from 7 to 1, the stRuPrec (mm, previous water storage capacity of the global reservoir) is set to equal the differe,ce between stTot (mm, total water storage capacity of the global reservoir) and stRurSurf (mm, water storage capacity of the surface reservoir) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRuPrec_for_end_of_cycle ( j , data ) : \"\"\" when the phase changes from 7 to 1 , the stRuPrec ( mm , previous water storage capacity of the global reservoir ) is set to equal the differe , ce between stTot ( mm , total water storage capacity of the global reservoir ) and stRurSurf ( mm , water storage capacity of the surface reservoir ) Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 24 # ! stRurSurf is not defined ... we may want to drop this group condition = condition_end_of_cycle ( j , data ) # ! renaming stRuPrec to total_tank_stock_previous_value # // data [ \" stRuPrec \" ][ j :,:,:] = np . where ( data [ \" total_tank_stock_previous_value \" ][ j :,:,:] = np . where ( condition , # ! renaming stTot to total_tank_stock # ! renaming stRuSurf with surface_tank_stock # // data [ \" stRu \" ][ j ,:,:] - data [ \" stRurSurf \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" surface_tank_stock \" ][ j ,:,:], # essai stTot # ! renaming stRuPrec to total_tank_stock_previous_value # // data [ \" stRuPrec \" ][ j ,:,:], data [ \" total_tank_stock_previous_value \" ][ j ,:,:], ) return data update_stRurMaxPrec_for_end_of_cycle def update_stRurMaxPrec_for_end_of_cycle ( j , data ) When the phase changes from 7 to 1, the stRurMaxPrec (mm, previous maximum water capacity to root front) is set to equal root_tank_capacity (mm). Value is broadcasted along time dimension. For every other day, it keeps its initial value of 0. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRurMaxPrec_for_end_of_cycle ( j , data ) : \"\"\" When the phase changes from 7 to 1 , the stRurMaxPrec ( mm , previous maximum water capacity to root front ) is set to equal root_tank_capacity ( mm ) . Value is broadcasted along time dimension . For every other day , it keeps its initial value of 0 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 22 condition = condition_end_of_cycle ( j , data ) # ! renaming stRurMaxPrec to root_tank_capacity_previous_season # // data [ \" stRurMaxPrec \" ][ j :,:,:] = np . where ( data [ \" root_tank_capacity_previous_season \" ][ j :,:,:] = np . where ( condition , # ! renaming stRurMax to root_tank_capacity # // data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:], # ! renaming stRurMaxPrec to root_tank_capacity_previous_season # // data [ \" stRurMaxPrec \" ][ j ,:,:], data [ \" root_tank_capacity_previous_season \" ][ j ,:,:], ) return data update_stRurPrec_for_end_of_cycle def update_stRurPrec_for_end_of_cycle ( j , data ) when the phase changes from 7 to 1, stRurPrec is set to equal stRur/stRurMax, that is to say the ratio of the water storage capacity of the root reservoir. Otherwise, it stays at its initial value of 0. Its value is broadcasted along j. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRurPrec_for_end_of_cycle ( j , data ) : \"\"\" when the phase changes from 7 to 1 , stRurPrec is set to equal stRur / stRurMax , that is to say the ratio of the water storage capacity of the root reservoir . Otherwise , it stays at its initial value of 0 . Its value is broadcasted along j . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 23 condition = condition_end_of_cycle ( j , data ) data [ \" stRurPrec \" ][ j :,:,:] = np . where ( condition , # ! renaming stRur to root_tank_stock # ! renaming stRurMax to root_tank_capacity # // data [ \" stRur \" ][ j ,:,:] / data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_stock \" ][ j ,:,:] / data [ \" root_tank_capacity \" ][ j ,:,:], data [ \" stRurPrec \" ][ j ,:,:], ) return data update_surface_tank_stock def update_surface_tank_stock ( j , data ) This function updates the value of surface_tank_stock. We update surface_tank_stock by adding the eauDispo, which as this point is the water available from 1) rain, 2) irrigation for the day after estimation of intake by mulch, and 3) runoff. However, we do not allow surface_tank_stock to exceed 110% of the surface_tank_capacity. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_surface_tank_stock ( j , data ) : \"\"\" This function updates the value of surface_tank_stock . We update surface_tank_stock by adding the eauDispo , which as this point is the water available from 1 ) rain , 2 ) irrigation for the day after estimation of intake by mulch , and 3 ) runoff . However , we do not allow surface_tank_stock to exceed 110 % of the surface_tank_capacity . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 27 # ! renaming stRuSurf to surface_tank_stock # // data [ \" stRuSurf \" ][ j :,:,:] = np . minimum ( data [ \" surface_tank_stock \" ][ j :,:,:] = np . minimum ( # // data [ \" stRuSurf \" ][ j ,:,:] + data [ \" eauDispo \" ][ j ,:,:], data [ \" surface_tank_stock \" ][ j ,:,:] + data [ \" eauDispo \" ][ j ,:,:], # ! renaming ruSurf to surface_tank_capacity # // 1 . 1 * data [ \" ruSurf \" ][ j ,:,:] 1 . 1 * data [ \" surface_tank_capacity \" ] ) return data update_surface_tank_stock_according_to_transpiration def update_surface_tank_stock_according_to_transpiration ( j , data ) This function updates the surface tank stock to reflect plant transpiration. if the root tank stock is above 0, then surface tank stock is updated by subtracting the plant transpiration modulated by the ratio between the transpirable water and the root tank stock. That is to say, the more transpirable water is close to the root tank stock, the more of transpirated water by plant will be removed from surface tank stock. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_surface_tank_stock_according_to_transpiration ( j , data ) : \"\"\" This function updates the surface tank stock to reflect plant transpiration . if the root tank stock is above 0 , then surface tank stock is updated by subtracting the plant transpiration modulated by the ratio between the transpirable water and the root tank stock . That is to say , the more transpirable water is close to the root tank stock , the more of transpirated water by plant will be removed from surface tank stock . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 66 # ! renaming stRuSurf with surface_tank_stock # // data [ \" stRuSurf \" ][ j :,:,:] = np . where ( data [ \" surface_tank_stock \" ][ j :,:,:] = np . where ( # ! renaming stRur to surface_tank_stock # // data [ \" stRur \" ][ j ,:,:] > 0 , data [ \" root_tank_stock \" ][ j ,:,:] > 0 , # // np . maximum ( data [ \" stRuSurf \" ][ j ,:,:] - ( data [ \" tr \" ][ j ,:,:] * np . minimum ( data [ \" trSurf \" ][ j ,:,:] / data [ \" stRur \" ][ j ,:,:], 1 )) , 0 ) , # ! renaming stRuSurf with surface_tank_stock # // np . maximum ( data [ \" stRuSurf \" ][ j ,:,:] - ( data [ \" tr \" ][ j ,:,:] * np . minimum ( data [ \" trSurf \" ][ j ,:,:] / data [ \" root_tank_stock \" ][ j ,:,:], 1 )) , 0 ) , np . maximum ( data [ \" surface_tank_stock \" ][ j ,:,:] - \\ ( data [ \" tr \" ][ j ,:,:] * np . minimum ( data [ \" trSurf \" ][ j ,:,:] / data [ \" root_tank_stock \" ][ j ,:,:], 1 )) , 0 , ) , # // data [ \" stRuSurf \" ][ j ,:,:], data [ \" surface_tank_stock \" ][ j ,:,:], ) return data update_total_tank_stock def update_total_tank_stock ( j , data ) This functions updates the value of total_tank_stock with the value of transpirable water. ? why incrementing stTot by eauTranspi ? ? we then consider that transpirable water is the water that fills the total_tank_stock ? Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock ( j , data ) : \"\"\" This functions updates the value of total_tank_stock with the value of transpirable water . ? why incrementing stTot by eauTranspi ? ? we then consider that transpirable water is the water that fills the total_tank_stock ? Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 29 # ! renaming stTot with total_tank_stock # // data [ \" stTot \" ][ j :,:,:] = ( data [ \" stTot \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:] ) . copy () #[..., np . newaxis ] data [ \" total_tank_stock \" ][ j :,:,:] = ( data [ \" total_tank_stock \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:] ) return data update_total_tank_stock_step_2 def update_total_tank_stock_step_2 ( j , data ) This function performs the second update of total_tank_stock/stTot/stRu in the reservoir filling wrapper function. It will increase the total_tank_stock depending on the variation of transpirable water and height of humectation front. test image markdown In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day, then total_tank_stock takes delta_total_tank_stock as value. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we increase the value of total_tank_stock by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock will remain unchanged, and if the root tank is full, total_tank_stock will be increased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock_step_2 ( j , data ) : \"\"\" This function performs the second update of total_tank_stock / stTot / stRu in the reservoir filling wrapper function . It will increase the total_tank_stock depending on the variation of transpirable water and height of humectation front . test image markdown ! [ Drag Racing ]( Dragster . jpg ) In this function , if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), if the depth of humectation front ( hum ) is above the root_tank_capacity_previous_season ( condition 1 passed , and 2 failed , which should be the case for most of the simulations that will be single - season ), and if the depth of humectation front ( hum ) has decreased since the previous day , then total_tank_stock takes delta_total_tank_stock as value . If the depth of humectation front did not change or increased since the previous day ( humPrec ), then total_tank_stock is unchanged . Notably , root_tank_capacity_previous_season is initialized at 0 , and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity . humPrec is initialized with the same value as hum . However , in the update_humPrec_for_end_of_cycle function , at the day of transition between phase 7 and phase 0 , it takes hum as value , with a minimum bound of surface_tank_capacity . Starting from second simulation season ( root_tank_capacity_previous_season != 0 ), if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), and if the depth of humectation front stays below or equel to the total soil capacity ( conditions 1 and 2 passed ), then we increase the value of total_tank_stock by a the difference of water height between the variation of total tank stock ( delta_total_tank_stock ) and the depth of humectation front ( hum ), proportionally to the filling of the root tank capacity of previous season ( stRurPrec ). Thus , if the root tank is empty , total_tank_stock will remain unchanged , and if the root tank is full , total_tank_stock will be increased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) #! renaming stTot to total_tank_stock # // data[\"stTot\"][j:,:,:] = np.where( data [ \"total_tank_stock\" ][ j : , : , : ] = np . where ( condition_1 , np . where ( #! condition_2 , #! we replace stRurPrec with stRur at indice j-1 #! renaming stRur to root_tank_stock #! renaming stTot to total_tank_stock #! renaming stRuVar with delta_total_tank_stock # // data[\"stTot\"][j,:,:] + (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:], data [ \"total_tank_stock\" ][ j , : , : ] + ( data [ \"delta_total_tank_stock\" ][ j , : , : ] - data [ \"hum\" ][ j , : , : ]) * data [ \"stRurPrec\" ][ j , : , : ], np . where ( condition_3 , #! renaming stRuVar with delta_total_tank_stock # //data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j , : , : ], #! renaming stTot to total_tank_stock # // data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j , : , : ], ), ), #! renaming stTot to total_tank_stock # // data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j , : , : ], ) return data update_total_tank_stock_step_3 def update_total_tank_stock_step_3 ( j , data ) This function updates the total tank stock where these is overflow occuring. When capacity of total tank is exceeded, it corrects the stock value with maximum capacity of total tank. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock_step_3 ( j , data ) : \"\"\" This function updates the total tank stock where these is overflow occuring . When capacity of total tank is exceeded , it corrects the stock value with maximum capacity of total tank . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // condition = ( data [ \" stTot \" ][ j ,:,:] > data [ \" stRuMax \" ][ j ,:,:] ) condition = condition_total_tank_overflow ( j , data ) # groupe 37 # essais stTot # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // data [ \" stRu \" ][ j ,:,:] = np . where ( # // data [ \" stTot \" ][ j :,:,:] = np . where ( data [ \" total_tank_stock \" ][ j :,:,:] = np . where ( condition , # // data [ \" stRuMax \" ][ j ,:,:], data [ \" total_tank_capacity \" ][ j ,:,:], # data [ \" stRu \" ][ j ,:,:], # // data [ \" stTot \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:], ) #[..., np . newaxis ] return data update_total_tank_stock_with_transpiration def update_total_tank_stock_with_transpiration ( j , data ) View Source def update_total_tank_stock_with_transpiration ( j , data ) : # data [ \" stRu \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRu \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) # essais stTot # group 68 # ! renaming stTot to total_tank_stock # // data [ \" stTot \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stTot \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] data [ \" total_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] ## ok return data update_total_tank_stock_with_water_consumption def update_total_tank_stock_with_water_consumption ( j , data ) This function updates the total tank stock by subtracting the lower water consumption value from estimate_water_consumption_from_root_tank_stock Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock_with_water_consumption ( j , data ) : \"\"\" This function updates the total tank stock by subtracting the lower water consumption value from estimate_water_consumption_from_root_tank_stock Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 62 # ! renaming stTot to total_tank_stock # // data [ \" stTot \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stTot \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" total_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) #[..., np . newaxis ] return data update_water_consumption_according_to_rooting def update_water_consumption_according_to_rooting ( j , data ) This function updates the water consumption consoRur according to rooting depth. If the root tank capacity is lower than the surface tank capacity, meaning than the roots did not dive into the deep tank yet, then the water consumption is updated to equal the evaporation at the prorata of the exploration of surface tank by the roots. Else, consoRur keeps it value, which was previously computed by estimate_water_consumption_from_root_tank_stock. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_water_consumption_according_to_rooting ( j , data ) : \"\"\" This function updates the water consumption consoRur according to rooting depth . If the root tank capacity is lower than the surface tank capacity , meaning than the roots did not dive into the deep tank yet , then the water consumption is updated to equal the evaporation at the prorata of the exploration of surface tank by the roots . Else , consoRur keeps it value , which was previously computed by estimate_water_consumption_from_root_tank_stock . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # fraction d ' eau evapore sur la part transpirable qd les racines sont moins # profondes que le reservoir de surface , mise a jour des stocks transpirables # group 63 data [ \" consoRur \" ][ j :,:,:] = np . where ( # ! renaming stRurMax with root_tank_capacity # ! renaming ruSurf with surface_tank_capacity # // data [ \" stRurMax \" ][ j ,:,:] < data [ \" ruSurf \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j :,:,:] < data [ \" surface_tank_capacity \" ], # ! renaming stRur to root_tank_stock # ! renaming ruSurf with surface_tank_capacity # // data [ \" evap \" ][ j ,:,:] * data [ \" stRur \" ][ j ,:,:] / data [ \" ruSurf \" ][ j ,:,:], data [ \" evap \" ][ j ,:,:] * data [ \" root_tank_stock \" ][ j ,:,:] / data [ \" surface_tank_capacity \" ], data [ \" consoRur \" ][ j ,:,:], ) return data","title":"Bilan Hydro"},{"location":"reference/sarra_py/bilan_hydro/#module-sarra_pybilan_hydro","text":"View Source import numpy as np import xarray as xr from sarra_py.bilan_carbo import estimate_kcp def InitPlotMc ( data , grid_width , grid_height , paramITK , paramTypeSol , duration ): \"\"\" Initializes variables related to crop residues boimass (mulch) in the data xarray dataset. This code has been adapted from the original InitPlotMc procedure, Bileau.pas code. Comments with tab indentation are from the original code. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. \"\"\" # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] #// data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock #// data[\"stTot\"] = data[\"stockIniProf\"] #//data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ] . expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock #// data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] return data def update_irrigation_tank_stock ( j , data ): \"\"\" Update the Irrigation Tank Stock In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged. Args: j (int): Index of time step in data data (xarray Dataset): Dataset that contains various data fields Returns: xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions. \"\"\" condition = ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) # group 1 #! renaming stockIrr with irrigation_tank_stock #//data[\"stockIrr\"][j, :, :] = np.where( data [ \"irrigation_tank_stock\" ][ j , :, :] = np . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// (data[\"stRurMax\"] < data[\"ruSurf\"]), ( data [ \"root_tank_capacity\" ] < data [ \"surface_tank_capacity\" ])[ j , :, :], #! renaming stRuSurf to surface_tank_stock #// data[\"stRuSurf\"][j, :, :], data [ \"surface_tank_stock\" ][ j , :, :], #! renaming stRur to root_tank_stock #// data[\"stRur\"][j, :, :], data [ \"root_tank_stock\" ][ j , :, :], ), data [ \"irrigation_tank_stock\" ][ j , :, :], ) return data def update_irrigation_tank_capacity ( j , data ): \"\"\" Update Irrigation Tank Capacity The function updates the maximum water capacity of irrigation tank based on the conditions specified in the function. If the automatic irrigation mode is ON, and if the current phase is between 0 and 6, and if the root tank capacity is less than the surface tank capacity, meaning that the roots have not reached the limit between the surface compartment and deep compartment, then the irrigation tank capacity is set to the surface tank capacity, which is given a minimum value equal to the surface tank capacity. Otherwise, the irrigation tank capacity remains unchanged. If we are in automatic irrigation mode, and between phases 0 and 6, and if root_tank_capacity is less than surface_tank_capacity, meaning that roots haven't reached the limit between the surface compartment and deep compartment, then we define irrigation_tank_capacity as equal to surface_tank_capacity, that is to say, we give to irrigation_tank_capacity a minimum value that equals surface_tank_capacity. else, we do not modify irrigation_tank_capacity value Args: j (int): Index of the time step being processed. data (xarray dataset): The input dataset containing all the information necessary to run the model. Returns: xarray dataset: The input dataset with updated values of the irrigation tank capacity. \"\"\" # group 2 condition = \\ ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) # renaming ruIrr with irrigation_tank_capacity #// data[\"ruIrr\"][j, :, :] = np.where( data [ \"irrigation_tank_capacity\" ][ j , :, :] = np . where ( condition , np . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// (data[\"stRurMax\"] < data[\"ruSurf\"]), data [ \"root_tank_capacity\" ][ j ,:,:] < data [ \"surface_tank_capacity\" ], #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ], #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ][ j ,:,:], ), data [ \"irrigation_tank_capacity\" ][ j , :, :], ) return data def compute_daily_irrigation ( j , data , paramITK ): \"\"\" Computes the Total Daily Irrigation (mm) If we are in the automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between the current volume of water in the irrigation tank (irrigation_tank_stock) and the total capacity of the irrigation tank (irrigation_tank_capacity), bounded by a minimum of 0 and a maximum of maxIrrig. This computed value represents the amount of water to be added to the irrigation tank. If the above conditions are not met, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need (irrigation) with the previous irrigation history of the day (irrigTotDay). irrigTotDay : \"total irrigation of the day, both from the irrigation history and the estimated irrigation need\" (mm) // irrigation_total_day if we are in automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between irrigation_tank_stock and irrigation_tank_capacity (that is to say, 90% of the volume needed to fill the irrigation tank), bounded by a minimum of 0 and a maximum of maxIrrig. Else, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need with the irrigation history of the day. Args: j: An integer representing the current day. data: A xarray dataset. paramITK: A dictionary of parameters. Returns: data: A xarray dataset with the updated irrigationTotDay field. \"\"\" #! renaming stockIrr with irrigation_tank_stock #! renaming ruIrr with irrigation_tank_capacity condition = ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) & \\ ( data [ \"irrigation_tank_stock\" ][ j , :, :] / data [ \"irrigation_tank_capacity\" ][ j ,:,:] \\ < paramITK [ \"irrigAutoTarget\" ]) # group 3 data [ \"irrigTotDay\" ][ j , :, :] = xr . where ( condition , np . minimum ( np . maximum ( 0 , # ! replacing correctedIrrigation by irrigation #! renaming stockIrr with irrigation_tank_stock #! renaming ruIrr with irrigation_tank_capacity # // ((data[\"ruIrr\"][j, :, :] - data[\"stockIrr\"][j, :, :]) * 0.9) - data[\"correctedIrrigation\"][j, :, :]), (( data [ \"irrigation_tank_capacity\" ][ j , :, :] - data [ \"irrigation_tank_stock\" ][ j , :, :]) * 0.9 ) \\ - data [ \"irrigation\" ][ j , :, :] ), paramITK [ \"maxIrrig\" ] ), 0 , ) # group 4 data [ \"irrigTotDay\" ][ j , :, :] = ( # ! replacing correctedIrrigation by irrigation # // data[\"correctedIrrigation\"][j, :, :] + data[\"irrigTotDay\"][j, :, :]).copy() data [ \"irrigation\" ][ j , :, :] + data [ \"irrigTotDay\" ][ j , :, :]) return data def EvalIrrigPhase ( j , data , paramITK ): \"\"\" Computes the irrigation state for a given day, including the size and filling of the irrigation tank and the irrigation demand. The computation of the irrigation state is based on the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). The water stock in the irrigation tank (stockIrr) and the maximum water capacity of the irrigation tank (ruIrr) are first calculated, with minimum boundaries determined by properties of the surface reservoir. The irrigation demand (irrigTotDay) is then computed. The irrigation tank stock and capacity are only computed to avoid issues with very shallow rooting, where the calculation of the filling of root_tank_capacity by root_tank_stock can be inappropriate and result in inadapted results for automatic irrigation. Note: In this irrigation management, the daily rainfall is not taken into account. Translated from the procedure EvalIrrigPhase, of the original Pascal codes bileau.pas and exmodules2.pas. In irrigAuto mode, this function computes the size and filling of the irrigation tank, and the irrigation demand, according to the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), and the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). It first calculates stockIrr, the water stock in the irrigation tank, and ruIrr, the maximum water capacity of irrigation tank. Both stockIrr and ruIrr are given minimum boundaries related to properties of the surface reservoir. Then, it calculates the irrigation demand, irrigTotDay. irrigation_tank_stock and irrigation_tank_capacity are only computed in order to avoid issues with very shallow rooting, where calculation of filling of root_tank_capacity by root_tank_stock can be inappropriate and lead to inadapted results for automatic irrigation Notes from CB, 2014 : Modification due \u00e0 la prise en compte effet Mulch Soit on a une irrigation observ\u00e9e, soit on calcul la dose d'irrigation Elle est calcul\u00e9e en fonction d'un seuil d'humidit\u00e9 (IrrigAutoTarget) et de possibilit\u00e9 technique ou choix (MaxIrrig, Precision) Dans cette gestion d'irrigation la pluie du jour n'est pas prise en compte N.B.: here, precision is not taken into account anymore Args: j (int): Index of the day for which the irrigation state is being computed. data (xarray.Dataset): The input data, including the arrays for irrigation and correctedIrrigation. paramITK (dict): The parameters for the ITK model. Returns: xarray.Dataset: The updated data, including the computed values for the irrigation state. \"\"\" # First, we store initial irrigation value of the day in the # correctedIrrigation array # ! it does not seem definition and use of correctedIrrigation is useful # ! instead we will just use the already defined irrigation array # // data[\"correctedIrrigation\"][j, :, :] = data[\"irrigation\"][j, :, :].copy(deep=True) data = update_irrigation_tank_stock ( j , data ) data = update_irrigation_tank_capacity ( j , data ) data = compute_daily_irrigation ( j , data , paramITK ) return data def calculate_total_water_availability ( j , data ): \"\"\" Calculates the total water available for a day by adding the rainfall and the irrigation. The total water available is computed by adding the rainfall for the day, which is stored in the \"rain\" array, and the total daily irrigation, which is stored in the \"irrigTotDay\" array. This calculation is performed to allow for subsequent calculations of the mulch filling and runoff. The mulch layer is considered to be directly under the rainfall and irrigation, which is represented by the \"irrigTotDay\" value. Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas This function computes the total water available for the day, by summing the rain and the irrigation. Notes from CB, 2014 : Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig, ici irrigTotDay qui est l'irrigation observ\u00e9e ou calcul\u00e9e, d'o\u00f9 on regroupe les deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement. Args: j (int): The index of the current day. data (xarray.Dataset): The data set containing information about the rainfall, irrigation, and water availability. Returns: xarray.Dataset: The data set with updated information about the total water availability for the current day. \"\"\" data [ \"eauDispo\" ][ j ,:,:] = data [ \"rain\" ][ j ,:,:] + data [ \"irrigTotDay\" ][ j ,:,:] return data def estimate_water_captured_by_mulch ( j , data , paramITK ): \"\"\" Determination of water gathered by the mulch (eauCaptee, mm): We determine the quantity of water gathered by mulch by multiplying the available water (eauDispo, from rain and irrigation, mm) with a exponential function of covering capacity of the considered mulch (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the fraction of soil covered by mulch. The value of eauCaptee is bounded by the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of water already present in it (stockMc, mm). Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 7 #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"eauCaptee\"][j,:,:] = np.minimum( data [ \"water_gathered_by_mulch\" ][ j ,:,:] = np . minimum ( data [ \"eauDispo\" ][ j ,:,:] * ( 1 - np . exp ( - paramITK [ \"surfMc\" ] / 1000 * data [ \"biomMc\" ][ j ,:,:])), #// (paramITK[\"humSatMc\"] * data[\"biomMc\"][j,:,:] / 10000) - data[\"stockMc\"][j,:,:], ( paramITK [ \"humSatMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 10000 ) - data [ \"mulch_water_stock\" ][ j ,:,:], ) return data def update_available_water_after_mulch_filling ( j , data ): \"\"\" Updating available water (eauDispo, mm) : As some water is gathered by the mulch, the available water is updated by subtracting the gathered water (eauCaptee, mm) from the total available water (eauDispo, mm). This value is bounded by 0, as the available water cannot be negative. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch # group 8 #// data[\"eauDispo\"][j:,:,:] = np.maximum(data[\"eauDispo\"][j,:,:] - data[\"eauCaptee\"][j,:,:], 0) # //[...,np.newaxis] data [ \"eauDispo\" ][ j :,:,:] = np . maximum ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"water_gathered_by_mulch\" ][ j ,:,:], 0 ) # //[...,np.newaxis] return data def update_mulch_water_stock ( j , data ): \"\"\" Updating water stock in mulch (stockMc, mm) : The water stock in mulch is updated by adding the gathered water (eauCaptee, mm) Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy # group 9 #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"stockMc\"][j:,:,:] = (data[\"stockMc\"][j,:,:] + data[\"eauCaptee\"][j,:,:]) # //[...,np.newaxis] data [ \"mulch_water_stock\" ][ j :,:,:] = ( data [ \"mulch_water_stock\" ][ j ,:,:] + data [ \"water_gathered_by_mulch\" ][ j ,:,:]) # //[...,np.newaxis] return data def RempliMc ( j , data , paramITK ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas wrapper function, updates water_gathered_by_mulch, eauDispo, and mulch_water_stock For more details, it is advised to refer to the works of Eric Scopel (UR AIDA), and the PhD dissertation of Fernando Maceina. Notes from CB, 2014 : Hypotheses : A chaque pluie, on estime la quantit\u00e9 d'eau pour saturer le couvert. On la retire \u00e0 l'eauDispo (pluie + irrig). On calcule la capacit\u00e9 maximum de stockage fonction de la biomasse et du taux de saturation rapport\u00e9e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1 mm = 1 litre d'eau / m2 1 mm = 10 tonnes d'eau / hectare = 10 000 kg/ha La biomasse est en kg/ha pour se rapporter \u00e0 la quantit\u00e9 de pluie capt\u00e9e en mm Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha \u00e0 humSat 2.8 kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit\u00e9 \u00e0 capter est fonction du taux de couverture du sol calcul\u00e9 comme le LTR SurfMc est sp\u00e9cifi\u00e9 en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On retire alors les mm d'eau capt\u00e9es \u00e0 la pluie incidente. Le ruisselement est ensuite calcul\u00e9 avec l'effet de contrainte du mulch group 10 \"\"\" data = estimate_water_captured_by_mulch ( j , data , paramITK ) data = update_available_water_after_mulch_filling ( j , data ) data = update_mulch_water_stock ( j , data ) return data def estimate_runoff ( j , data ): \"\"\" Evaluation of runoff (\"lame de ruissellement\", lr, mm) : If the quantity of rain (mm) is above the runoff threshold (seuilRuiss, mm), runoff is computed as the difference between the available water (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0. seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data Question : should runoff be computed taking in consideration water captured by mulch to account for mulch effect on runoff mitigation ? Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 11 data [ \"lr\" ][ j ,:,:] = xr . where ( data [ \"rain\" ][ j ,:,:] > data [ \"seuilRuiss\" ], ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"seuilRuiss\" ]) * data [ \"pourcRuiss\" ], 0 , ) return data def update_available_water_after_runoff ( j , data ): \"\"\" Updating available water (eauDispo, mm) : The available water is updated by subtracting the runoff (lr, mm) from the total available water (eauDispo, mm). This value is broadcasted onto the days axis. Args: j (_type_): _description_ data (_type_): _description_ \"\"\" # group 12 data [ \"eauDispo\" ][ j :,:,:] = ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"lr\" ][ j ,:,:]) return data def EvalRunOff ( j , data , paramTypeSol ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas, exmodules1.pas and exmodules2.pas Notes from CB, 2014 : On a regroup\u00e9 avant la pluie et l'irrigation (a cause de l'effet Mulch) si mulch on a enlev\u00e9 l'eau capt\u00e9e oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS Args: j (_type_): _description_ data (_type_): _description_ paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" data = estimate_runoff ( j , data ) data = update_available_water_after_runoff ( j , data ) return data def initialize_root_tank_capacity ( j , data , paramITK ): \"\"\" updating stRurMax/root_tank_capacity, step 1 : stRurMax, also called ruRac in some versions of the model, is the root_tank_capacity. At the phase change between phases 0 and 1 (initialisation), the maximum root water storage is initialised by multiplying the initial root depth (profRacIni, mm) with the soil water storage capacity (ru, mm/m). This value is broadcasted on the time series. For every other day in the cycle, the value remains unchanged. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 14 #! renaming stRurMax to root_tank_capacity #// data[\"stRurMax\"][j:,:,:] = np.where( data [ \"root_tank_capacity\" ][ j :,:,:] = xr . where ( ( data [ \"changePhase\" ][ j ,:,:] == 1 ) & ( data [ \"numPhase\" ][ j ,:,:] == 1 ), paramITK [ \"profRacIni\" ] / 1000 * data [ \"ru\" ], #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) return data def estimate_delta_root_tank_capacity ( j , data ): \"\"\" Updates daily root capacity variation (delta_root_tank_capacity, in mm water/day) based on the current phase of the plant, the daily root growth speed, and the drought stress coefficient. The daily root capacity variation is calculated as the product of soil water storage capacity (ru), the daily root growth speed (vRac), and a coefficient (cstr + 0.3). This coefficient is capped at 1.0. The daily root capacity variation is modulated by drought stress only when the root tank capacity is greater than the surface tank capacity and the current phase is strictly greater than 1 and at the day of phase change. If the root tank capacity is lower than the surface tank capacity or if the current phase is 1 or below or not at the day of phase change, the daily root capacity variation remains unchanged. The drought stress coefficient, cstr, measures the level of drought stress with 0 being full stress. The root growth speed is assumed to still occur during a drought stress as a matter of survival, with a certain level of tolerance given by the [0.3, 1] bound of the coefficient. Updating delta_root_tank_capacity / dayVrac (daily variation in water height accessible to roots, mm water/day) : At the day of phase change, for phases strictly above 1, and for which root_tank_capacity is greater than surface_tank_capacity, the variation of root tank capacity delta_root_tank_capacity is computed as the product of soil water storage capacity (ru, mm/m), the daily root growth speed (vRac, mm/day), and a coefficient, the latter being equal to the drought stress coefficient (cstr) plus 0.3, with a maximum bound of 1.0. That is to say, when the root_tank_capacity is greater than surface_tank_capacity, the root growth speed is modulated by drought stress. When root_tank_capacity is lower than surface_tank_capacity, the root growth speed is not modulated by drought stress. When we are not at the day of phase change, or if we are at phase of 1 and below, delta_root_change_capacity is unchanged. cstr is the drought stress coefficient, with a value of 0 meaning full stress. Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian BARON, this is based on the hypothesis that during a drought stress (cstr = 0), the plant will still grow roots as a matter of survival. Furthermore, using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr interval, there is no effect of drought stress on the root growth speed, allowing for a certain level of tolerance of the plant. Args: j (int): The current iteration step of the process. data (xarray.Dataset): The input data containing relevant information. Returns: xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored. \"\"\" # group 15 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & \\ # // np.invert((data[\"numPhase\"][j,:,:] == 1) & (data[\"changePhase\"][j,:,:] == 1)) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) #! renaming dayVrac to delta_root_tank_capacity #// data[\"dayVrac\"][j,:,:] = np.where( data [ \"delta_root_tank_capacity\" ][ j ,:,:] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity #// (data[\"stRurMax\"][j,:,:] > data[\"ruSurf\"][j,:,:]), ( data [ \"root_tank_capacity\" ][ j ,:,:] > data [ \"surface_tank_capacity\" ]), ( data [ \"vRac\" ][ j ,:,:] * np . minimum ( data [ \"cstr\" ][ j ,:,:] + 0.3 , 1.0 )) / 1000 * data [ \"ru\" ], data [ \"vRac\" ][ j ,:,:] / 1000 * data [ \"ru\" ], ), #// data[\"dayVrac\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ) return data def update_delta_root_tank_capacity ( j , data ): \"\"\" updating delta_root_tank_capacity : At the day of phase change, for phases strictly above 1, and for which the difference between the water height to humectation front (hum, mm) and the root_tank_capacity is less than the delta_root_tank_capacity, delta_root_tank_capacity is updated to be equal to the difference between the water height to humectation front and the root_tank_capacity. In other words, the change in root tank capacity delta_root_tank_capacity is limited by the water height to humectation front. For any other day or if root_tank_capacity is above delta_root_tank_capacity, delta_root_tank_capacity value is unchanged. Args: j (_type_): _description_ data (_type_): _description_ \"\"\" # group 16 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & \\ # // np.invert((data[\"numPhase\"][j,:,:] == 1) & (data[\"changePhase\"][j,:,:] == 1)) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) #! renaming deltaRur with delta_root_tank_capacity #// data[\"deltaRur\"][j:,:,:] = np.where( data [ \"delta_root_tank_capacity\" ][ j :,:,:] = np . where ( condition , np . where ( #! renaming stRurMax to root_tank_capacity #! renaming dayVrac to delta_root_tank_capacity #// (data[\"hum\"][j,:,:] - data[\"stRurMax\"][j,:,:]) < data[\"dayVrac\"][j,:,:], ( data [ \"hum\" ][ j ,:,:] - data [ \"root_tank_capacity\" ][ j ,:,:]) < data [ \"delta_root_tank_capacity\" ][ j ,:,:], #// data[\"hum\"][j,:,:] - data[\"stRurMax\"][j,:,:], data [ \"hum\" ][ j ,:,:] - data [ \"root_tank_capacity\" ][ j ,:,:], #! renaming dayVrac to delta_root_tank_capacity #// data[\"dayVrac\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ), #// data[\"deltaRur\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ) return data def update_root_tank_capacity ( j , data ): \"\"\" updating root_tank_capacity/stRurMax/ruRac, step 2 : At the day of phase change, for phases strictly above 1, root_tank_capacity is updated to be summed with the change in root water storage capacity delta_root_tank_capacity. In other words, root_tank_capacity is incremented by the change in root water storage capacity linked to root growth. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 17 # ! simplified conditions # // data[\"stRurMax\"][j:,:,:] = np.where( # // (data[\"numPhase\"][j,:,:] > 0), # // np.where( # // np.invert((data[\"changePhase\"][j,:,:] == 1) & (data[\"numPhase\"][j,:,:] == 1)), # // data[\"stRurMax\"][j,:,:] + data[\"deltaRur\"][j,:,:], # // data[\"stRurMax\"][j,:,:], # // ), # // data[\"stRurMax\"][j,:,:], # // )#[...,np.newaxis] #! renaming stRurMax to root_tank_capacity #! renaming deltaRur to delta_root_tank_capacity #// data[\"stRurMax\"][j:,:,:] = np.where( data [ \"root_tank_capacity\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), #// data[\"stRurMax\"][j,:,:] + data[\"deltaRur\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:] + data [ \"delta_root_tank_capacity\" ][ j ,:,:], #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) return data def update_root_tank_stock ( j , data ): \"\"\" updating root_tank_stock/stRur/stockrac : At the day of phase change, for phases strictly above 1, and for which the root_tank_capacity is above surface_tank_capacity (meaning that roots go beyond the surface water storage capacity), root_tank_stock is incremented by delta_root_tank_capacity. However, if root_tank_capacity is BELOW surface_tank_capacity (meaning that roots do not plunge into the deep reservoir), root_tank_stock is updated to be equal to surface_tank_stock minus 1/10th of the surface_tank_capacity, multiplied by the ratio between root_tank_capacity and surface_tank_capacity. That is to say \"we take at the prorata of depth and surface stock\". For any other day, root_tank_stock is unchanged. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 18 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & np.invert((data[\"changePhase\"][j,:,:] == 1) & (data[\"numPhase\"][j,:,:] == 1)), condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ), #! renaming stRur to root_tank_stock #// data[\"stRur\"][j:,:,:] = np.where( data [ \"root_tank_stock\" ][ j :,:,:] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity #// (data[\"stRurMax\"][j,:,:] > data[\"ruSurf\"][j,:,:]), ( data [ \"root_tank_capacity\" ][ j ,:,:] > data [ \"surface_tank_capacity\" ]), #! renaming stRur to root_tank_stock #! renaming deltaRur to delta_root_tank_capacity #// data[\"stRur\"][j,:,:] + data[\"deltaRur\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:] + data [ \"delta_root_tank_capacity\" ][ j ,:,:], #! renaming stRur to root_tank_stock #! renaming stRuSurf to surface_tank_stock #// np.maximum((data[\"stRuSurf\"][j,:,:] - data[\"ruSurf\"][j,:,:] * 1/10) * (data[\"stRurMax\"][j,:,:] / data[\"ruSurf\"][j,:,:]), 0), np . maximum (( data [ \"surface_tank_stock\" ][ j ,:,:] - data [ \"surface_tank_capacity\" ] * 1 / 10 ) * ( data [ \"root_tank_capacity\" ][ j ,:,:] / data [ \"surface_tank_capacity\" ]), 0 ), ) . expand_dims ( \"time\" , axis = 0 ), #! renaming stRur to root_tank_stock #// data[\"stRur\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:], ) return data def EvolRurCstr2 ( j , data , paramITK ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas Notes from CB, 10/06/2015 : Stress trop fort enracinement Trop d'effet de stress en tout d\u00e9but de croissance : 1) la plantule a des r\u00e9serves et favorise l'enracinement 2) dynamique sp\u00e9cifique sur le r\u00e9servoir de surface Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement est sup\u00e9rieur \u00e9 la profondeur du r\u00e9servoir de surface. Effet stres a un effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur la vitesse) La vitesse d'enracinement potentielle de la plante peut etre bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est convertie en quantite d'eau maximum equivalente IN: Vrac : mm (en mm/jour) : Vitesse racinaire journali\u00e8re \u00a7\u00a7 Daily root depth Hum : mm Quantit\u00e9 d'eau maximum jusqu'au front d'humectation \u00a7\u00a7 Maximum water capacity to humectation front StRuSurf : mm RU : mm/m RuSurf : mm/m INOUT: stRurMax : mm ==== ruRac stRur : mm ==== stockRac NB : on remet le nom de variables de CB plut\u00f4t que celles utilis\u00e9es par MC dans le code Java \"\"\" # ! dayvrac et deltarur reset \u00e0 chaque it\u00e9ration ; on traine donc le j sur les autres variables data = initialize_root_tank_capacity ( j , data , paramITK ) data = estimate_delta_root_tank_capacity ( j , data ) data = update_delta_root_tank_capacity ( j , data ) data = update_root_tank_capacity ( j , data ) data = update_root_tank_stock ( j , data ) return data ####################### list of functions for rempliRes ####################### def condition_end_of_cycle ( j , data ): \"\"\" Returns conditions needed to apply functions related to end of cycle. Returns: _type_: _description_ \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] == 7 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) return condition def update_humPrec_for_end_of_cycle ( j , data ): \"\"\" This function saves information about the humectation front depth at the end of a growth cycle so it can be used in the next cycle. humPrec is initialized in the function InitPlotMc, and set to be equal to hum, itself being initialized to take the maximum value between surface_tank_capacity, root_tank_capacity and total_tank_stock. At the harvest date (numPhase = 7), the humPrec variable is set to equal the highest value between hum (mm, humectation front depth) and surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (int): number of the day data (xarray dataset): _description_ Returns: xarray dataset: _description_ \"\"\" # group 20 condition = condition_end_of_cycle ( j , data ) data [ \"humPrec\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// np.maximum(data[\"hum\"][j,:,:], data[\"ruSurf\"][j,:,:]), np . maximum ( data [ \"hum\" ][ j ,:,:], data [ \"surface_tank_capacity\" ]), data [ \"humPrec\" ][ j ,:,:], ) return data def update_hum_for_end_of_cycle ( j , data ): \"\"\" This function updates information about the humectation front depth at the end of a growth cycle. At the harvest date (numPhase = 7), the hum variable is set to equal the surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 21 condition = condition_end_of_cycle ( j , data ) data [ \"hum\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// data[\"ruSurf\"][j,:,:], data [ \"surface_tank_capacity\" ], data [ \"hum\" ][ j ,:,:], ) return data def update_stRurMaxPrec_for_end_of_cycle ( j , data ): \"\"\" When the phase changes from 7 to 1, the stRurMaxPrec (mm, previous maximum water capacity to root front) is set to equal root_tank_capacity (mm). Value is broadcasted along time dimension. For every other day, it keeps its initial value of 0. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 22 condition = condition_end_of_cycle ( j , data ) #! renaming stRurMaxPrec to root_tank_capacity_previous_season #// data[\"stRurMaxPrec\"][j:,:,:] = np.where( data [ \"root_tank_capacity_previous_season\" ][ j :,:,:] = np . where ( condition , #! renaming stRurMax to root_tank_capacity #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], #! renaming stRurMaxPrec to root_tank_capacity_previous_season #// data[\"stRurMaxPrec\"][j,:,:], data [ \"root_tank_capacity_previous_season\" ][ j ,:,:], ) return data def update_stRurPrec_for_end_of_cycle ( j , data ): \"\"\" when the phase changes from 7 to 1, stRurPrec is set to equal stRur/stRurMax, that is to say the ratio of the water storage capacity of the root reservoir. Otherwise, it stays at its initial value of 0. Its value is broadcasted along j. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 23 condition = condition_end_of_cycle ( j , data ) data [ \"stRurPrec\" ][ j :,:,:] = np . where ( condition , #! renaming stRur to root_tank_stock #! renaming stRurMax to root_tank_capacity #// data[\"stRur\"][j,:,:]/data[\"stRurMax\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:] / data [ \"root_tank_capacity\" ][ j ,:,:], data [ \"stRurPrec\" ][ j ,:,:], ) return data def update_stRuPrec_for_end_of_cycle ( j , data ): \"\"\" when the phase changes from 7 to 1, the stRuPrec (mm, previous water storage capacity of the global reservoir) is set to equal the differe,ce between stTot (mm, total water storage capacity of the global reservoir) and stRurSurf (mm, water storage capacity of the surface reservoir) Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 24 #! stRurSurf is not defined... we may want to drop this group condition = condition_end_of_cycle ( j , data ) #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuPrec\"][j:,:,:] = np.where( data [ \"total_tank_stock_previous_value\" ][ j :,:,:] = np . where ( condition , #! renaming stTot to total_tank_stock #! renaming stRuSurf with surface_tank_stock #// data[\"stRu\"][j,:,:] - data[\"stRurSurf\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"surface_tank_stock\" ][ j ,:,:], # essai stTot #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j ,:,:], ) return data def reset_total_tank_capacity ( j , data ): \"\"\" This function resets the value total_tank_capacity/stRuMax at each loop. ? Why redfining stRuMax at each loop ? Neither ru, profRu ? nor total_tank_capacity are modified during the simulation. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 25 #! renaming stRuMax to total_tank_capacity #// data[\"stRuMax\"][j:,:,:] = (data[\"ru\"] * data[\"profRu\"] / 1000) #.copy()#[...,np.newaxis] data [ \"total_tank_capacity\" ][ j :,:,:] = ( data [ \"ru\" ] * data [ \"profRu\" ] / 1000 ) return data def update_surface_tank_stock ( j , data ): \"\"\" This function updates the value of surface_tank_stock. We update surface_tank_stock by adding the eauDispo, which as this point is the water available from 1) rain, 2) irrigation for the day after estimation of intake by mulch, and 3) runoff. However, we do not allow surface_tank_stock to exceed 110% of the surface_tank_capacity. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 27 #! renaming stRuSurf to surface_tank_stock #// data[\"stRuSurf\"][j:,:,:] = np.minimum( data [ \"surface_tank_stock\" ][ j :,:,:] = np . minimum ( #// data[\"stRuSurf\"][j,:,:] + data[\"eauDispo\"][j,:,:], data [ \"surface_tank_stock\" ][ j ,:,:] + data [ \"eauDispo\" ][ j ,:,:], #! renaming ruSurf to surface_tank_capacity #// 1.1 * data[\"ruSurf\"][j,:,:] 1.1 * data [ \"surface_tank_capacity\" ] ) return data def estimate_transpirable_water ( j , data ): \"\"\" This function estimates the daily volume of transpirable water. eauTranspi (mm, water transpirable) is the water available for transpiration from the surface reservoir. If surface_tank_stock at the end of the previous day (index j-1) is lower than 10% of the surface_tank_capacity, the water available for transpirable water equals the water available for the day (eauDispo), minus the difference between 1/10th of the surface_tank_capacity and surface_tank_stock. This transpirable water has a min bound at 0 mm. Said otherwise, a part of the water available for the day (eauDispo) is considered as bound to the surface reservoir and cannot be transpired. If surface_tank_stock at the end of the previous day (index j-1) is upper than 10% of the surface_tank_capacity, transpirable water equals eauDispo. Remark : if the use of j-1 indices is too problematic, it seems feasible to run this function just before update_surface_tank_stock. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 28 data [ \"eauTranspi\" ][ j ,:,:] = np . where ( # ! modifying to replace stRuSurfPrec by stRuSurf at undex j-1 #! renaming ruSurf to surface_tank_capacity #! renaming stRuSurfPrec to surface_tank_stock # // data[\"stRuSurfPrec\"][j,:,:] < data[\"ruSurf\"][j,:,:]/10, data [ \"surface_tank_stock\" ][ j - 1 ,:,:] < 0.1 * data [ \"surface_tank_capacity\" ], np . maximum ( 0 , # ! modifying to replace stRuSurfPrec by stRuSurf at iundex j-1 #! renaming ruSurf to surface_tank_capacity #! renaming stRuSurf to surface_tank_stock # //data[\"eauDispo\"][j,:,:] - (data[\"ruSurf\"][j,:,:]/10 - data[\"stRuSurfPrec\"][j,:,:]) data [ \"eauDispo\" ][ j ,:,:] - ( 0.1 * data [ \"surface_tank_capacity\" ] - data [ \"surface_tank_stock\" ][ j - 1 ,:,:]) ), data [ \"eauDispo\" ][ j ,:,:], ) return data def update_total_tank_stock ( j , data ): \"\"\" This functions updates the value of total_tank_stock with the value of transpirable water. ? why incrementing stTot by eauTranspi ? ? we then consider that transpirable water is the water that fills the total_tank_stock ? Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 29 #! renaming stTot with total_tank_stock #// data[\"stTot\"][j:,:,:] = (data[\"stTot\"][j,:,:] + data[\"eauTranspi\"][j,:,:]).copy()#[...,np.newaxis] data [ \"total_tank_stock\" ][ j :,:,:] = ( data [ \"total_tank_stock\" ][ j ,:,:] + data [ \"eauTranspi\" ][ j ,:,:]) return data def update_delta_total_tank_stock ( j , data ): \"\"\" This function estimates delta_total_tank_stock delta_total_tank_stock is the positive variation of transpirable water stock. It is computed as the difference between the total_tank_stock and stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is initialized to be equal to total_tank_stock at the beginning of the simulation. total_tank_stock is initialized with stockIrr parameter. Thus, simulations should start with a 0 value. stRuPrec is updated at each cycle with the update_struprec function. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 30 #! we propose a different version based on stTot #! renaming stTot to total_tank_stock #! renaming stRuVar to delta_total_tank_stock #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuVar\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"stRuPrec\"][j,:,:])[...,np.newaxis] data [ \"delta_total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"total_tank_stock_previous_value\" ][ j ,:,:]) return data def conditions_rempliRes ( j , data ): \"\"\"_summary_ Returns: _type_: _description_ \"\"\" #! renaming stRuVar with delta_total_tank_stock #//condition_1 = (data[\"stRuVar\"][j,:,:] > data[\"hum\"][j,:,:]) condition_1 = ( data [ \"delta_total_tank_stock\" ][ j ,:,:] > data [ \"hum\" ][ j ,:,:]) #! renaming stRurMaxPrec to root_tank_capacity_previous_season #// condition_2 = (data[\"hum\"][j,:,:] <= data[\"stRurMaxPrec\"][j,:,:]) condition_2 = ( data [ \"hum\" ][ j ,:,:] <= data [ \"root_tank_capacity_previous_season\" ][ j ,:,:]) #! we replace humPrec by hum with indice j-1 #// condition_3 = (data[\"hum\"][j,:,:] < data[\"humPrec\"][j,:,:]) condition_3 = ( data [ \"hum\" ][ j ,:,:] < data [ \"humPrec\" ][ j ,:,:]) return condition_1 , condition_2 , condition_3 def update_total_tank_stock_step_2 ( j , data ): \"\"\" This function performs the second update of total_tank_stock/stTot/stRu in the reservoir filling wrapper function. It will increase the total_tank_stock depending on the variation of transpirable water and height of humectation front. test image markdown ![Drag Racing](Dragster.jpg) In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day, then total_tank_stock takes delta_total_tank_stock as value. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we increase the value of total_tank_stock by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock will remain unchanged, and if the root tank is full, total_tank_stock will be increased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) #! renaming stTot to total_tank_stock #// data[\"stTot\"][j:,:,:] = np.where( data [ \"total_tank_stock\" ][ j :,:,:] = np . where ( condition_1 , np . where ( #! condition_2 , #! we replace stRurPrec with stRur at indice j-1 #! renaming stRur to root_tank_stock #! renaming stTot to total_tank_stock #! renaming stRuVar with delta_total_tank_stock #// data[\"stTot\"][j,:,:] + (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:] + ( data [ \"delta_total_tank_stock\" ][ j ,:,:] - data [ \"hum\" ][ j ,:,:]) * data [ \"stRurPrec\" ][ j ,:,:], np . where ( condition_3 , #! renaming stRuVar with delta_total_tank_stock #//data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:], #! renaming stTot to total_tank_stock #// data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:], ), ), #! renaming stTot to total_tank_stock #// data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:], ) return data def update_stRuPrec ( j , data ): \"\"\" This function performs the update of total_tank_stock_previous_value/stRuPrec in the reservoir filling wrapper function. It will decrease the total_tank_stock_previous_value depending on the variation of transpirable water and height of humectation front. test image markdown ![Drag Racing](Dragster.jpg) In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day (condition 3 passed), then total_tank_stock_previous_value equals 0. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock_previous_value is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we decrease the value of total_tank_stock_previous_value by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock_previous_value will remain unchanged, and if the root tank is full, total_tank_stock_previous_value will be decreased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # group 32 #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"][j:,:,:] = np.where( data [ \"total_tank_stock_previous_value\" ][ j :,:,:] = np . where ( condition_1 , np . where ( condition_2 , #! replacing stRurPrec with ratio formula #! renaming stRuVar with delta_total_tank_stock #! renaming stRuPrec with total_tank_stock_previous_value #//np.maximum(0, data[\"stRuPrec\"][j,:,:] - (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:]), np . maximum ( 0 , data [ \"total_tank_stock_previous_value\" ][ j ,:,:] - ( data [ \"delta_total_tank_stock\" ][ j ,:,:] - data [ \"hum\" ][ j ,:,:]) * data [ \"stRurPrec\" ][ j ,:,:]), np . where ( condition_3 , 0 , #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j ,:,:], ), ), #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j ,:,:], ) return data def update_delta_total_tank_stock_step_2 ( j , data ): \"\"\" Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # groupe 33 #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j:,:,:] = np.where( data [ \"delta_total_tank_stock\" ][ j :,:,:] = np . where ( condition_1 , np . where ( condition_2 , #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j,:,:] + (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:] + ( data [ \"delta_total_tank_stock\" ][ j ,:,:] - data [ \"hum\" ][ j ,:,:]) * data [ \"stRurPrec\" ][ j ,:,:], np . where ( condition_3 , #! renaming stRuVar with delta_total_tank_stock #! renaming stRuPrec with total_tank_stock_previous_value #// data[\"stRuVar\"][j,:,:] + data[\"stRuPrec\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:] + data [ \"total_tank_stock_previous_value\" ][ j ,:,:], #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:], ), ), #! renaming stRuVar with delta_total_tank_stock #// data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j ,:,:], ) return data def update_hum ( j , data ): \"\"\" This function updates the depth to humectation front (hum) to be the maximum value between the depth to humectation front (hum) and delta_total_tank_stock (that is to say depth of humectation front can only increase), bounded by total_tank_capacity (that is to say humectation front can not go deep indefinitely). Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 34 #! renaming stRuVar with delta_total_tank_stock #// data[\"hum\"][j:,:,:] = np.maximum(data[\"stRuVar\"][j,:,:], data[\"hum\"][j,:,:])#[...,np.newaxis] data [ \"hum\" ][ j :,:,:] = np . maximum ( data [ \"delta_total_tank_stock\" ][ j ,:,:], data [ \"hum\" ][ j ,:,:]) # groupe 35 #! renaming stRuMax to total_tank_capacity #// data[\"hum\"][j:,:,:] = np.minimum(data[\"stRuMax\"][j,:,:], data[\"hum\"][j,:,:])#[...,np.newaxis] data [ \"hum\" ][ j :,:,:] = np . minimum ( data [ \"total_tank_capacity\" ][ j ,:,:], data [ \"hum\" ][ j ,:,:]) return data def condition_total_tank_overflow ( j , data ): \"\"\"_summary_ Returns: _type_: _description_ \"\"\" condition = ( data [ \"total_tank_stock\" ][ j ,:,:] > data [ \"total_tank_capacity\" ][ j ,:,:]) return condition def update_dr ( j , data ): \"\"\" This function estimates the daily drainage (dr). When total tank overflows, it computes drainage from the differences between the total_tank_stock (that is to say the total and total_tank_capacity. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// condition = (data[\"stTot\"][j,:,:] > data[\"stRuMax\"][j,:,:]) condition = condition_total_tank_overflow ( j , data ) # groupe 36 # essais stTot data [ \"dr\" ][ j ,:,:] = np . where ( condition , #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// data[\"stRu\"][j,:,:] - data[\"stRuMax\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"total_tank_capacity\" ][ j ,:,:], 0 , ) return data def update_total_tank_stock_step_3 ( j , data ): \"\"\" This function updates the total tank stock where these is overflow occuring. When capacity of total tank is exceeded, it corrects the stock value with maximum capacity of total tank. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// condition = (data[\"stTot\"][j,:,:] > data[\"stRuMax\"][j,:,:]) condition = condition_total_tank_overflow ( j , data ) # groupe 37 # essais stTot #! renaming stTot to total_tank_stock #! renaming stRuMax to total_tank_capacity #// data[\"stRu\"][j,:,:] = np.where( #// data[\"stTot\"][j:,:,:] = np.where( data [ \"total_tank_stock\" ][ j :,:,:] = np . where ( condition , #// data[\"stRuMax\"][j,:,:], data [ \"total_tank_capacity\" ][ j ,:,:], # data[\"stRu\"][j,:,:], #// data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j ,:,:], ) #[...,np.newaxis] return data def update_hum_step_2 ( j , data ): \"\"\" We update the depth to humectation front (hum) again, to reflect eventual changes in total_tank_stock values. ? we could have placed the previous hum update function here Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 38 # // avant modif 10/06/2015 # data[\"hum\"][j:,:,:] = np.maximum(data[\"hum\"][j,:,:], data[\"stRu\"][j,:,:]) # essais stTot #! renaming stTot to total_tank_stock #// data[\"hum\"][j:,:,:] = np.maximum(data[\"hum\"][j,:,:], data[\"stTot\"][j,:,:])[...,np.newaxis] data [ \"hum\" ][ j :,:,:] = np . maximum ( data [ \"hum\" ][ j ,:,:], data [ \"total_tank_stock\" ][ j ,:,:]) #[...,np.newaxis] #! en conflit avec le calcul pr\u00e9c\u00e9dent de hum return data def update_root_tank_stock_step_2 ( j , data ): \"\"\" Finally, we update root tank stock (root_tank_stock) with the computed values First we increment root_tank_stock with transpirable water (eauTranspi), within the limits of root_tank_capacity. Then, we limit the value of root_tank_stock within total_tank_stock Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 39 # Rempli res racines #! renaming stRur to root_tank_stock #! renaming stRurMax to root_tank_capacity #// data[\"stRur\"][j:,:,:] = np.minimum(data[\"stRur\"][j,:,:] + data[\"eauTranspi\"][j,:,:], data[\"stRurMax\"][j,:,:])[...,np.newaxis] data [ \"root_tank_stock\" ][ j :,:,:] = np . minimum ( data [ \"root_tank_stock\" ][ j ,:,:] + data [ \"eauTranspi\" ][ j ,:,:], data [ \"root_tank_capacity\" ][ j ,:,:]) #[...,np.newaxis] # groupe 40 # essais stTot #! renaming stRur to root_tank_stock #! renaming stTot to total_tank_stock #// data[\"stRur\"][j,:,:] = np.minimum(data[\"stRur\"][j,:,:], data[\"stRu\"][j,:,:]) data [ \"root_tank_stock\" ][ j :,:,:] = np . minimum ( data [ \"root_tank_stock\" ][ j ,:,:], data [ \"total_tank_stock\" ][ j ,:,:]) #[...,np.newaxis] return data def rempliRes ( j , data ): \"\"\" Translated from the procedure rempliRes, of the original Pascal codes bileau.pas Main hypotheses : - the water dynamics is represented by a filling from the top and an evolution of the reservoirs sizes when the filling is above the maximum quantity of the current size (humectation front). - when the maximum size is reached by filling, it is considered as drainage. - inside a reservoir, water is distributed homogeneously (may be considered valid up to 2m depth, according to CB, from other sources). 3 reservoirs are represented: 1) a global reservoir, evolving in depth according to the humectation front 2) a surface reservoir (fixed size) where evaporation and a part of the transpiration occurs when roots are present 3) a root reservoir, evolving according to the root front (when roots are present) REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks Notes from CB, 10/06/2015 : prise en compte de stock d'eau r\u00e9silient pour les simulation continues Hypoth\u00e8se de la MAJ des stock en fn de l'eau r\ufffdsiliente de l'ann\ufffde pr\ufffdc\ufffddente dans le cas des simulations pluri annuelle en continue (NbAn = 1): A la r\ufffdcolte on recup\ufffdre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec) et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien. On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf) Si le StRu avec l'apport d'eau devinet sup au Hum alors on tient compte dans cette augmentation du stock r\ufffdsilient avec deux cas possible : Si StRu est < \ufffd stRurMaxprec alors on ajoute l'eau r\ufffdsiliente contenue dans l'ancienne zone racinaire en fn de la diff\ufffdrence de stock Sinon on a de l'eau r\ufffdsiliente au maximum de la CC jusqu'\ufffd l'ancienne HumPrec, on rempli alors StRu de la diff\ufffdrence etre ces deux valeurs puis on fait la MAJ des Dr, StRur, Hum etc... \"\"\" # section 1 : updating the end_of_cycle memory variables data = update_humPrec_for_end_of_cycle ( j , data ) data = update_hum_for_end_of_cycle ( j , data ) data = update_stRurMaxPrec_for_end_of_cycle ( j , data ) data = update_stRurPrec_for_end_of_cycle ( j , data ) data = update_stRuPrec_for_end_of_cycle ( j , data ) data = reset_total_tank_capacity ( j , data ) # verif ok # # filling the surface tank with available water data = update_surface_tank_stock ( j , data ) # verif ok # # estimates transpirable water data = estimate_transpirable_water ( j , data ) # verif ok # # increments total tank stock with transpirable water # # (meaning that total tank stock may represent a transpirable water tank) data = update_total_tank_stock ( j , data ) # verif ok # # estimating positive delta between total_root_tank and stRuPrec data = update_delta_total_tank_stock ( j , data ) # verif ok # # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged data = update_total_tank_stock_step_2 ( j , data ) # verif ok # # then total_tank_stock_previous_value can 1) take 0 or 2) be unchanged data = update_stRuPrec ( j , data ) #???? # # delta_total_tank_stock can 1) be incremented of total_tank_stock_previous_value or 2) be unchanged data = update_delta_total_tank_stock_step_2 ( j , data ) # # # here, in case 1, In this function, if the variation of transpirable water # # (delta_total_tank_stock) increases above the depth of humectation front # # (hum), if the depth of humectation front (hum) is above the # # root_tank_capacity_previous_season (condition 1 passed, and 2 failed, # # which should be the case for most of the simulations that will be # # single-season), and if the depth of humectation front (hum) has decreased # # since the previous day (condition 3 passed), then total_tank_stock takes the value of # # delta_total_tank_stock, total_tank_stock_previous_value equals 0, and # # delta_total_tank_stock is incremented by total_tank_stock_previous_value. # # # # in case 2, nothing happens. # # update_hum manages increase in hum data = update_hum ( j , data ) # # in case of overflowing... # # calculating drainage data = update_dr ( j , data ) # # limiting the total_tank_stock to the total_tank_capacity (when overflowing) data = update_total_tank_stock_step_3 ( j , data ) # # update again hum value, but we could merge functions with update_hum data = update_hum_step_2 ( j , data ) # # filling root_tank_stock with transpirable water, within the limits of total_tank_stock data = update_root_tank_stock_step_2 ( j , data ) return data ######################################################################################## def estimate_fesw ( j , data ): \"\"\" This function estimates the fraction of evaporable soil water (fesw, mm). fesw is defined as the ratio of water stock in the surface tank over 110% of the surface tank capacity. It is adapted from the EvalFESW procedure, from bileau.pas and bhytypeFAO.pas files from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! renaming stRuSurf to surface_tank_stock #! renaming ruSurf with surface_tank_capacity #// data[\"fesw\"][j,:,:] = data[\"stRuSurf\"][j,:,:] / (data[\"ruSurf\"][j,:,:] + data[\"ruSurf\"][j,:,:] / 10) data [ \"fesw\" ][ j ,:,:] = data [ \"surface_tank_stock\" ][ j ,:,:] / ( data [ \"surface_tank_capacity\" ] + 0.1 * data [ \"surface_tank_capacity\" ]) return data def estimate_kce ( j , data , paramITK ): \"\"\" This function estimates the coefficient of evaporation from the soil (kce). This approach takes into consideration three factors acting on limitation of kce : 1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover 2) Mulch - permanent covering effect : we consider a value of 1.0 for no covering, and 0.0 is full covering with plastic sheet ; this mulch parameter has been used in previous versions of the model where evolution of mulch biomass was not explicitely taken into consideration, can be used in the case of crops with self-mulching phenomena, where a standard mulch parameter value of 0.7 can be applied. 3) Mulch - evolutive covering effect BiomMc : biomass of mulch This function has been adapted from EvalKceMC procedure, bileau.pas and exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like it has been adapted from the dual crop coefficient from the FAO56 paper. But this is still to confirm on a point of view of the history of the model. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"kce\" ][ j ,:,:] = data [ \"ltr\" ][ j ,:,:] * paramITK [ \"mulch\" ] / 100 * \\ np . exp ( - paramITK [ \"coefMc\" ] * paramITK [ \"surfMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 1000 ) return data def estimate_soil_potential_evaporation ( j , data ): \"\"\" This function computes estimation of potential soil evaporation (mm, evapPot). It performs its computations solely from the evaporation forcing driven by climatic demand, limited by the coefficient of evaporation from the soil (kce). Note : difference in humectation of the top and bottom tanks is not taken into consideration in this approach. The This function has been adapted from DemandeSol procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 44 data [ \"evapPot\" ][ j ,:,:] = data [ \"ET0\" ][ j ,:,:] * data [ \"kce\" ][ j ,:,:] return data def estimate_soil_evaporation ( j , data ): \"\"\" This function computes estimation of soil evaporation (mm, evap). It uses the potential soil evaporation (evapPot) and the fraction of evaporable soil water (fesw), bounded by the surface tank stock. It has been adapted from the EvapRuSurf procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #! replacing stRuSurf by surface_tank_stock #// data[\"evap\"][j:,:,:] = np.minimum(data[\"evapPot\"][j,:,:] * data[\"fesw\"][j,:,:]**2, data[\"stRuSurf\"][j,:,:])[...,np.newaxis] data [ \"evap\" ][ j :,:,:] = np . minimum ( data [ \"evapPot\" ][ j ,:,:] * data [ \"fesw\" ][ j ,:,:] ** 2 , data [ \"surface_tank_stock\" ][ j ,:,:] ) return data def estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ): \"\"\" This function calculates the fraction of evaporable water from the mulch (FEMcW). If the mulch water stock is greater than 0, then we compute FEMcW, which we consider to be equal to the filling ratio of the mulch water capacity. We then update the mulch water stock by removing the water height equivalent to the climate forcing demand, modulated by FEMcW and the plant cover (ltr). This function is adapted from the procedure EvapMC, from bileau.pas and exmodules 2.pas file from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 45 data [ \"FEMcW\" ][ j ,:,:] = np . where ( #! replacing stockMc with mulch_water_stock #// data[\"stockMc\"][j,:,:] > 0, data [ \"mulch_water_stock\" ][ j ,:,:] > 0 , #! inverting the fraction to get stock over capacity, and not the other way round #// (paramITK[\"humSatMc\"] * data[\"biomMc\"][j,:,:] * 0.001) / data[\"stockMc\"][j,:,:], data [ \"mulch_water_stock\" ][ j ,:,:] / ( paramITK [ \"humSatMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 1000 ), data [ \"FEMcW\" ][ j ,:,:], ) # group 46 #! replacing stockMc with mulch_water_stock #// data[\"stockMc\"][j:,:,:] = np.maximum( data [ \"mulch_water_stock\" ][ j :,:,:] = np . maximum ( 0 , #! removing the power of 2 in the equation #// data[\"stockMc\"][j,:,:] - data[\"ltr\"][j,:,:] * data[\"ET0\"][j,:,:] * data[\"FEMcW\"][j,:,:]**2, data [ \"mulch_water_stock\" ][ j ,:,:] - ( data [ \"ltr\" ][ j ,:,:] * data [ \"ET0\" ][ j ,:,:] * data [ \"FEMcW\" ][ j ,:,:] ** 2 ), ) return data def estimate_ftsw ( j , data ): \"\"\" This function estimates the fraction of evaporable soil water (fesw) from the root reservoir. It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 & 2.pas, risocas.pas, riz.pas files from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" data [ \"ftsw\" ][ j :,:,:] = np . where ( #! renaming stRurMax to root_tank_capacity #// data[\"stRurMax\"][j,:,:] > 0, data [ \"root_tank_capacity\" ][ j ,:,:] > 0 , #! renaming stRur to root_tank_stock #! renaming stRurMax to root_tank_capacity #// data[\"stRur\"][j,:,:] / data[\"stRurMax\"][j,:,:], data [ \"root_tank_stock\" ][ j ,:,:] / data [ \"root_tank_capacity\" ][ j ,:,:], 0 , ) return data def estimate_potential_plant_transpiration ( j , data ): \"\"\" This function computes the potential transpiration from the plant. Computation is based on the climate forcing (ET0), as well as the kcp coefficient. This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and exmodules 1 & 2.pas files from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ggroup 51 data [ \"trPot\" ][ j ,:,:] = ( data [ \"kcp\" ][ j ,:,:] * data [ \"ET0\" ][ j ,:,:]) return data def estimate_kcTot ( j , data ): \"\"\" This function computes the total kc coefficient. Computation is based on the kcp (transpiration coefficient) and kce (evaporation from the soil) coefficients. Where the crop coefficient is 0 (meaning that there was no emergence yet), kcTot takes the value of kce. This function is based on the EvalKcTot procedure, from the bileau.pas and exmodules 1 & 2.pas files, from the original FORTRAN code. #! Note : code has been modified to match the original SARRA-H behavior. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # added a condition on 19/08/22 to match SARRA-H original behavior data [ \"kcTot\" ][ j ,:,:] = np . where ( data [ \"kcp\" ][ j ,:,:] == 0.0 , data [ \"kce\" ][ j ,:,:], data [ \"kce\" ][ j ,:,:] + data [ \"kcp\" ][ j ,:,:], ) return data def estimate_pFact ( j , data , paramVariete ): \"\"\"_summary_ This function computes the pFactor, which is a bound coefficient used in the computation of cstr from ftsw. This coefficient delimits the portion of the FTSW below which water stress starts to influence the transpiration. FAO reference for critical FTSW value for transpiration response (0 = stomata respond immediately if FTSW<1; 0.5 for most of the crops) pFact is bounded in [0.1, 0.8]. For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 53 data [ \"pFact\" ][ j :,:,:] = paramVariete [ \"PFactor\" ] + \\ 0.04 * ( 5 - np . maximum ( data [ \"kcp\" ][ j ,:,:], 1 ) * data [ \"ET0\" ][ j ,:,:]) # group 54 data [ \"pFact\" ][ j :,:,:] = np . minimum ( np . maximum ( 0.1 , data [ \"pFact\" ][ j ,:,:], ), 0.8 , ) return data def estimate_cstr ( j , data ): \"\"\" This function computes the water stress coefficient cstr. It uses ftsw and pFact. cstr is bounded in [0, 1]. This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" #group 55 data [ \"cstr\" ][ j :,:,:] = np . minimum (( data [ \"ftsw\" ][ j ,:,:] / ( 1 - data [ \"pFact\" ][ j ,:,:])), 1 ) # group 56 data [ \"cstr\" ][ j :,:,:] = np . maximum ( 0 , data [ \"cstr\" ][ j ,:,:]) return data def estimate_plant_transpiration ( j , data ): \"\"\" This function computes the transpiration from the plant. This function is based on the EvalTranspi procedure, from bileau.pas, bhytypeFAO.pas, exmodules 1 & 2.pas, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 58 data [ \"tr\" ][ j :,:,:] = ( data [ \"trPot\" ][ j ,:,:] * data [ \"cstr\" ][ j ,:,:]) return data def compute_evapotranspiration ( j , data , paramITK , paramVariete ): data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) return data def estimate_transpirable_surface_water ( j , data ): \"\"\" This function estimates the transpirable surface water. It removes 1/10th of surface tank capacity as water is condidered as bound. This function is based on the ConsoResSep procedure, from bileau.pas, exmodules 1 & 2.pas files, from the original FORTRAN code. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 59 #! replacing stRuSurf by surface_tank_stock #! renaming ruSurf with surface_tank_capacity #// data[\"trSurf\"][j:,:,:] = np.maximum(0, data[\"stRuSurf\"][j,:,:] - data[\"ruSurf\"][j,:,:] / 10)[...,np.newaxis] data [ \"trSurf\" ][ j :,:,:] = np . maximum ( 0 , data [ \"surface_tank_stock\" ][ j ,:,:] - data [ \"surface_tank_capacity\" ] * 0.1 , ) return data def apply_evaporation_on_surface_tank_stock ( j , data ): # qte d'eau evapore a consommer sur le reservoir de surface # group 60 #! replacing stRuSurf by surface_tank_stock #// data[\"stRuSurf\"][j:,:,:] = np.maximum(0, data[\"stRuSurf\"][j,:,:] - data[\"evap\"][j,:,:])[...,np.newaxis] data [ \"surface_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"surface_tank_stock\" ][ j ,:,:] - data [ \"evap\" ][ j ,:,:]) return data def estimate_water_consumption_from_root_tank_stock ( j , data ): \"\"\" This function estimates consoRur, which is the water to be consumed from the root tank stock. If soil evaporation (evap) is higher than transpirable surface water (trSurf), then consumption from root tank stock equals trSurf. Else, it equals evap. #? how to interpret this ? Args: j (_type_): _description_ data (_type_): _description_ \"\"\" data [ \"consoRur\" ][ j :,:,:] = np . where ( data [ \"evap\" ][ j ,:,:] > data [ \"trSurf\" ][ j ,:,:], data [ \"trSurf\" ][ j ,:,:], data [ \"evap\" ][ j ,:,:], ) return data def update_total_tank_stock_with_water_consumption ( j , data ): \"\"\" This function updates the total tank stock by subtracting the lower water consumption value from estimate_water_consumption_from_root_tank_stock Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 62 #! renaming stTot to total_tank_stock #// data[\"stTot\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"consoRur\"][j,:,:])[...,np.newaxis] data [ \"total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"consoRur\" ][ j ,:,:]) #[...,np.newaxis] return data def update_water_consumption_according_to_rooting ( j , data ): \"\"\" This function updates the water consumption consoRur according to rooting depth. If the root tank capacity is lower than the surface tank capacity, meaning than the roots did not dive into the deep tank yet, then the water consumption is updated to equal the evaporation at the prorata of the exploration of surface tank by the roots. Else, consoRur keeps it value, which was previously computed by estimate_water_consumption_from_root_tank_stock. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # fraction d'eau evapore sur la part transpirable qd les racines sont moins # profondes que le reservoir de surface, mise a jour des stocks transpirables # group 63 data [ \"consoRur\" ][ j :,:,:] = np . where ( #! renaming stRurMax with root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// data[\"stRurMax\"][j,:,:] < data[\"ruSurf\"][j,:,:], data [ \"root_tank_capacity\" ][ j :,:,:] < data [ \"surface_tank_capacity\" ], #! renaming stRur to root_tank_stock #! renaming ruSurf with surface_tank_capacity #// data[\"evap\"][j,:,:] * data[\"stRur\"][j,:,:] / data[\"ruSurf\"][j,:,:], data [ \"evap\" ][ j ,:,:] * data [ \"root_tank_stock\" ][ j ,:,:] / data [ \"surface_tank_capacity\" ], data [ \"consoRur\" ][ j ,:,:], ) return data def update_root_tank_stock_with_water_consumption ( j , data ): \"\"\" This function updates root tank stock according to water consumption. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 64 #! renaming stRur to root_tank_stock #// data[\"stRur\"][j:,:,:] = np.maximum(0, data[\"stRur\"][j,:,:] - data[\"consoRur\"][j,:,:])#[...,np.newaxis] data [ \"root_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"root_tank_stock\" ][ j ,:,:] - data [ \"consoRur\" ][ j ,:,:]) return data def update_plant_transpiration ( j , data ): \"\"\" reajustement de la qte transpirable considerant que l'evap a eu lieu avant mise a jour des stocks transpirables if plant transpiration is higher than the root tank stock, then plant transpiration is updated to be equal to the difference between the root tank stock and the plant transpiration. Else, its value is unmodified. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 65 data [ \"tr\" ][ j :,:,:] = np . where ( #! renaming stRur to root_tank_stock #// data[\"tr\"][j,:,:] > data[\"stRur\"][j,:,:], data [ \"tr\" ][ j ,:,:] > data [ \"root_tank_stock\" ][ j ,:,:], #// np.maximum(data[\"stRur\"][j,:,:] - data[\"tr\"][j,:,:], 0), np . maximum ( data [ \"root_tank_stock\" ][ j ,:,:] - data [ \"tr\" ][ j ,:,:], 0 ), data [ \"tr\" ][ j ,:,:], ) return data def update_surface_tank_stock_according_to_transpiration ( j , data ): \"\"\" This function updates the surface tank stock to reflect plant transpiration. if the root tank stock is above 0, then surface tank stock is updated by subtracting the plant transpiration modulated by the ratio between the transpirable water and the root tank stock. That is to say, the more transpirable water is close to the root tank stock, the more of transpirated water by plant will be removed from surface tank stock. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 66 #! renaming stRuSurf with surface_tank_stock #// data[\"stRuSurf\"][j:,:,:] = np.where( data [ \"surface_tank_stock\" ][ j :,:,:] = np . where ( #! renaming stRur to surface_tank_stock #// data[\"stRur\"][j,:,:] > 0, data [ \"root_tank_stock\" ][ j ,:,:] > 0 , #// np.maximum(data[\"stRuSurf\"][j,:,:] - (data[\"tr\"][j,:,:] * np.minimum(data[\"trSurf\"][j,:,:]/data[\"stRur\"][j,:,:], 1)), 0), #! renaming stRuSurf with surface_tank_stock #// np.maximum(data[\"stRuSurf\"][j,:,:] - (data[\"tr\"][j,:,:] * np.minimum(data[\"trSurf\"][j,:,:]/data[\"root_tank_stock\"][j,:,:], 1)), 0), np . maximum ( data [ \"surface_tank_stock\" ][ j ,:,:] - \\ ( data [ \"tr\" ][ j ,:,:] * np . minimum ( data [ \"trSurf\" ][ j ,:,:] / data [ \"root_tank_stock\" ][ j ,:,:], 1 )), 0 , ), #// data[\"stRuSurf\"][j,:,:], data [ \"surface_tank_stock\" ][ j ,:,:], ) return data def update_root_tank_stock_with_transpiration ( j , data ): \"\"\"_summary_ Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 67 #! renaming stRur to root_tank_stock #// data[\"stRur\"][j:,:,:] = np.maximum(0, data[\"stRur\"][j,:,:] - data[\"tr\"][j,:,:])#[...,np.newaxis] data [ \"root_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"root_tank_stock\" ][ j ,:,:] - data [ \"tr\" ][ j ,:,:]) #[...,np.newaxis] return data def update_total_tank_stock_with_transpiration ( j , data ): # data[\"stRu\"][j:,:,:] = np.maximum(0, data[\"stRu\"][j,:,:] - data[\"tr\"][j,:,:]) # essais stTot # group 68 #! renaming stTot to total_tank_stock #// data[\"stTot\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"tr\"][j,:,:])#[...,np.newaxis] data [ \"total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"tr\" ][ j ,:,:]) #[...,np.newaxis] ## ok return data def update_etr_etm ( j , data ): # group 69 data [ \"etr\" ][ j :,:,:] = ( data [ \"tr\" ][ j ,:,:] + data [ \"evap\" ][ j ,:,:]) . copy () #[...,np.newaxis] # group 70 data [ \"etm\" ][ j :,:,:] = ( data [ \"trPot\" ][ j ,:,:] + data [ \"evapPot\" ][ j ,:,:]) . copy () #[...,np.newaxis] return data def ConsoResSep ( j , data ): \"\"\" d'apr\u00e8s bileau.pas group 71 Separation de tr et evap. Consommation de l'eau sur les reservoirs Hypothese : l'evaporation est le processus le plus rapide, retranche en premier sur le reservoir de surface. Comme reservoir de surface et reservoirs racinaires se chevauchent, il nous faut aussi calcule sur le reservoir ayant des racines la part deja extraite pour l'evaporation. Quand la profondeur des racines est inferieur au reservoir de surface on ne consomme en evaporation que la fraction correspondant a cette profondeur sur celle du reservoir de surface (consoRur). Les estimations d'evaporation et de transpirations sont effectues separemment, on peut ainsi avoir une consommation legerement superieure a l'eau disponible. On diminuera donc la transpiration en consequence. Modif : Pour les stock d'eau on tient compte de la partie rajoutee au reservoir de surface qui ne peut etre que evapore (air dry) // Parametres IN: stRurMax : mm RuSurf : mm evap : mm trPot : mm evaPot : mm INOUT : stRuSurf : mm tr : mm stRur : mm stRu : mm OUT: etr : mm etm : mm \"\"\" data = estimate_transpirable_surface_water ( j , data ) data = apply_evaporation_on_surface_tank_stock ( j , data ) data = estimate_water_consumption_from_root_tank_stock ( j , data ) data = update_total_tank_stock_with_water_consumption ( j , data ) data = update_water_consumption_according_to_rooting ( j , data ) data = update_root_tank_stock_with_water_consumption ( j , data ) data = update_plant_transpiration ( j , data ) data = update_surface_tank_stock_according_to_transpiration ( j , data ) data = update_root_tank_stock_with_transpiration ( j , data ) data = update_total_tank_stock_with_transpiration ( j , data ) data = update_etr_etm ( j , data ) return data","title":"Module sarra_py.bilan_hydro"},{"location":"reference/sarra_py/bilan_hydro/#functions","text":"","title":"Functions"},{"location":"reference/sarra_py/bilan_hydro/#consoressep","text":"def ConsoResSep ( j , data ) d'apr\u00e8s bileau.pas group 71 Separation de tr et evap. Consommation de l'eau sur les reservoirs Hypothese : l'evaporation est le processus le plus rapide, retranche en premier sur le reservoir de surface. Comme reservoir de surface et reservoirs racinaires se chevauchent, il nous faut aussi calcule sur le reservoir ayant des racines la part deja extraite pour l'evaporation. Quand la profondeur des racines est inferieur au reservoir de surface on ne consomme en evaporation que la fraction correspondant a cette profondeur sur celle du reservoir de surface (consoRur). Les estimations d'evaporation et de transpirations sont effectues separemment, on peut ainsi avoir une consommation legerement superieure a l'eau disponible. On diminuera donc la transpiration en consequence. Modif : Pour les stock d'eau on tient compte de la partie rajoutee au reservoir de surface qui ne peut etre que evapore (air dry) // Parametres IN: stRurMax : mm RuSurf : mm evap : mm trPot : mm evaPot : mm INOUT : stRuSurf : mm tr : mm stRur : mm stRu : mm OUT: etr : mm etm : mm View Source def ConsoResSep ( j , data ) : \"\"\" d ' apr\u00e8s bileau.pas group 71 Separation de tr et evap . Consommation de l ' eau sur les reservoirs Hypothese : l ' evaporation est le processus le plus rapide, retranche en premier sur le reservoir de surface . Comme reservoir de surface et reservoirs racinaires se chevauchent , il nous faut aussi calcule sur le reservoir ayant des racines la part deja extraite pour l ' evaporation. Quand la profondeur des racines est inferieur au reservoir de surface on ne consomme en evaporation que la fraction correspondant a cette profondeur sur celle du reservoir de surface ( consoRur ) . Les estimations d ' evaporation et de transpirations sont effectues separemment , on peut ainsi avoir une consommation legerement superieure a l ' eau disponible. On diminuera donc la transpiration en consequence. Modif : Pour les stock d ' eau on tient compte de la partie rajoutee au reservoir de surface qui ne peut etre que evapore ( air dry ) // Parametres IN : stRurMax : mm RuSurf : mm evap : mm trPot : mm evaPot : mm INOUT : stRuSurf : mm tr : mm stRur : mm stRu : mm OUT : etr : mm etm : mm \"\"\" data = estimate_transpirable_surface_water ( j , data ) data = apply_evaporation_on_surface_tank_stock ( j , data ) data = estimate_water_consumption_from_root_tank_stock ( j , data ) data = update_total_tank_stock_with_water_consumption ( j , data ) data = update_water_consumption_according_to_rooting ( j , data ) data = update_root_tank_stock_with_water_consumption ( j , data ) data = update_plant_transpiration ( j , data ) data = update_surface_tank_stock_according_to_transpiration ( j , data ) data = update_root_tank_stock_with_transpiration ( j , data ) data = update_total_tank_stock_with_transpiration ( j , data ) data = update_etr_etm ( j , data ) return data","title":"ConsoResSep"},{"location":"reference/sarra_py/bilan_hydro/#evalirrigphase","text":"def EvalIrrigPhase ( j , data , paramITK ) Computes the irrigation state for a given day, including the size and filling of the irrigation tank and the irrigation demand. The computation of the irrigation state is based on the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). The water stock in the irrigation tank (stockIrr) and the maximum water capacity of the irrigation tank (ruIrr) are first calculated, with minimum boundaries determined by properties of the surface reservoir. The irrigation demand (irrigTotDay) is then computed. The irrigation tank stock and capacity are only computed to avoid issues with very shallow rooting, where the calculation of the filling of root_tank_capacity by root_tank_stock can be inappropriate and result in inadapted results for automatic irrigation. Note: In this irrigation management, the daily rainfall is not taken into account. Translated from the procedure EvalIrrigPhase, of the original Pascal codes bileau.pas and exmodules2.pas. In irrigAuto mode, this function computes the size and filling of the irrigation tank, and the irrigation demand, according to the irrigation target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), and the size and filling of the root zone (stRurMax, stRur) and the surface reservoir (stRuSurf, ruSurf). It first calculates stockIrr, the water stock in the irrigation tank, and ruIrr, the maximum water capacity of irrigation tank. Both stockIrr and ruIrr are given minimum boundaries related to properties of the surface reservoir. Then, it calculates the irrigation demand, irrigTotDay. irrigation_tank_stock and irrigation_tank_capacity are only computed in order to avoid issues with very shallow rooting, where calculation of filling of root_tank_capacity by root_tank_stock can be inappropriate and lead to inadapted results for automatic irrigation Notes from CB, 2014 : Modification due \u00e0 la prise en compte effet Mulch Soit on a une irrigation observ\u00e9e, soit on calcul la dose d'irrigation Elle est calcul\u00e9e en fonction d'un seuil d'humidit\u00e9 (IrrigAutoTarget) et de possibilit\u00e9 technique ou choix (MaxIrrig, Precision) Dans cette gestion d'irrigation la pluie du jour n'est pas prise en compte N.B.: here, precision is not taken into account anymore Parameters: Name Type Description Default j int Index of the day for which the irrigation state is being computed. None data xarray.Dataset The input data, including the arrays for irrigation and correctedIrrigation. None paramITK dict The parameters for the ITK model. None Returns: Type Description xarray.Dataset The updated data, including the computed values for the irrigation state. View Source def EvalIrrigPhase ( j , data , paramITK ) : \"\"\" Computes the irrigation state for a given day , including the size and filling of the irrigation tank and the irrigation demand . The computation of the irrigation state is based on the irrigation target ( irrigAutoTarget ) , the maximum irrigation capacity ( maxIrrig ) , the size and filling of the root zone ( stRurMax , stRur ) and the surface reservoir ( stRuSurf , ruSurf ) . The water stock in the irrigation tank ( stockIrr ) and the maximum water capacity of the irrigation tank ( ruIrr ) are first calculated , with minimum boundaries determined by properties of the surface reservoir . The irrigation demand ( irrigTotDay ) is then computed . The irrigation tank stock and capacity are only computed to avoid issues with very shallow rooting , where the calculation of the filling of root_tank_capacity by root_tank_stock can be inappropriate and result in inadapted results for automatic irrigation . Note : In this irrigation management , the daily rainfall is not taken into account . Translated from the procedure EvalIrrigPhase , of the original Pascal codes bileau . pas and exmodules2 . pas . In irrigAuto mode , this function computes the size and filling of the irrigation tank , and the irrigation demand , according to the irrigation target ( irrigAutoTarget ) , the maximum irrigation capacity ( maxIrrig ) , and the size and filling of the root zone ( stRurMax , stRur ) and the surface reservoir ( stRuSurf , ruSurf ) . It first calculates stockIrr , the water stock in the irrigation tank , and ruIrr , the maximum water capacity of irrigation tank . Both stockIrr and ruIrr are given minimum boundaries related to properties of the surface reservoir . Then , it calculates the irrigation demand , irrigTotDay . irrigation_tank_stock and irrigation_tank_capacity are only computed in order to avoid issues with very shallow rooting , where calculation of filling of root_tank_capacity by root_tank_stock can be inappropriate and lead to inadapted results for automatic irrigation Notes from CB , 2014 : Modification due \u00e0 la prise en compte effet Mulch Soit on a une irrigation observ \u00e9 e , soit on calcul la dose d ' irrigation Elle est calcul\u00e9e en fonction d ' un seuil d ' humidit \u00e9 ( IrrigAutoTarget ) et de possibilit \u00e9 technique ou choix ( MaxIrrig , Precision ) Dans cette gestion d ' irrigation la pluie du jour n ' est pas prise en compte N . B .: here , precision is not taken into account anymore Args : j ( int ) : Index of the day for which the irrigation state is being computed . data ( xarray . Dataset ) : The input data , including the arrays for irrigation and correctedIrrigation . paramITK ( dict ) : The parameters for the ITK model . Returns : xarray . Dataset : The updated data , including the computed values for the irrigation state . \"\"\" # First , we store initial irrigation value of the day in the # correctedIrrigation array # ! it does not seem definition and use of correctedIrrigation is useful # ! instead we will just use the already defined irrigation array # // data [ \" correctedIrrigation \" ][ j , :, :] = data [ \" irrigation \" ][ j , :, :]. copy ( deep = True ) data = update_irrigation_tank_stock ( j , data ) data = update_irrigation_tank_capacity ( j , data ) data = compute_daily_irrigation ( j , data , paramITK ) return data","title":"EvalIrrigPhase"},{"location":"reference/sarra_py/bilan_hydro/#evalrunoff","text":"def EvalRunOff ( j , data , paramTypeSol ) Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas, exmodules1.pas and exmodules2.pas Notes from CB, 2014 : On a regroup\u00e9 avant la pluie et l'irrigation (a cause de l'effet Mulch) si mulch on a enlev\u00e9 l'eau capt\u00e9e oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS Parameters: Name Type Description Default j type description None data type description None paramTypeSol type description None Returns: Type Description type description View Source def EvalRunOff ( j , data , paramTypeSol ) : \"\"\" Translated from the procedure PluieIrrig , of the original Pascal codes bileau . pas , exmodules1 . pas and exmodules2 . pas Notes from CB , 2014 : On a regroup\u00e9 avant la pluie et l ' irrigation ( a cause de l ' effet Mulch ) si mulch on a enlev\u00e9 l ' eau capt\u00e9e oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS Args: j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramTypeSol ( _type_ ) : _description_ Returns: _type_: _description_ \"\"\" data = estimate_runoff ( j , data ) data = update_available_water_after_runoff ( j , data ) return data","title":"EvalRunOff"},{"location":"reference/sarra_py/bilan_hydro/#evolrurcstr2","text":"def EvolRurCstr2 ( j , data , paramITK ) Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas Notes from CB, 10/06/2015 : Stress trop fort enracinement Trop d'effet de stress en tout d\u00e9but de croissance : 1) la plantule a des r\u00e9serves et favorise l'enracinement 2) dynamique sp\u00e9cifique sur le r\u00e9servoir de surface Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement est sup\u00e9rieur \u00e9 la profondeur du r\u00e9servoir de surface. Effet stres a un effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur la vitesse) La vitesse d'enracinement potentielle de la plante peut etre bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est convertie en quantite d'eau maximum equivalente IN: Vrac : mm (en mm/jour) : Vitesse racinaire journali\u00e8re \u00a7\u00a7 Daily root depth Hum : mm Quantit\u00e9 d'eau maximum jusqu'au front d'humectation \u00a7\u00a7 Maximum water capacity to humectation front StRuSurf : mm RU : mm/m RuSurf : mm/m INOUT: stRurMax : mm ==== ruRac stRur : mm ==== stockRac NB : on remet le nom de variables de CB plut\u00f4t que celles utilis\u00e9es par MC dans le code Java View Source def EvolRurCstr2 ( j , data , paramITK ): \"\"\" Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas Notes from CB, 10/06/2015 : Stress trop fort enracinement Trop d'effet de stress en tout d\u00e9but de croissance : 1) la plantule a des r\u00e9serves et favorise l'enracinement 2) dynamique sp\u00e9cifique sur le r\u00e9servoir de surface Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement est sup\u00e9rieur \u00e9 la profondeur du r\u00e9servoir de surface. Effet stres a un effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur la vitesse) La vitesse d'enracinement potentielle de la plante peut etre bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est convertie en quantite d'eau maximum equivalente IN: Vrac : mm (en mm/jour) : Vitesse racinaire journali\u00e8re \u00a7\u00a7 Daily root depth Hum : mm Quantit\u00e9 d'eau maximum jusqu'au front d'humectation \u00a7\u00a7 Maximum water capacity to humectation front StRuSurf : mm RU : mm/m RuSurf : mm/m INOUT: stRurMax : mm ==== ruRac stRur : mm ==== stockRac NB : on remet le nom de variables de CB plut\u00f4t que celles utilis\u00e9es par MC dans le code Java \"\"\" # ! dayvrac et deltarur reset \u00e0 chaque it\u00e9ration ; on traine donc le j sur les autres variables data = initialize_root_tank_capacity ( j , data , paramITK ) data = estimate_delta_root_tank_capacity ( j , data ) data = update_delta_root_tank_capacity ( j , data ) data = update_root_tank_capacity ( j , data ) data = update_root_tank_stock ( j , data ) return data","title":"EvolRurCstr2"},{"location":"reference/sarra_py/bilan_hydro/#initplotmc","text":"def InitPlotMc ( data , grid_width , grid_height , paramITK , paramTypeSol , duration ) Initializes variables related to crop residues boimass (mulch) in the data xarray dataset. This code has been adapted from the original InitPlotMc procedure, Bileau.pas code. Comments with tab indentation are from the original code. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. View Source def InitPlotMc ( data , grid_width , grid_height , paramITK , paramTypeSol , duration ): \"\"\" Initializes variables related to crop residues boimass (mulch) in the data xarray dataset. This code has been adapted from the original InitPlotMc procedure, Bileau.pas code. Comments with tab indentation are from the original code. As the rain is the first variable to be initialized in the data xarray dataset, its dimensions are used to initialize the other variables. \"\"\" # Soil maximum water storage capacity (mm) # Capacit\u00e9 maximale de la RU (mm) # StRurMax := Ru * ProfRacIni / 1000; #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"] = data[\"ru\"] * paramITK[\"profRacIni\"] / 1000 data [ \"root_tank_capacity\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"ru\" ] * paramITK [ \"profRacIni\" ] / 1000 )[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stRurMax\"].attrs = {\"units\": \"mm\", \"long_name\": \"Soil maximum water storage capacity\"} data [ \"root_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximum water storage capacity\" } # Maximum water capacity of surface tank (mm) # Reserve utile de l'horizon de surface (mm) # RuSurf := EpaisseurSurf / 1000 * Ru; #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"] = data[\"epaisseurSurf\"] / 1000 * data[\"ru\"] data [ \"surface_tank_capacity\" ] = data [ \"epaisseurSurf\" ] / 1000 * data [ \"ru\" ] #// data[\"ruSurf\"].attrs = {\"units\": \"mm\", \"long_name\": \"Maximum water capacity of surface tank\"} data [ \"surface_tank_capacity\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity of surface tank\" } # ? # // PfTranspi := EpaisseurSurf * HumPf; # // StTot := StockIniSurf - PfTranspi/2 + StockIniProf; # StTot := StockIniSurf + StockIniProf; # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniSurf\"] + paramTypeSol[\"stockIniProf\"])) #! modifi\u00e9 pour faire correspondre les r\u00e9sultats de simulation, \u00e0 remettre en place pour un calcul correct d\u00e8s que possible # data[\"stTot\"] = np.full((grid_width, grid_height, duration), (paramTypeSol[\"stockIniProf\"])) #! renaming stTot to total_tank_stock #// data[\"stTot\"] = data[\"stockIniProf\"] #//data[\"total_tank_stock\"] = data[\"stockIniProf\"] #! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time data [ \"total_tank_stock\" ] = ( data [ \"rain\" ] . dims , np . repeat ( np . array ( data [ \"stockIniProf\" ])[ np . newaxis ,:,:], duration , axis = 0 )) #// data[\"stTot\"].attrs = {\"units\": \"mm\", \"long_name\": \"?\"} data [ \"total_tank_stock\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"?\" } # Soil maximal depth (mm) # Profondeur maximale de sol (mm) # ProfRU := EpaisseurSurf + EpaisseurProf; data [ \"profRu\" ] = data [ \"epaisseurProf\" ] + data [ \"epaisseurSurf\" ] data [ \"profRu\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Soil maximal depth\" } # Maximum water capacity to humectation front (mm) # Quantit\u00e9 d'eau maximum jusqu'au front d'humectation (mm) # // modif 10/06/2015 resilience stock d'eau # // Front d'humectation egal a RuSurf trop de stress initial # // Hum := max(StTot, StRurMax); # Hum := max(RuSurf, StRurMax); # // Hum mis a profRuSurf # Hum := max(StTot, Hum); data [ \"hum\" ] = ( data [ \"rain\" ] . dims , np . full (( duration , grid_width , grid_height ), np . maximum ( np . maximum ( #! renaming ruSurf with surface_tank_capacity #// data[\"ruSurf\"], data [ \"surface_tank_capacity\" ] . expand_dims ({ \"time\" : duration }), #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"], data [ \"root_tank_capacity\" ], ), #! renaming stTot with total_tank_stock #// data[\"stTot\"], data [ \"total_tank_stock\" ], ) )) data [ \"hum\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"Maximum water capacity to humectation front\" } # Previous value for Maximum water capacity to humectation front (mm) # HumPrec := Hum; data [ \"humPrec\" ] = data [ \"hum\" ] # ? # StRurPrec := 0; # Previous value for stTot # StRurMaxPrec := 0; # //modif 10/06/2015 resilience stock d'eau #! renaming stTot with total_tank_stock #! renaminog stRuPrec with total_tank_stock_previous_value #// data[\"stRuPrec\"] = data[\"stTot\"] data [ \"total_tank_stock_previous_value\" ] = data [ \"total_tank_stock\" ] return data","title":"InitPlotMc"},{"location":"reference/sarra_py/bilan_hydro/#remplimc","text":"def RempliMc ( j , data , paramITK ) Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas wrapper function, updates water_gathered_by_mulch, eauDispo, and mulch_water_stock For more details, it is advised to refer to the works of Eric Scopel (UR AIDA), and the PhD dissertation of Fernando Maceina. Notes from CB, 2014 : Hypotheses : A chaque pluie, on estime la quantit\u00e9 d'eau pour saturer le couvert. On la retire \u00e0 l'eauDispo (pluie + irrig). On calcule la capacit\u00e9 maximum de stockage fonction de la biomasse et du taux de saturation rapport\u00e9e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1 mm = 1 litre d'eau / m2 1 mm = 10 tonnes d'eau / hectare = 10 000 kg/ha La biomasse est en kg/ha pour se rapporter \u00e0 la quantit\u00e9 de pluie capt\u00e9e en mm Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha \u00e0 humSat 2.8 kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit\u00e9 \u00e0 capter est fonction du taux de couverture du sol calcul\u00e9 comme le LTR SurfMc est sp\u00e9cifi\u00e9 en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On retire alors les mm d'eau capt\u00e9es \u00e0 la pluie incidente. Le ruisselement est ensuite calcul\u00e9 avec l'effet de contrainte du mulch group 10 View Source def RempliMc ( j , data , paramITK ) : \"\"\" Translated from the procedure PluieIrrig , of the original Pascal codes bileau . pas and exmodules2 . pas wrapper function , updates water_gathered_by_mulch , eauDispo , and mulch_water_stock For more details , it is advised to refer to the works of Eric Scopel ( UR AIDA ) , and the PhD dissertation of Fernando Maceina . Notes from CB , 2014 : Hypotheses : A chaque pluie , on estime la quantit \u00e9 d ' eau pour saturer le couvert. On la retire \u00e0 l ' eauDispo (pluie + irrig). On calcule la capacit\u00e9 maximum de stockage fonction de la biomasse et du taux de saturation rapport \u00e9 e en mm ( humSatMc en kg H2O / kg de biomasse ) . La pluie est en mm : 1 mm = 1 litre d ' eau / m2 1 mm = 10 tonnes d ' eau / hectare = 10 000 kg/ha La biomasse est en kg / ha pour se rapporter \u00e0 la quantit \u00e9 de pluie capt \u00e9 e en mm Kg H2O / kg Kg / ha et kg / m2 on divise par 10 000 ( pour 3000 kg / ha \u00e0 humSat 2 . 8 kg H2O / kg on a un stockage max de 0 . 84 mm de pluie ! ? ) Cette capacit \u00e9 \u00e0 capter est fonction du taux de couverture du sol calcul \u00e9 comme le LTR SurfMc est sp \u00e9 cifi \u00e9 en ha / t ( 0 . 39 ) , on rapporte en ha / kg en divisant par 1000 On retire alors les mm d ' eau capt\u00e9es \u00e0 la pluie incidente. Le ruisselement est ensuite calcul \u00e9 avec l ' effet de contrainte du mulch group 10 \"\"\" data = estimate_water_captured_by_mulch ( j , data , paramITK ) data = update_available_water_after_mulch_filling ( j , data ) data = update_mulch_water_stock ( j , data ) return data","title":"RempliMc"},{"location":"reference/sarra_py/bilan_hydro/#apply_evaporation_on_surface_tank_stock","text":"def apply_evaporation_on_surface_tank_stock ( j , data ) View Source def apply_evaporation_on_surface_tank_stock ( j , data ) : # qte d ' eau evapore a consommer sur le reservoir de surface # group 60 # ! replacing stRuSurf by surface_tank_stock # // data [ \" stRuSurf \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRuSurf \" ][ j ,:,:] - data [ \" evap \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" surface_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" surface_tank_stock \" ][ j ,:,:] - data [ \" evap \" ][ j ,:,:] ) return data","title":"apply_evaporation_on_surface_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#calculate_total_water_availability","text":"def calculate_total_water_availability ( j , data ) Calculates the total water available for a day by adding the rainfall and the irrigation. The total water available is computed by adding the rainfall for the day, which is stored in the \"rain\" array, and the total daily irrigation, which is stored in the \"irrigTotDay\" array. This calculation is performed to allow for subsequent calculations of the mulch filling and runoff. The mulch layer is considered to be directly under the rainfall and irrigation, which is represented by the \"irrigTotDay\" value. Translated from the procedure PluieIrrig, of the original Pascal codes bileau.pas and exmodules2.pas This function computes the total water available for the day, by summing the rain and the irrigation. Notes from CB, 2014 : Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig, ici irrigTotDay qui est l'irrigation observ\u00e9e ou calcul\u00e9e, d'o\u00f9 on regroupe les deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement. Parameters: Name Type Description Default j int The index of the current day. None data xarray.Dataset The data set containing information about the rainfall, irrigation, and water availability. None Returns: Type Description xarray.Dataset The data set with updated information about the total water availability for the current day. View Source def calculate_total_water_availability ( j , data ) : \"\"\" Calculates the total water available for a day by adding the rainfall and the irrigation . The total water available is computed by adding the rainfall for the day , which is stored in the \"rain\" array , and the total daily irrigation , which is stored in the \"irrigTotDay\" array . This calculation is performed to allow for subsequent calculations of the mulch filling and runoff . The mulch layer is considered to be directly under the rainfall and irrigation , which is represented by the \"irrigTotDay\" value . Translated from the procedure PluieIrrig , of the original Pascal codes bileau . pas and exmodules2 . pas This function computes the total water available for the day , by summing the rain and the irrigation . Notes from CB , 2014 : Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig , ici irrigTotDay qui est l ' irrigation observ\u00e9e ou calcul\u00e9e , d ' o\u00f9 on regroupe les deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement . Args: j ( int ) : The index of the current day . data ( xarray . Dataset ) : The data set containing information about the rainfall , irrigation , and water availability . Returns: xarray . Dataset: The data set with updated information about the total water availability for the current day . \"\"\" data [ \"eauDispo\" ][ j , : , : ] = data [ \"rain\" ][ j , : , : ] + data [ \"irrigTotDay\" ][ j , : , : ] return data","title":"calculate_total_water_availability"},{"location":"reference/sarra_py/bilan_hydro/#compute_daily_irrigation","text":"def compute_daily_irrigation ( j , data , paramITK ) Computes the Total Daily Irrigation (mm) If we are in the automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between the current volume of water in the irrigation tank (irrigation_tank_stock) and the total capacity of the irrigation tank (irrigation_tank_capacity), bounded by a minimum of 0 and a maximum of maxIrrig. This computed value represents the amount of water to be added to the irrigation tank. If the above conditions are not met, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need (irrigation) with the previous irrigation history of the day (irrigTotDay). irrigTotDay : \"total irrigation of the day, both from the irrigation history and the estimated irrigation need\" (mm) // irrigation_total_day if we are in automatic irrigation mode, and between phases 0 and 6, and if the filling of the irrigation tank is below the target filling value (irrigAutoTarget, decimal percentage), we first compute 90% of the difference between irrigation_tank_stock and irrigation_tank_capacity (that is to say, 90% of the volume needed to fill the irrigation tank), bounded by a minimum of 0 and a maximum of maxIrrig. Else, the computed value is 0. Then, we calculate the total irrigation of the day by summing the estimated irrigation need with the irrigation history of the day. Parameters: Name Type Description Default j None An integer representing the current day. None data None A xarray dataset. None paramITK None A dictionary of parameters. None Returns: Type Description data A xarray dataset with the updated irrigationTotDay field. View Source def compute_daily_irrigation ( j , data , paramITK ) : \"\"\" Computes the Total Daily Irrigation ( mm ) If we are in the automatic irrigation mode , and between phases 0 and 6 , and if the filling of the irrigation tank is below the target filling value ( irrigAutoTarget , decimal percentage ) , we first compute 90 % of the difference between the current volume of water in the irrigation tank ( irrigation_tank_stock ) and the total capacity of the irrigation tank ( irrigation_tank_capacity ) , bounded by a minimum of 0 and a maximum of maxIrrig . This computed value represents the amount of water to be added to the irrigation tank . If the above conditions are not met , the computed value is 0 . Then , we calculate the total irrigation of the day by summing the estimated irrigation need ( irrigation ) with the previous irrigation history of the day ( irrigTotDay ) . irrigTotDay : \" total irrigation of the day, both from the irrigation history and the estimated irrigation need \" (mm) // irrigation_total_day if we are in automatic irrigation mode , and between phases 0 and 6 , and if the filling of the irrigation tank is below the target filling value ( irrigAutoTarget , decimal percentage ) , we first compute 90 % of the difference between irrigation_tank_stock and irrigation_tank_capacity ( that is to say , 90 % of the volume needed to fill the irrigation tank ) , bounded by a minimum of 0 and a maximum of maxIrrig . Else , the computed value is 0 . Then , we calculate the total irrigation of the day by summing the estimated irrigation need with the irrigation history of the day . Args : j : An integer representing the current day . data : A xarray dataset . paramITK : A dictionary of parameters . Returns : data : A xarray dataset with the updated irrigationTotDay field . \"\"\" # ! renaming stockIrr with irrigation_tank_stock # ! renaming ruIrr with irrigation_tank_capacity condition = ( data [ \" irrigAuto \" ][ j , :, :] == True ) & \\ ( data [ \" numPhase \" ][ j , :, :] > 0 ) & \\ ( data [ \" numPhase \" ][ j , :, :] < 6 ) & \\ ( data [ \" irrigation_tank_stock \" ][ j , :, :] / data [ \" irrigation_tank_capacity \" ][ j ,:,:] \\ < paramITK [ \" irrigAutoTarget \" ] ) # group 3 data [ \" irrigTotDay \" ][ j , :, :] = xr . where ( condition , np . minimum ( np . maximum ( 0 , # ! replacing correctedIrrigation by irrigation # ! renaming stockIrr with irrigation_tank_stock # ! renaming ruIrr with irrigation_tank_capacity # // (( data [ \" ruIrr \" ][ j , :, :] - data [ \" stockIrr \" ][ j , :, :] ) * 0 . 9 ) - data [ \" correctedIrrigation \" ][ j , :, :] ) , (( data [ \" irrigation_tank_capacity \" ][ j , :, :] - data [ \" irrigation_tank_stock \" ][ j , :, :] ) * 0 . 9 ) \\ - data [ \" irrigation \" ][ j , :, :] ) , paramITK [ \" maxIrrig \" ] ) , 0 , ) # group 4 data [ \" irrigTotDay \" ][ j , :, :] = ( # ! replacing correctedIrrigation by irrigation # // data [ \" correctedIrrigation \" ][ j , :, :] + data [ \" irrigTotDay \" ][ j , :, :] ) . copy () data [ \" irrigation \" ][ j , :, :] + data [ \" irrigTotDay \" ][ j , :, :] ) return data","title":"compute_daily_irrigation"},{"location":"reference/sarra_py/bilan_hydro/#compute_evapotranspiration","text":"def compute_evapotranspiration ( j , data , paramITK , paramVariete ) View Source def compute_evapotranspiration ( j , data , paramITK , paramVariete ) : data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) return data","title":"compute_evapotranspiration"},{"location":"reference/sarra_py/bilan_hydro/#condition_end_of_cycle","text":"def condition_end_of_cycle ( j , data ) Returns conditions needed to apply functions related to end of cycle. Returns: Type Description type description View Source def condition_end_of_cycle ( j , data ) : \"\"\" Returns conditions needed to apply functions related to end of cycle . Returns : _type_ : _description_ \"\"\" condition = ( data [ \" numPhase \" ][ j ,:,:] == 7 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 ) return condition","title":"condition_end_of_cycle"},{"location":"reference/sarra_py/bilan_hydro/#condition_total_tank_overflow","text":"def condition_total_tank_overflow ( j , data ) summary Returns: Type Description type description View Source def condition_total_tank_overflow ( j , data ) : \"\"\" _summary_ Returns : _type_ : _description_ \"\"\" condition = ( data [ \" total_tank_stock \" ][ j ,:,:] > data [ \" total_tank_capacity \" ][ j ,:,:] ) return condition","title":"condition_total_tank_overflow"},{"location":"reference/sarra_py/bilan_hydro/#conditions_remplires","text":"def conditions_rempliRes ( j , data ) summary Returns: Type Description type description View Source def conditions_rempliRes ( j , data ) : \"\"\" _summary_ Returns : _type_ : _description_ \"\"\" # ! renaming stRuVar with delta_total_tank_stock # // condition_1 = ( data [ \" stRuVar \" ][ j ,:,:] > data [ \" hum \" ][ j ,:,:] ) condition_1 = ( data [ \" delta_total_tank_stock \" ][ j ,:,:] > data [ \" hum \" ][ j ,:,:] ) # ! renaming stRurMaxPrec to root_tank_capacity_previous_season # // condition_2 = ( data [ \" hum \" ][ j ,:,:] <= data [ \" stRurMaxPrec \" ][ j ,:,:] ) condition_2 = ( data [ \" hum \" ][ j ,:,:] <= data [ \" root_tank_capacity_previous_season \" ][ j ,:,:] ) # ! we replace humPrec by hum with indice j - 1 # // condition_3 = ( data [ \" hum \" ][ j ,:,:] < data [ \" humPrec \" ][ j ,:,:] ) condition_3 = ( data [ \" hum \" ][ j ,:,:] < data [ \" humPrec \" ][ j ,:,:] ) return condition_1 , condition_2 , condition_3","title":"conditions_rempliRes"},{"location":"reference/sarra_py/bilan_hydro/#estimate_femcw_and_update_mulch_water_stock","text":"def estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) This function calculates the fraction of evaporable water from the mulch (FEMcW). If the mulch water stock is greater than 0, then we compute FEMcW, which we consider to be equal to the filling ratio of the mulch water capacity. We then update the mulch water stock by removing the water height equivalent to the climate forcing demand, modulated by FEMcW and the plant cover (ltr). This function is adapted from the procedure EvapMC, from bileau.pas and exmodules 2.pas file from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) : \"\"\" This function calculates the fraction of evaporable water from the mulch ( FEMcW ) . If the mulch water stock is greater than 0 , then we compute FEMcW , which we consider to be equal to the filling ratio of the mulch water capacity . We then update the mulch water stock by removing the water height equivalent to the climate forcing demand , modulated by FEMcW and the plant cover ( ltr ) . This function is adapted from the procedure EvapMC , from bileau . pas and exmodules 2 . pas file from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 45 data [ \" FEMcW \" ][ j ,:,:] = np . where ( # ! replacing stockMc with mulch_water_stock # // data [ \" stockMc \" ][ j ,:,:] > 0 , data [ \" mulch_water_stock \" ][ j ,:,:] > 0 , # ! inverting the fraction to get stock over capacity , and not the other way round # // ( paramITK [ \" humSatMc \" ] * data [ \" biomMc \" ][ j ,:,:] * 0 . 001 ) / data [ \" stockMc \" ][ j ,:,:], data [ \" mulch_water_stock \" ][ j ,:,:] / ( paramITK [ \" humSatMc \" ] * data [ \" biomMc \" ][ j ,:,:] / 1000 ) , data [ \" FEMcW \" ][ j ,:,:], ) # group 46 # ! replacing stockMc with mulch_water_stock # // data [ \" stockMc \" ][ j :,:,:] = np . maximum ( data [ \" mulch_water_stock \" ][ j :,:,:] = np . maximum ( 0 , # ! removing the power of 2 in the equation # // data [ \" stockMc \" ][ j ,:,:] - data [ \" ltr \" ][ j ,:,:] * data [ \" ET0 \" ][ j ,:,:] * data [ \" FEMcW \" ][ j ,:,:] ** 2 , data [ \" mulch_water_stock \" ][ j ,:,:] - ( data [ \" ltr \" ][ j ,:,:] * data [ \" ET0 \" ][ j ,:,:] * data [ \" FEMcW \" ][ j ,:,:] ** 2 ) , ) return data","title":"estimate_FEMcW_and_update_mulch_water_stock"},{"location":"reference/sarra_py/bilan_hydro/#estimate_cstr","text":"def estimate_cstr ( j , data ) This function computes the water stress coefficient cstr. It uses ftsw and pFact. cstr is bounded in [0, 1]. This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_cstr ( j , data ) : \"\"\" This function computes the water stress coefficient cstr . It uses ftsw and pFact . cstr is bounded in [ 0 , 1 ]. This function is based on the CstrPFactor procedure , from bileau . pas , exmodules 1 & 2 . pas , risocas . pas files , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 55 data [ \" cstr \" ][ j :,:,:] = np . minimum (( data [ \" ftsw \" ][ j ,:,:] / ( 1 - data [ \" pFact \" ][ j ,:,:] )) , 1 ) # group 56 data [ \" cstr \" ][ j :,:,:] = np . maximum ( 0 , data [ \" cstr \" ][ j ,:,:] ) return data","title":"estimate_cstr"},{"location":"reference/sarra_py/bilan_hydro/#estimate_delta_root_tank_capacity","text":"def estimate_delta_root_tank_capacity ( j , data ) Updates daily root capacity variation (delta_root_tank_capacity, in mm water/day) based on the current phase of the plant, the daily root growth speed, and the drought stress coefficient. The daily root capacity variation is calculated as the product of soil water storage capacity (ru), the daily root growth speed (vRac), and a coefficient (cstr + 0.3). This coefficient is capped at 1.0. The daily root capacity variation is modulated by drought stress only when the root tank capacity is greater than the surface tank capacity and the current phase is strictly greater than 1 and at the day of phase change. If the root tank capacity is lower than the surface tank capacity or if the current phase is 1 or below or not at the day of phase change, the daily root capacity variation remains unchanged. The drought stress coefficient, cstr, measures the level of drought stress with 0 being full stress. The root growth speed is assumed to still occur during a drought stress as a matter of survival, with a certain level of tolerance given by the [0.3, 1] bound of the coefficient. Updating delta_root_tank_capacity / dayVrac (daily variation in water height accessible to roots, mm water/day) : At the day of phase change, for phases strictly above 1, and for which root_tank_capacity is greater than surface_tank_capacity, the variation of root tank capacity delta_root_tank_capacity is computed as the product of soil water storage capacity (ru, mm/m), the daily root growth speed (vRac, mm/day), and a coefficient, the latter being equal to the drought stress coefficient (cstr) plus 0.3, with a maximum bound of 1.0. That is to say, when the root_tank_capacity is greater than surface_tank_capacity, the root growth speed is modulated by drought stress. When root_tank_capacity is lower than surface_tank_capacity, the root growth speed is not modulated by drought stress. When we are not at the day of phase change, or if we are at phase of 1 and below, delta_root_change_capacity is unchanged. cstr is the drought stress coefficient, with a value of 0 meaning full stress. Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian BARON, this is based on the hypothesis that during a drought stress (cstr = 0), the plant will still grow roots as a matter of survival. Furthermore, using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr interval, there is no effect of drought stress on the root growth speed, allowing for a certain level of tolerance of the plant. Parameters: Name Type Description Default j int The current iteration step of the process. None data xarray.Dataset The input data containing relevant information. None Returns: Type Description xarray.Dataset The updated input data with the daily root capacity variation calculated and stored. View Source def estimate_delta_root_tank_capacity ( j , data ): \"\"\" Updates daily root capacity variation (delta_root_tank_capacity, in mm water/day) based on the current phase of the plant, the daily root growth speed, and the drought stress coefficient. The daily root capacity variation is calculated as the product of soil water storage capacity (ru), the daily root growth speed (vRac), and a coefficient (cstr + 0.3). This coefficient is capped at 1.0. The daily root capacity variation is modulated by drought stress only when the root tank capacity is greater than the surface tank capacity and the current phase is strictly greater than 1 and at the day of phase change. If the root tank capacity is lower than the surface tank capacity or if the current phase is 1 or below or not at the day of phase change, the daily root capacity variation remains unchanged. The drought stress coefficient, cstr, measures the level of drought stress with 0 being full stress. The root growth speed is assumed to still occur during a drought stress as a matter of survival, with a certain level of tolerance given by the [0.3, 1] bound of the coefficient. Updating delta_root_tank_capacity / dayVrac (daily variation in water height accessible to roots, mm water/day) : At the day of phase change, for phases strictly above 1, and for which root_tank_capacity is greater than surface_tank_capacity, the variation of root tank capacity delta_root_tank_capacity is computed as the product of soil water storage capacity (ru, mm/m), the daily root growth speed (vRac, mm/day), and a coefficient, the latter being equal to the drought stress coefficient (cstr) plus 0.3, with a maximum bound of 1.0. That is to say, when the root_tank_capacity is greater than surface_tank_capacity, the root growth speed is modulated by drought stress. When root_tank_capacity is lower than surface_tank_capacity, the root growth speed is not modulated by drought stress. When we are not at the day of phase change, or if we are at phase of 1 and below, delta_root_change_capacity is unchanged. cstr is the drought stress coefficient, with a value of 0 meaning full stress. Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian BARON, this is based on the hypothesis that during a drought stress (cstr = 0), the plant will still grow roots as a matter of survival. Furthermore, using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr interval, there is no effect of drought stress on the root growth speed, allowing for a certain level of tolerance of the plant. Args: j (int): The current iteration step of the process. data (xarray.Dataset): The input data containing relevant information. Returns: xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored. \"\"\" # group 15 # ! simplified conditions # // condition = (data[\"numPhase\"][j,:,:] > 0) & \\ # // np.invert((data[\"numPhase\"][j,:,:] == 1) & (data[\"changePhase\"][j,:,:] == 1)) condition = ( data [ \"numPhase\" ][ j ,:,:] > 1 ) & ( data [ \"changePhase\" ][ j ,:,:] == 1 ) #! renaming dayVrac to delta_root_tank_capacity #// data[\"dayVrac\"][j,:,:] = np.where( data [ \"delta_root_tank_capacity\" ][ j ,:,:] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity #// (data[\"stRurMax\"][j,:,:] > data[\"ruSurf\"][j,:,:]), ( data [ \"root_tank_capacity\" ][ j ,:,:] > data [ \"surface_tank_capacity\" ]), ( data [ \"vRac\" ][ j ,:,:] * np . minimum ( data [ \"cstr\" ][ j ,:,:] + 0.3 , 1.0 )) / 1000 * data [ \"ru\" ], data [ \"vRac\" ][ j ,:,:] / 1000 * data [ \"ru\" ], ), #// data[\"dayVrac\"][j,:,:], data [ \"delta_root_tank_capacity\" ][ j ,:,:], ) return data","title":"estimate_delta_root_tank_capacity"},{"location":"reference/sarra_py/bilan_hydro/#estimate_fesw","text":"def estimate_fesw ( j , data ) This function estimates the fraction of evaporable soil water (fesw, mm). fesw is defined as the ratio of water stock in the surface tank over 110% of the surface tank capacity. It is adapted from the EvalFESW procedure, from bileau.pas and bhytypeFAO.pas files from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_fesw ( j , data ) : \"\"\" This function estimates the fraction of evaporable soil water ( fesw , mm ) . fesw is defined as the ratio of water stock in the surface tank over 110 % of the surface tank capacity . It is adapted from the EvalFESW procedure , from bileau . pas and bhytypeFAO . pas files from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! renaming stRuSurf to surface_tank_stock # ! renaming ruSurf with surface_tank_capacity # // data [ \" fesw \" ][ j ,:,:] = data [ \" stRuSurf \" ][ j ,:,:] / ( data [ \" ruSurf \" ][ j ,:,:] + data [ \" ruSurf \" ][ j ,:,:] / 10 ) data [ \" fesw \" ][ j ,:,:] = data [ \" surface_tank_stock \" ][ j ,:,:] / ( data [ \" surface_tank_capacity \" ] + 0 . 1 * data [ \" surface_tank_capacity \" ] ) return data","title":"estimate_fesw"},{"location":"reference/sarra_py/bilan_hydro/#estimate_ftsw","text":"def estimate_ftsw ( j , data ) This function estimates the fraction of evaporable soil water (fesw) from the root reservoir. It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 & 2.pas, risocas.pas, riz.pas files from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_ftsw ( j , data ) : \"\"\" This function estimates the fraction of evaporable soil water ( fesw ) from the root reservoir . It is based on the EvalFTSW procedure , from the bileau . pas , exmodules 1 & 2 . pas , risocas . pas , riz . pas files from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" ftsw \" ][ j :,:,:] = np . where ( # ! renaming stRurMax to root_tank_capacity # // data [ \" stRurMax \" ][ j ,:,:] > 0 , data [ \" root_tank_capacity \" ][ j ,:,:] > 0 , # ! renaming stRur to root_tank_stock # ! renaming stRurMax to root_tank_capacity # // data [ \" stRur \" ][ j ,:,:] / data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_stock \" ][ j ,:,:] / data [ \" root_tank_capacity \" ][ j ,:,:], 0 , ) return data","title":"estimate_ftsw"},{"location":"reference/sarra_py/bilan_hydro/#estimate_kctot","text":"def estimate_kcTot ( j , data ) This function computes the total kc coefficient. Computation is based on the kcp (transpiration coefficient) and kce (evaporation from the soil) coefficients. Where the crop coefficient is 0 (meaning that there was no emergence yet), kcTot takes the value of kce. This function is based on the EvalKcTot procedure, from the bileau.pas and exmodules 1 & 2.pas files, from the original FORTRAN code.","title":"estimate_kcTot"},{"location":"reference/sarra_py/bilan_hydro/#note-code-has-been-modified-to-match-the-original-sarra-h-behavior","text":"Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_kcTot ( j , data ) : \"\"\" This function computes the total kc coefficient . Computation is based on the kcp ( transpiration coefficient ) and kce ( evaporation from the soil ) coefficients . Where the crop coefficient is 0 ( meaning that there was no emergence yet ) , kcTot takes the value of kce . This function is based on the EvalKcTot procedure , from the bileau . pas and exmodules 1 & 2 . pas files , from the original FORTRAN code . # ! Note : code has been modified to match the original SARRA - H behavior . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # added a condition on 19 / 08 / 22 to match SARRA - H original behavior data [ \" kcTot \" ][ j ,:,:] = np . where ( data [ \" kcp \" ][ j ,:,:] == 0 . 0 , data [ \" kce \" ][ j ,:,:], data [ \" kce \" ][ j ,:,:] + data [ \" kcp \" ][ j ,:,:], ) return data","title":"! Note : code has been modified to match the original SARRA-H behavior."},{"location":"reference/sarra_py/bilan_hydro/#estimate_kce","text":"def estimate_kce ( j , data , paramITK ) This function estimates the coefficient of evaporation from the soil (kce). This approach takes into consideration three factors acting on limitation of kce : 1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover 2) Mulch - permanent covering effect : we consider a value of 1.0 for no covering, and 0.0 is full covering with plastic sheet ; this mulch parameter has been used in previous versions of the model where evolution of mulch biomass was not explicitely taken into consideration, can be used in the case of crops with self-mulching phenomena, where a standard mulch parameter value of 0.7 can be applied. 3) Mulch - evolutive covering effect BiomMc : biomass of mulch This function has been adapted from EvalKceMC procedure, bileau.pas and exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like it has been adapted from the dual crop coefficient from the FAO56 paper. But this is still to confirm on a point of view of the history of the model. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def estimate_kce ( j , data , paramITK ) : \"\"\" This function estimates the coefficient of evaporation from the soil ( kce ) . This approach takes into consideration three factors acting on limitation of kce : 1 ) ltr : plant cover , 1 = no plant cover , 0 = full plant cover 2 ) Mulch - permanent covering effect : we consider a value of 1 . 0 for no covering , and 0 . 0 is full covering with plastic sheet ; this mulch parameter has been used in previous versions of the model where evolution of mulch biomass was not explicitely taken into consideration , can be used in the case of crops with self - mulching phenomena , where a standard mulch parameter value of 0 . 7 can be applied . 3 ) Mulch - evolutive covering effect BiomMc : biomass of mulch This function has been adapted from EvalKceMC procedure , bileau . pas and exmodules 2 . pas from the original FORTRAN code . In its spirit , it looks like it has been adapted from the dual crop coefficient from the FAO56 paper . But this is still to confirm on a point of view of the history of the model . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" data [ \" kce \" ][ j ,:,:] = data [ \" ltr \" ][ j ,:,:] * paramITK [ \" mulch \" ] / 100 * \\ np . exp ( - paramITK [ \" coefMc \" ] * paramITK [ \" surfMc \" ] * data [ \" biomMc \" ][ j ,:,:] / 1000 ) return data","title":"estimate_kce"},{"location":"reference/sarra_py/bilan_hydro/#estimate_pfact","text":"def estimate_pFact ( j , data , paramVariete ) summary This function computes the pFactor, which is a bound coefficient used in the computation of cstr from ftsw. This coefficient delimits the portion of the FTSW below which water stress starts to influence the transpiration. FAO reference for critical FTSW value for transpiration response (0 = stomata respond immediately if FTSW<1; 0.5 for most of the crops) pFact is bounded in [0.1, 0.8]. For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf This function is based on the CstrPFactor procedure, from bileau.pas, exmodules 1 & 2.pas, risocas.pas files, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def estimate_pFact ( j , data , paramVariete ) : \"\"\" _summary_ This function computes the pFactor , which is a bound coefficient used in the computation of cstr from ftsw . This coefficient delimits the portion of the FTSW below which water stress starts to influence the transpiration . FAO reference for critical FTSW value for transpiration response ( 0 = stomata respond immediately if FTSW < 1 ; 0.5 for most of the crops) pFact is bounded in [ 0 . 1 , 0 . 8 ]. For details see https : // agritrop . cirad . fr / 556855 / 1 / document_556855 . pdf This function is based on the CstrPFactor procedure , from bileau . pas , exmodules 1 & 2 . pas , risocas . pas files , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 53 data [ \" pFact \" ][ j :,:,:] = paramVariete [ \" PFactor \" ] + \\ 0 . 04 * ( 5 - np . maximum ( data [ \" kcp \" ][ j ,:,:], 1 ) * data [ \" ET0 \" ][ j ,:,:] ) # group 54 data [ \" pFact \" ][ j :,:,:] = np . minimum ( np . maximum ( 0 . 1 , data [ \" pFact \" ][ j ,:,:], ) , 0 . 8 , ) return data","title":"estimate_pFact"},{"location":"reference/sarra_py/bilan_hydro/#estimate_plant_transpiration","text":"def estimate_plant_transpiration ( j , data ) This function computes the transpiration from the plant. This function is based on the EvalTranspi procedure, from bileau.pas, bhytypeFAO.pas, exmodules 1 & 2.pas, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_plant_transpiration ( j , data ) : \"\"\" This function computes the transpiration from the plant . This function is based on the EvalTranspi procedure , from bileau . pas , bhytypeFAO . pas , exmodules 1 & 2 . pas , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 58 data [ \" tr \" ][ j :,:,:] = ( data [ \" trPot \" ][ j ,:,:] * data [ \" cstr \" ][ j ,:,:] ) return data","title":"estimate_plant_transpiration"},{"location":"reference/sarra_py/bilan_hydro/#estimate_potential_plant_transpiration","text":"def estimate_potential_plant_transpiration ( j , data ) This function computes the potential transpiration from the plant. Computation is based on the climate forcing (ET0), as well as the kcp coefficient. This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and exmodules 1 & 2.pas files from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_potential_plant_transpiration ( j , data ) : \"\"\" This function computes the potential transpiration from the plant . Computation is based on the climate forcing ( ET0 ) , as well as the kcp coefficient . This code is based on the DemandePlante procedure , from the bileau . pas , bhytypeFAO . pas , and exmodules 1 & 2 . pas files from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ggroup 51 data [ \" trPot \" ][ j ,:,:] = ( data [ \" kcp \" ][ j ,:,:] * data [ \" ET0 \" ][ j ,:,:] ) return data","title":"estimate_potential_plant_transpiration"},{"location":"reference/sarra_py/bilan_hydro/#estimate_runoff","text":"def estimate_runoff ( j , data ) Evaluation of runoff (\"lame de ruissellement\", lr, mm) : If the quantity of rain (mm) is above the runoff threshold (seuilRuiss, mm), runoff is computed as the difference between the available water (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0. seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data Question : should runoff be computed taking in consideration water captured by mulch to account for mulch effect on runoff mitigation ? Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_runoff ( j , data ): \"\"\" Evaluation of runoff (\"lame de ruissellement\", lr, mm) : If the quantity of rain (mm) is above the runoff threshold (seuilRuiss, mm), runoff is computed as the difference between the available water (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0. seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data Question : should runoff be computed taking in consideration water captured by mulch to account for mulch effect on runoff mitigation ? Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 11 data [ \"lr\" ][ j ,:,:] = xr . where ( data [ \"rain\" ][ j ,:,:] > data [ \"seuilRuiss\" ], ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"seuilRuiss\" ]) * data [ \"pourcRuiss\" ], 0 , ) return data","title":"estimate_runoff"},{"location":"reference/sarra_py/bilan_hydro/#estimate_soil_evaporation","text":"def estimate_soil_evaporation ( j , data ) This function computes estimation of soil evaporation (mm, evap). It uses the potential soil evaporation (evapPot) and the fraction of evaporable soil water (fesw), bounded by the surface tank stock. It has been adapted from the EvapRuSurf procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_soil_evaporation ( j , data ) : \"\"\" This function computes estimation of soil evaporation ( mm , evap ) . It uses the potential soil evaporation ( evapPot ) and the fraction of evaporable soil water ( fesw ) , bounded by the surface tank stock . It has been adapted from the EvapRuSurf procedure , from bileau . pas and exmodules 1 & 2 . pas file from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! replacing stRuSurf by surface_tank_stock # // data [ \" evap \" ][ j :,:,:] = np . minimum ( data [ \" evapPot \" ][ j ,:,:] * data [ \" fesw \" ][ j ,:,:] ** 2 , data [ \" stRuSurf \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" evap \" ][ j :,:,:] = np . minimum ( data [ \" evapPot \" ][ j ,:,:] * data [ \" fesw \" ][ j ,:,:] ** 2 , data [ \" surface_tank_stock \" ][ j ,:,:] ) return data","title":"estimate_soil_evaporation"},{"location":"reference/sarra_py/bilan_hydro/#estimate_soil_potential_evaporation","text":"def estimate_soil_potential_evaporation ( j , data ) This function computes estimation of potential soil evaporation (mm, evapPot). It performs its computations solely from the evaporation forcing driven by climatic demand, limited by the coefficient of evaporation from the soil (kce). Note : difference in humectation of the top and bottom tanks is not taken into consideration in this approach. The This function has been adapted from DemandeSol procedure, from bileau.pas and exmodules 1 & 2.pas file from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_soil_potential_evaporation ( j , data ) : \"\"\" This function computes estimation of potential soil evaporation ( mm , evapPot ) . It performs its computations solely from the evaporation forcing driven by climatic demand , limited by the coefficient of evaporation from the soil ( kce ) . Note : difference in humectation of the top and bottom tanks is not taken into consideration in this approach . The This function has been adapted from DemandeSol procedure , from bileau . pas and exmodules 1 & 2 . pas file from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 44 data [ \" evapPot \" ][ j ,:,:] = data [ \" ET0 \" ][ j ,:,:] * data [ \" kce \" ][ j ,:,:] return data","title":"estimate_soil_potential_evaporation"},{"location":"reference/sarra_py/bilan_hydro/#estimate_transpirable_surface_water","text":"def estimate_transpirable_surface_water ( j , data ) This function estimates the transpirable surface water. It removes 1/10th of surface tank capacity as water is condidered as bound. This function is based on the ConsoResSep procedure, from bileau.pas, exmodules 1 & 2.pas files, from the original FORTRAN code. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_transpirable_surface_water ( j , data ) : \"\"\" This function estimates the transpirable surface water . It removes 1 / 10 th of surface tank capacity as water is condidered as bound . This function is based on the ConsoResSep procedure , from bileau . pas , exmodules 1 & 2 . pas files , from the original FORTRAN code . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 59 # ! replacing stRuSurf by surface_tank_stock # ! renaming ruSurf with surface_tank_capacity # // data [ \" trSurf \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRuSurf \" ][ j ,:,:] - data [ \" ruSurf \" ][ j ,:,:] / 10 ) [..., np . newaxis ] data [ \" trSurf \" ][ j :,:,:] = np . maximum ( 0 , data [ \" surface_tank_stock \" ][ j ,:,:] - data [ \" surface_tank_capacity \" ] * 0 . 1 , ) return data","title":"estimate_transpirable_surface_water"},{"location":"reference/sarra_py/bilan_hydro/#estimate_transpirable_water","text":"def estimate_transpirable_water ( j , data ) This function estimates the daily volume of transpirable water. eauTranspi (mm, water transpirable) is the water available for transpiration from the surface reservoir. If surface_tank_stock at the end of the previous day (index j-1) is lower than 10% of the surface_tank_capacity, the water available for transpirable water equals the water available for the day (eauDispo), minus the difference between 1/10th of the surface_tank_capacity and surface_tank_stock. This transpirable water has a min bound at 0 mm. Said otherwise, a part of the water available for the day (eauDispo) is considered as bound to the surface reservoir and cannot be transpired. If surface_tank_stock at the end of the previous day (index j-1) is upper than 10% of the surface_tank_capacity, transpirable water equals eauDispo. Remark : if the use of j-1 indices is too problematic, it seems feasible to run this function just before update_surface_tank_stock. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def estimate_transpirable_water ( j , data ) : \"\"\" This function estimates the daily volume of transpirable water . eauTranspi ( mm , water transpirable ) is the water available for transpiration from the surface reservoir . If surface_tank_stock at the end of the previous day ( index j - 1 ) is lower than 10 % of the surface_tank_capacity , the water available for transpirable water equals the water available for the day ( eauDispo ) , minus the difference between 1 / 10 th of the surface_tank_capacity and surface_tank_stock . This transpirable water has a min bound at 0 mm . Said otherwise , a part of the water available for the day ( eauDispo ) is considered as bound to the surface reservoir and cannot be transpired . If surface_tank_stock at the end of the previous day ( index j - 1 ) is upper than 10 % of the surface_tank_capacity , transpirable water equals eauDispo . Remark : if the use of j - 1 indices is too problematic , it seems feasible to run this function just before update_surface_tank_stock . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 28 data [ \" eauTranspi \" ][ j ,:,:] = np . where ( # ! modifying to replace stRuSurfPrec by stRuSurf at undex j - 1 # ! renaming ruSurf to surface_tank_capacity # ! renaming stRuSurfPrec to surface_tank_stock # // data [ \" stRuSurfPrec \" ][ j ,:,:] < data [ \" ruSurf \" ][ j ,:,:] / 10 , data [ \" surface_tank_stock \" ][ j - 1 ,:,:] < 0 . 1 * data [ \" surface_tank_capacity \" ], np . maximum ( 0 , # ! modifying to replace stRuSurfPrec by stRuSurf at iundex j - 1 # ! renaming ruSurf to surface_tank_capacity # ! renaming stRuSurf to surface_tank_stock # // data [ \" eauDispo \" ][ j ,:,:] - ( data [ \" ruSurf \" ][ j ,:,:] / 10 - data [ \" stRuSurfPrec \" ][ j ,:,:] ) data [ \" eauDispo \" ][ j ,:,:] - ( 0 . 1 * data [ \" surface_tank_capacity \" ] - data [ \" surface_tank_stock \" ][ j - 1 ,:,:] ) ) , data [ \" eauDispo \" ][ j ,:,:], ) return data","title":"estimate_transpirable_water"},{"location":"reference/sarra_py/bilan_hydro/#estimate_water_captured_by_mulch","text":"def estimate_water_captured_by_mulch ( j , data , paramITK ) Determination of water gathered by the mulch (eauCaptee, mm): We determine the quantity of water gathered by mulch by multiplying the available water (eauDispo, from rain and irrigation, mm) with a exponential function of covering capacity of the considered mulch (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the fraction of soil covered by mulch. The value of eauCaptee is bounded by the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of water already present in it (stockMc, mm). Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def estimate_water_captured_by_mulch ( j , data , paramITK ): \"\"\" Determination of water gathered by the mulch (eauCaptee, mm): We determine the quantity of water gathered by mulch by multiplying the available water (eauDispo, from rain and irrigation, mm) with a exponential function of covering capacity of the considered mulch (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the fraction of soil covered by mulch. The value of eauCaptee is bounded by the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of water already present in it (stockMc, mm). Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 7 #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"eauCaptee\"][j,:,:] = np.minimum( data [ \"water_gathered_by_mulch\" ][ j ,:,:] = np . minimum ( data [ \"eauDispo\" ][ j ,:,:] * ( 1 - np . exp ( - paramITK [ \"surfMc\" ] / 1000 * data [ \"biomMc\" ][ j ,:,:])), #// (paramITK[\"humSatMc\"] * data[\"biomMc\"][j,:,:] / 10000) - data[\"stockMc\"][j,:,:], ( paramITK [ \"humSatMc\" ] * data [ \"biomMc\" ][ j ,:,:] / 10000 ) - data [ \"mulch_water_stock\" ][ j ,:,:], ) return data","title":"estimate_water_captured_by_mulch"},{"location":"reference/sarra_py/bilan_hydro/#estimate_water_consumption_from_root_tank_stock","text":"def estimate_water_consumption_from_root_tank_stock ( j , data ) This function estimates consoRur, which is the water to be consumed from the root tank stock. If soil evaporation (evap) is higher than transpirable surface water (trSurf), then consumption from root tank stock equals trSurf. Else, it equals evap.","title":"estimate_water_consumption_from_root_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#how-to-interpret-this","text":"Parameters: Name Type Description Default j type description None data type description None View Source def estimate_water_consumption_from_root_tank_stock ( j , data ) : \"\"\" This function estimates consoRur , which is the water to be consumed from the root tank stock . If soil evaporation ( evap ) is higher than transpirable surface water ( trSurf ) , then consumption from root tank stock equals trSurf . Else , it equals evap . #? how to interpret this ? Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ \"\"\" data [ \" consoRur \" ][ j :,:,:] = np . where ( data [ \" evap \" ][ j ,:,:] > data [ \" trSurf \" ][ j ,:,:], data [ \" trSurf \" ][ j ,:,:], data [ \" evap \" ][ j ,:,:], ) return data","title":"? how to interpret this ?"},{"location":"reference/sarra_py/bilan_hydro/#initialize_root_tank_capacity","text":"def initialize_root_tank_capacity ( j , data , paramITK ) updating stRurMax/root_tank_capacity, step 1 : stRurMax, also called ruRac in some versions of the model, is the root_tank_capacity. At the phase change between phases 0 and 1 (initialisation), the maximum root water storage is initialised by multiplying the initial root depth (profRacIni, mm) with the soil water storage capacity (ru, mm/m). This value is broadcasted on the time series. For every other day in the cycle, the value remains unchanged. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def initialize_root_tank_capacity ( j , data , paramITK ) : \"\"\" updating stRurMax / root_tank_capacity , step 1 : stRurMax , also called ruRac in some versions of the model , is the root_tank_capacity . At the phase change between phases 0 and 1 ( initialisation ) , the maximum root water storage is initialised by multiplying the initial root depth ( profRacIni , mm ) with the soil water storage capacity ( ru , mm / m ) . This value is broadcasted on the time series . For every other day in the cycle , the value remains unchanged . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 14 # ! renaming stRurMax to root_tank_capacity # // data [ \" stRurMax \" ][ j :,:,:] = np . where ( data [ \" root_tank_capacity \" ][ j :,:,:] = xr . where ( ( data [ \" changePhase \" ][ j ,:,:] == 1 ) & ( data [ \" numPhase \" ][ j ,:,:] == 1 ) , paramITK [ \" profRacIni \" ] / 1000 * data [ \" ru \" ], # // data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:], ) return data","title":"initialize_root_tank_capacity"},{"location":"reference/sarra_py/bilan_hydro/#remplires","text":"def rempliRes ( j , data ) Translated from the procedure rempliRes, of the original Pascal codes bileau.pas Main hypotheses : - the water dynamics is represented by a filling from the top and an evolution of the reservoirs sizes when the filling is above the maximum quantity of the current size (humectation front). - when the maximum size is reached by filling, it is considered as drainage. - inside a reservoir, water is distributed homogeneously (may be considered valid up to 2m depth, according to CB, from other sources). 3 reservoirs are represented: 1) a global reservoir, evolving in depth according to the humectation front 2) a surface reservoir (fixed size) where evaporation and a part of the transpiration occurs when roots are present 3) a root reservoir, evolving according to the root front (when roots are present) REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks Notes from CB, 10/06/2015 : prise en compte de stock d'eau r\u00e9silient pour les simulation continues Hypoth\u00e8se de la MAJ des stock en fn de l'eau r\ufffdsiliente de l'ann\ufffde pr\ufffdc\ufffddente dans le cas des simulations pluri annuelle en continue (NbAn = 1): A la r\ufffdcolte on recup\ufffdre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec) et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien. On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf) Si le StRu avec l'apport d'eau devinet sup au Hum alors on tient compte dans cette augmentation du stock r\ufffdsilient avec deux cas possible : Si StRu est < \ufffd stRurMaxprec alors on ajoute l'eau r\ufffdsiliente contenue dans l'ancienne zone racinaire en fn de la diff\ufffdrence de stock Sinon on a de l'eau r\ufffdsiliente au maximum de la CC jusqu'\ufffd l'ancienne HumPrec, on rempli alors StRu de la diff\ufffdrence etre ces deux valeurs puis on fait la MAJ des Dr, StRur, Hum etc... View Source def rempliRes ( j , data ): \"\"\" Translated from the procedure rempliRes, of the original Pascal codes bileau.pas Main hypotheses : - the water dynamics is represented by a filling from the top and an evolution of the reservoirs sizes when the filling is above the maximum quantity of the current size (humectation front). - when the maximum size is reached by filling, it is considered as drainage. - inside a reservoir, water is distributed homogeneously (may be considered valid up to 2m depth, according to CB, from other sources). 3 reservoirs are represented: 1) a global reservoir, evolving in depth according to the humectation front 2) a surface reservoir (fixed size) where evaporation and a part of the transpiration occurs when roots are present 3) a root reservoir, evolving according to the root front (when roots are present) REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks Notes from CB, 10/06/2015 : prise en compte de stock d'eau r\u00e9silient pour les simulation continues Hypoth\u00e8se de la MAJ des stock en fn de l'eau r\ufffdsiliente de l'ann\ufffde pr\ufffdc\ufffddente dans le cas des simulations pluri annuelle en continue (NbAn = 1): A la r\ufffdcolte on recup\ufffdre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec) et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien. On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf) Si le StRu avec l'apport d'eau devinet sup au Hum alors on tient compte dans cette augmentation du stock r\ufffdsilient avec deux cas possible : Si StRu est < \ufffd stRurMaxprec alors on ajoute l'eau r\ufffdsiliente contenue dans l'ancienne zone racinaire en fn de la diff\ufffdrence de stock Sinon on a de l'eau r\ufffdsiliente au maximum de la CC jusqu'\ufffd l'ancienne HumPrec, on rempli alors StRu de la diff\ufffdrence etre ces deux valeurs puis on fait la MAJ des Dr, StRur, Hum etc... \"\"\" # section 1 : updating the end_of_cycle memory variables data = update_humPrec_for_end_of_cycle ( j , data ) data = update_hum_for_end_of_cycle ( j , data ) data = update_stRurMaxPrec_for_end_of_cycle ( j , data ) data = update_stRurPrec_for_end_of_cycle ( j , data ) data = update_stRuPrec_for_end_of_cycle ( j , data ) data = reset_total_tank_capacity ( j , data ) # verif ok # # filling the surface tank with available water data = update_surface_tank_stock ( j , data ) # verif ok # # estimates transpirable water data = estimate_transpirable_water ( j , data ) # verif ok # # increments total tank stock with transpirable water # # (meaning that total tank stock may represent a transpirable water tank) data = update_total_tank_stock ( j , data ) # verif ok # # estimating positive delta between total_root_tank and stRuPrec data = update_delta_total_tank_stock ( j , data ) # verif ok # # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged data = update_total_tank_stock_step_2 ( j , data ) # verif ok # # then total_tank_stock_previous_value can 1) take 0 or 2) be unchanged data = update_stRuPrec ( j , data ) #???? # # delta_total_tank_stock can 1) be incremented of total_tank_stock_previous_value or 2) be unchanged data = update_delta_total_tank_stock_step_2 ( j , data ) # # # here, in case 1, In this function, if the variation of transpirable water # # (delta_total_tank_stock) increases above the depth of humectation front # # (hum), if the depth of humectation front (hum) is above the # # root_tank_capacity_previous_season (condition 1 passed, and 2 failed, # # which should be the case for most of the simulations that will be # # single-season), and if the depth of humectation front (hum) has decreased # # since the previous day (condition 3 passed), then total_tank_stock takes the value of # # delta_total_tank_stock, total_tank_stock_previous_value equals 0, and # # delta_total_tank_stock is incremented by total_tank_stock_previous_value. # # # # in case 2, nothing happens. # # update_hum manages increase in hum data = update_hum ( j , data ) # # in case of overflowing... # # calculating drainage data = update_dr ( j , data ) # # limiting the total_tank_stock to the total_tank_capacity (when overflowing) data = update_total_tank_stock_step_3 ( j , data ) # # update again hum value, but we could merge functions with update_hum data = update_hum_step_2 ( j , data ) # # filling root_tank_stock with transpirable water, within the limits of total_tank_stock data = update_root_tank_stock_step_2 ( j , data ) return data","title":"rempliRes"},{"location":"reference/sarra_py/bilan_hydro/#reset_total_tank_capacity","text":"def reset_total_tank_capacity ( j , data ) This function resets the value total_tank_capacity/stRuMax at each loop. ? Why redfining stRuMax at each loop ? Neither ru, profRu ? nor total_tank_capacity are modified during the simulation. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def reset_total_tank_capacity ( j , data ) : \"\"\" This function resets the value total_tank_capacity / stRuMax at each loop . ? Why redfining stRuMax at each loop ? Neither ru , profRu ? nor total_tank_capacity are modified during the simulation . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 25 # ! renaming stRuMax to total_tank_capacity # // data [ \" stRuMax \" ][ j :,:,:] = ( data [ \" ru \" ] * data [ \" profRu \" ] / 1000 ) #. copy () #[..., np . newaxis ] data [ \" total_tank_capacity \" ][ j :,:,:] = ( data [ \" ru \" ] * data [ \" profRu \" ] / 1000 ) return data","title":"reset_total_tank_capacity"},{"location":"reference/sarra_py/bilan_hydro/#update_available_water_after_mulch_filling","text":"def update_available_water_after_mulch_filling ( j , data ) Updating available water (eauDispo, mm) : As some water is gathered by the mulch, the available water is updated by subtracting the gathered water (eauCaptee, mm) from the total available water (eauDispo, mm). This value is bounded by 0, as the available water cannot be negative. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_available_water_after_mulch_filling ( j , data ): \"\"\" Updating available water (eauDispo, mm) : As some water is gathered by the mulch, the available water is updated by subtracting the gathered water (eauCaptee, mm) from the total available water (eauDispo, mm). This value is bounded by 0, as the available water cannot be negative. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy #! modyfing variable names to improve readability #! replacing eauCaptee by water_gathered_by_mulch # group 8 #// data[\"eauDispo\"][j:,:,:] = np.maximum(data[\"eauDispo\"][j,:,:] - data[\"eauCaptee\"][j,:,:], 0) # //[...,np.newaxis] data [ \"eauDispo\" ][ j :,:,:] = np . maximum ( data [ \"eauDispo\" ][ j ,:,:] - data [ \"water_gathered_by_mulch\" ][ j ,:,:], 0 ) # //[...,np.newaxis] return data","title":"update_available_water_after_mulch_filling"},{"location":"reference/sarra_py/bilan_hydro/#update_available_water_after_runoff","text":"def update_available_water_after_runoff ( j , data ) Updating available water (eauDispo, mm) : The available water is updated by subtracting the runoff (lr, mm) from the total available water (eauDispo, mm). This value is broadcasted onto the days axis. Parameters: Name Type Description Default j type description None data type description None View Source def update_available_water_after_runoff ( j , data ) : \"\"\" Updating available water ( eauDispo , mm ) : The available water is updated by subtracting the runoff ( lr , mm ) from the total available water ( eauDispo , mm ) . This value is broadcasted onto the days axis . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ \"\"\" # group 12 data [ \" eauDispo \" ][ j :,:,:] = ( data [ \" eauDispo \" ][ j ,:,:] - data [ \" lr \" ][ j ,:,:] ) return data","title":"update_available_water_after_runoff"},{"location":"reference/sarra_py/bilan_hydro/#update_delta_root_tank_capacity","text":"def update_delta_root_tank_capacity ( j , data ) updating delta_root_tank_capacity : At the day of phase change, for phases strictly above 1, and for which the difference between the water height to humectation front (hum, mm) and the root_tank_capacity is less than the delta_root_tank_capacity, delta_root_tank_capacity is updated to be equal to the difference between the water height to humectation front and the root_tank_capacity. In other words, the change in root tank capacity delta_root_tank_capacity is limited by the water height to humectation front. For any other day or if root_tank_capacity is above delta_root_tank_capacity, delta_root_tank_capacity value is unchanged. Parameters: Name Type Description Default j type description None data type description None View Source def update_delta_root_tank_capacity ( j , data ) : \"\"\" updating delta_root_tank_capacity : At the day of phase change , for phases strictly above 1 , and for which the difference between the water height to humectation front ( hum , mm ) and the root_tank_capacity is less than the delta_root_tank_capacity , delta_root_tank_capacity is updated to be equal to the difference between the water height to humectation front and the root_tank_capacity . In other words , the change in root tank capacity delta_root_tank_capacity is limited by the water height to humectation front . For any other day or if root_tank_capacity is above delta_root_tank_capacity , delta_root_tank_capacity value is unchanged . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ \"\"\" # group 16 # ! simplified conditions # // condition = ( data [ \" numPhase \" ][ j ,:,:] > 0 ) & \\ # // np . invert (( data [ \" numPhase \" ][ j ,:,:] == 1 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 )) condition = ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 ) # ! renaming deltaRur with delta_root_tank_capacity # // data [ \" deltaRur \" ][ j :,:,:] = np . where ( data [ \" delta_root_tank_capacity \" ][ j :,:,:] = np . where ( condition , np . where ( # ! renaming stRurMax to root_tank_capacity # ! renaming dayVrac to delta_root_tank_capacity # // ( data [ \" hum \" ][ j ,:,:] - data [ \" stRurMax \" ][ j ,:,:] ) < data [ \" dayVrac \" ][ j ,:,:], ( data [ \" hum \" ][ j ,:,:] - data [ \" root_tank_capacity \" ][ j ,:,:] ) < data [ \" delta_root_tank_capacity \" ][ j ,:,:], # // data [ \" hum \" ][ j ,:,:] - data [ \" stRurMax \" ][ j ,:,:], data [ \" hum \" ][ j ,:,:] - data [ \" root_tank_capacity \" ][ j ,:,:], # ! renaming dayVrac to delta_root_tank_capacity # // data [ \" dayVrac \" ][ j ,:,:], data [ \" delta_root_tank_capacity \" ][ j ,:,:], ) , # // data [ \" deltaRur \" ][ j ,:,:], data [ \" delta_root_tank_capacity \" ][ j ,:,:], ) return data","title":"update_delta_root_tank_capacity"},{"location":"reference/sarra_py/bilan_hydro/#update_delta_total_tank_stock","text":"def update_delta_total_tank_stock ( j , data ) This function estimates delta_total_tank_stock delta_total_tank_stock is the positive variation of transpirable water stock. It is computed as the difference between the total_tank_stock and stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is initialized to be equal to total_tank_stock at the beginning of the simulation. total_tank_stock is initialized with stockIrr parameter. Thus, simulations should start with a 0 value. stRuPrec is updated at each cycle with the update_struprec function. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_delta_total_tank_stock ( j , data ): \"\"\" This function estimates delta_total_tank_stock delta_total_tank_stock is the positive variation of transpirable water stock. It is computed as the difference between the total_tank_stock and stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is initialized to be equal to total_tank_stock at the beginning of the simulation. total_tank_stock is initialized with stockIrr parameter. Thus, simulations should start with a 0 value. stRuPrec is updated at each cycle with the update_struprec function. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 30 #! we propose a different version based on stTot #! renaming stTot to total_tank_stock #! renaming stRuVar to delta_total_tank_stock #! renaming stRuPrec to total_tank_stock_previous_value #// data[\"stRuVar\"][j:,:,:] = np.maximum(0, data[\"stTot\"][j,:,:] - data[\"stRuPrec\"][j,:,:])[...,np.newaxis] data [ \"delta_total_tank_stock\" ][ j :,:,:] = np . maximum ( 0 , data [ \"total_tank_stock\" ][ j ,:,:] - data [ \"total_tank_stock_previous_value\" ][ j ,:,:]) return data","title":"update_delta_total_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#update_delta_total_tank_stock_step_2","text":"def update_delta_total_tank_stock_step_2 ( j , data ) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_delta_total_tank_stock_step_2 ( j , data ) : \"\"\" Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # groupe 33 # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j :,:,:] = np . where ( data [ \" delta_total_tank_stock \" ][ j :,:,:] = np . where ( condition_1 , np . where ( condition_2 , # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j ,:,:] + ( data [ \" stRuVar \" ][ j ,:,:] - data [ \" hum \" ][ j ,:,:] ) * data [ \" stRurPrec \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:] + ( data [ \" delta_total_tank_stock \" ][ j ,:,:] - data [ \" hum \" ][ j ,:,:] ) * data [ \" stRurPrec \" ][ j ,:,:], np . where ( condition_3 , # ! renaming stRuVar with delta_total_tank_stock # ! renaming stRuPrec with total_tank_stock_previous_value # // data [ \" stRuVar \" ][ j ,:,:] + data [ \" stRuPrec \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:] + data [ \" total_tank_stock_previous_value \" ][ j ,:,:], # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:], ) , ) , # ! renaming stRuVar with delta_total_tank_stock # // data [ \" stRuVar \" ][ j ,:,:], data [ \" delta_total_tank_stock \" ][ j ,:,:], ) return data","title":"update_delta_total_tank_stock_step_2"},{"location":"reference/sarra_py/bilan_hydro/#update_dr","text":"def update_dr ( j , data ) This function estimates the daily drainage (dr). When total tank overflows, it computes drainage from the differences between the total_tank_stock (that is to say the total and total_tank_capacity. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_dr ( j , data ) : \"\"\" This function estimates the daily drainage ( dr ) . When total tank overflows , it computes drainage from the differences between the total_tank_stock ( that is to say the total and total_tank_capacity . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // condition = ( data [ \" stTot \" ][ j ,:,:] > data [ \" stRuMax \" ][ j ,:,:] ) condition = condition_total_tank_overflow ( j , data ) # groupe 36 # essais stTot data [ \" dr \" ][ j ,:,:] = np . where ( condition , # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // data [ \" stRu \" ][ j ,:,:] - data [ \" stRuMax \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" total_tank_capacity \" ][ j ,:,:], 0 , ) return data","title":"update_dr"},{"location":"reference/sarra_py/bilan_hydro/#update_etr_etm","text":"def update_etr_etm ( j , data ) View Source def update_etr_etm ( j , data ) : # group 69 data [ \" etr \" ][ j :,:,:] = ( data [ \" tr \" ][ j ,:,:] + data [ \" evap \" ][ j ,:,:] ) . copy () #[..., np . newaxis ] # group 70 data [ \" etm \" ][ j :,:,:] = ( data [ \" trPot \" ][ j ,:,:] + data [ \" evapPot \" ][ j ,:,:] ) . copy () #[..., np . newaxis ] return data","title":"update_etr_etm"},{"location":"reference/sarra_py/bilan_hydro/#update_hum","text":"def update_hum ( j , data ) This function updates the depth to humectation front (hum) to be the maximum value between the depth to humectation front (hum) and delta_total_tank_stock (that is to say depth of humectation front can only increase), bounded by total_tank_capacity (that is to say humectation front can not go deep indefinitely). Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_hum ( j , data ) : \"\"\" This function updates the depth to humectation front (hum) to be the maximum value between the depth to humectation front (hum) and delta_total_tank_stock (that is to say depth of humectation front can only increase), bounded by total_tank_capacity (that is to say humectation front can not go deep indefinitely). Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # groupe 34 #! renaming stRuVar with delta_total_tank_stock # // data [ \"hum\" ][ j:,:,: ] = np . maximum ( data [ \"stRuVar\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) # [ ...,np.newaxis ] data [ \"hum\" ][ j:,:,: ] = np . maximum ( data [ \"delta_total_tank_stock\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) # groupe 35 #! renaming stRuMax to total_tank_capacity # // data [ \"hum\" ][ j:,:,: ] = np . minimum ( data [ \"stRuMax\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) # [ ...,np.newaxis ] data [ \"hum\" ][ j:,:,: ] = np . minimum ( data [ \"total_tank_capacity\" ][ j,:,: ] , data [ \"hum\" ][ j,:,: ] ) return data","title":"update_hum"},{"location":"reference/sarra_py/bilan_hydro/#update_humprec_for_end_of_cycle","text":"def update_humPrec_for_end_of_cycle ( j , data ) This function saves information about the humectation front depth at the end of a growth cycle so it can be used in the next cycle. humPrec is initialized in the function InitPlotMc, and set to be equal to hum, itself being initialized to take the maximum value between surface_tank_capacity, root_tank_capacity and total_tank_stock. At the harvest date (numPhase = 7), the humPrec variable is set to equal the highest value between hum (mm, humectation front depth) and surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Parameters: Name Type Description Default j int number of the day None data xarray dataset description None Returns: Type Description None xarray dataset: description View Source def update_humPrec_for_end_of_cycle ( j , data ): \"\"\" This function saves information about the humectation front depth at the end of a growth cycle so it can be used in the next cycle. humPrec is initialized in the function InitPlotMc, and set to be equal to hum, itself being initialized to take the maximum value between surface_tank_capacity, root_tank_capacity and total_tank_stock. At the harvest date (numPhase = 7), the humPrec variable is set to equal the highest value between hum (mm, humectation front depth) and surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (int): number of the day data (xarray dataset): _description_ Returns: xarray dataset: _description_ \"\"\" # group 20 condition = condition_end_of_cycle ( j , data ) data [ \"humPrec\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// np.maximum(data[\"hum\"][j,:,:], data[\"ruSurf\"][j,:,:]), np . maximum ( data [ \"hum\" ][ j ,:,:], data [ \"surface_tank_capacity\" ]), data [ \"humPrec\" ][ j ,:,:], ) return data","title":"update_humPrec_for_end_of_cycle"},{"location":"reference/sarra_py/bilan_hydro/#update_hum_for_end_of_cycle","text":"def update_hum_for_end_of_cycle ( j , data ) This function updates information about the humectation front depth at the end of a growth cycle. At the harvest date (numPhase = 7), the hum variable is set to equal the surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_hum_for_end_of_cycle ( j , data ): \"\"\" This function updates information about the humectation front depth at the end of a growth cycle. At the harvest date (numPhase = 7), the hum variable is set to equal the surface_tank_capacity (mm). This value is broadcasted over the time dimension. At any other point in time, its value is unchanged. This means... Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 21 condition = condition_end_of_cycle ( j , data ) data [ \"hum\" ][ j :,:,:] = np . where ( condition , #! renaming ruSurf to surface_tank_capacity #// data[\"ruSurf\"][j,:,:], data [ \"surface_tank_capacity\" ], data [ \"hum\" ][ j ,:,:], ) return data","title":"update_hum_for_end_of_cycle"},{"location":"reference/sarra_py/bilan_hydro/#update_hum_step_2","text":"def update_hum_step_2 ( j , data ) We update the depth to humectation front (hum) again, to reflect eventual changes in total_tank_stock values. ? we could have placed the previous hum update function here Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_hum_step_2 ( j , data ) : \"\"\" We update the depth to humectation front ( hum ) again , to reflect eventual changes in total_tank_stock values . ? we could have placed the previous hum update function here Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # groupe 38 # // avant modif 10 / 06 / 2015 # data [ \" hum \" ][ j :,:,:] = np . maximum ( data [ \" hum \" ][ j ,:,:], data [ \" stRu \" ][ j ,:,:] ) # essais stTot # ! renaming stTot to total_tank_stock # // data [ \" hum \" ][ j :,:,:] = np . maximum ( data [ \" hum \" ][ j ,:,:], data [ \" stTot \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" hum \" ][ j :,:,:] = np . maximum ( data [ \" hum \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] ) #[..., np . newaxis ] # ! en conflit avec le calcul pr \u00e9 c \u00e9 dent de hum return data","title":"update_hum_step_2"},{"location":"reference/sarra_py/bilan_hydro/#update_irrigation_tank_capacity","text":"def update_irrigation_tank_capacity ( j , data ) Update Irrigation Tank Capacity The function updates the maximum water capacity of irrigation tank based on the conditions specified in the function. If the automatic irrigation mode is ON, and if the current phase is between 0 and 6, and if the root tank capacity is less than the surface tank capacity, meaning that the roots have not reached the limit between the surface compartment and deep compartment, then the irrigation tank capacity is set to the surface tank capacity, which is given a minimum value equal to the surface tank capacity. Otherwise, the irrigation tank capacity remains unchanged. If we are in automatic irrigation mode, and between phases 0 and 6, and if root_tank_capacity is less than surface_tank_capacity, meaning that roots haven't reached the limit between the surface compartment and deep compartment, then we define irrigation_tank_capacity as equal to surface_tank_capacity, that is to say, we give to irrigation_tank_capacity a minimum value that equals surface_tank_capacity. else, we do not modify irrigation_tank_capacity value Parameters: Name Type Description Default j int Index of the time step being processed. None data xarray dataset The input dataset containing all the information necessary to run the model. None Returns: Type Description None xarray dataset: The input dataset with updated values of the irrigation tank capacity. View Source def update_irrigation_tank_capacity ( j , data ) : \"\"\" Update Irrigation Tank Capacity The function updates the maximum water capacity of irrigation tank based on the conditions specified in the function . If the automatic irrigation mode is ON , and if the current phase is between 0 and 6 , and if the root tank capacity is less than the surface tank capacity , meaning that the roots have not reached the limit between the surface compartment and deep compartment , then the irrigation tank capacity is set to the surface tank capacity , which is given a minimum value equal to the surface tank capacity . Otherwise , the irrigation tank capacity remains unchanged . If we are in automatic irrigation mode , and between phases 0 and 6 , and if root_tank_capacity is less than surface_tank_capacity , meaning that roots haven ' t reached the limit between the surface compartment and deep compartment , then we define irrigation_tank_capacity as equal to surface_tank_capacity , that is to say , we give to irrigation_tank_capacity a minimum value that equals surface_tank_capacity . else , we do not modify irrigation_tank_capacity value Args : j ( int ) : Index of the time step being processed . data ( xarray dataset ) : The input dataset containing all the information necessary to run the model . Returns : xarray dataset : The input dataset with updated values of the irrigation tank capacity . \"\"\" # group 2 condition = \\ ( data [ \" irrigAuto \" ][ j , :, :] == True ) & \\ ( data [ \" numPhase \" ][ j , :, :] > 0 ) & \\ ( data [ \" numPhase \" ][ j , :, :] < 6 ) # renaming ruIrr with irrigation_tank_capacity # // data [ \" ruIrr \" ][ j , :, :] = np . where ( data [ \" irrigation_tank_capacity \" ][ j , :, :] = np . where ( condition , np . where ( # ! renaming stRurMax to root_tank_capacity # ! renaming ruSurf with surface_tank_capacity # // ( data [ \" stRurMax \" ] < data [ \" ruSurf \" ] ) , data [ \" root_tank_capacity \" ][ j ,:,:] < data [ \" surface_tank_capacity \" ], # // data [ \" ruSurf \" ], data [ \" surface_tank_capacity \" ], # // data [ \" stRurMax \" ], data [ \" root_tank_capacity \" ][ j ,:,:], ) , data [ \" irrigation_tank_capacity \" ][ j , :, :], ) return data","title":"update_irrigation_tank_capacity"},{"location":"reference/sarra_py/bilan_hydro/#update_irrigation_tank_stock","text":"def update_irrigation_tank_stock ( j , data ) Update the Irrigation Tank Stock In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged. Parameters: Name Type Description Default j int Index of time step in data None data xarray Dataset Dataset that contains various data fields None Returns: Type Description None xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions. View Source def update_irrigation_tank_stock ( j , data ): \"\"\" Update the Irrigation Tank Stock In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged. Args: j (int): Index of time step in data data (xarray Dataset): Dataset that contains various data fields Returns: xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions. \"\"\" condition = ( data [ \"irrigAuto\" ][ j , :, :] == True ) & \\ ( data [ \"numPhase\" ][ j , :, :] > 0 ) & \\ ( data [ \"numPhase\" ][ j , :, :] < 6 ) # group 1 #! renaming stockIrr with irrigation_tank_stock #//data[\"stockIrr\"][j, :, :] = np.where( data [ \"irrigation_tank_stock\" ][ j , :, :] = np . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf with surface_tank_capacity #// (data[\"stRurMax\"] < data[\"ruSurf\"]), ( data [ \"root_tank_capacity\" ] < data [ \"surface_tank_capacity\" ])[ j , :, :], #! renaming stRuSurf to surface_tank_stock #// data[\"stRuSurf\"][j, :, :], data [ \"surface_tank_stock\" ][ j , :, :], #! renaming stRur to root_tank_stock #// data[\"stRur\"][j, :, :], data [ \"root_tank_stock\" ][ j , :, :], ), data [ \"irrigation_tank_stock\" ][ j , :, :], ) return data","title":"update_irrigation_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#update_mulch_water_stock","text":"def update_mulch_water_stock ( j , data ) Updating water stock in mulch (stockMc, mm) : The water stock in mulch is updated by adding the gathered water (eauCaptee, mm) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_mulch_water_stock ( j , data ): \"\"\" Updating water stock in mulch (stockMc, mm) : The water stock in mulch is updated by adding the gathered water (eauCaptee, mm) Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # ! correction as broadcasting on xarray seems less constrained than on numpy # group 9 #! replacing eauCaptee by water_gathered_by_mulch #! replacing stockMc by mulch_water_stock #// data[\"stockMc\"][j:,:,:] = (data[\"stockMc\"][j,:,:] + data[\"eauCaptee\"][j,:,:]) # //[...,np.newaxis] data [ \"mulch_water_stock\" ][ j :,:,:] = ( data [ \"mulch_water_stock\" ][ j ,:,:] + data [ \"water_gathered_by_mulch\" ][ j ,:,:]) # //[...,np.newaxis] return data","title":"update_mulch_water_stock"},{"location":"reference/sarra_py/bilan_hydro/#update_plant_transpiration","text":"def update_plant_transpiration ( j , data ) reajustement de la qte transpirable considerant que l'evap a eu lieu avant mise a jour des stocks transpirables if plant transpiration is higher than the root tank stock, then plant transpiration is updated to be equal to the difference between the root tank stock and the plant transpiration. Else, its value is unmodified. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_plant_transpiration ( j , data ) : \"\"\" reajustement de la qte transpirable considerant que l ' evap a eu lieu avant mise a jour des stocks transpirables if plant transpiration is higher than the root tank stock , then plant transpiration is updated to be equal to the difference between the root tank stock and the plant transpiration . Else , its value is unmodified . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 65 data [ \" tr \" ][ j :,:,:] = np . where ( # ! renaming stRur to root_tank_stock # // data [ \" tr \" ][ j ,:,:] > data [ \" stRur \" ][ j ,:,:], data [ \" tr \" ][ j ,:,:] > data [ \" root_tank_stock \" ][ j ,:,:], # // np . maximum ( data [ \" stRur \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:], 0 ) , np . maximum ( data [ \" root_tank_stock \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:], 0 ) , data [ \" tr \" ][ j ,:,:], ) return data","title":"update_plant_transpiration"},{"location":"reference/sarra_py/bilan_hydro/#update_root_tank_capacity","text":"def update_root_tank_capacity ( j , data ) updating root_tank_capacity/stRurMax/ruRac, step 2 : At the day of phase change, for phases strictly above 1, root_tank_capacity is updated to be summed with the change in root water storage capacity delta_root_tank_capacity. In other words, root_tank_capacity is incremented by the change in root water storage capacity linked to root growth. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_capacity ( j , data ) : \"\"\" updating root_tank_capacity / stRurMax / ruRac , step 2 : At the day of phase change , for phases strictly above 1 , root_tank_capacity is updated to be summed with the change in root water storage capacity delta_root_tank_capacity . In other words , root_tank_capacity is incremented by the change in root water storage capacity linked to root growth . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 17 # ! simplified conditions # // data [ \" stRurMax \" ][ j :,:,:] = np . where ( # // ( data [ \" numPhase \" ][ j ,:,:] > 0 ) , # // np . where ( # // np . invert (( data [ \" changePhase \" ][ j ,:,:] == 1 ) & ( data [ \" numPhase \" ][ j ,:,:] == 1 )) , # // data [ \" stRurMax \" ][ j ,:,:] + data [ \" deltaRur \" ][ j ,:,:], # // data [ \" stRurMax \" ][ j ,:,:], # // ) , # // data [ \" stRurMax \" ][ j ,:,:], # // ) #[..., np . newaxis ] # ! renaming stRurMax to root_tank_capacity # ! renaming deltaRur to delta_root_tank_capacity # // data [ \" stRurMax \" ][ j :,:,:] = np . where ( data [ \" root_tank_capacity \" ][ j :,:,:] = np . where ( ( data [ \" numPhase \" ][ j ,:,:] > 1 ) & ( data [ \" changePhase \" ][ j ,:,:] == 1 ) , # // data [ \" stRurMax \" ][ j ,:,:] + data [ \" deltaRur \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:] + data [ \" delta_root_tank_capacity \" ][ j ,:,:], # // data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:], ) return data","title":"update_root_tank_capacity"},{"location":"reference/sarra_py/bilan_hydro/#update_root_tank_stock","text":"def update_root_tank_stock ( j , data ) updating root_tank_stock/stRur/stockrac : At the day of phase change, for phases strictly above 1, and for which the root_tank_capacity is above surface_tank_capacity (meaning that roots go beyond the surface water storage capacity), root_tank_stock is incremented by delta_root_tank_capacity. However, if root_tank_capacity is BELOW surface_tank_capacity (meaning that roots do not plunge into the deep reservoir), root_tank_stock is updated to be equal to surface_tank_stock minus 1/10th of the surface_tank_capacity, multiplied by the ratio between root_tank_capacity and surface_tank_capacity. That is to say \"we take at the prorata of depth and surface stock\". For any other day, root_tank_stock is unchanged. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock ( j , data ) : \"\"\" updating root_tank_stock/stRur/stockrac : At the day of phase change, for phases strictly above 1, and for which the root_tank_capacity is above surface_tank_capacity (meaning that roots go beyond the surface water storage capacity), root_tank_stock is incremented by delta_root_tank_capacity. However, if root_tank_capacity is BELOW surface_tank_capacity (meaning that roots do not plunge into the deep reservoir), root_tank_stock is updated to be equal to surface_tank_stock minus 1/10th of the surface_tank_capacity, multiplied by the ratio between root_tank_capacity and surface_tank_capacity. That is to say \" we take at the prorata of depth and surface stock \". For any other day, root_tank_stock is unchanged. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" # group 18 # ! simplified conditions # // condition = ( data [ \"numPhase\" ][ j,:,: ] > 0 ) & np . invert (( data [ \"changePhase\" ][ j,:,: ] == 1 ) & ( data [ \"numPhase\" ][ j,:,: ] == 1 )), condition = ( data [ \"numPhase\" ][ j,:,: ] > 1 ) & ( data [ \"changePhase\" ][ j,:,: ] == 1 ), #! renaming stRur to root_tank_stock # // data [ \"stRur\" ][ j:,:,: ] = np . where ( data [ \"root_tank_stock\" ][ j:,:,: ] = xr . where ( condition , xr . where ( #! renaming stRurMax to root_tank_capacity #! renaming ruSurf to surface_tank_capacity # // ( data [ \"stRurMax\" ][ j,:,: ] > data [ \"ruSurf\" ][ j,:,: ] ), ( data [ \"root_tank_capacity\" ][ j,:,: ] > data [ \"surface_tank_capacity\" ] ), #! renaming stRur to root_tank_stock #! renaming deltaRur to delta_root_tank_capacity # // data [ \"stRur\" ][ j,:,: ] + data [ \"deltaRur\" ][ j,:,: ] , data [ \"root_tank_stock\" ][ j,:,: ] + data [ \"delta_root_tank_capacity\" ][ j,:,: ] , #! renaming stRur to root_tank_stock #! renaming stRuSurf to surface_tank_stock # // np . maximum (( data [ \"stRuSurf\" ][ j,:,: ] - data [ \"ruSurf\" ][ j,:,: ] * 1 / 10 ) * ( data [ \"stRurMax\" ][ j,:,: ] / data [ \"ruSurf\" ][ j,:,: ] ), 0 ), np . maximum (( data [ \"surface_tank_stock\" ][ j,:,: ] - data [ \"surface_tank_capacity\" ] * 1 / 10 ) * ( data [ \"root_tank_capacity\" ][ j,:,: ] / data [ \"surface_tank_capacity\" ] ), 0 ), ). expand_dims ( \"time\" , axis = 0 ), #! renaming stRur to root_tank_stock # // data [ \"stRur\" ][ j,:,: ] , data [ \"root_tank_stock\" ][ j,:,: ] , ) return data","title":"update_root_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#update_root_tank_stock_step_2","text":"def update_root_tank_stock_step_2 ( j , data ) Finally, we update root tank stock (root_tank_stock) with the computed values First we increment root_tank_stock with transpirable water (eauTranspi), within the limits of root_tank_capacity. Then, we limit the value of root_tank_stock within total_tank_stock Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock_step_2 ( j , data ) : \"\"\" Finally , we update root tank stock ( root_tank_stock ) with the computed values First we increment root_tank_stock with transpirable water ( eauTranspi ) , within the limits of root_tank_capacity . Then , we limit the value of root_tank_stock within total_tank_stock Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # groupe 39 # Rempli res racines # ! renaming stRur to root_tank_stock # ! renaming stRurMax to root_tank_capacity # // data [ \" stRur \" ][ j :,:,:] = np . minimum ( data [ \" stRur \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:], data [ \" stRurMax \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" root_tank_stock \" ][ j :,:,:] = np . minimum ( data [ \" root_tank_stock \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:] ) #[..., np . newaxis ] # groupe 40 # essais stTot # ! renaming stRur to root_tank_stock # ! renaming stTot to total_tank_stock # // data [ \" stRur \" ][ j ,:,:] = np . minimum ( data [ \" stRur \" ][ j ,:,:], data [ \" stRu \" ][ j ,:,:] ) data [ \" root_tank_stock \" ][ j :,:,:] = np . minimum ( data [ \" root_tank_stock \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] ) #[..., np . newaxis ] return data","title":"update_root_tank_stock_step_2"},{"location":"reference/sarra_py/bilan_hydro/#update_root_tank_stock_with_transpiration","text":"def update_root_tank_stock_with_transpiration ( j , data ) summary Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock_with_transpiration ( j , data ) : \"\"\" _summary_ Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 67 # ! renaming stRur to root_tank_stock # // data [ \" stRur \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRur \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] data [ \" root_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" root_tank_stock \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] return data","title":"update_root_tank_stock_with_transpiration"},{"location":"reference/sarra_py/bilan_hydro/#update_root_tank_stock_with_water_consumption","text":"def update_root_tank_stock_with_water_consumption ( j , data ) This function updates root tank stock according to water consumption. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_root_tank_stock_with_water_consumption ( j , data ) : \"\"\" This function updates root tank stock according to water consumption . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 64 # ! renaming stRur to root_tank_stock # // data [ \" stRur \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRur \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) #[..., np . newaxis ] data [ \" root_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" root_tank_stock \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) return data","title":"update_root_tank_stock_with_water_consumption"},{"location":"reference/sarra_py/bilan_hydro/#update_struprec","text":"def update_stRuPrec ( j , data ) This function performs the update of total_tank_stock_previous_value/stRuPrec in the reservoir filling wrapper function. It will decrease the total_tank_stock_previous_value depending on the variation of transpirable water and height of humectation front. test image markdown In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day (condition 3 passed), then total_tank_stock_previous_value equals 0. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock_previous_value is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we decrease the value of total_tank_stock_previous_value by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock_previous_value will remain unchanged, and if the root tank is full, total_tank_stock_previous_value will be decreased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRuPrec ( j , data ) : \"\"\" This function performs the update of total_tank_stock_previous_value / stRuPrec in the reservoir filling wrapper function . It will decrease the total_tank_stock_previous_value depending on the variation of transpirable water and height of humectation front . test image markdown ! [ Drag Racing ]( Dragster . jpg ) In this function , if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), if the depth of humectation front ( hum ) is above the root_tank_capacity_previous_season ( condition 1 passed , and 2 failed , which should be the case for most of the simulations that will be single - season ), and if the depth of humectation front ( hum ) has decreased since the previous day ( condition 3 passed ), then total_tank_stock_previous_value equals 0. If the depth of humectation front did not change or increased since the previous day ( humPrec ), then total_tank_stock_previous_value is unchanged . Notably , root_tank_capacity_previous_season is initialized at 0 , and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity . humPrec is initialized with the same value as hum . However , in the update_humPrec_for_end_of_cycle function , at the day of transition between phase 7 and phase 0 , it takes hum as value , with a minimum bound of surface_tank_capacity . Starting from second simulation season ( root_tank_capacity_previous_season != 0 ), if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), and if the depth of humectation front stays below or equel to the total soil capacity ( conditions 1 and 2 passed ), then we decrease the value of total_tank_stock_previous_value by a the difference of water height between the variation of total tank stock ( delta_total_tank_stock ) and the depth of humectation front ( hum ), proportionally to the filling of the root tank capacity of previous season ( stRurPrec ). Thus , if the root tank is empty , total_tank_stock_previous_value will remain unchanged , and if the root tank is full , total_tank_stock_previous_value will be decreased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) # group 32 #! renaming stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"][j:,:,:] = np.where( data [ \"total_tank_stock_previous_value\" ][ j : , : , : ] = np . where ( condition_1 , np . where ( condition_2 , #! replacing stRurPrec with ratio formula #! renaming stRuVar with delta_total_tank_stock #! renaming stRuPrec with total_tank_stock_previous_value # //np.maximum(0, data[\"stRuPrec\"][j,:,:] - (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:]), np . maximum ( 0 , data [ \"total_tank_stock_previous_value\" ][ j , : , : ] - ( data [ \"delta_total_tank_stock\" ][ j , : , : ] - data [ \"hum\" ][ j , : , : ]) * data [ \"stRurPrec\" ][ j , : , : ]), np . where ( condition_3 , 0 , #! renaming stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j , : , : ], ), ), #! renaming stRuPrec with total_tank_stock_previous_value # // data[\"stRuPrec\"][j,:,:], data [ \"total_tank_stock_previous_value\" ][ j , : , : ], ) return data","title":"update_stRuPrec"},{"location":"reference/sarra_py/bilan_hydro/#update_struprec_for_end_of_cycle","text":"def update_stRuPrec_for_end_of_cycle ( j , data ) when the phase changes from 7 to 1, the stRuPrec (mm, previous water storage capacity of the global reservoir) is set to equal the differe,ce between stTot (mm, total water storage capacity of the global reservoir) and stRurSurf (mm, water storage capacity of the surface reservoir) Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRuPrec_for_end_of_cycle ( j , data ) : \"\"\" when the phase changes from 7 to 1 , the stRuPrec ( mm , previous water storage capacity of the global reservoir ) is set to equal the differe , ce between stTot ( mm , total water storage capacity of the global reservoir ) and stRurSurf ( mm , water storage capacity of the surface reservoir ) Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 24 # ! stRurSurf is not defined ... we may want to drop this group condition = condition_end_of_cycle ( j , data ) # ! renaming stRuPrec to total_tank_stock_previous_value # // data [ \" stRuPrec \" ][ j :,:,:] = np . where ( data [ \" total_tank_stock_previous_value \" ][ j :,:,:] = np . where ( condition , # ! renaming stTot to total_tank_stock # ! renaming stRuSurf with surface_tank_stock # // data [ \" stRu \" ][ j ,:,:] - data [ \" stRurSurf \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" surface_tank_stock \" ][ j ,:,:], # essai stTot # ! renaming stRuPrec to total_tank_stock_previous_value # // data [ \" stRuPrec \" ][ j ,:,:], data [ \" total_tank_stock_previous_value \" ][ j ,:,:], ) return data","title":"update_stRuPrec_for_end_of_cycle"},{"location":"reference/sarra_py/bilan_hydro/#update_strurmaxprec_for_end_of_cycle","text":"def update_stRurMaxPrec_for_end_of_cycle ( j , data ) When the phase changes from 7 to 1, the stRurMaxPrec (mm, previous maximum water capacity to root front) is set to equal root_tank_capacity (mm). Value is broadcasted along time dimension. For every other day, it keeps its initial value of 0. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRurMaxPrec_for_end_of_cycle ( j , data ) : \"\"\" When the phase changes from 7 to 1 , the stRurMaxPrec ( mm , previous maximum water capacity to root front ) is set to equal root_tank_capacity ( mm ) . Value is broadcasted along time dimension . For every other day , it keeps its initial value of 0 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 22 condition = condition_end_of_cycle ( j , data ) # ! renaming stRurMaxPrec to root_tank_capacity_previous_season # // data [ \" stRurMaxPrec \" ][ j :,:,:] = np . where ( data [ \" root_tank_capacity_previous_season \" ][ j :,:,:] = np . where ( condition , # ! renaming stRurMax to root_tank_capacity # // data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j ,:,:], # ! renaming stRurMaxPrec to root_tank_capacity_previous_season # // data [ \" stRurMaxPrec \" ][ j ,:,:], data [ \" root_tank_capacity_previous_season \" ][ j ,:,:], ) return data","title":"update_stRurMaxPrec_for_end_of_cycle"},{"location":"reference/sarra_py/bilan_hydro/#update_strurprec_for_end_of_cycle","text":"def update_stRurPrec_for_end_of_cycle ( j , data ) when the phase changes from 7 to 1, stRurPrec is set to equal stRur/stRurMax, that is to say the ratio of the water storage capacity of the root reservoir. Otherwise, it stays at its initial value of 0. Its value is broadcasted along j. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_stRurPrec_for_end_of_cycle ( j , data ) : \"\"\" when the phase changes from 7 to 1 , stRurPrec is set to equal stRur / stRurMax , that is to say the ratio of the water storage capacity of the root reservoir . Otherwise , it stays at its initial value of 0 . Its value is broadcasted along j . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 23 condition = condition_end_of_cycle ( j , data ) data [ \" stRurPrec \" ][ j :,:,:] = np . where ( condition , # ! renaming stRur to root_tank_stock # ! renaming stRurMax to root_tank_capacity # // data [ \" stRur \" ][ j ,:,:] / data [ \" stRurMax \" ][ j ,:,:], data [ \" root_tank_stock \" ][ j ,:,:] / data [ \" root_tank_capacity \" ][ j ,:,:], data [ \" stRurPrec \" ][ j ,:,:], ) return data","title":"update_stRurPrec_for_end_of_cycle"},{"location":"reference/sarra_py/bilan_hydro/#update_surface_tank_stock","text":"def update_surface_tank_stock ( j , data ) This function updates the value of surface_tank_stock. We update surface_tank_stock by adding the eauDispo, which as this point is the water available from 1) rain, 2) irrigation for the day after estimation of intake by mulch, and 3) runoff. However, we do not allow surface_tank_stock to exceed 110% of the surface_tank_capacity. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_surface_tank_stock ( j , data ) : \"\"\" This function updates the value of surface_tank_stock . We update surface_tank_stock by adding the eauDispo , which as this point is the water available from 1 ) rain , 2 ) irrigation for the day after estimation of intake by mulch , and 3 ) runoff . However , we do not allow surface_tank_stock to exceed 110 % of the surface_tank_capacity . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 27 # ! renaming stRuSurf to surface_tank_stock # // data [ \" stRuSurf \" ][ j :,:,:] = np . minimum ( data [ \" surface_tank_stock \" ][ j :,:,:] = np . minimum ( # // data [ \" stRuSurf \" ][ j ,:,:] + data [ \" eauDispo \" ][ j ,:,:], data [ \" surface_tank_stock \" ][ j ,:,:] + data [ \" eauDispo \" ][ j ,:,:], # ! renaming ruSurf to surface_tank_capacity # // 1 . 1 * data [ \" ruSurf \" ][ j ,:,:] 1 . 1 * data [ \" surface_tank_capacity \" ] ) return data","title":"update_surface_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#update_surface_tank_stock_according_to_transpiration","text":"def update_surface_tank_stock_according_to_transpiration ( j , data ) This function updates the surface tank stock to reflect plant transpiration. if the root tank stock is above 0, then surface tank stock is updated by subtracting the plant transpiration modulated by the ratio between the transpirable water and the root tank stock. That is to say, the more transpirable water is close to the root tank stock, the more of transpirated water by plant will be removed from surface tank stock. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_surface_tank_stock_according_to_transpiration ( j , data ) : \"\"\" This function updates the surface tank stock to reflect plant transpiration . if the root tank stock is above 0 , then surface tank stock is updated by subtracting the plant transpiration modulated by the ratio between the transpirable water and the root tank stock . That is to say , the more transpirable water is close to the root tank stock , the more of transpirated water by plant will be removed from surface tank stock . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 66 # ! renaming stRuSurf with surface_tank_stock # // data [ \" stRuSurf \" ][ j :,:,:] = np . where ( data [ \" surface_tank_stock \" ][ j :,:,:] = np . where ( # ! renaming stRur to surface_tank_stock # // data [ \" stRur \" ][ j ,:,:] > 0 , data [ \" root_tank_stock \" ][ j ,:,:] > 0 , # // np . maximum ( data [ \" stRuSurf \" ][ j ,:,:] - ( data [ \" tr \" ][ j ,:,:] * np . minimum ( data [ \" trSurf \" ][ j ,:,:] / data [ \" stRur \" ][ j ,:,:], 1 )) , 0 ) , # ! renaming stRuSurf with surface_tank_stock # // np . maximum ( data [ \" stRuSurf \" ][ j ,:,:] - ( data [ \" tr \" ][ j ,:,:] * np . minimum ( data [ \" trSurf \" ][ j ,:,:] / data [ \" root_tank_stock \" ][ j ,:,:], 1 )) , 0 ) , np . maximum ( data [ \" surface_tank_stock \" ][ j ,:,:] - \\ ( data [ \" tr \" ][ j ,:,:] * np . minimum ( data [ \" trSurf \" ][ j ,:,:] / data [ \" root_tank_stock \" ][ j ,:,:], 1 )) , 0 , ) , # // data [ \" stRuSurf \" ][ j ,:,:], data [ \" surface_tank_stock \" ][ j ,:,:], ) return data","title":"update_surface_tank_stock_according_to_transpiration"},{"location":"reference/sarra_py/bilan_hydro/#update_total_tank_stock","text":"def update_total_tank_stock ( j , data ) This functions updates the value of total_tank_stock with the value of transpirable water. ? why incrementing stTot by eauTranspi ? ? we then consider that transpirable water is the water that fills the total_tank_stock ? Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock ( j , data ) : \"\"\" This functions updates the value of total_tank_stock with the value of transpirable water . ? why incrementing stTot by eauTranspi ? ? we then consider that transpirable water is the water that fills the total_tank_stock ? Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 29 # ! renaming stTot with total_tank_stock # // data [ \" stTot \" ][ j :,:,:] = ( data [ \" stTot \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:] ) . copy () #[..., np . newaxis ] data [ \" total_tank_stock \" ][ j :,:,:] = ( data [ \" total_tank_stock \" ][ j ,:,:] + data [ \" eauTranspi \" ][ j ,:,:] ) return data","title":"update_total_tank_stock"},{"location":"reference/sarra_py/bilan_hydro/#update_total_tank_stock_step_2","text":"def update_total_tank_stock_step_2 ( j , data ) This function performs the second update of total_tank_stock/stTot/stRu in the reservoir filling wrapper function. It will increase the total_tank_stock depending on the variation of transpirable water and height of humectation front. test image markdown In this function, if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), if the depth of humectation front (hum) is above the root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which should be the case for most of the simulations that will be single-season), and if the depth of humectation front (hum) has decreased since the previous day, then total_tank_stock takes delta_total_tank_stock as value. If the depth of humectation front did not change or increased since the previous day (humPrec), then total_tank_stock is unchanged. Notably, root_tank_capacity_previous_season is initialized at 0, and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity. humPrec is initialized with the same value as hum. However, in the update_humPrec_for_end_of_cycle function, at the day of transition between phase 7 and phase 0, it takes hum as value, with a minimum bound of surface_tank_capacity. Starting from second simulation season (root_tank_capacity_previous_season != 0), if the variation of transpirable water (delta_total_tank_stock) increases above the depth of humectation front (hum), and if the depth of humectation front stays below or equel to the total soil capacity (conditions 1 and 2 passed), then we increase the value of total_tank_stock by a the difference of water height between the variation of total tank stock (delta_total_tank_stock) and the depth of humectation front (hum), proportionally to the filling of the root tank capacity of previous season (stRurPrec). Thus, if the root tank is empty, total_tank_stock will remain unchanged, and if the root tank is full, total_tank_stock will be increased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock_step_2 ( j , data ) : \"\"\" This function performs the second update of total_tank_stock / stTot / stRu in the reservoir filling wrapper function . It will increase the total_tank_stock depending on the variation of transpirable water and height of humectation front . test image markdown ! [ Drag Racing ]( Dragster . jpg ) In this function , if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), if the depth of humectation front ( hum ) is above the root_tank_capacity_previous_season ( condition 1 passed , and 2 failed , which should be the case for most of the simulations that will be single - season ), and if the depth of humectation front ( hum ) has decreased since the previous day , then total_tank_stock takes delta_total_tank_stock as value . If the depth of humectation front did not change or increased since the previous day ( humPrec ), then total_tank_stock is unchanged . Notably , root_tank_capacity_previous_season is initialized at 0 , and takes another value only at end of cycle ; hum is initialized at a value different from 0 and evolves daily between delta_total_tank_stock and total_tank_capacity . humPrec is initialized with the same value as hum . However , in the update_humPrec_for_end_of_cycle function , at the day of transition between phase 7 and phase 0 , it takes hum as value , with a minimum bound of surface_tank_capacity . Starting from second simulation season ( root_tank_capacity_previous_season != 0 ), if the variation of transpirable water ( delta_total_tank_stock ) increases above the depth of humectation front ( hum ), and if the depth of humectation front stays below or equel to the total soil capacity ( conditions 1 and 2 passed ), then we increase the value of total_tank_stock by a the difference of water height between the variation of total tank stock ( delta_total_tank_stock ) and the depth of humectation front ( hum ), proportionally to the filling of the root tank capacity of previous season ( stRurPrec ). Thus , if the root tank is empty , total_tank_stock will remain unchanged , and if the root tank is full , total_tank_stock will be increased up to the amount of water making the difference between quantity of water for humectation front and the variation in daily transpirable water . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition_1 , condition_2 , condition_3 = conditions_rempliRes ( j , data ) #! renaming stTot to total_tank_stock # // data[\"stTot\"][j:,:,:] = np.where( data [ \"total_tank_stock\" ][ j : , : , : ] = np . where ( condition_1 , np . where ( #! condition_2 , #! we replace stRurPrec with stRur at indice j-1 #! renaming stRur to root_tank_stock #! renaming stTot to total_tank_stock #! renaming stRuVar with delta_total_tank_stock # // data[\"stTot\"][j,:,:] + (data[\"stRuVar\"][j,:,:] - data[\"hum\"][j,:,:]) * data[\"stRurPrec\"][j,:,:], data [ \"total_tank_stock\" ][ j , : , : ] + ( data [ \"delta_total_tank_stock\" ][ j , : , : ] - data [ \"hum\" ][ j , : , : ]) * data [ \"stRurPrec\" ][ j , : , : ], np . where ( condition_3 , #! renaming stRuVar with delta_total_tank_stock # //data[\"stRuVar\"][j,:,:], data [ \"delta_total_tank_stock\" ][ j , : , : ], #! renaming stTot to total_tank_stock # // data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j , : , : ], ), ), #! renaming stTot to total_tank_stock # // data[\"stTot\"][j,:,:], data [ \"total_tank_stock\" ][ j , : , : ], ) return data","title":"update_total_tank_stock_step_2"},{"location":"reference/sarra_py/bilan_hydro/#update_total_tank_stock_step_3","text":"def update_total_tank_stock_step_3 ( j , data ) This function updates the total tank stock where these is overflow occuring. When capacity of total tank is exceeded, it corrects the stock value with maximum capacity of total tank. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock_step_3 ( j , data ) : \"\"\" This function updates the total tank stock where these is overflow occuring . When capacity of total tank is exceeded , it corrects the stock value with maximum capacity of total tank . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // condition = ( data [ \" stTot \" ][ j ,:,:] > data [ \" stRuMax \" ][ j ,:,:] ) condition = condition_total_tank_overflow ( j , data ) # groupe 37 # essais stTot # ! renaming stTot to total_tank_stock # ! renaming stRuMax to total_tank_capacity # // data [ \" stRu \" ][ j ,:,:] = np . where ( # // data [ \" stTot \" ][ j :,:,:] = np . where ( data [ \" total_tank_stock \" ][ j :,:,:] = np . where ( condition , # // data [ \" stRuMax \" ][ j ,:,:], data [ \" total_tank_capacity \" ][ j ,:,:], # data [ \" stRu \" ][ j ,:,:], # // data [ \" stTot \" ][ j ,:,:], data [ \" total_tank_stock \" ][ j ,:,:], ) #[..., np . newaxis ] return data","title":"update_total_tank_stock_step_3"},{"location":"reference/sarra_py/bilan_hydro/#update_total_tank_stock_with_transpiration","text":"def update_total_tank_stock_with_transpiration ( j , data ) View Source def update_total_tank_stock_with_transpiration ( j , data ) : # data [ \" stRu \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stRu \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) # essais stTot # group 68 # ! renaming stTot to total_tank_stock # // data [ \" stTot \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stTot \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] data [ \" total_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" tr \" ][ j ,:,:] ) #[..., np . newaxis ] ## ok return data","title":"update_total_tank_stock_with_transpiration"},{"location":"reference/sarra_py/bilan_hydro/#update_total_tank_stock_with_water_consumption","text":"def update_total_tank_stock_with_water_consumption ( j , data ) This function updates the total tank stock by subtracting the lower water consumption value from estimate_water_consumption_from_root_tank_stock Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_total_tank_stock_with_water_consumption ( j , data ) : \"\"\" This function updates the total tank stock by subtracting the lower water consumption value from estimate_water_consumption_from_root_tank_stock Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # group 62 # ! renaming stTot to total_tank_stock # // data [ \" stTot \" ][ j :,:,:] = np . maximum ( 0 , data [ \" stTot \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) [..., np . newaxis ] data [ \" total_tank_stock \" ][ j :,:,:] = np . maximum ( 0 , data [ \" total_tank_stock \" ][ j ,:,:] - data [ \" consoRur \" ][ j ,:,:] ) #[..., np . newaxis ] return data","title":"update_total_tank_stock_with_water_consumption"},{"location":"reference/sarra_py/bilan_hydro/#update_water_consumption_according_to_rooting","text":"def update_water_consumption_according_to_rooting ( j , data ) This function updates the water consumption consoRur according to rooting depth. If the root tank capacity is lower than the surface tank capacity, meaning than the roots did not dive into the deep tank yet, then the water consumption is updated to equal the evaporation at the prorata of the exploration of surface tank by the roots. Else, consoRur keeps it value, which was previously computed by estimate_water_consumption_from_root_tank_stock. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def update_water_consumption_according_to_rooting ( j , data ) : \"\"\" This function updates the water consumption consoRur according to rooting depth . If the root tank capacity is lower than the surface tank capacity , meaning than the roots did not dive into the deep tank yet , then the water consumption is updated to equal the evaporation at the prorata of the exploration of surface tank by the roots . Else , consoRur keeps it value , which was previously computed by estimate_water_consumption_from_root_tank_stock . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # fraction d ' eau evapore sur la part transpirable qd les racines sont moins # profondes que le reservoir de surface , mise a jour des stocks transpirables # group 63 data [ \" consoRur \" ][ j :,:,:] = np . where ( # ! renaming stRurMax with root_tank_capacity # ! renaming ruSurf with surface_tank_capacity # // data [ \" stRurMax \" ][ j ,:,:] < data [ \" ruSurf \" ][ j ,:,:], data [ \" root_tank_capacity \" ][ j :,:,:] < data [ \" surface_tank_capacity \" ], # ! renaming stRur to root_tank_stock # ! renaming ruSurf with surface_tank_capacity # // data [ \" evap \" ][ j ,:,:] * data [ \" stRur \" ][ j ,:,:] / data [ \" ruSurf \" ][ j ,:,:], data [ \" evap \" ][ j ,:,:] * data [ \" root_tank_stock \" ][ j ,:,:] / data [ \" surface_tank_capacity \" ], data [ \" consoRur \" ][ j ,:,:], ) return data","title":"update_water_consumption_according_to_rooting"},{"location":"reference/sarra_py/bilan_pheno/","text":"Module sarra_py.bilan_pheno View Source import numpy as np import copy import xarray as xr def reset ( j , data ): data = data . copy ( deep = True ) # when reaching stage 7, we reset the main phenological variables to zero data [ \"changePhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"changePhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"sdj\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"sdj\" ][ j ,:,:]) #[np.newaxis,...] data [ \"ruRac\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"nbJourCompte\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"startLock\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 1 , data [ \"startLock\" ][ j ,:,:]) #[np.newaxis,...] # and we leave numPhas last data [ \"numPhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] return data def testing_for_initialization ( j , data , paramITK , paramVariete ): \"\"\" This function tests if the conditions are met to initiate the crop. If numPhase is 0, if the current day is equal or above the sowing date, and if surface_tank_stock is above the threshold for sowing, we initiate the crop : 1) we set numPhase to 1 ; we broadcast the value over remaining days. 2) we set changePhase of this particular day to 1. 3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to be SDJLevee ; we broadcast the value over remaining days. 4) we set initPhase to 1 ; we broadcast the value over remaining days. initPhase is only used in update_pheno_phase_1_to_2 function, so that we do not go directly from phase 0 to phase 2. It is used as a specific flag for phase 0 to 1 transition. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" #! replacing stRuSurf by surface_tank_stock condition = \\ ( data [ \"numPhase\" ][ j , :, :] == 0 ) & \\ ( j >= data [ \"sowing_date\" ][ j ,:,:]) & \\ ( data [ \"surface_tank_stock\" ][ j , :, :] >= paramITK [ \"seuilEauSemis\" ]) # & (data[\"startLock\"][j,:,:] == 0) data [ \"numPhase\" ][ j :, :, :] = xr . where ( condition , 1 , data [ \"numPhase\" ][ j , :, :]) data [ \"changePhase\" ][ j , :, :] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j , :, :]) data [ \"seuilTempPhaseSuivante\" ][ j :, :, :] = xr . where ( condition , paramVariete [ \"SDJLevee\" ], data [ \"seuilTempPhaseSuivante\" ][ j , :, :], ) #flagging phase change has been done data [ \"initPhase\" ][ j , :, :] = xr . where ( condition , 1 , data [ \"initPhase\" ][ j , :, :] ) return data def flag_change_phase ( j , data , num_phase ): \"\"\" This function flags the day for phase change. If the phase number is above the num_phase value, and if the sum of thermal time is above the threshold, this function returns changePhase flags. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" # flagging the day for phase change condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"sdj\" ][ j ,:,:] >= data [ \"seuilTempPhaseSuivante\" ][ j ,:,:]) data [ \"changePhase\" ][ j ,:,:] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j ,:,:], ) return data def update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ): \"\"\" This function updates the sum of thermal time needed to reach the next phase. When numPhase equals the requested phase number, and if changePhase is 1 (meaning that we are at a phase transition day), the seuilTempPhaseSuivante is incremented by the thermal_time_threshold value. This value is stage-specific : - 1 to 2 : SDJLevee - 2 to 3 : SDJBVP - 4 to 5 : SDJRPR - 5 to 6 : SDJMatu1 - 6 to 7 : SDJMatu2 These parameters are passed explicitly when calling this function. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"seuilTempPhaseSuivante\" ][ j :,:,:] = np . where ( condition , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:] + thermal_time_threshold , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:] ) return data def increment_phase_number ( j , data ): \"\"\" This function increments the phase number. When the phase number is not 0, and if changePhase is 1 (meaning that we are at a phase transition day), and initPhase is 0 (meaning that the phase number has not been incremented yet this day), the phase number is incremented by 1. Also, the phase change flag initPhase is set to 1. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] != 0 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) & \\ ( data [ \"initPhase\" ][ j ,:,:] != 1 ) # incrementing phase number data [ \"numPhase\" ][ j :,:,:] = np . where ( condition , data [ \"numPhase\" ][ j ,:,:] + 1 , data [ \"numPhase\" ][ j ,:,:], ) # flagging this day as having been incremented data [ \"initPhase\" ][ j , :, :] = xr . where ( condition , 1 , data [ \"initPhase\" ][ j , :, :] ) return data def update_thermal_time_previous_phase ( j , data , num_phase ): \"\"\" This function stores the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"seuilTempPhasePrec\" ][ j :,:,:] = xr . where ( condition , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:], data [ \"seuilTempPhasePrec\" ][ j ,:,:] ) return data def update_pheno_phase_1_to_2 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 1 to 2. First, it flags the day for phase change : If numPhase is 1 and sum of thermal time is above the threshold (which value comes here from the previous function testing_for_initialization), we set changePhase of this particular day to 1. Second, we update the thermal time to next phase : if numPhase is 1 and changePhase is 1 (meaning that we are at the transition day between phases 1 and 2), we set the sum of thermal time to the next phase as SDJLevee ; we broadcast the value over remaining days. We do it before updating phase number because we need to test what is the phase number before updating it Third, we update the phase number : if numPhase is different from 0 and changePhase is 1 (meaning that we are at the transition day between two phases, to the exception of transition day between phases 0 and 1), we increment numPhase by 1 ; we broadcast the value over remaining days. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 1 thermal_time_threshold = paramVariete [ \"SDJLevee\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_2_to_3 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 2 to 3. It has the same structure as update_pheno_phase_1_to_2, with the exception of update_thermal_time_previous_phase function, which is called to store the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 2 thermal_time_threshold = paramVariete [ \"SDJBVP\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_3_to_4 ( j , data ): \"\"\" This function manages phase change from phases number 3 to 4. It is specific as phase 3 is photoperiodic ; its length is not computed the same way as the other phases. Notably, the phasePhotoper flag is updated with the PhotoperSarrahV3() function. First, this function flags the day for phase change : If numPhase is 3 and the phasePhotoper flag is 0, we set changePhase of this particular day to 1. This means the photoperiodic phase is over. Second, we update the phasePhotoper flag : if numPhase is 3 and changePhase is 1 (meaning that we are at the transition day between phases 3 and 4), we set the phasePhotoper flag to 1. Third, we update the phase number and flag incrementation using increment_phase_number(). Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" # flagging the day for phase change (specific to phase 3) condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & \\ ( data [ \"phasePhotoper\" ][ j ,:,:] == 0 ) data [ \"changePhase\" ][ j ,:,:] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j ,:,:], ) # updating phasePhotoper (specific to phase 3) condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"phasePhotoper\" ][ j ,:,:] = np . where ( condition , 1 , data [ \"phasePhotoper\" ][ j ,:,:], ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_4_to_5 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 4 to 5. It has the same structure as update_pheno_phase_2_to_3. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 4 thermal_time_threshold = paramVariete [ \"SDJRPR\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_5_to_6 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 5 to 6. It has the same structure as update_pheno_phase_2_to_3. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 5 thermal_time_threshold = paramVariete [ \"SDJMatu1\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_6_to_7 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 6 to 7. It has the same structure as update_pheno_phase_2_to_3. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 6 thermal_time_threshold = paramVariete [ \"SDJMatu2\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ): \"\"\" This function manages the evolution of the phenological phases. It is a wrapper function that calls the specific functions for each phase. This function is called at the beginning of the day and makes the phenological phases evolve. For this, it increments the phase number and changes the value of the thermal time threshold of the next phase. ChangePhase is a boolean informing the model to know if a day is a day of phase change, which is used to initialize specific variables in certain functions. It includes a generic method for the test of the end of the photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase and = 1 at the beginning of the phase. Phenological phases used in this model (as for cereal crops) : 0. from the sowing day to the beginning of the conditions favorable for germination, and from the harvest to the end of the simulation (no crop) 1. from the beginning of the conditions favorable for germination to the day of germination (du d\u00e9but des conditions favorables pour la germination au jour de la lev\u00e9e) 2. from the day of germination to the beginning of the photoperiodic phase (du jour de la lev\u00e9e au d\u00e9but de la phase photop\u00e9riodique) 3. from the beginning of the photoperiodic phase to the beginning of the reproductive phase 4. from the beginning of the reproductive phase to the beginning of the maturation (only for maize and rice) 5. from the beginning of the maturation to the grain milk stage (du d\u00e9but de la maturation au stade grain laiteux) 6. from the grain milk stage to the end of the maturation (du d\u00e9but du stade grain laiteux au jour de r\u00e9colte) 7. the day of the harvest Notes : In the case of multiannual continuous simulations, we do not reinitialize the reservoirs, at harvest we put the moisture front at the depth of the surface reservoir This allows to keep the rooting constraint phenomenon for the following season if there is little rain while having the water stock in depth remaining from the previous season. This function has been originally translated from the EvalPhenoSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. \"\"\" data = testing_for_initialization ( j , data , paramITK , paramVariete ) data = update_pheno_phase_1_to_2 ( j , data , paramVariete ) data = update_pheno_phase_2_to_3 ( j , data , paramVariete ) data = update_pheno_phase_3_to_4 ( j , data ) data = update_pheno_phase_4_to_5 ( j , data , paramVariete ) data = update_pheno_phase_5_to_6 ( j , data , paramVariete ) data = update_pheno_phase_6_to_7 ( j , data , paramVariete ) return data def calculate_daily_thermal_time ( j , data , paramVariete ): \"\"\"calculating daily thermal time Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version. Pb de m\u00e9thode !? v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase); v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2); v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin); DegresDuJour:= v * (TOpt1-TBase); # If Tmoy <= Topt2 then # DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase # else # DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2))); # If (Numphase >=1) then # SomDegresJour := SomDegresJour + DegresDuJour # else SomDegresJour := 0; Returns: _type_: _description_ \"\"\" data [ \"ddj\" ][ j ,:,:] = xr . where ( data [ \"tpMoy\" ][ j ,:,:] <= paramVariete [ \"TOpt2\" ], np . maximum ( np . minimum ( paramVariete [ \"TOpt1\" ], data [ \"tpMoy\" ][ j ,:,:]), paramVariete [ \"TBase\" ]) - paramVariete [ \"TBase\" ], ( paramVariete [ \"TOpt1\" ] - paramVariete [ \"TBase\" ]) * ( 1 - (( np . minimum ( paramVariete [ \"TLim\" ], data [ \"tpMoy\" ][ j ,:,:]) - paramVariete [ \"TOpt2\" ]) / ( paramVariete [ \"TLim\" ] - paramVariete [ \"TOpt2\" ]))), ) return data def calculate_sum_of_thermal_time ( j , data , paramVariete ): \"\"\" Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. calculating sum of thermal time sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly Note : in SARRA-H, when numPhase > 7, sdj is set to 0 and sdj stops cumulating Returns: _type_: _description_ \"\"\" data [ \"sdj\" ][ j :,:,:] = xr . where ( ( j >= data [ \"sowing_date\" ][ j ,:,:]) & ( data [ \"numPhase\" ][ j ,:,:] >= 1 ), data [ \"sdj\" ][ j - 1 ,:,:] + data [ \"ddj\" ][ j ,:,:], 0 , ) return data def update_root_growth_speed ( j , data , paramVariete ): \"\"\" This function updates the root growth speed (vRac, mm/day) according to the current phase (numPhase). This function has been adapted from the EvalVitesseRacSarraV3 procedure of the phenologie.pas and exmodules 1 & 2.pas files of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" phase_correspondances = { 1 : paramVariete [ 'VRacLevee' ], 2 : paramVariete [ 'VRacBVP' ], 3 : paramVariete [ 'VRacPSP' ], 4 : paramVariete [ 'VRacRPR' ], 5 : paramVariete [ 'VRacMatu1' ], 6 : paramVariete [ 'VRacMatu2' ], } for phase in range ( 1 , 6 ): data [ \"vRac\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == phase , phase_correspondances [ phase ], data [ \"vRac\" ][ j ,:,:], ) # phase 0 ou 7 data [ \"vRac\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 0 ) | ( data [ \"numPhase\" ][ j ,:,:] == 7 ), 0 , data [ \"vRac\" ][ j ,:,:], ) return data def update_photoperiodism ( j , data , paramVariete ): \"\"\" This function aims at managing the photoperiodic sensitivity of the crop. It first updates the sumPP variable : on the transition day between phase 2 and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100. Then, we compute the thermal_time_since_previous_phase (thermal time since the transition between phases 2 and 3), and the time_above_critical_day_length, which is the difference between day length and critical day length PPcrit, in decimal hours. On all days with numPhase = 3 (so including the transition day), the sumPP is calculated as a function of thermal_time_since_previous_phase and PPExp (attenuator for progressive PSP response to PP ; rarely used in calibration procedure, a robust value is 0.17), multiplied by a ratio between the daily time above critical day length and the difference between SeuilPP (Upper day length limit of PP response) and PPCrit (Lower day length limit to PP response). Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range 0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to 1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model) This function has been adapted from the PhotoperSarrahV3 procedure of the phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version. Notes CB : Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite photoperiodique et pour les varietes non photoperiodique. PPsens varie de 0,4 a 1,2. Pour PPsens > 2.5 = vari\u00e9t\u00e9 non photoperiodique. SeuilPP = 13.5 PPcrit = 12 SumPP est dans ce cas une variable quotidienne (et non un cumul) Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" thermal_time_since_previous_phase = np . maximum ( 0.01 , data [ \"sdj\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]) time_above_critical_day_length = np . maximum ( 0 , data [ \"dureeDuJour\" ][ j ,:,:] - paramVariete [ \"PPCrit\" ]) data [ \"sumPP\" ][ j ,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 3 , np . where ( data [ \"changePhase\" ][ j ,:,:] == 1 , # if numPhase = 3 and changePhase == 1, sumPP = 100 100 , # if numPhase = 3 and changePhase != 1, sumPP calculated through formula (( 1000 / thermal_time_since_previous_phase ) ** ( paramVariete [ \"PPExp\" ])) \\ * time_above_critical_day_length / ( paramVariete [ \"SeuilPP\" ] - paramVariete [ \"PPCrit\" ]), ), # if numPhase != 3, sumPP is not updated data [ \"sumPP\" ][ j ,:,:], ) data [ \"phasePhotoper\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & ( data [ \"sumPP\" ][ j ,:,:] < paramVariete [ \"PPsens\" ]), 0 , data [ \"phasePhotoper\" ][ j ,:,:], ) return data def MortaliteSarraV3 ( j , data , paramITK , paramVariete ): \"\"\" This functions tests for death of young plants. First, for numphase = 2 and changePhase = 1, hence at the transition day between phase 1 and 2 at this point of the loop, the nbJourCompte and nbjStress variables are set to 0. Second, for numPhase equal or above 2, on each day nbJourCompte is incremented by 1. Thus this part just count days since emergence. Third, for numPhase equal or above 2, for days where nbJourCompte is lower than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress variable is incremented by 1. Thus, we count the number of days with negative deltaBiomasseAerienne since emergence as stress days. Finally, for days where nbjStress is equal or higher than seuilCstrMortality, the crop is reset by setting numPhase, root_tank_capacity and nbjStress to 0. This all seems a bit simplistic though, and can be improved. This function has been adapted from the MortaliteSarraV3 procedure of the bilancarbonsarra.pas and exmodules 1 & 2.pas codes of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbJourCompte' ][ j ,:,:], ) data [ 'nbjStress' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbjStress' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , data [ 'nbJourCompte' ][ j ,:,:] + 1 , data [ 'nbJourCompte' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbJourCompte\" ][ j ,:,:] < paramITK [ \"nbjTestSemis\" ]) & \\ ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , data [ \"nbjStress\" ][ j ,:,:] + 1 , data [ \"nbjStress\" ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbjStress\" ][ j ,:,:] == paramVariete [ \"seuilCstrMortality\" ]) data [ \"numPhase\" ][ j ,:,:] = np . where ( condition , 0 , data [ \"numPhase\" ][ j ,:,:], ) #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"][j,:,:] = np.where( data [ \"root_tank_capacity\" ][ j ,:,:] = np . where ( condition , 0 , #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"nbjStress\" ][ j ,:,:], ) return data Functions EvalPhenoSarrahV3 def EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ) This function manages the evolution of the phenological phases. It is a wrapper function that calls the specific functions for each phase. This function is called at the beginning of the day and makes the phenological phases evolve. For this, it increments the phase number and changes the value of the thermal time threshold of the next phase. ChangePhase is a boolean informing the model to know if a day is a day of phase change, which is used to initialize specific variables in certain functions. It includes a generic method for the test of the end of the photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase and = 1 at the beginning of the phase. Phenological phases used in this model (as for cereal crops) : from the sowing day to the beginning of the conditions favorable for germination, and from the harvest to the end of the simulation (no crop) from the beginning of the conditions favorable for germination to the day of germination (du d\u00e9but des conditions favorables pour la germination au jour de la lev\u00e9e) from the day of germination to the beginning of the photoperiodic phase (du jour de la lev\u00e9e au d\u00e9but de la phase photop\u00e9riodique) from the beginning of the photoperiodic phase to the beginning of the reproductive phase from the beginning of the reproductive phase to the beginning of the maturation (only for maize and rice) from the beginning of the maturation to the grain milk stage (du d\u00e9but de la maturation au stade grain laiteux) from the grain milk stage to the end of the maturation (du d\u00e9but du stade grain laiteux au jour de r\u00e9colte) the day of the harvest Notes : In the case of multiannual continuous simulations, we do not reinitialize the reservoirs, at harvest we put the moisture front at the depth of the surface reservoir This allows to keep the rooting constraint phenomenon for the following season if there is little rain while having the water stock in depth remaining from the previous season. This function has been originally translated from the EvalPhenoSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. View Source def EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ): \"\"\" This function manages the evolution of the phenological phases. It is a wrapper function that calls the specific functions for each phase. This function is called at the beginning of the day and makes the phenological phases evolve. For this, it increments the phase number and changes the value of the thermal time threshold of the next phase. ChangePhase is a boolean informing the model to know if a day is a day of phase change, which is used to initialize specific variables in certain functions. It includes a generic method for the test of the end of the photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase and = 1 at the beginning of the phase. Phenological phases used in this model (as for cereal crops) : 0. from the sowing day to the beginning of the conditions favorable for germination, and from the harvest to the end of the simulation (no crop) 1. from the beginning of the conditions favorable for germination to the day of germination (du d\u00e9but des conditions favorables pour la germination au jour de la lev\u00e9e) 2. from the day of germination to the beginning of the photoperiodic phase (du jour de la lev\u00e9e au d\u00e9but de la phase photop\u00e9riodique) 3. from the beginning of the photoperiodic phase to the beginning of the reproductive phase 4. from the beginning of the reproductive phase to the beginning of the maturation (only for maize and rice) 5. from the beginning of the maturation to the grain milk stage (du d\u00e9but de la maturation au stade grain laiteux) 6. from the grain milk stage to the end of the maturation (du d\u00e9but du stade grain laiteux au jour de r\u00e9colte) 7. the day of the harvest Notes : In the case of multiannual continuous simulations, we do not reinitialize the reservoirs, at harvest we put the moisture front at the depth of the surface reservoir This allows to keep the rooting constraint phenomenon for the following season if there is little rain while having the water stock in depth remaining from the previous season. This function has been originally translated from the EvalPhenoSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. \"\"\" data = testing_for_initialization ( j , data , paramITK , paramVariete ) data = update_pheno_phase_1_to_2 ( j , data , paramVariete ) data = update_pheno_phase_2_to_3 ( j , data , paramVariete ) data = update_pheno_phase_3_to_4 ( j , data ) data = update_pheno_phase_4_to_5 ( j , data , paramVariete ) data = update_pheno_phase_5_to_6 ( j , data , paramVariete ) data = update_pheno_phase_6_to_7 ( j , data , paramVariete ) return data MortaliteSarraV3 def MortaliteSarraV3 ( j , data , paramITK , paramVariete ) This functions tests for death of young plants. First, for numphase = 2 and changePhase = 1, hence at the transition day between phase 1 and 2 at this point of the loop, the nbJourCompte and nbjStress variables are set to 0. Second, for numPhase equal or above 2, on each day nbJourCompte is incremented by 1. Thus this part just count days since emergence. Third, for numPhase equal or above 2, for days where nbJourCompte is lower than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress variable is incremented by 1. Thus, we count the number of days with negative deltaBiomasseAerienne since emergence as stress days. Finally, for days where nbjStress is equal or higher than seuilCstrMortality, the crop is reset by setting numPhase, root_tank_capacity and nbjStress to 0. This all seems a bit simplistic though, and can be improved. This function has been adapted from the MortaliteSarraV3 procedure of the bilancarbonsarra.pas and exmodules 1 & 2.pas codes of the Sarra-H model, Pascal version. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def MortaliteSarraV3 ( j , data , paramITK , paramVariete ): \"\"\" This functions tests for death of young plants. First, for numphase = 2 and changePhase = 1, hence at the transition day between phase 1 and 2 at this point of the loop, the nbJourCompte and nbjStress variables are set to 0. Second, for numPhase equal or above 2, on each day nbJourCompte is incremented by 1. Thus this part just count days since emergence. Third, for numPhase equal or above 2, for days where nbJourCompte is lower than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress variable is incremented by 1. Thus, we count the number of days with negative deltaBiomasseAerienne since emergence as stress days. Finally, for days where nbjStress is equal or higher than seuilCstrMortality, the crop is reset by setting numPhase, root_tank_capacity and nbjStress to 0. This all seems a bit simplistic though, and can be improved. This function has been adapted from the MortaliteSarraV3 procedure of the bilancarbonsarra.pas and exmodules 1 & 2.pas codes of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbJourCompte' ][ j ,:,:], ) data [ 'nbjStress' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbjStress' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , data [ 'nbJourCompte' ][ j ,:,:] + 1 , data [ 'nbJourCompte' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbJourCompte\" ][ j ,:,:] < paramITK [ \"nbjTestSemis\" ]) & \\ ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , data [ \"nbjStress\" ][ j ,:,:] + 1 , data [ \"nbjStress\" ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbjStress\" ][ j ,:,:] == paramVariete [ \"seuilCstrMortality\" ]) data [ \"numPhase\" ][ j ,:,:] = np . where ( condition , 0 , data [ \"numPhase\" ][ j ,:,:], ) #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"][j,:,:] = np.where( data [ \"root_tank_capacity\" ][ j ,:,:] = np . where ( condition , 0 , #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"nbjStress\" ][ j ,:,:], ) return data calculate_daily_thermal_time def calculate_daily_thermal_time ( j , data , paramVariete ) calculating daily thermal time Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version. Pb de m\u00e9thode !? v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase); v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2); v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin); DegresDuJour:= v * (TOpt1-TBase); If Tmoy <= Topt2 then DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase else DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2))); If (Numphase >=1) then SomDegresJour := SomDegresJour + DegresDuJour else SomDegresJour := 0; Returns: Type Description type description View Source def calculate_daily_thermal_time ( j , data , paramVariete ): \"\"\"calculating daily thermal time Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version. Pb de m\u00e9thode !? v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase); v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2); v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin); DegresDuJour:= v * (TOpt1-TBase); # If Tmoy <= Topt2 then # DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase # else # DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2))); # If (Numphase >=1) then # SomDegresJour := SomDegresJour + DegresDuJour # else SomDegresJour := 0; Returns: _type_: _description_ \"\"\" data [ \"ddj\" ][ j ,:,: ] = xr . where ( data [ \"tpMoy\" ][ j ,:,: ] <= paramVariete [ \"TOpt2\" ] , np . maximum ( np . minimum ( paramVariete [ \"TOpt1\" ] , data [ \"tpMoy\" ][ j ,:,: ] ), paramVariete [ \"TBase\" ] ) - paramVariete [ \"TBase\" ] , ( paramVariete [ \"TOpt1\" ] - paramVariete [ \"TBase\" ] ) * ( 1 - (( np . minimum ( paramVariete [ \"TLim\" ] , data [ \"tpMoy\" ][ j ,:,: ] ) - paramVariete [ \"TOpt2\" ] ) / ( paramVariete [ \"TLim\" ] - paramVariete [ \"TOpt2\" ] ))), ) return data calculate_sum_of_thermal_time def calculate_sum_of_thermal_time ( j , data , paramVariete ) Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. calculating sum of thermal time sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly Note : in SARRA - H , when numPhase > 7 , sdj is set to 0 and sdj stops cumulating Returns : _type_ : _description_ View Source def calculate_sum_of_thermal_time ( j , data , paramVariete ) : \"\"\" Translated from the EvalDegresJourSarrahV3 procedure of the phenologie . pas and exmodules . pas files of the Sarra - H model , Pascal version . calculating sum of thermal time sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly Note : in SARRA - H , when numPhase > 7 , sdj is set to 0 and sdj stops cumulating Returns : _type_ : _description_ \"\"\" data [ \" sdj \" ][ j :,:,:] = xr . where ( ( j >= data [ \" sowing_date \" ][ j ,:,:] ) & ( data [ \" numPhase \" ][ j ,:,:] >= 1 ) , data [ \" sdj \" ][ j - 1 ,:,:] + data [ \" ddj \" ][ j ,:,:], 0 , ) return data flag_change_phase def flag_change_phase ( j , data , num_phase ) This function flags the day for phase change. If the phase number is above the num_phase value, and if the sum of thermal time is above the threshold, this function returns changePhase flags. Parameters: Name Type Description Default j type description None data type description None num_phase type description None Returns: Type Description type description View Source def flag_change_phase ( j , data , num_phase ) : \"\"\" This function flags the day for phase change . If the phase number is above the num_phase value , and if the sum of thermal time is above the threshold , this function returns changePhase flags . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ num_phase ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # flagging the day for phase change condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == num_phase ) & \\ ( data [ \" sdj \" ][ j ,:,:] >= data [ \" seuilTempPhaseSuivante \" ][ j ,:,:] ) data [ \" changePhase \" ][ j ,:,:] = xr . where ( condition , 1 , data [ \" changePhase \" ][ j ,:,:], ) return data increment_phase_number def increment_phase_number ( j , data ) This function increments the phase number. When the phase number is not 0, and if changePhase is 1 (meaning that we are at a phase transition day), and initPhase is 0 (meaning that the phase number has not been incremented yet this day), the phase number is incremented by 1. Also, the phase change flag initPhase is set to 1. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def increment_phase_number ( j , data ) : \"\"\" This function increments the phase number . When the phase number is not 0 , and if changePhase is 1 ( meaning that we are at a phase transition day ) , and initPhase is 0 ( meaning that the phase number has not been incremented yet this day ) , the phase number is incremented by 1 . Also , the phase change flag initPhase is set to 1 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition = \\ ( data [ \" numPhase \" ][ j ,:,:] != 0 ) & \\ ( data [ \" changePhase \" ][ j ,:,:] == 1 ) & \\ ( data [ \" initPhase \" ][ j ,:,:] != 1 ) # incrementing phase number data [ \" numPhase \" ][ j :,:,:] = np . where ( condition , data [ \" numPhase \" ][ j ,:,:] + 1 , data [ \" numPhase \" ][ j ,:,:], ) # flagging this day as having been incremented data [ \" initPhase \" ][ j , :, :] = xr . where ( condition , 1 , data [ \" initPhase \" ][ j , :, :] ) return data reset def reset ( j , data ) View Source def reset ( j , data ): data = data . copy ( deep = True ) # when reaching stage 7, we reset the main phenological variables to zero data [ \"changePhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"changePhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"sdj\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"sdj\" ][ j ,:,:]) #[np.newaxis,...] data [ \"ruRac\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"nbJourCompte\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"startLock\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 1 , data [ \"startLock\" ][ j ,:,:]) #[np.newaxis,...] # and we leave numPhas last data [ \"numPhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] return data testing_for_initialization def testing_for_initialization ( j , data , paramITK , paramVariete ) This function tests if the conditions are met to initiate the crop. If numPhase is 0, if the current day is equal or above the sowing date, and if surface_tank_stock is above the threshold for sowing, we initiate the crop : 1) we set numPhase to 1 ; we broadcast the value over remaining days. 2) we set changePhase of this particular day to 1. 3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to be SDJLevee ; we broadcast the value over remaining days. 4) we set initPhase to 1 ; we broadcast the value over remaining days. initPhase is only used in update_pheno_phase_1_to_2 function, so that we do not go directly from phase 0 to phase 2. It is used as a specific flag for phase 0 to 1 transition. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def testing_for_initialization ( j , data , paramITK , paramVariete ) : \"\"\" This function tests if the conditions are met to initiate the crop. If numPhase is 0, if the current day is equal or above the sowing date, and if surface_tank_stock is above the threshold for sowing, we initiate the crop : 1) we set numPhase to 1 ; we broadcast the value over remaining days. 2) we set changePhase of this particular day to 1. 3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to be SDJLevee ; we broadcast the value over remaining days. 4) we set initPhase to 1 ; we broadcast the value over remaining days. initPhase is only used in update_pheno_phase_1_to_2 function, so that we do not go directly from phase 0 to phase 2. It is used as a specific flag for phase 0 to 1 transition. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" #! replacing stRuSurf by surface_tank_stock condition = \\ ( data [ \"numPhase\" ][ j, :, : ] == 0 ) & \\ ( j >= data [ \"sowing_date\" ][ j,:,: ] ) & \\ ( data [ \"surface_tank_stock\" ][ j, :, : ] >= paramITK [ \"seuilEauSemis\" ] ) # & ( data [ \"startLock\" ][ j,:,: ] == 0 ) data [ \"numPhase\" ][ j:, :, : ] = xr . where ( condition , 1 , data [ \"numPhase\" ][ j, :, : ] ) data [ \"changePhase\" ][ j, :, : ] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j, :, : ] ) data [ \"seuilTempPhaseSuivante\" ][ j:, :, : ] = xr . where ( condition , paramVariete [ \"SDJLevee\" ] , data [ \"seuilTempPhaseSuivante\" ][ j, :, : ] , ) #flagging phase change has been done data [ \"initPhase\" ][ j, :, : ] = xr . where ( condition , 1 , data [ \"initPhase\" ][ j, :, : ] ) return data update_pheno_phase_1_to_2 def update_pheno_phase_1_to_2 ( j , data , paramVariete ) This function manages phase change from phases number 1 to 2. First, it flags the day for phase change : If numPhase is 1 and sum of thermal time is above the threshold (which value comes here from the previous function testing_for_initialization), we set changePhase of this particular day to 1. Second, we update the thermal time to next phase : if numPhase is 1 and changePhase is 1 (meaning that we are at the transition day between phases 1 and 2), we set the sum of thermal time to the next phase as SDJLevee ; we broadcast the value over remaining days. We do it before updating phase number because we need to test what is the phase number before updating it Third, we update the phase number : if numPhase is different from 0 and changePhase is 1 (meaning that we are at the transition day between two phases, to the exception of transition day between phases 0 and 1), we increment numPhase by 1 ; we broadcast the value over remaining days. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_1_to_2 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 1 to 2 . First , it flags the day for phase change : If numPhase is 1 and sum of thermal time is above the threshold ( which value comes here from the previous function testing_for_initialization ) , we set changePhase of this particular day to 1 . Second , we update the thermal time to next phase : if numPhase is 1 and changePhase is 1 ( meaning that we are at the transition day between phases 1 and 2 ) , we set the sum of thermal time to the next phase as SDJLevee ; we broadcast the value over remaining days . We do it before updating phase number because we need to test what is the phase number before updating it Third , we update the phase number : if numPhase is different from 0 and changePhase is 1 ( meaning that we are at the transition day between two phases , to the exception of transition day between phases 0 and 1 ) , we increment numPhase by 1 ; we broadcast the value over remaining days. Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 1 thermal_time_threshold = paramVariete [ \" SDJLevee \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data update_pheno_phase_2_to_3 def update_pheno_phase_2_to_3 ( j , data , paramVariete ) This function manages phase change from phases number 2 to 3. It has the same structure as update_pheno_phase_1_to_2, with the exception of update_thermal_time_previous_phase function, which is called to store the present thermal time threshold in the seuilTempPhasePrec variable. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_2_to_3 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 2 to 3. It has the same structure as update_pheno_phase_1_to_2, with the exception of update_thermal_time_previous_phase function, which is called to store the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 2 thermal_time_threshold = paramVariete [ \"SDJBVP\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data update_pheno_phase_3_to_4 def update_pheno_phase_3_to_4 ( j , data ) This function manages phase change from phases number 3 to 4. It is specific as phase 3 is photoperiodic ; its length is not computed the same way as the other phases. Notably, the phasePhotoper flag is updated with the PhotoperSarrahV3() function. First, this function flags the day for phase change : If numPhase is 3 and the phasePhotoper flag is 0, we set changePhase of this particular day to 1. This means the photoperiodic phase is over. Second, we update the phasePhotoper flag : if numPhase is 3 and changePhase is 1 (meaning that we are at the transition day between phases 3 and 4), we set the phasePhotoper flag to 1. Third, we update the phase number and flag incrementation using increment_phase_number(). Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_3_to_4 ( j , data ) : \"\"\" This function manages phase change from phases number 3 to 4 . It is specific as phase 3 is photoperiodic ; its length is not computed the same way as the other phases . Notably , the phasePhotoper flag is updated with the PhotoperSarrahV3 () function . First , this function flags the day for phase change : If numPhase is 3 and the phasePhotoper flag is 0 , we set changePhase of this particular day to 1 . This means the photoperiodic phase is over . Second , we update the phasePhotoper flag : if numPhase is 3 and changePhase is 1 ( meaning that we are at the transition day between phases 3 and 4 ) , we set the phasePhotoper flag to 1 . Third , we update the phase number and flag incrementation using increment_phase_number () . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # flagging the day for phase change ( specific to phase 3 ) condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == 3 ) & \\ ( data [ \" phasePhotoper \" ][ j ,:,:] == 0 ) data [ \" changePhase \" ][ j ,:,:] = xr . where ( condition , 1 , data [ \" changePhase \" ][ j ,:,:], ) # updating phasePhotoper ( specific to phase 3 ) condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == 3 ) & \\ ( data [ \" changePhase \" ][ j ,:,:] == 1 ) data [ \" phasePhotoper \" ][ j ,:,:] = np . where ( condition , 1 , data [ \" phasePhotoper \" ][ j ,:,:], ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data update_pheno_phase_4_to_5 def update_pheno_phase_4_to_5 ( j , data , paramVariete ) This function manages phase change from phases number 4 to 5. It has the same structure as update_pheno_phase_2_to_3. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_4_to_5 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 4 to 5 . It has the same structure as update_pheno_phase_2_to_3 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 4 thermal_time_threshold = paramVariete [ \" SDJRPR \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \" previous thermal time to next phase \" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data update_pheno_phase_5_to_6 def update_pheno_phase_5_to_6 ( j , data , paramVariete ) This function manages phase change from phases number 5 to 6. It has the same structure as update_pheno_phase_2_to_3. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_5_to_6 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 5 to 6 . It has the same structure as update_pheno_phase_2_to_3 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 5 thermal_time_threshold = paramVariete [ \" SDJMatu1 \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \" previous thermal time to next phase \" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data update_pheno_phase_6_to_7 def update_pheno_phase_6_to_7 ( j , data , paramVariete ) This function manages phase change from phases number 6 to 7. It has the same structure as update_pheno_phase_2_to_3. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_6_to_7 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 6 to 7 . It has the same structure as update_pheno_phase_2_to_3 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 6 thermal_time_threshold = paramVariete [ \" SDJMatu2 \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \" previous thermal time to next phase \" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data update_photoperiodism def update_photoperiodism ( j , data , paramVariete ) This function aims at managing the photoperiodic sensitivity of the crop. It first updates the sumPP variable : on the transition day between phase 2 and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100. Then, we compute the thermal_time_since_previous_phase (thermal time since the transition between phases 2 and 3), and the time_above_critical_day_length, which is the difference between day length and critical day length PPcrit, in decimal hours. On all days with numPhase = 3 (so including the transition day), the sumPP is calculated as a function of thermal_time_since_previous_phase and PPExp (attenuator for progressive PSP response to PP ; rarely used in calibration procedure, a robust value is 0.17), multiplied by a ratio between the daily time above critical day length and the difference between SeuilPP (Upper day length limit of PP response) and PPCrit (Lower day length limit to PP response). Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range 0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to 1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model) This function has been adapted from the PhotoperSarrahV3 procedure of the phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version. Notes CB : Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite photoperiodique et pour les varietes non photoperiodique. PPsens varie de 0,4 a 1,2. Pour PPsens > 2.5 = vari\u00e9t\u00e9 non photoperiodique. SeuilPP = 13.5 PPcrit = 12 SumPP est dans ce cas une variable quotidienne (et non un cumul) Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def update_photoperiodism ( j , data , paramVariete ): \"\"\" This function aims at managing the photoperiodic sensitivity of the crop. It first updates the sumPP variable : on the transition day between phase 2 and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100. Then, we compute the thermal_time_since_previous_phase (thermal time since the transition between phases 2 and 3), and the time_above_critical_day_length, which is the difference between day length and critical day length PPcrit, in decimal hours. On all days with numPhase = 3 (so including the transition day), the sumPP is calculated as a function of thermal_time_since_previous_phase and PPExp (attenuator for progressive PSP response to PP ; rarely used in calibration procedure, a robust value is 0.17), multiplied by a ratio between the daily time above critical day length and the difference between SeuilPP (Upper day length limit of PP response) and PPCrit (Lower day length limit to PP response). Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range 0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to 1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model) This function has been adapted from the PhotoperSarrahV3 procedure of the phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version. Notes CB : Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite photoperiodique et pour les varietes non photoperiodique. PPsens varie de 0,4 a 1,2. Pour PPsens > 2.5 = vari\u00e9t\u00e9 non photoperiodique. SeuilPP = 13.5 PPcrit = 12 SumPP est dans ce cas une variable quotidienne (et non un cumul) Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" thermal_time_since_previous_phase = np . maximum ( 0.01 , data [ \"sdj\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]) time_above_critical_day_length = np . maximum ( 0 , data [ \"dureeDuJour\" ][ j ,:,:] - paramVariete [ \"PPCrit\" ]) data [ \"sumPP\" ][ j ,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 3 , np . where ( data [ \"changePhase\" ][ j ,:,:] == 1 , # if numPhase = 3 and changePhase == 1, sumPP = 100 100 , # if numPhase = 3 and changePhase != 1, sumPP calculated through formula (( 1000 / thermal_time_since_previous_phase ) ** ( paramVariete [ \"PPExp\" ])) \\ * time_above_critical_day_length / ( paramVariete [ \"SeuilPP\" ] - paramVariete [ \"PPCrit\" ]), ), # if numPhase != 3, sumPP is not updated data [ \"sumPP\" ][ j ,:,:], ) data [ \"phasePhotoper\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & ( data [ \"sumPP\" ][ j ,:,:] < paramVariete [ \"PPsens\" ]), 0 , data [ \"phasePhotoper\" ][ j ,:,:], ) return data update_root_growth_speed def update_root_growth_speed ( j , data , paramVariete ) This function updates the root growth speed (vRac, mm/day) according to the current phase (numPhase). This function has been adapted from the EvalVitesseRacSarraV3 procedure of the phenologie.pas and exmodules 1 & 2.pas files of the Sarra-H model, Pascal version. Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def update_root_growth_speed ( j , data , paramVariete ) : \"\"\" This function updates the root growth speed (vRac, mm/day) according to the current phase (numPhase). This function has been adapted from the EvalVitesseRacSarraV3 procedure of the phenologie.pas and exmodules 1 & 2.pas files of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" phase_correspondances = { 1 : paramVariete [ 'VRacLevee' ] , 2 : paramVariete [ 'VRacBVP' ] , 3 : paramVariete [ 'VRacPSP' ] , 4 : paramVariete [ 'VRacRPR' ] , 5 : paramVariete [ 'VRacMatu1' ] , 6 : paramVariete [ 'VRacMatu2' ] , } for phase in range ( 1 , 6 ) : data [ \"vRac\" ][ j:,:,: ] = np . where ( data [ \"numPhase\" ][ j,:,: ] == phase , phase_correspondances [ phase ] , data [ \"vRac\" ][ j,:,: ] , ) # phase 0 ou 7 data [ \"vRac\" ][ j:,:,: ] = np . where ( ( data [ \"numPhase\" ][ j,:,: ] == 0 ) | ( data [ \"numPhase\" ][ j,:,: ] == 7 ), 0 , data [ \"vRac\" ][ j,:,: ] , ) return data update_thermal_time_next_phase def update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) This function updates the sum of thermal time needed to reach the next phase. When numPhase equals the requested phase number, and if changePhase is 1 (meaning that we are at a phase transition day), the seuilTempPhaseSuivante is incremented by the thermal_time_threshold value. This value is stage-specific : 1 to 2 : SDJLevee 2 to 3 : SDJBVP 4 to 5 : SDJRPR 5 to 6 : SDJMatu1 6 to 7 : SDJMatu2 These parameters are passed explicitly when calling this function. Parameters: Name Type Description Default j type description None data type description None num_phase type description None Returns: Type Description type description View Source def update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) : \"\"\" This function updates the sum of thermal time needed to reach the next phase . When numPhase equals the requested phase number , and if changePhase is 1 ( meaning that we are at a phase transition day ) , the seuilTempPhaseSuivante is incremented by the thermal_time_threshold value . This value is stage - specific : - 1 to 2 : SDJLevee - 2 to 3 : SDJBVP - 4 to 5 : SDJRPR - 5 to 6 : SDJMatu1 - 6 to 7 : SDJMatu2 These parameters are passed explicitly when calling this function . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ num_phase ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == num_phase ) & \\ ( data [ \" changePhase \" ][ j ,:,:] == 1 ) data [ \" seuilTempPhaseSuivante \" ][ j :,:,:] = np . where ( condition , data [ \" seuilTempPhaseSuivante \" ][ j ,:,:] + thermal_time_threshold , data [ \" seuilTempPhaseSuivante \" ][ j ,:,:] ) return data update_thermal_time_previous_phase def update_thermal_time_previous_phase ( j , data , num_phase ) This function stores the present thermal time threshold in the seuilTempPhasePrec variable. Parameters: Name Type Description Default j type description None data type description None num_phase type description None Returns: Type Description type description View Source def update_thermal_time_previous_phase ( j , data , num_phase ): \"\"\" This function stores the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"seuilTempPhasePrec\" ][ j :,:,:] = xr . where ( condition , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:], data [ \"seuilTempPhasePrec\" ][ j ,:,:] ) return data","title":"Bilan Pheno"},{"location":"reference/sarra_py/bilan_pheno/#module-sarra_pybilan_pheno","text":"View Source import numpy as np import copy import xarray as xr def reset ( j , data ): data = data . copy ( deep = True ) # when reaching stage 7, we reset the main phenological variables to zero data [ \"changePhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"changePhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"sdj\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"sdj\" ][ j ,:,:]) #[np.newaxis,...] data [ \"ruRac\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"nbJourCompte\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"startLock\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 1 , data [ \"startLock\" ][ j ,:,:]) #[np.newaxis,...] # and we leave numPhas last data [ \"numPhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] return data def testing_for_initialization ( j , data , paramITK , paramVariete ): \"\"\" This function tests if the conditions are met to initiate the crop. If numPhase is 0, if the current day is equal or above the sowing date, and if surface_tank_stock is above the threshold for sowing, we initiate the crop : 1) we set numPhase to 1 ; we broadcast the value over remaining days. 2) we set changePhase of this particular day to 1. 3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to be SDJLevee ; we broadcast the value over remaining days. 4) we set initPhase to 1 ; we broadcast the value over remaining days. initPhase is only used in update_pheno_phase_1_to_2 function, so that we do not go directly from phase 0 to phase 2. It is used as a specific flag for phase 0 to 1 transition. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" #! replacing stRuSurf by surface_tank_stock condition = \\ ( data [ \"numPhase\" ][ j , :, :] == 0 ) & \\ ( j >= data [ \"sowing_date\" ][ j ,:,:]) & \\ ( data [ \"surface_tank_stock\" ][ j , :, :] >= paramITK [ \"seuilEauSemis\" ]) # & (data[\"startLock\"][j,:,:] == 0) data [ \"numPhase\" ][ j :, :, :] = xr . where ( condition , 1 , data [ \"numPhase\" ][ j , :, :]) data [ \"changePhase\" ][ j , :, :] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j , :, :]) data [ \"seuilTempPhaseSuivante\" ][ j :, :, :] = xr . where ( condition , paramVariete [ \"SDJLevee\" ], data [ \"seuilTempPhaseSuivante\" ][ j , :, :], ) #flagging phase change has been done data [ \"initPhase\" ][ j , :, :] = xr . where ( condition , 1 , data [ \"initPhase\" ][ j , :, :] ) return data def flag_change_phase ( j , data , num_phase ): \"\"\" This function flags the day for phase change. If the phase number is above the num_phase value, and if the sum of thermal time is above the threshold, this function returns changePhase flags. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" # flagging the day for phase change condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"sdj\" ][ j ,:,:] >= data [ \"seuilTempPhaseSuivante\" ][ j ,:,:]) data [ \"changePhase\" ][ j ,:,:] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j ,:,:], ) return data def update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ): \"\"\" This function updates the sum of thermal time needed to reach the next phase. When numPhase equals the requested phase number, and if changePhase is 1 (meaning that we are at a phase transition day), the seuilTempPhaseSuivante is incremented by the thermal_time_threshold value. This value is stage-specific : - 1 to 2 : SDJLevee - 2 to 3 : SDJBVP - 4 to 5 : SDJRPR - 5 to 6 : SDJMatu1 - 6 to 7 : SDJMatu2 These parameters are passed explicitly when calling this function. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"seuilTempPhaseSuivante\" ][ j :,:,:] = np . where ( condition , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:] + thermal_time_threshold , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:] ) return data def increment_phase_number ( j , data ): \"\"\" This function increments the phase number. When the phase number is not 0, and if changePhase is 1 (meaning that we are at a phase transition day), and initPhase is 0 (meaning that the phase number has not been incremented yet this day), the phase number is incremented by 1. Also, the phase change flag initPhase is set to 1. Args: j (_type_): _description_ data (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] != 0 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) & \\ ( data [ \"initPhase\" ][ j ,:,:] != 1 ) # incrementing phase number data [ \"numPhase\" ][ j :,:,:] = np . where ( condition , data [ \"numPhase\" ][ j ,:,:] + 1 , data [ \"numPhase\" ][ j ,:,:], ) # flagging this day as having been incremented data [ \"initPhase\" ][ j , :, :] = xr . where ( condition , 1 , data [ \"initPhase\" ][ j , :, :] ) return data def update_thermal_time_previous_phase ( j , data , num_phase ): \"\"\" This function stores the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"seuilTempPhasePrec\" ][ j :,:,:] = xr . where ( condition , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:], data [ \"seuilTempPhasePrec\" ][ j ,:,:] ) return data def update_pheno_phase_1_to_2 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 1 to 2. First, it flags the day for phase change : If numPhase is 1 and sum of thermal time is above the threshold (which value comes here from the previous function testing_for_initialization), we set changePhase of this particular day to 1. Second, we update the thermal time to next phase : if numPhase is 1 and changePhase is 1 (meaning that we are at the transition day between phases 1 and 2), we set the sum of thermal time to the next phase as SDJLevee ; we broadcast the value over remaining days. We do it before updating phase number because we need to test what is the phase number before updating it Third, we update the phase number : if numPhase is different from 0 and changePhase is 1 (meaning that we are at the transition day between two phases, to the exception of transition day between phases 0 and 1), we increment numPhase by 1 ; we broadcast the value over remaining days. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 1 thermal_time_threshold = paramVariete [ \"SDJLevee\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_2_to_3 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 2 to 3. It has the same structure as update_pheno_phase_1_to_2, with the exception of update_thermal_time_previous_phase function, which is called to store the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 2 thermal_time_threshold = paramVariete [ \"SDJBVP\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_3_to_4 ( j , data ): \"\"\" This function manages phase change from phases number 3 to 4. It is specific as phase 3 is photoperiodic ; its length is not computed the same way as the other phases. Notably, the phasePhotoper flag is updated with the PhotoperSarrahV3() function. First, this function flags the day for phase change : If numPhase is 3 and the phasePhotoper flag is 0, we set changePhase of this particular day to 1. This means the photoperiodic phase is over. Second, we update the phasePhotoper flag : if numPhase is 3 and changePhase is 1 (meaning that we are at the transition day between phases 3 and 4), we set the phasePhotoper flag to 1. Third, we update the phase number and flag incrementation using increment_phase_number(). Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" # flagging the day for phase change (specific to phase 3) condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & \\ ( data [ \"phasePhotoper\" ][ j ,:,:] == 0 ) data [ \"changePhase\" ][ j ,:,:] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j ,:,:], ) # updating phasePhotoper (specific to phase 3) condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"phasePhotoper\" ][ j ,:,:] = np . where ( condition , 1 , data [ \"phasePhotoper\" ][ j ,:,:], ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_4_to_5 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 4 to 5. It has the same structure as update_pheno_phase_2_to_3. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 4 thermal_time_threshold = paramVariete [ \"SDJRPR\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_5_to_6 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 5 to 6. It has the same structure as update_pheno_phase_2_to_3. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 5 thermal_time_threshold = paramVariete [ \"SDJMatu1\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def update_pheno_phase_6_to_7 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 6 to 7. It has the same structure as update_pheno_phase_2_to_3. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 6 thermal_time_threshold = paramVariete [ \"SDJMatu2\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data def EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ): \"\"\" This function manages the evolution of the phenological phases. It is a wrapper function that calls the specific functions for each phase. This function is called at the beginning of the day and makes the phenological phases evolve. For this, it increments the phase number and changes the value of the thermal time threshold of the next phase. ChangePhase is a boolean informing the model to know if a day is a day of phase change, which is used to initialize specific variables in certain functions. It includes a generic method for the test of the end of the photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase and = 1 at the beginning of the phase. Phenological phases used in this model (as for cereal crops) : 0. from the sowing day to the beginning of the conditions favorable for germination, and from the harvest to the end of the simulation (no crop) 1. from the beginning of the conditions favorable for germination to the day of germination (du d\u00e9but des conditions favorables pour la germination au jour de la lev\u00e9e) 2. from the day of germination to the beginning of the photoperiodic phase (du jour de la lev\u00e9e au d\u00e9but de la phase photop\u00e9riodique) 3. from the beginning of the photoperiodic phase to the beginning of the reproductive phase 4. from the beginning of the reproductive phase to the beginning of the maturation (only for maize and rice) 5. from the beginning of the maturation to the grain milk stage (du d\u00e9but de la maturation au stade grain laiteux) 6. from the grain milk stage to the end of the maturation (du d\u00e9but du stade grain laiteux au jour de r\u00e9colte) 7. the day of the harvest Notes : In the case of multiannual continuous simulations, we do not reinitialize the reservoirs, at harvest we put the moisture front at the depth of the surface reservoir This allows to keep the rooting constraint phenomenon for the following season if there is little rain while having the water stock in depth remaining from the previous season. This function has been originally translated from the EvalPhenoSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. \"\"\" data = testing_for_initialization ( j , data , paramITK , paramVariete ) data = update_pheno_phase_1_to_2 ( j , data , paramVariete ) data = update_pheno_phase_2_to_3 ( j , data , paramVariete ) data = update_pheno_phase_3_to_4 ( j , data ) data = update_pheno_phase_4_to_5 ( j , data , paramVariete ) data = update_pheno_phase_5_to_6 ( j , data , paramVariete ) data = update_pheno_phase_6_to_7 ( j , data , paramVariete ) return data def calculate_daily_thermal_time ( j , data , paramVariete ): \"\"\"calculating daily thermal time Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version. Pb de m\u00e9thode !? v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase); v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2); v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin); DegresDuJour:= v * (TOpt1-TBase); # If Tmoy <= Topt2 then # DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase # else # DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2))); # If (Numphase >=1) then # SomDegresJour := SomDegresJour + DegresDuJour # else SomDegresJour := 0; Returns: _type_: _description_ \"\"\" data [ \"ddj\" ][ j ,:,:] = xr . where ( data [ \"tpMoy\" ][ j ,:,:] <= paramVariete [ \"TOpt2\" ], np . maximum ( np . minimum ( paramVariete [ \"TOpt1\" ], data [ \"tpMoy\" ][ j ,:,:]), paramVariete [ \"TBase\" ]) - paramVariete [ \"TBase\" ], ( paramVariete [ \"TOpt1\" ] - paramVariete [ \"TBase\" ]) * ( 1 - (( np . minimum ( paramVariete [ \"TLim\" ], data [ \"tpMoy\" ][ j ,:,:]) - paramVariete [ \"TOpt2\" ]) / ( paramVariete [ \"TLim\" ] - paramVariete [ \"TOpt2\" ]))), ) return data def calculate_sum_of_thermal_time ( j , data , paramVariete ): \"\"\" Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. calculating sum of thermal time sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly Note : in SARRA-H, when numPhase > 7, sdj is set to 0 and sdj stops cumulating Returns: _type_: _description_ \"\"\" data [ \"sdj\" ][ j :,:,:] = xr . where ( ( j >= data [ \"sowing_date\" ][ j ,:,:]) & ( data [ \"numPhase\" ][ j ,:,:] >= 1 ), data [ \"sdj\" ][ j - 1 ,:,:] + data [ \"ddj\" ][ j ,:,:], 0 , ) return data def update_root_growth_speed ( j , data , paramVariete ): \"\"\" This function updates the root growth speed (vRac, mm/day) according to the current phase (numPhase). This function has been adapted from the EvalVitesseRacSarraV3 procedure of the phenologie.pas and exmodules 1 & 2.pas files of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" phase_correspondances = { 1 : paramVariete [ 'VRacLevee' ], 2 : paramVariete [ 'VRacBVP' ], 3 : paramVariete [ 'VRacPSP' ], 4 : paramVariete [ 'VRacRPR' ], 5 : paramVariete [ 'VRacMatu1' ], 6 : paramVariete [ 'VRacMatu2' ], } for phase in range ( 1 , 6 ): data [ \"vRac\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == phase , phase_correspondances [ phase ], data [ \"vRac\" ][ j ,:,:], ) # phase 0 ou 7 data [ \"vRac\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 0 ) | ( data [ \"numPhase\" ][ j ,:,:] == 7 ), 0 , data [ \"vRac\" ][ j ,:,:], ) return data def update_photoperiodism ( j , data , paramVariete ): \"\"\" This function aims at managing the photoperiodic sensitivity of the crop. It first updates the sumPP variable : on the transition day between phase 2 and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100. Then, we compute the thermal_time_since_previous_phase (thermal time since the transition between phases 2 and 3), and the time_above_critical_day_length, which is the difference between day length and critical day length PPcrit, in decimal hours. On all days with numPhase = 3 (so including the transition day), the sumPP is calculated as a function of thermal_time_since_previous_phase and PPExp (attenuator for progressive PSP response to PP ; rarely used in calibration procedure, a robust value is 0.17), multiplied by a ratio between the daily time above critical day length and the difference between SeuilPP (Upper day length limit of PP response) and PPCrit (Lower day length limit to PP response). Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range 0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to 1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model) This function has been adapted from the PhotoperSarrahV3 procedure of the phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version. Notes CB : Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite photoperiodique et pour les varietes non photoperiodique. PPsens varie de 0,4 a 1,2. Pour PPsens > 2.5 = vari\u00e9t\u00e9 non photoperiodique. SeuilPP = 13.5 PPcrit = 12 SumPP est dans ce cas une variable quotidienne (et non un cumul) Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" thermal_time_since_previous_phase = np . maximum ( 0.01 , data [ \"sdj\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]) time_above_critical_day_length = np . maximum ( 0 , data [ \"dureeDuJour\" ][ j ,:,:] - paramVariete [ \"PPCrit\" ]) data [ \"sumPP\" ][ j ,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 3 , np . where ( data [ \"changePhase\" ][ j ,:,:] == 1 , # if numPhase = 3 and changePhase == 1, sumPP = 100 100 , # if numPhase = 3 and changePhase != 1, sumPP calculated through formula (( 1000 / thermal_time_since_previous_phase ) ** ( paramVariete [ \"PPExp\" ])) \\ * time_above_critical_day_length / ( paramVariete [ \"SeuilPP\" ] - paramVariete [ \"PPCrit\" ]), ), # if numPhase != 3, sumPP is not updated data [ \"sumPP\" ][ j ,:,:], ) data [ \"phasePhotoper\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & ( data [ \"sumPP\" ][ j ,:,:] < paramVariete [ \"PPsens\" ]), 0 , data [ \"phasePhotoper\" ][ j ,:,:], ) return data def MortaliteSarraV3 ( j , data , paramITK , paramVariete ): \"\"\" This functions tests for death of young plants. First, for numphase = 2 and changePhase = 1, hence at the transition day between phase 1 and 2 at this point of the loop, the nbJourCompte and nbjStress variables are set to 0. Second, for numPhase equal or above 2, on each day nbJourCompte is incremented by 1. Thus this part just count days since emergence. Third, for numPhase equal or above 2, for days where nbJourCompte is lower than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress variable is incremented by 1. Thus, we count the number of days with negative deltaBiomasseAerienne since emergence as stress days. Finally, for days where nbjStress is equal or higher than seuilCstrMortality, the crop is reset by setting numPhase, root_tank_capacity and nbjStress to 0. This all seems a bit simplistic though, and can be improved. This function has been adapted from the MortaliteSarraV3 procedure of the bilancarbonsarra.pas and exmodules 1 & 2.pas codes of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbJourCompte' ][ j ,:,:], ) data [ 'nbjStress' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbjStress' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , data [ 'nbJourCompte' ][ j ,:,:] + 1 , data [ 'nbJourCompte' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbJourCompte\" ][ j ,:,:] < paramITK [ \"nbjTestSemis\" ]) & \\ ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , data [ \"nbjStress\" ][ j ,:,:] + 1 , data [ \"nbjStress\" ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbjStress\" ][ j ,:,:] == paramVariete [ \"seuilCstrMortality\" ]) data [ \"numPhase\" ][ j ,:,:] = np . where ( condition , 0 , data [ \"numPhase\" ][ j ,:,:], ) #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"][j,:,:] = np.where( data [ \"root_tank_capacity\" ][ j ,:,:] = np . where ( condition , 0 , #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"nbjStress\" ][ j ,:,:], ) return data","title":"Module sarra_py.bilan_pheno"},{"location":"reference/sarra_py/bilan_pheno/#functions","text":"","title":"Functions"},{"location":"reference/sarra_py/bilan_pheno/#evalphenosarrahv3","text":"def EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ) This function manages the evolution of the phenological phases. It is a wrapper function that calls the specific functions for each phase. This function is called at the beginning of the day and makes the phenological phases evolve. For this, it increments the phase number and changes the value of the thermal time threshold of the next phase. ChangePhase is a boolean informing the model to know if a day is a day of phase change, which is used to initialize specific variables in certain functions. It includes a generic method for the test of the end of the photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase and = 1 at the beginning of the phase. Phenological phases used in this model (as for cereal crops) : from the sowing day to the beginning of the conditions favorable for germination, and from the harvest to the end of the simulation (no crop) from the beginning of the conditions favorable for germination to the day of germination (du d\u00e9but des conditions favorables pour la germination au jour de la lev\u00e9e) from the day of germination to the beginning of the photoperiodic phase (du jour de la lev\u00e9e au d\u00e9but de la phase photop\u00e9riodique) from the beginning of the photoperiodic phase to the beginning of the reproductive phase from the beginning of the reproductive phase to the beginning of the maturation (only for maize and rice) from the beginning of the maturation to the grain milk stage (du d\u00e9but de la maturation au stade grain laiteux) from the grain milk stage to the end of the maturation (du d\u00e9but du stade grain laiteux au jour de r\u00e9colte) the day of the harvest Notes : In the case of multiannual continuous simulations, we do not reinitialize the reservoirs, at harvest we put the moisture front at the depth of the surface reservoir This allows to keep the rooting constraint phenomenon for the following season if there is little rain while having the water stock in depth remaining from the previous season. This function has been originally translated from the EvalPhenoSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. View Source def EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ): \"\"\" This function manages the evolution of the phenological phases. It is a wrapper function that calls the specific functions for each phase. This function is called at the beginning of the day and makes the phenological phases evolve. For this, it increments the phase number and changes the value of the thermal time threshold of the next phase. ChangePhase is a boolean informing the model to know if a day is a day of phase change, which is used to initialize specific variables in certain functions. It includes a generic method for the test of the end of the photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase and = 1 at the beginning of the phase. Phenological phases used in this model (as for cereal crops) : 0. from the sowing day to the beginning of the conditions favorable for germination, and from the harvest to the end of the simulation (no crop) 1. from the beginning of the conditions favorable for germination to the day of germination (du d\u00e9but des conditions favorables pour la germination au jour de la lev\u00e9e) 2. from the day of germination to the beginning of the photoperiodic phase (du jour de la lev\u00e9e au d\u00e9but de la phase photop\u00e9riodique) 3. from the beginning of the photoperiodic phase to the beginning of the reproductive phase 4. from the beginning of the reproductive phase to the beginning of the maturation (only for maize and rice) 5. from the beginning of the maturation to the grain milk stage (du d\u00e9but de la maturation au stade grain laiteux) 6. from the grain milk stage to the end of the maturation (du d\u00e9but du stade grain laiteux au jour de r\u00e9colte) 7. the day of the harvest Notes : In the case of multiannual continuous simulations, we do not reinitialize the reservoirs, at harvest we put the moisture front at the depth of the surface reservoir This allows to keep the rooting constraint phenomenon for the following season if there is little rain while having the water stock in depth remaining from the previous season. This function has been originally translated from the EvalPhenoSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. \"\"\" data = testing_for_initialization ( j , data , paramITK , paramVariete ) data = update_pheno_phase_1_to_2 ( j , data , paramVariete ) data = update_pheno_phase_2_to_3 ( j , data , paramVariete ) data = update_pheno_phase_3_to_4 ( j , data ) data = update_pheno_phase_4_to_5 ( j , data , paramVariete ) data = update_pheno_phase_5_to_6 ( j , data , paramVariete ) data = update_pheno_phase_6_to_7 ( j , data , paramVariete ) return data","title":"EvalPhenoSarrahV3"},{"location":"reference/sarra_py/bilan_pheno/#mortalitesarrav3","text":"def MortaliteSarraV3 ( j , data , paramITK , paramVariete ) This functions tests for death of young plants. First, for numphase = 2 and changePhase = 1, hence at the transition day between phase 1 and 2 at this point of the loop, the nbJourCompte and nbjStress variables are set to 0. Second, for numPhase equal or above 2, on each day nbJourCompte is incremented by 1. Thus this part just count days since emergence. Third, for numPhase equal or above 2, for days where nbJourCompte is lower than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress variable is incremented by 1. Thus, we count the number of days with negative deltaBiomasseAerienne since emergence as stress days. Finally, for days where nbjStress is equal or higher than seuilCstrMortality, the crop is reset by setting numPhase, root_tank_capacity and nbjStress to 0. This all seems a bit simplistic though, and can be improved. This function has been adapted from the MortaliteSarraV3 procedure of the bilancarbonsarra.pas and exmodules 1 & 2.pas codes of the Sarra-H model, Pascal version. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def MortaliteSarraV3 ( j , data , paramITK , paramVariete ): \"\"\" This functions tests for death of young plants. First, for numphase = 2 and changePhase = 1, hence at the transition day between phase 1 and 2 at this point of the loop, the nbJourCompte and nbjStress variables are set to 0. Second, for numPhase equal or above 2, on each day nbJourCompte is incremented by 1. Thus this part just count days since emergence. Third, for numPhase equal or above 2, for days where nbJourCompte is lower than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress variable is incremented by 1. Thus, we count the number of days with negative deltaBiomasseAerienne since emergence as stress days. Finally, for days where nbjStress is equal or higher than seuilCstrMortality, the crop is reset by setting numPhase, root_tank_capacity and nbjStress to 0. This all seems a bit simplistic though, and can be improved. This function has been adapted from the MortaliteSarraV3 procedure of the bilancarbonsarra.pas and exmodules 1 & 2.pas codes of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"numPhase\" ][ j ,:,:] == 2 ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbJourCompte' ][ j ,:,:], ) data [ 'nbjStress' ][ j :,:,:] = np . where ( condition , 0 , data [ 'nbjStress' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) data [ 'nbJourCompte' ][ j :,:,:] = np . where ( condition , data [ 'nbJourCompte' ][ j ,:,:] + 1 , data [ 'nbJourCompte' ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbJourCompte\" ][ j ,:,:] < paramITK [ \"nbjTestSemis\" ]) & \\ ( data [ \"deltaBiomasseAerienne\" ][ j ,:,:] < 0 ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , data [ \"nbjStress\" ][ j ,:,:] + 1 , data [ \"nbjStress\" ][ j ,:,:], ) condition = ( data [ \"numPhase\" ][ j ,:,:] >= 2 ) & \\ ( data [ \"nbjStress\" ][ j ,:,:] == paramVariete [ \"seuilCstrMortality\" ]) data [ \"numPhase\" ][ j ,:,:] = np . where ( condition , 0 , data [ \"numPhase\" ][ j ,:,:], ) #! renaming stRurMax with root_tank_capacity #// data[\"stRurMax\"][j,:,:] = np.where( data [ \"root_tank_capacity\" ][ j ,:,:] = np . where ( condition , 0 , #// data[\"stRurMax\"][j,:,:], data [ \"root_tank_capacity\" ][ j ,:,:], ) data [ \"nbjStress\" ][ j :,:,:] = np . where ( condition , 0 , data [ \"nbjStress\" ][ j ,:,:], ) return data","title":"MortaliteSarraV3"},{"location":"reference/sarra_py/bilan_pheno/#calculate_daily_thermal_time","text":"def calculate_daily_thermal_time ( j , data , paramVariete ) calculating daily thermal time Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version. Pb de m\u00e9thode !? v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase); v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2); v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin); DegresDuJour:= v * (TOpt1-TBase);","title":"calculate_daily_thermal_time"},{"location":"reference/sarra_py/bilan_pheno/#if-tmoy-topt2-then","text":"","title":"If Tmoy &lt;= Topt2 then"},{"location":"reference/sarra_py/bilan_pheno/#degresdujour-maxmintopt1tmoytbase-tbase","text":"","title":"DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase"},{"location":"reference/sarra_py/bilan_pheno/#else","text":"","title":"else"},{"location":"reference/sarra_py/bilan_pheno/#degresdujour-topt1-tbase-1-mintl-tmoy-topt2-tl-topt2","text":"","title":"DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2)));"},{"location":"reference/sarra_py/bilan_pheno/#if-numphase-1-then","text":"","title":"If (Numphase &gt;=1) then"},{"location":"reference/sarra_py/bilan_pheno/#somdegresjour-somdegresjour-degresdujour","text":"","title":"SomDegresJour := SomDegresJour + DegresDuJour"},{"location":"reference/sarra_py/bilan_pheno/#else-somdegresjour-0","text":"Returns: Type Description type description View Source def calculate_daily_thermal_time ( j , data , paramVariete ): \"\"\"calculating daily thermal time Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version. Pb de m\u00e9thode !? v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase); v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2); v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin); DegresDuJour:= v * (TOpt1-TBase); # If Tmoy <= Topt2 then # DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase # else # DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2))); # If (Numphase >=1) then # SomDegresJour := SomDegresJour + DegresDuJour # else SomDegresJour := 0; Returns: _type_: _description_ \"\"\" data [ \"ddj\" ][ j ,:,: ] = xr . where ( data [ \"tpMoy\" ][ j ,:,: ] <= paramVariete [ \"TOpt2\" ] , np . maximum ( np . minimum ( paramVariete [ \"TOpt1\" ] , data [ \"tpMoy\" ][ j ,:,: ] ), paramVariete [ \"TBase\" ] ) - paramVariete [ \"TBase\" ] , ( paramVariete [ \"TOpt1\" ] - paramVariete [ \"TBase\" ] ) * ( 1 - (( np . minimum ( paramVariete [ \"TLim\" ] , data [ \"tpMoy\" ][ j ,:,: ] ) - paramVariete [ \"TOpt2\" ] ) / ( paramVariete [ \"TLim\" ] - paramVariete [ \"TOpt2\" ] ))), ) return data","title":"else SomDegresJour := 0;"},{"location":"reference/sarra_py/bilan_pheno/#calculate_sum_of_thermal_time","text":"def calculate_sum_of_thermal_time ( j , data , paramVariete ) Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version. calculating sum of thermal time sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly Note : in SARRA - H , when numPhase > 7 , sdj is set to 0 and sdj stops cumulating Returns : _type_ : _description_ View Source def calculate_sum_of_thermal_time ( j , data , paramVariete ) : \"\"\" Translated from the EvalDegresJourSarrahV3 procedure of the phenologie . pas and exmodules . pas files of the Sarra - H model , Pascal version . calculating sum of thermal time sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly Note : in SARRA - H , when numPhase > 7 , sdj is set to 0 and sdj stops cumulating Returns : _type_ : _description_ \"\"\" data [ \" sdj \" ][ j :,:,:] = xr . where ( ( j >= data [ \" sowing_date \" ][ j ,:,:] ) & ( data [ \" numPhase \" ][ j ,:,:] >= 1 ) , data [ \" sdj \" ][ j - 1 ,:,:] + data [ \" ddj \" ][ j ,:,:], 0 , ) return data","title":"calculate_sum_of_thermal_time"},{"location":"reference/sarra_py/bilan_pheno/#flag_change_phase","text":"def flag_change_phase ( j , data , num_phase ) This function flags the day for phase change. If the phase number is above the num_phase value, and if the sum of thermal time is above the threshold, this function returns changePhase flags. Parameters: Name Type Description Default j type description None data type description None num_phase type description None Returns: Type Description type description View Source def flag_change_phase ( j , data , num_phase ) : \"\"\" This function flags the day for phase change . If the phase number is above the num_phase value , and if the sum of thermal time is above the threshold , this function returns changePhase flags . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ num_phase ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # flagging the day for phase change condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == num_phase ) & \\ ( data [ \" sdj \" ][ j ,:,:] >= data [ \" seuilTempPhaseSuivante \" ][ j ,:,:] ) data [ \" changePhase \" ][ j ,:,:] = xr . where ( condition , 1 , data [ \" changePhase \" ][ j ,:,:], ) return data","title":"flag_change_phase"},{"location":"reference/sarra_py/bilan_pheno/#increment_phase_number","text":"def increment_phase_number ( j , data ) This function increments the phase number. When the phase number is not 0, and if changePhase is 1 (meaning that we are at a phase transition day), and initPhase is 0 (meaning that the phase number has not been incremented yet this day), the phase number is incremented by 1. Also, the phase change flag initPhase is set to 1. Parameters: Name Type Description Default j type description None data type description None Returns: Type Description type description View Source def increment_phase_number ( j , data ) : \"\"\" This function increments the phase number . When the phase number is not 0 , and if changePhase is 1 ( meaning that we are at a phase transition day ) , and initPhase is 0 ( meaning that the phase number has not been incremented yet this day ) , the phase number is incremented by 1 . Also , the phase change flag initPhase is set to 1 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition = \\ ( data [ \" numPhase \" ][ j ,:,:] != 0 ) & \\ ( data [ \" changePhase \" ][ j ,:,:] == 1 ) & \\ ( data [ \" initPhase \" ][ j ,:,:] != 1 ) # incrementing phase number data [ \" numPhase \" ][ j :,:,:] = np . where ( condition , data [ \" numPhase \" ][ j ,:,:] + 1 , data [ \" numPhase \" ][ j ,:,:], ) # flagging this day as having been incremented data [ \" initPhase \" ][ j , :, :] = xr . where ( condition , 1 , data [ \" initPhase \" ][ j , :, :] ) return data","title":"increment_phase_number"},{"location":"reference/sarra_py/bilan_pheno/#reset","text":"def reset ( j , data ) View Source def reset ( j , data ): data = data . copy ( deep = True ) # when reaching stage 7, we reset the main phenological variables to zero data [ \"changePhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"changePhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"sdj\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"sdj\" ][ j ,:,:]) #[np.newaxis,...] data [ \"ruRac\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"nbJourCompte\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] data [ \"startLock\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 1 , data [ \"startLock\" ][ j ,:,:]) #[np.newaxis,...] # and we leave numPhas last data [ \"numPhase\" ][ j :,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 7 , 0 , data [ \"numPhase\" ][ j ,:,:]) #[np.newaxis,...] return data","title":"reset"},{"location":"reference/sarra_py/bilan_pheno/#testing_for_initialization","text":"def testing_for_initialization ( j , data , paramITK , paramVariete ) This function tests if the conditions are met to initiate the crop. If numPhase is 0, if the current day is equal or above the sowing date, and if surface_tank_stock is above the threshold for sowing, we initiate the crop : 1) we set numPhase to 1 ; we broadcast the value over remaining days. 2) we set changePhase of this particular day to 1. 3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to be SDJLevee ; we broadcast the value over remaining days. 4) we set initPhase to 1 ; we broadcast the value over remaining days. initPhase is only used in update_pheno_phase_1_to_2 function, so that we do not go directly from phase 0 to phase 2. It is used as a specific flag for phase 0 to 1 transition. Parameters: Name Type Description Default j type description None data type description None paramITK type description None Returns: Type Description type description View Source def testing_for_initialization ( j , data , paramITK , paramVariete ) : \"\"\" This function tests if the conditions are met to initiate the crop. If numPhase is 0, if the current day is equal or above the sowing date, and if surface_tank_stock is above the threshold for sowing, we initiate the crop : 1) we set numPhase to 1 ; we broadcast the value over remaining days. 2) we set changePhase of this particular day to 1. 3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to be SDJLevee ; we broadcast the value over remaining days. 4) we set initPhase to 1 ; we broadcast the value over remaining days. initPhase is only used in update_pheno_phase_1_to_2 function, so that we do not go directly from phase 0 to phase 2. It is used as a specific flag for phase 0 to 1 transition. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" #! replacing stRuSurf by surface_tank_stock condition = \\ ( data [ \"numPhase\" ][ j, :, : ] == 0 ) & \\ ( j >= data [ \"sowing_date\" ][ j,:,: ] ) & \\ ( data [ \"surface_tank_stock\" ][ j, :, : ] >= paramITK [ \"seuilEauSemis\" ] ) # & ( data [ \"startLock\" ][ j,:,: ] == 0 ) data [ \"numPhase\" ][ j:, :, : ] = xr . where ( condition , 1 , data [ \"numPhase\" ][ j, :, : ] ) data [ \"changePhase\" ][ j, :, : ] = xr . where ( condition , 1 , data [ \"changePhase\" ][ j, :, : ] ) data [ \"seuilTempPhaseSuivante\" ][ j:, :, : ] = xr . where ( condition , paramVariete [ \"SDJLevee\" ] , data [ \"seuilTempPhaseSuivante\" ][ j, :, : ] , ) #flagging phase change has been done data [ \"initPhase\" ][ j, :, : ] = xr . where ( condition , 1 , data [ \"initPhase\" ][ j, :, : ] ) return data","title":"testing_for_initialization"},{"location":"reference/sarra_py/bilan_pheno/#update_pheno_phase_1_to_2","text":"def update_pheno_phase_1_to_2 ( j , data , paramVariete ) This function manages phase change from phases number 1 to 2. First, it flags the day for phase change : If numPhase is 1 and sum of thermal time is above the threshold (which value comes here from the previous function testing_for_initialization), we set changePhase of this particular day to 1. Second, we update the thermal time to next phase : if numPhase is 1 and changePhase is 1 (meaning that we are at the transition day between phases 1 and 2), we set the sum of thermal time to the next phase as SDJLevee ; we broadcast the value over remaining days. We do it before updating phase number because we need to test what is the phase number before updating it Third, we update the phase number : if numPhase is different from 0 and changePhase is 1 (meaning that we are at the transition day between two phases, to the exception of transition day between phases 0 and 1), we increment numPhase by 1 ; we broadcast the value over remaining days. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_1_to_2 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 1 to 2 . First , it flags the day for phase change : If numPhase is 1 and sum of thermal time is above the threshold ( which value comes here from the previous function testing_for_initialization ) , we set changePhase of this particular day to 1 . Second , we update the thermal time to next phase : if numPhase is 1 and changePhase is 1 ( meaning that we are at the transition day between phases 1 and 2 ) , we set the sum of thermal time to the next phase as SDJLevee ; we broadcast the value over remaining days . We do it before updating phase number because we need to test what is the phase number before updating it Third , we update the phase number : if numPhase is different from 0 and changePhase is 1 ( meaning that we are at the transition day between two phases , to the exception of transition day between phases 0 and 1 ) , we increment numPhase by 1 ; we broadcast the value over remaining days. Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 1 thermal_time_threshold = paramVariete [ \" SDJLevee \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data","title":"update_pheno_phase_1_to_2"},{"location":"reference/sarra_py/bilan_pheno/#update_pheno_phase_2_to_3","text":"def update_pheno_phase_2_to_3 ( j , data , paramVariete ) This function manages phase change from phases number 2 to 3. It has the same structure as update_pheno_phase_1_to_2, with the exception of update_thermal_time_previous_phase function, which is called to store the present thermal time threshold in the seuilTempPhasePrec variable. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_2_to_3 ( j , data , paramVariete ): \"\"\" This function manages phase change from phases number 2 to 3. It has the same structure as update_pheno_phase_1_to_2, with the exception of update_thermal_time_previous_phase function, which is called to store the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ paramITK (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" num_phase = 2 thermal_time_threshold = paramVariete [ \"SDJBVP\" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \"previous thermal time to next phase\" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data","title":"update_pheno_phase_2_to_3"},{"location":"reference/sarra_py/bilan_pheno/#update_pheno_phase_3_to_4","text":"def update_pheno_phase_3_to_4 ( j , data ) This function manages phase change from phases number 3 to 4. It is specific as phase 3 is photoperiodic ; its length is not computed the same way as the other phases. Notably, the phasePhotoper flag is updated with the PhotoperSarrahV3() function. First, this function flags the day for phase change : If numPhase is 3 and the phasePhotoper flag is 0, we set changePhase of this particular day to 1. This means the photoperiodic phase is over. Second, we update the phasePhotoper flag : if numPhase is 3 and changePhase is 1 (meaning that we are at the transition day between phases 3 and 4), we set the phasePhotoper flag to 1. Third, we update the phase number and flag incrementation using increment_phase_number(). Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_3_to_4 ( j , data ) : \"\"\" This function manages phase change from phases number 3 to 4 . It is specific as phase 3 is photoperiodic ; its length is not computed the same way as the other phases . Notably , the phasePhotoper flag is updated with the PhotoperSarrahV3 () function . First , this function flags the day for phase change : If numPhase is 3 and the phasePhotoper flag is 0 , we set changePhase of this particular day to 1 . This means the photoperiodic phase is over . Second , we update the phasePhotoper flag : if numPhase is 3 and changePhase is 1 ( meaning that we are at the transition day between phases 3 and 4 ) , we set the phasePhotoper flag to 1 . Third , we update the phase number and flag incrementation using increment_phase_number () . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # flagging the day for phase change ( specific to phase 3 ) condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == 3 ) & \\ ( data [ \" phasePhotoper \" ][ j ,:,:] == 0 ) data [ \" changePhase \" ][ j ,:,:] = xr . where ( condition , 1 , data [ \" changePhase \" ][ j ,:,:], ) # updating phasePhotoper ( specific to phase 3 ) condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == 3 ) & \\ ( data [ \" changePhase \" ][ j ,:,:] == 1 ) data [ \" phasePhotoper \" ][ j ,:,:] = np . where ( condition , 1 , data [ \" phasePhotoper \" ][ j ,:,:], ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data","title":"update_pheno_phase_3_to_4"},{"location":"reference/sarra_py/bilan_pheno/#update_pheno_phase_4_to_5","text":"def update_pheno_phase_4_to_5 ( j , data , paramVariete ) This function manages phase change from phases number 4 to 5. It has the same structure as update_pheno_phase_2_to_3. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_4_to_5 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 4 to 5 . It has the same structure as update_pheno_phase_2_to_3 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 4 thermal_time_threshold = paramVariete [ \" SDJRPR \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \" previous thermal time to next phase \" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data","title":"update_pheno_phase_4_to_5"},{"location":"reference/sarra_py/bilan_pheno/#update_pheno_phase_5_to_6","text":"def update_pheno_phase_5_to_6 ( j , data , paramVariete ) This function manages phase change from phases number 5 to 6. It has the same structure as update_pheno_phase_2_to_3. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_5_to_6 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 5 to 6 . It has the same structure as update_pheno_phase_2_to_3 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 5 thermal_time_threshold = paramVariete [ \" SDJMatu1 \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \" previous thermal time to next phase \" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data","title":"update_pheno_phase_5_to_6"},{"location":"reference/sarra_py/bilan_pheno/#update_pheno_phase_6_to_7","text":"def update_pheno_phase_6_to_7 ( j , data , paramVariete ) This function manages phase change from phases number 6 to 7. It has the same structure as update_pheno_phase_2_to_3. Parameters: Name Type Description Default j type description None data type description None paramITK type description None paramVariete type description None Returns: Type Description type description View Source def update_pheno_phase_6_to_7 ( j , data , paramVariete ) : \"\"\" This function manages phase change from phases number 6 to 7 . It has the same structure as update_pheno_phase_2_to_3 . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ paramITK ( _type_ ) : _description_ paramVariete ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" num_phase = 6 thermal_time_threshold = paramVariete [ \" SDJMatu2 \" ] # flagging the day for phase change data = flag_change_phase ( j , data , num_phase ) # saving \" previous thermal time to next phase \" to be used data = update_thermal_time_previous_phase ( j , data , num_phase ) # updating thermal time to next phase data = update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) # updating phase number and flagging incrementation data = increment_phase_number ( j , data ) return data","title":"update_pheno_phase_6_to_7"},{"location":"reference/sarra_py/bilan_pheno/#update_photoperiodism","text":"def update_photoperiodism ( j , data , paramVariete ) This function aims at managing the photoperiodic sensitivity of the crop. It first updates the sumPP variable : on the transition day between phase 2 and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100. Then, we compute the thermal_time_since_previous_phase (thermal time since the transition between phases 2 and 3), and the time_above_critical_day_length, which is the difference between day length and critical day length PPcrit, in decimal hours. On all days with numPhase = 3 (so including the transition day), the sumPP is calculated as a function of thermal_time_since_previous_phase and PPExp (attenuator for progressive PSP response to PP ; rarely used in calibration procedure, a robust value is 0.17), multiplied by a ratio between the daily time above critical day length and the difference between SeuilPP (Upper day length limit of PP response) and PPCrit (Lower day length limit to PP response). Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range 0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to 1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model) This function has been adapted from the PhotoperSarrahV3 procedure of the phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version. Notes CB : Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite photoperiodique et pour les varietes non photoperiodique. PPsens varie de 0,4 a 1,2. Pour PPsens > 2.5 = vari\u00e9t\u00e9 non photoperiodique. SeuilPP = 13.5 PPcrit = 12 SumPP est dans ce cas une variable quotidienne (et non un cumul) Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def update_photoperiodism ( j , data , paramVariete ): \"\"\" This function aims at managing the photoperiodic sensitivity of the crop. It first updates the sumPP variable : on the transition day between phase 2 and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100. Then, we compute the thermal_time_since_previous_phase (thermal time since the transition between phases 2 and 3), and the time_above_critical_day_length, which is the difference between day length and critical day length PPcrit, in decimal hours. On all days with numPhase = 3 (so including the transition day), the sumPP is calculated as a function of thermal_time_since_previous_phase and PPExp (attenuator for progressive PSP response to PP ; rarely used in calibration procedure, a robust value is 0.17), multiplied by a ratio between the daily time above critical day length and the difference between SeuilPP (Upper day length limit of PP response) and PPCrit (Lower day length limit to PP response). Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range 0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to 1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model) This function has been adapted from the PhotoperSarrahV3 procedure of the phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version. Notes CB : Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite photoperiodique et pour les varietes non photoperiodique. PPsens varie de 0,4 a 1,2. Pour PPsens > 2.5 = vari\u00e9t\u00e9 non photoperiodique. SeuilPP = 13.5 PPcrit = 12 SumPP est dans ce cas une variable quotidienne (et non un cumul) Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" thermal_time_since_previous_phase = np . maximum ( 0.01 , data [ \"sdj\" ][ j ,:,:] - data [ \"seuilTempPhasePrec\" ][ j ,:,:]) time_above_critical_day_length = np . maximum ( 0 , data [ \"dureeDuJour\" ][ j ,:,:] - paramVariete [ \"PPCrit\" ]) data [ \"sumPP\" ][ j ,:,:] = np . where ( data [ \"numPhase\" ][ j ,:,:] == 3 , np . where ( data [ \"changePhase\" ][ j ,:,:] == 1 , # if numPhase = 3 and changePhase == 1, sumPP = 100 100 , # if numPhase = 3 and changePhase != 1, sumPP calculated through formula (( 1000 / thermal_time_since_previous_phase ) ** ( paramVariete [ \"PPExp\" ])) \\ * time_above_critical_day_length / ( paramVariete [ \"SeuilPP\" ] - paramVariete [ \"PPCrit\" ]), ), # if numPhase != 3, sumPP is not updated data [ \"sumPP\" ][ j ,:,:], ) data [ \"phasePhotoper\" ][ j :,:,:] = np . where ( ( data [ \"numPhase\" ][ j ,:,:] == 3 ) & ( data [ \"sumPP\" ][ j ,:,:] < paramVariete [ \"PPsens\" ]), 0 , data [ \"phasePhotoper\" ][ j ,:,:], ) return data","title":"update_photoperiodism"},{"location":"reference/sarra_py/bilan_pheno/#update_root_growth_speed","text":"def update_root_growth_speed ( j , data , paramVariete ) This function updates the root growth speed (vRac, mm/day) according to the current phase (numPhase). This function has been adapted from the EvalVitesseRacSarraV3 procedure of the phenologie.pas and exmodules 1 & 2.pas files of the Sarra-H model, Pascal version. Parameters: Name Type Description Default j type description None data type description None paramVariete type description None Returns: Type Description type description View Source def update_root_growth_speed ( j , data , paramVariete ) : \"\"\" This function updates the root growth speed (vRac, mm/day) according to the current phase (numPhase). This function has been adapted from the EvalVitesseRacSarraV3 procedure of the phenologie.pas and exmodules 1 & 2.pas files of the Sarra-H model, Pascal version. Args: j (_type_): _description_ data (_type_): _description_ paramVariete (_type_): _description_ Returns: _type_: _description_ \"\"\" phase_correspondances = { 1 : paramVariete [ 'VRacLevee' ] , 2 : paramVariete [ 'VRacBVP' ] , 3 : paramVariete [ 'VRacPSP' ] , 4 : paramVariete [ 'VRacRPR' ] , 5 : paramVariete [ 'VRacMatu1' ] , 6 : paramVariete [ 'VRacMatu2' ] , } for phase in range ( 1 , 6 ) : data [ \"vRac\" ][ j:,:,: ] = np . where ( data [ \"numPhase\" ][ j,:,: ] == phase , phase_correspondances [ phase ] , data [ \"vRac\" ][ j,:,: ] , ) # phase 0 ou 7 data [ \"vRac\" ][ j:,:,: ] = np . where ( ( data [ \"numPhase\" ][ j,:,: ] == 0 ) | ( data [ \"numPhase\" ][ j,:,: ] == 7 ), 0 , data [ \"vRac\" ][ j,:,: ] , ) return data","title":"update_root_growth_speed"},{"location":"reference/sarra_py/bilan_pheno/#update_thermal_time_next_phase","text":"def update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) This function updates the sum of thermal time needed to reach the next phase. When numPhase equals the requested phase number, and if changePhase is 1 (meaning that we are at a phase transition day), the seuilTempPhaseSuivante is incremented by the thermal_time_threshold value. This value is stage-specific : 1 to 2 : SDJLevee 2 to 3 : SDJBVP 4 to 5 : SDJRPR 5 to 6 : SDJMatu1 6 to 7 : SDJMatu2 These parameters are passed explicitly when calling this function. Parameters: Name Type Description Default j type description None data type description None num_phase type description None Returns: Type Description type description View Source def update_thermal_time_next_phase ( j , data , num_phase , thermal_time_threshold ) : \"\"\" This function updates the sum of thermal time needed to reach the next phase . When numPhase equals the requested phase number , and if changePhase is 1 ( meaning that we are at a phase transition day ) , the seuilTempPhaseSuivante is incremented by the thermal_time_threshold value . This value is stage - specific : - 1 to 2 : SDJLevee - 2 to 3 : SDJBVP - 4 to 5 : SDJRPR - 5 to 6 : SDJMatu1 - 6 to 7 : SDJMatu2 These parameters are passed explicitly when calling this function . Args : j ( _type_ ) : _description_ data ( _type_ ) : _description_ num_phase ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" condition = \\ ( data [ \" numPhase \" ][ j ,:,:] == num_phase ) & \\ ( data [ \" changePhase \" ][ j ,:,:] == 1 ) data [ \" seuilTempPhaseSuivante \" ][ j :,:,:] = np . where ( condition , data [ \" seuilTempPhaseSuivante \" ][ j ,:,:] + thermal_time_threshold , data [ \" seuilTempPhaseSuivante \" ][ j ,:,:] ) return data","title":"update_thermal_time_next_phase"},{"location":"reference/sarra_py/bilan_pheno/#update_thermal_time_previous_phase","text":"def update_thermal_time_previous_phase ( j , data , num_phase ) This function stores the present thermal time threshold in the seuilTempPhasePrec variable. Parameters: Name Type Description Default j type description None data type description None num_phase type description None Returns: Type Description type description View Source def update_thermal_time_previous_phase ( j , data , num_phase ): \"\"\" This function stores the present thermal time threshold in the seuilTempPhasePrec variable. Args: j (_type_): _description_ data (_type_): _description_ num_phase (_type_): _description_ Returns: _type_: _description_ \"\"\" condition = \\ ( data [ \"numPhase\" ][ j ,:,:] == num_phase ) & \\ ( data [ \"changePhase\" ][ j ,:,:] == 1 ) data [ \"seuilTempPhasePrec\" ][ j :,:,:] = xr . where ( condition , data [ \"seuilTempPhaseSuivante\" ][ j ,:,:], data [ \"seuilTempPhasePrec\" ][ j ,:,:] ) return data","title":"update_thermal_time_previous_phase"},{"location":"reference/sarra_py/comparison_tools_old/","text":"Module sarra_py.comparison_tools_old View Source from matplotlib import pyplot as plt import pandas as pd import numpy as np def get_var_correspondance (): var_correspondance = { 'DegresDuJour' : \"ddj\" , 'Lai' : \"lai\" , 'FTSW' : \"ftsw\" , 'Cstr' : \"cstr\" , 'Eto' : \"ET0\" , 'ETM' : \"etm\" , 'ETR' : \"etr\" , 'Sla' : \"sla\" , 'Assim' : \"assim\" , # 'DayLength', 'Par' : 'par' , # 'RgCalc', # 'VDPCalc', 'TMoyCalc' : \"tpMoy\" , # 'HMoyCalc', 'EauDispo' : 'eauDispo' , 'StockSurface' : \"stRuSurf\" , 'StockRac' : \"stRur\" , 'RURac' : 'stRurMax' , 'Kcp' : 'kcp' , 'Kce' : \"kce\" , 'EvapPot' : 'evapPot' , 'Evap' : \"evap\" , 'TrPot' : \"trPot\" , 'Tr' : \"tr\" , 'Lr' : 'lr' , 'Dr' : 'dr' , 'SumDegresDay' : \"sdj\" , 'BiomasseTotale' : \"biomasseTotale\" , 'BiomasseAerienne' : 'biomasseAerienne' , 'BiomasseFeuilles' : \"biomasseFeuille\" , 'BiomasseTiges' : \"biomasseTige\" , 'BiomasseVegetative' : \"biomasseVegetative\" , 'BiomasseRacinaire' : \"biomasseRacinaire\" , 'Rdt' : \"rdt\" , 'VitesseRacinaire' : \"vRac\" , 'FESW' : \"fesw\" , 'Kc' : \"kcTot\" , 'Ltr' : 'ltr' , 'DRespMaint' : 'respMaint' , 'DBiomTot' : \"deltaBiomasseTotale\" , 'DRdtPot' : \"dRdtPot\" , 'Reallocation' : 'reallocation' , 'RdtPot' : 'rdtPot' , # 'RayExtra', # 'SumDDPhasePrec', # 'SeuilTemp', # 'TMinMoy', # 'TMaxMoy', # 'FtswMoy', 'IrrigTotDay' : 'irrigTotDay' , 'Conversion' : 'conv' , 'StockTotal' : 'stTot' , 'BiomMc' : 'biomMc' , 'StockMc' : 'stockMc' , 'LitFeuilles' : \"litFeuilles\" , 'LitTiges' : \"litTiges\" , 'FeuillesUp' : \"feuillesUp\" , 'TigesUp' : \"tigesUp\" , 'Hum' : \"hum\" , #'EToCO2', } return var_correspondance def graph_comparison ( var_gt , var_sim , data , df_weather , df_gt ): plt . rcParams [ \"figure.figsize\" ] = [ 7.50 , 3.50 ] plt . rcParams [ \"figure.autolayout\" ] = True ax1 = plt . subplot () l1 , = ax1 . plot ( df_weather [ \"Jour\" ], data [ \"numPhase\" ][ 0 , 0 ,:], color = 'black' , label = \"sim\" ) ax2 = ax1 . twinx () l2 , = ax2 . plot ( df_weather [ \"Jour\" ], data [ var_sim ][ 0 , 0 ,:], color = 'red' , label = var_sim + \" (sim)\" ) l3 , = ax2 . plot ( df_gt [ \"Jour\" ], df_gt [ var_gt ], color = 'orange' , label = var_gt + \" (sarrah)\" ) # plt.plot(df_weather[\"Jour\"], data[\"numPhase\"][0,0,:], label=\"numPhase\", alpha=0.5) # plt.plot(df_weather[\"Jour\"], data[var_sim][0,0,:], color='red', label=var_sim+\" (sim)\") # plt.plot(df_gt[\"Jour\"], df_gt[var_gt], color='orange', label=var_gt+\" (sarrah)\") plt . legend ([ l1 , l2 , l3 ], [ \"numPhase\" , var_sim + \" (sim)\" , var_gt + \" (sarrah)\" ]) plt . legend () plt . xticks ( rotation = 45 ) plt . show () def compute_earliest_diff ( var_gt , var_sim , data , df_weather , df_gt , tol = 10E-6 ): try : df_gt_2 = df_gt df_gt_2 = df_gt_2 . merge ( pd . DataFrame ({ \"Jour\" : df_weather [ \"Jour\" ], var_sim : data [ var_sim ][ 0 , 0 ,:]}), left_on = \"Jour\" , right_on = \"Jour\" ) df_gt_2 [ \"delta\" ] = np . abs ( df_gt_2 [ var_sim ] - df_gt_2 [ var_gt ]) df_gt_2 [ \"signif\" ] = False df_gt_2 [ \"signif\" ] = df_gt_2 . apply ( lambda x : x [ \"delta\" ] > tol , axis = 1 ) if np . nansum ( df_gt_2 [ \"signif\" ]) == 0.0 : earliest = datetime . date ( 1990 , 1 , 1 ) else : earliest = df_gt_2 . loc [ df_gt_2 [ \"signif\" ] == True , \"Jour\" ] . values [ 0 ] meandiff = np . nanmean ( df_gt_2 [ \"delta\" ]) except : earliest , meandiff = np . nan , np . nan return earliest , meandiff Functions compute_earliest_diff def compute_earliest_diff ( var_gt , var_sim , data , df_weather , df_gt , tol = 1e-05 ) View Source def compute_earliest_diff ( var_gt , var_sim , data , df_weather , df_gt , tol = 10E-6 ) : try : df_gt_2 = df_gt df_gt_2 = df_gt_2 . merge ( pd . DataFrame ( { \"Jour\" : df_weather [ \"Jour\" ] , var_sim : data [ var_sim ][ 0,0,: ] } ), left_on = \"Jour\" , right_on = \"Jour\" ) df_gt_2 [ \"delta\" ] = np . abs ( df_gt_2 [ var_sim ] - df_gt_2 [ var_gt ] ) df_gt_2 [ \"signif\" ] = False df_gt_2 [ \"signif\" ] = df_gt_2 . apply ( lambda x : x [ \"delta\" ]> tol , axis = 1 ) if np . nansum ( df_gt_2 [ \"signif\" ] ) == 0.0 : earliest = datetime . date ( 1990 , 1 , 1 ) else : earliest = df_gt_2 . loc [ df_gt_2[\"signif\" ]== True , \"Jour\" ] . values [ 0 ] meandiff = np . nanmean ( df_gt_2 [ \"delta\" ] ) except : earliest , meandiff = np . nan , np . nan return earliest , meandiff get_var_correspondance def get_var_correspondance ( ) View Source def get_var_correspondance (): var_correspondance = { 'DegresDuJour' : \"ddj\" , 'Lai' : \"lai\" , 'FTSW' : \"ftsw\" , 'Cstr' : \"cstr\" , 'Eto' : \"ET0\" , 'ETM' : \"etm\" , 'ETR' : \"etr\" , 'Sla' : \"sla\" , 'Assim' : \"assim\" , # 'DayLength', 'Par' : 'par' , # 'RgCalc', # 'VDPCalc', 'TMoyCalc' : \"tpMoy\" , # 'HMoyCalc', 'EauDispo' : 'eauDispo' , 'StockSurface' : \"stRuSurf\" , 'StockRac' : \"stRur\" , 'RURac' : 'stRurMax' , 'Kcp' : 'kcp' , 'Kce' : \"kce\" , 'EvapPot' : 'evapPot' , 'Evap' : \"evap\" , 'TrPot' : \"trPot\" , 'Tr' : \"tr\" , 'Lr' : 'lr' , 'Dr' : 'dr' , 'SumDegresDay' : \"sdj\" , 'BiomasseTotale' : \"biomasseTotale\" , 'BiomasseAerienne' : 'biomasseAerienne' , 'BiomasseFeuilles' : \"biomasseFeuille\" , 'BiomasseTiges' : \"biomasseTige\" , 'BiomasseVegetative' : \"biomasseVegetative\" , 'BiomasseRacinaire' : \"biomasseRacinaire\" , 'Rdt' : \"rdt\" , 'VitesseRacinaire' : \"vRac\" , 'FESW' : \"fesw\" , 'Kc' : \"kcTot\" , 'Ltr' : 'ltr' , 'DRespMaint' : 'respMaint' , 'DBiomTot' : \"deltaBiomasseTotale\" , 'DRdtPot' : \"dRdtPot\" , 'Reallocation' : 'reallocation' , 'RdtPot' : 'rdtPot' , # 'RayExtra', # 'SumDDPhasePrec', # 'SeuilTemp', # 'TMinMoy', # 'TMaxMoy', # 'FtswMoy', 'IrrigTotDay' : 'irrigTotDay' , 'Conversion' : 'conv' , 'StockTotal' : 'stTot' , 'BiomMc' : 'biomMc' , 'StockMc' : 'stockMc' , 'LitFeuilles' : \"litFeuilles\" , 'LitTiges' : \"litTiges\" , 'FeuillesUp' : \"feuillesUp\" , 'TigesUp' : \"tigesUp\" , 'Hum' : \"hum\" , #'EToCO2', } return var_correspondance graph_comparison def graph_comparison ( var_gt , var_sim , data , df_weather , df_gt ) View Source def graph_comparison ( var_gt , var_sim , data , df_weather , df_gt ) : plt . rcParams [ \"figure.figsize\" ] = [ 7.50, 3.50 ] plt . rcParams [ \"figure.autolayout\" ] = True ax1 = plt . subplot () l1 , = ax1 . plot ( df_weather [ \"Jour\" ] , data [ \"numPhase\" ][ 0,0,: ] , color = 'black' , label = \"sim\" ) ax2 = ax1 . twinx () l2 , = ax2 . plot ( df_weather [ \"Jour\" ] , data [ var_sim ][ 0,0,: ] , color = 'red' , label = var_sim + \" (sim)\" ) l3 , = ax2 . plot ( df_gt [ \"Jour\" ] , df_gt [ var_gt ] , color = 'orange' , label = var_gt + \" (sarrah)\" ) # plt . plot ( df_weather [ \"Jour\" ] , data [ \"numPhase\" ][ 0,0,: ] , label = \"numPhase\" , alpha = 0.5 ) # plt . plot ( df_weather [ \"Jour\" ] , data [ var_sim ][ 0,0,: ] , color = 'red' , label = var_sim + \" (sim)\" ) # plt . plot ( df_gt [ \"Jour\" ] , df_gt [ var_gt ] , color = 'orange' , label = var_gt + \" (sarrah)\" ) plt . legend ( [ l1, l2, l3 ] , [ \"numPhase\",var_sim+\" (sim)\", var_gt+\" (sarrah)\" ] ) plt . legend () plt . xticks ( rotation = 45 ) plt . show ()","title":"Comparison Tools Old"},{"location":"reference/sarra_py/comparison_tools_old/#module-sarra_pycomparison_tools_old","text":"View Source from matplotlib import pyplot as plt import pandas as pd import numpy as np def get_var_correspondance (): var_correspondance = { 'DegresDuJour' : \"ddj\" , 'Lai' : \"lai\" , 'FTSW' : \"ftsw\" , 'Cstr' : \"cstr\" , 'Eto' : \"ET0\" , 'ETM' : \"etm\" , 'ETR' : \"etr\" , 'Sla' : \"sla\" , 'Assim' : \"assim\" , # 'DayLength', 'Par' : 'par' , # 'RgCalc', # 'VDPCalc', 'TMoyCalc' : \"tpMoy\" , # 'HMoyCalc', 'EauDispo' : 'eauDispo' , 'StockSurface' : \"stRuSurf\" , 'StockRac' : \"stRur\" , 'RURac' : 'stRurMax' , 'Kcp' : 'kcp' , 'Kce' : \"kce\" , 'EvapPot' : 'evapPot' , 'Evap' : \"evap\" , 'TrPot' : \"trPot\" , 'Tr' : \"tr\" , 'Lr' : 'lr' , 'Dr' : 'dr' , 'SumDegresDay' : \"sdj\" , 'BiomasseTotale' : \"biomasseTotale\" , 'BiomasseAerienne' : 'biomasseAerienne' , 'BiomasseFeuilles' : \"biomasseFeuille\" , 'BiomasseTiges' : \"biomasseTige\" , 'BiomasseVegetative' : \"biomasseVegetative\" , 'BiomasseRacinaire' : \"biomasseRacinaire\" , 'Rdt' : \"rdt\" , 'VitesseRacinaire' : \"vRac\" , 'FESW' : \"fesw\" , 'Kc' : \"kcTot\" , 'Ltr' : 'ltr' , 'DRespMaint' : 'respMaint' , 'DBiomTot' : \"deltaBiomasseTotale\" , 'DRdtPot' : \"dRdtPot\" , 'Reallocation' : 'reallocation' , 'RdtPot' : 'rdtPot' , # 'RayExtra', # 'SumDDPhasePrec', # 'SeuilTemp', # 'TMinMoy', # 'TMaxMoy', # 'FtswMoy', 'IrrigTotDay' : 'irrigTotDay' , 'Conversion' : 'conv' , 'StockTotal' : 'stTot' , 'BiomMc' : 'biomMc' , 'StockMc' : 'stockMc' , 'LitFeuilles' : \"litFeuilles\" , 'LitTiges' : \"litTiges\" , 'FeuillesUp' : \"feuillesUp\" , 'TigesUp' : \"tigesUp\" , 'Hum' : \"hum\" , #'EToCO2', } return var_correspondance def graph_comparison ( var_gt , var_sim , data , df_weather , df_gt ): plt . rcParams [ \"figure.figsize\" ] = [ 7.50 , 3.50 ] plt . rcParams [ \"figure.autolayout\" ] = True ax1 = plt . subplot () l1 , = ax1 . plot ( df_weather [ \"Jour\" ], data [ \"numPhase\" ][ 0 , 0 ,:], color = 'black' , label = \"sim\" ) ax2 = ax1 . twinx () l2 , = ax2 . plot ( df_weather [ \"Jour\" ], data [ var_sim ][ 0 , 0 ,:], color = 'red' , label = var_sim + \" (sim)\" ) l3 , = ax2 . plot ( df_gt [ \"Jour\" ], df_gt [ var_gt ], color = 'orange' , label = var_gt + \" (sarrah)\" ) # plt.plot(df_weather[\"Jour\"], data[\"numPhase\"][0,0,:], label=\"numPhase\", alpha=0.5) # plt.plot(df_weather[\"Jour\"], data[var_sim][0,0,:], color='red', label=var_sim+\" (sim)\") # plt.plot(df_gt[\"Jour\"], df_gt[var_gt], color='orange', label=var_gt+\" (sarrah)\") plt . legend ([ l1 , l2 , l3 ], [ \"numPhase\" , var_sim + \" (sim)\" , var_gt + \" (sarrah)\" ]) plt . legend () plt . xticks ( rotation = 45 ) plt . show () def compute_earliest_diff ( var_gt , var_sim , data , df_weather , df_gt , tol = 10E-6 ): try : df_gt_2 = df_gt df_gt_2 = df_gt_2 . merge ( pd . DataFrame ({ \"Jour\" : df_weather [ \"Jour\" ], var_sim : data [ var_sim ][ 0 , 0 ,:]}), left_on = \"Jour\" , right_on = \"Jour\" ) df_gt_2 [ \"delta\" ] = np . abs ( df_gt_2 [ var_sim ] - df_gt_2 [ var_gt ]) df_gt_2 [ \"signif\" ] = False df_gt_2 [ \"signif\" ] = df_gt_2 . apply ( lambda x : x [ \"delta\" ] > tol , axis = 1 ) if np . nansum ( df_gt_2 [ \"signif\" ]) == 0.0 : earliest = datetime . date ( 1990 , 1 , 1 ) else : earliest = df_gt_2 . loc [ df_gt_2 [ \"signif\" ] == True , \"Jour\" ] . values [ 0 ] meandiff = np . nanmean ( df_gt_2 [ \"delta\" ]) except : earliest , meandiff = np . nan , np . nan return earliest , meandiff","title":"Module sarra_py.comparison_tools_old"},{"location":"reference/sarra_py/comparison_tools_old/#functions","text":"","title":"Functions"},{"location":"reference/sarra_py/comparison_tools_old/#compute_earliest_diff","text":"def compute_earliest_diff ( var_gt , var_sim , data , df_weather , df_gt , tol = 1e-05 ) View Source def compute_earliest_diff ( var_gt , var_sim , data , df_weather , df_gt , tol = 10E-6 ) : try : df_gt_2 = df_gt df_gt_2 = df_gt_2 . merge ( pd . DataFrame ( { \"Jour\" : df_weather [ \"Jour\" ] , var_sim : data [ var_sim ][ 0,0,: ] } ), left_on = \"Jour\" , right_on = \"Jour\" ) df_gt_2 [ \"delta\" ] = np . abs ( df_gt_2 [ var_sim ] - df_gt_2 [ var_gt ] ) df_gt_2 [ \"signif\" ] = False df_gt_2 [ \"signif\" ] = df_gt_2 . apply ( lambda x : x [ \"delta\" ]> tol , axis = 1 ) if np . nansum ( df_gt_2 [ \"signif\" ] ) == 0.0 : earliest = datetime . date ( 1990 , 1 , 1 ) else : earliest = df_gt_2 . loc [ df_gt_2[\"signif\" ]== True , \"Jour\" ] . values [ 0 ] meandiff = np . nanmean ( df_gt_2 [ \"delta\" ] ) except : earliest , meandiff = np . nan , np . nan return earliest , meandiff","title":"compute_earliest_diff"},{"location":"reference/sarra_py/comparison_tools_old/#get_var_correspondance","text":"def get_var_correspondance ( ) View Source def get_var_correspondance (): var_correspondance = { 'DegresDuJour' : \"ddj\" , 'Lai' : \"lai\" , 'FTSW' : \"ftsw\" , 'Cstr' : \"cstr\" , 'Eto' : \"ET0\" , 'ETM' : \"etm\" , 'ETR' : \"etr\" , 'Sla' : \"sla\" , 'Assim' : \"assim\" , # 'DayLength', 'Par' : 'par' , # 'RgCalc', # 'VDPCalc', 'TMoyCalc' : \"tpMoy\" , # 'HMoyCalc', 'EauDispo' : 'eauDispo' , 'StockSurface' : \"stRuSurf\" , 'StockRac' : \"stRur\" , 'RURac' : 'stRurMax' , 'Kcp' : 'kcp' , 'Kce' : \"kce\" , 'EvapPot' : 'evapPot' , 'Evap' : \"evap\" , 'TrPot' : \"trPot\" , 'Tr' : \"tr\" , 'Lr' : 'lr' , 'Dr' : 'dr' , 'SumDegresDay' : \"sdj\" , 'BiomasseTotale' : \"biomasseTotale\" , 'BiomasseAerienne' : 'biomasseAerienne' , 'BiomasseFeuilles' : \"biomasseFeuille\" , 'BiomasseTiges' : \"biomasseTige\" , 'BiomasseVegetative' : \"biomasseVegetative\" , 'BiomasseRacinaire' : \"biomasseRacinaire\" , 'Rdt' : \"rdt\" , 'VitesseRacinaire' : \"vRac\" , 'FESW' : \"fesw\" , 'Kc' : \"kcTot\" , 'Ltr' : 'ltr' , 'DRespMaint' : 'respMaint' , 'DBiomTot' : \"deltaBiomasseTotale\" , 'DRdtPot' : \"dRdtPot\" , 'Reallocation' : 'reallocation' , 'RdtPot' : 'rdtPot' , # 'RayExtra', # 'SumDDPhasePrec', # 'SeuilTemp', # 'TMinMoy', # 'TMaxMoy', # 'FtswMoy', 'IrrigTotDay' : 'irrigTotDay' , 'Conversion' : 'conv' , 'StockTotal' : 'stTot' , 'BiomMc' : 'biomMc' , 'StockMc' : 'stockMc' , 'LitFeuilles' : \"litFeuilles\" , 'LitTiges' : \"litTiges\" , 'FeuillesUp' : \"feuillesUp\" , 'TigesUp' : \"tigesUp\" , 'Hum' : \"hum\" , #'EToCO2', } return var_correspondance","title":"get_var_correspondance"},{"location":"reference/sarra_py/comparison_tools_old/#graph_comparison","text":"def graph_comparison ( var_gt , var_sim , data , df_weather , df_gt ) View Source def graph_comparison ( var_gt , var_sim , data , df_weather , df_gt ) : plt . rcParams [ \"figure.figsize\" ] = [ 7.50, 3.50 ] plt . rcParams [ \"figure.autolayout\" ] = True ax1 = plt . subplot () l1 , = ax1 . plot ( df_weather [ \"Jour\" ] , data [ \"numPhase\" ][ 0,0,: ] , color = 'black' , label = \"sim\" ) ax2 = ax1 . twinx () l2 , = ax2 . plot ( df_weather [ \"Jour\" ] , data [ var_sim ][ 0,0,: ] , color = 'red' , label = var_sim + \" (sim)\" ) l3 , = ax2 . plot ( df_gt [ \"Jour\" ] , df_gt [ var_gt ] , color = 'orange' , label = var_gt + \" (sarrah)\" ) # plt . plot ( df_weather [ \"Jour\" ] , data [ \"numPhase\" ][ 0,0,: ] , label = \"numPhase\" , alpha = 0.5 ) # plt . plot ( df_weather [ \"Jour\" ] , data [ var_sim ][ 0,0,: ] , color = 'red' , label = var_sim + \" (sim)\" ) # plt . plot ( df_gt [ \"Jour\" ] , df_gt [ var_gt ] , color = 'orange' , label = var_gt + \" (sarrah)\" ) plt . legend ( [ l1, l2, l3 ] , [ \"numPhase\",var_sim+\" (sim)\", var_gt+\" (sarrah)\" ] ) plt . legend () plt . xticks ( rotation = 45 ) plt . show ()","title":"graph_comparison"},{"location":"reference/sarra_py/data_preparation/","text":"Module sarra_py.data_preparation View Source from os import listdir from os.path import isfile , join import pandas as pd import datetime import rasterio import os import rioxarray from tqdm import tqdm as tqdm import numpy as np import yaml import xarray as xr import astral from astral.sun import sun from astral import LocationInfo def build_rainfall_files_df ( rainfall_path , date_start , duration ): \"\"\" This function builds a dataframe containing the list of rainfall files from the provided path, and the given date_start and duration. Helper function used in get_grid_size() and load_TAMSAT_data(). Args: rainfall_path (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files = [ f for f in listdir ( rainfall_path ) if isfile ( join ( rainfall_path , f ))] rainfall_files_df = pd . DataFrame ({ \"filename\" : rainfall_files }) rainfall_files_df [ \"date\" ] = rainfall_files_df . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) rainfall_files_df = rainfall_files_df [( rainfall_files_df [ \"date\" ] >= date_start ) & ( rainfall_files_df [ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) return rainfall_files_df def get_grid_size ( rainfall_path , date_start , duration ): \"\"\" This function loads the list of rainfall files corresponding to the given date_start and duration, loads the first rainfall file, and returns its grid size, as dimensions of the rainfall grid define the output resolution of the model. Args: TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files_df = build_rainfall_files_df ( rainfall_path , date_start , duration ) # checking coherence between date_start and duration and available rainfall data if rainfall_files_df [ \"date\" ] . iloc [ - 1 ] != date_start + datetime . timedelta ( days = duration - 1 ) : raise ValueError ( \"The date range may not be covered by the available rainfall data ; please check rainfall entry files.\" ) # loading the first rainfall file to get the grid size src = rasterio . open ( os . path . join ( rainfall_path , rainfall_files_df . loc [ 0 , \"filename\" ])) array = src . read ( 1 ) grid_width = array . shape [ 0 ] grid_height = array . shape [ 1 ] return grid_width , grid_height def load_TAMSAT_data ( data , TAMSAT_path , date_start , duration ): \"\"\" This function loops over the rainfall raster files, and loads them into a xarray DataArray, which is then added to the rain data dictionary. It is tailored to the TAMSAT rainfall data files, hence its name. Args: data (_type_): _description_ TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" TAMSAT_files_df = build_rainfall_files_df ( TAMSAT_path , date_start , duration ) dataarray_full = None for i in range ( len ( TAMSAT_files_df )): dataarray = rioxarray . open_rasterio ( os . path . join ( TAMSAT_path , TAMSAT_files_df . loc [ i , \"filename\" ])) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" , \"spatial_ref\" ]) dataarray . attrs = {} dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full . rio . write_crs ( 4326 , inplace = True ) data [ \"rain\" ] = dataarray_full data [ \"rain\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"rainfall\" } return data def load_AgERA5_data ( data , AgERA5_data_path , date_start , duration ): \"\"\" This function loops over the AgERA5 raster files, and loads them into xarray DataArray, which are then added to the data dictionary. Args: data (_type_): _description_ AgERA5_data_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" # getting list of variables AgERA5_variables = [ path . split ( \"/\" )[ - 1 ] for path in [ x [ 0 ] for x in os . walk ( AgERA5_data_path )][ 1 :]] # building a dictionary of dataframes containing the list of files for each variable AgERA5_files_df_collection = {} for variable in AgERA5_variables : AgERA5_files = [ f for f in listdir ( os . path . join ( AgERA5_data_path , variable )) if isfile ( join ( os . path . join ( AgERA5_data_path , variable ), f ))] AgERA5_files_df_collection [ variable ] = pd . DataFrame ({ \"filename\" : AgERA5_files }) AgERA5_files_df_collection [ variable ][ \"date\" ] = AgERA5_files_df_collection [ variable ] . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) AgERA5_files_df_collection [ variable ] = AgERA5_files_df_collection [ variable ][( AgERA5_files_df_collection [ variable ][ \"date\" ] >= date_start ) & ( AgERA5_files_df_collection [ variable ][ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) # building a dictionary of correspondance between AgERA5 variables and SARRA variables AgERA5_SARRA_correspondance = { '10m_wind_speed_24_hour_mean' : None , '2m_temperature_24_hour_maximum' : None , '2m_temperature_24_hour_mean' : 'tpMoy' , '2m_temperature_24_hour_minimum' : None , 'ET0Hargeaves' : 'ET0' , 'solar_radiation_flux_daily' : 'rg' , 'vapour_pressure_24_hour_mean' : None , } # loading the data for variable in tqdm ( AgERA5_variables ) : if AgERA5_SARRA_correspondance [ variable ] != None : try : del dataarray_full except : pass dataarray_full = None for i in range ( duration ) : dataarray = rioxarray . open_rasterio ( os . path . join ( AgERA5_data_path , variable , AgERA5_files_df_collection [ variable ] . loc [ i , \"filename\" ])) dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) # TODO: add dataarray.attrs = {} to precise units and long_name # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # storing the variable in the data dictionary data [ AgERA5_SARRA_correspondance [ variable ]] = dataarray_full # unit conversion for solar radiation (kJ/m2 as provided by AgERA5 to MJ/m2/day) data [ \"rg\" ] = data [ \"rg\" ] / 1000 return data def load_paramVariete ( file_paramVariete ) : \"\"\" This function loads the parameters of the variety from the yaml file. Args: file_paramVariete (_type_): _description_ Raises: exception: _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/variety/' , file_paramVariete ), 'r' ) as stream : paramVariete = yaml . safe_load ( stream ) if paramVariete [ \"feuilAeroBase\" ] == 0.1 : raise Exception () return paramVariete def load_paramITK ( file_paramITK ): \"\"\" This function loads the ITK parameters from the yaml file. Args: file_paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/itk/' , file_paramITK ), 'r' ) as stream : paramITK = yaml . safe_load ( stream ) paramITK [ \"DateSemis\" ] = datetime . datetime . strptime ( paramITK [ \"DateSemis\" ], \"%Y-%m- %d \" ) . date () return paramITK def load_paramTypeSol ( file_paramTypeSol ): \"\"\" This function loads the soil parameters from the yaml file. Args: file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/soil/' , file_paramTypeSol ), 'r' ) as stream : paramTypeSol = yaml . safe_load ( stream ) return paramTypeSol def load_YAML_parameters ( file_paramVariete , file_paramITK , file_paramTypeSol ): \"\"\" This function loads the parameters from the yaml files. It is a wrapper for the three functions above. Args: file_paramVariete (_type_): _description_ file_paramITK (_type_): _description_ file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" paramVariete = load_paramVariete ( file_paramVariete ) paramITK = load_paramITK ( file_paramITK ) paramTypeSol = load_paramTypeSol ( file_paramTypeSol ) if ~ np . isnan ( paramITK [ \"NI\" ]): print ( \"NI NON NULL\" ) paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ])) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ]) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ])) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) return paramVariete , paramITK , paramTypeSol def initialize_default_irrigation ( data ): # default irrigation scheme data [ \"irrigation\" ] = data [ \"rain\" ] * 0 data [ \"irrigation\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"irrigation\" } return data def load_iSDA_soil_data ( data , grid_width , grid_height ): \"\"\" This function loads iSDA soil data and crop to the area of interest remark : it would be nice to try to modulate the percentage of runoff according to slope First, this function loads the iSDA soil data, crops it to the area of interest and resamples it to match the grid resolution. The iSDA soil class raster map obtained is passed to the xarray dataset as a new variable. For the sake of example, the file that is used here already has been downsampled at TAMSAT resolution. Its specs are available on the CIRAD Dataverse at the following adress : https://doi.org/10.1038/s41598-021-85639-y Second, a correspondance table matching the iSDA soil classes to the soil physical properties is loaded. Maps of soil physical properties are then created and added to the xarray dataset. Returns: _type_: _description_ \"\"\" # load raster data soil_type_file_path = \"../data/assets/iSDA_at_TAMSAT_resolution_zeroclass_1E6.tif\" dataarray = rioxarray . open_rasterio ( soil_type_file_path ) # crop to the area of interest area = { 'burkina' : [ 16 , - 6 , 9 , 3 ], #lat,lon lat,lon } selected_area = \"burkina\" dataarray = dataarray . where (( dataarray . y < area [ selected_area ][ 0 ]) & ( dataarray . y > area [ selected_area ][ 2 ]) & ( dataarray . x > area [ selected_area ][ 1 ]) & ( dataarray . x < area [ selected_area ][ 3 ]) ) . dropna ( dim = 'y' , how = 'all' ) . dropna ( dim = 'x' , how = 'all' ) # resample to match the grid resolution dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) dataarray . attrs = { \"units\" : \"arbitrary\" , \"long_name\" : \"soil_type\" } # add soil type identifier to the dataset data [ \"soil_type\" ] = dataarray data [ \"soil_type\" ] = data [ \"soil_type\" ] / 1000000 # conversion from 1E6 to 1E0 # load correspondance table path_soil_type_correspondance = \"../data/assets/TypeSol_Moy13_HWSD.csv\" df_soil_type_correspondance = pd . read_csv ( path_soil_type_correspondance , sep = \";\" , skiprows = 1 ) # correspondance between soil properties naming in the csv file and in the dataset soil_variables = { \"epaisseurProf\" : \"EpaisseurProf\" , \"epaisseurSurf\" : \"EpaisseurSurf\" , \"stockIniProf\" : \"StockIniProf\" , \"stockIniSurf\" : \"StockIniSurf\" , \"seuilRuiss\" : \"SeuilRuiss\" , \"pourcRuiss\" : \"PourcRuiss\" , \"ru\" : \"Ru\" , } # create maps of soil properties and add them to the dataset for soil_variable in soil_variables : dict_values = dict ( zip ( df_soil_type_correspondance [ \"Id\" ], df_soil_type_correspondance [ soil_variables [ soil_variable ]])) dict_values [ 0 ] = np . nan soil_types_converted = np . reshape ([ dict_values [ x . astype ( int )] for x in data [ \"soil_type\" ] . to_numpy () . flatten ()], ( grid_width , grid_height )) data [ soil_variable ] = ( data [ \"soil_type\" ] . dims , soil_types_converted ) # TODO: add dataarray.attrs = {} to precise units and long_name # converting pourcRuiss to decimal % data [ \"pourcRuiss\" ] = data [ \"pourcRuiss\" ] / 100 return data def calc_day_length ( day , lat ): \"\"\" This function calculates the day length for a given day and latitude. Args: day (_type_): _description_ lat (_type_): _description_ Returns: _type_: _description_ \"\"\" # print(day, lat) coords = LocationInfo ( latitude = float ( lat ), longitude = 0.0 ) daylight = astral . sun . daylight ( coords . observer , date = day ) dureeDuJour = ( daylight [ 1 ] - daylight [ 0 ]) . seconds / 3600 return dureeDuJour def calc_day_length_raster ( data , date_start , duration ): \"\"\" This function calculates the day length raster for a given period of time. Args: data (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" days = [ date_start + datetime . timedelta ( days = i ) for i in range ( duration )] # we will first define an empty array of the same shape as the rain array data [ \"dureeDuJour\" ] = ( data [ \"rain\" ] . dims , np . zeros ( data [ \"rain\" ] . shape )) # we will apply the calc_day_length function using a for loop on the y dimension, as well as on the j dimension for j in tqdm ( range ( duration )): for y in range ( len ( data [ \"y\" ])): data [ \"dureeDuJour\" ][ j , y ,:] = calc_day_length ( date_start + datetime . timedelta ( days = j ), data [ \"y\" ][ y ]) # optional : plot the day length raster # data[\"dureeDuJour\"][:,:,0].plot() return data Functions build_rainfall_files_df def build_rainfall_files_df ( rainfall_path , date_start , duration ) This function builds a dataframe containing the list of rainfall files from the provided path, and the given date_start and duration. Helper function used in get_grid_size() and load_TAMSAT_data(). Parameters: Name Type Description Default rainfall_path type description None Returns: Type Description type description View Source def build_rainfall_files_df ( rainfall_path , date_start , duration ): \"\"\" This function builds a dataframe containing the list of rainfall files from the provided path, and the given date_start and duration. Helper function used in get_grid_size() and load_TAMSAT_data(). Args: rainfall_path (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files = [ f for f in listdir ( rainfall_path ) if isfile ( join ( rainfall_path , f ))] rainfall_files_df = pd . DataFrame ({ \"filename\" : rainfall_files }) rainfall_files_df [ \"date\" ] = rainfall_files_df . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) rainfall_files_df = rainfall_files_df [( rainfall_files_df [ \"date\" ] >= date_start ) & ( rainfall_files_df [ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) return rainfall_files_df calc_day_length def calc_day_length ( day , lat ) This function calculates the day length for a given day and latitude. Parameters: Name Type Description Default day type description None lat type description None Returns: Type Description type description View Source def calc_day_length ( day , lat ) : \"\"\" This function calculates the day length for a given day and latitude . Args : day ( _type_ ) : _description_ lat ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # print ( day , lat ) coords = LocationInfo ( latitude = float ( lat ) , longitude = 0 . 0 ) daylight = astral . sun . daylight ( coords . observer , date = day ) dureeDuJour = ( daylight [ 1 ] - daylight [ 0 ] ) . seconds / 3600 return dureeDuJour calc_day_length_raster def calc_day_length_raster ( data , date_start , duration ) This function calculates the day length raster for a given period of time. Parameters: Name Type Description Default data type description None date_start type description None duration type description None Returns: Type Description type description View Source def calc_day_length_raster ( data , date_start , duration ) : \"\"\" This function calculates the day length raster for a given period of time. Args: data (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" days = [ date_start + datetime.timedelta(days=i) for i in range(duration) ] # we will first define an empty array of the same shape as the rain array data [ \"dureeDuJour\" ] = ( data [ \"rain\" ] . dims , np . zeros ( data [ \"rain\" ] . shape )) # we will apply the calc_day_length function using a for loop on the y dimension , as well as on the j dimension for j in tqdm ( range ( duration )) : for y in range ( len ( data [ \"y\" ] )) : data [ \"dureeDuJour\" ][ j,y,: ] = calc_day_length ( date_start + datetime . timedelta ( days = j ), data [ \"y\" ][ y ] ) # optional : plot the day length raster # data [ \"dureeDuJour\" ][ :,:,0 ] . plot () return data get_grid_size def get_grid_size ( rainfall_path , date_start , duration ) This function loads the list of rainfall files corresponding to the given date_start and duration, loads the first rainfall file, and returns its grid size, as dimensions of the rainfall grid define the output resolution of the model. Parameters: Name Type Description Default TAMSAT_path type description None date_start type description None duration type description None Returns: Type Description type description View Source def get_grid_size ( rainfall_path , date_start , duration ): \"\"\" This function loads the list of rainfall files corresponding to the given date_start and duration, loads the first rainfall file, and returns its grid size, as dimensions of the rainfall grid define the output resolution of the model. Args: TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files_df = build_rainfall_files_df ( rainfall_path , date_start , duration ) # checking coherence between date_start and duration and available rainfall data if rainfall_files_df [ \"date\" ] . iloc [ - 1 ] != date_start + datetime . timedelta ( days = duration - 1 ) : raise ValueError ( \"The date range may not be covered by the available rainfall data ; please check rainfall entry files.\" ) # loading the first rainfall file to get the grid size src = rasterio . open ( os . path . join ( rainfall_path , rainfall_files_df . loc [ 0 , \"filename\" ])) array = src . read ( 1 ) grid_width = array . shape [ 0 ] grid_height = array . shape [ 1 ] return grid_width , grid_height initialize_default_irrigation def initialize_default_irrigation ( data ) View Source def initialize_default_irrigation ( data ) : # default irrigation scheme data [ \" irrigation \" ] = data [ \" rain \" ] * 0 data [ \" irrigation \" ]. attrs = { \" units \" : \" mm \" , \" long_name \" : \" irrigation \" } return data load_AgERA5_data def load_AgERA5_data ( data , AgERA5_data_path , date_start , duration ) This function loops over the AgERA5 raster files, and loads them into xarray DataArray, which are then added to the data dictionary. Parameters: Name Type Description Default data type description None AgERA5_data_path type description None date_start type description None duration type description None Returns: Type Description type description View Source def load_AgERA5_data ( data , AgERA5_data_path , date_start , duration ): \"\"\" This function loops over the AgERA5 raster files, and loads them into xarray DataArray, which are then added to the data dictionary. Args: data (_type_): _description_ AgERA5_data_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" # getting list of variables AgERA5_variables = [ path . split ( \"/\" )[ - 1 ] for path in [ x [ 0 ] for x in os . walk ( AgERA5_data_path )][ 1 :]] # building a dictionary of dataframes containing the list of files for each variable AgERA5_files_df_collection = {} for variable in AgERA5_variables : AgERA5_files = [ f for f in listdir ( os . path . join ( AgERA5_data_path , variable )) if isfile ( join ( os . path . join ( AgERA5_data_path , variable ), f ))] AgERA5_files_df_collection [ variable ] = pd . DataFrame ({ \"filename\" : AgERA5_files }) AgERA5_files_df_collection [ variable ][ \"date\" ] = AgERA5_files_df_collection [ variable ] . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) AgERA5_files_df_collection [ variable ] = AgERA5_files_df_collection [ variable ][( AgERA5_files_df_collection [ variable ][ \"date\" ] >= date_start ) & ( AgERA5_files_df_collection [ variable ][ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) # building a dictionary of correspondance between AgERA5 variables and SARRA variables AgERA5_SARRA_correspondance = { '10m_wind_speed_24_hour_mean' : None , '2m_temperature_24_hour_maximum' : None , '2m_temperature_24_hour_mean' : 'tpMoy' , '2m_temperature_24_hour_minimum' : None , 'ET0Hargeaves' : 'ET0' , 'solar_radiation_flux_daily' : 'rg' , 'vapour_pressure_24_hour_mean' : None , } # loading the data for variable in tqdm ( AgERA5_variables ) : if AgERA5_SARRA_correspondance [ variable ] != None : try : del dataarray_full except : pass dataarray_full = None for i in range ( duration ) : dataarray = rioxarray . open_rasterio ( os . path . join ( AgERA5_data_path , variable , AgERA5_files_df_collection [ variable ] . loc [ i , \"filename\" ])) dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) # TODO: add dataarray.attrs = {} to precise units and long_name # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # storing the variable in the data dictionary data [ AgERA5_SARRA_correspondance [ variable ]] = dataarray_full # unit conversion for solar radiation (kJ/m2 as provided by AgERA5 to MJ/m2/day) data [ \"rg\" ] = data [ \"rg\" ] / 1000 return data load_TAMSAT_data def load_TAMSAT_data ( data , TAMSAT_path , date_start , duration ) This function loops over the rainfall raster files, and loads them into a xarray DataArray, which is then added to the rain data dictionary. It is tailored to the TAMSAT rainfall data files, hence its name. Parameters: Name Type Description Default data type description None TAMSAT_path type description None date_start type description None duration type description None Returns: Type Description type description View Source def load_TAMSAT_data ( data , TAMSAT_path , date_start , duration ): \"\"\" This function loops over the rainfall raster files, and loads them into a xarray DataArray, which is then added to the rain data dictionary. It is tailored to the TAMSAT rainfall data files, hence its name. Args: data (_type_): _description_ TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" TAMSAT_files_df = build_rainfall_files_df ( TAMSAT_path , date_start , duration ) dataarray_full = None for i in range ( len ( TAMSAT_files_df )): dataarray = rioxarray . open_rasterio ( os . path . join ( TAMSAT_path , TAMSAT_files_df . loc [ i , \"filename\" ])) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" , \"spatial_ref\" ]) dataarray . attrs = {} dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full . rio . write_crs ( 4326 , inplace = True ) data [ \"rain\" ] = dataarray_full data [ \"rain\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"rainfall\" } return data load_YAML_parameters def load_YAML_parameters ( file_paramVariete , file_paramITK , file_paramTypeSol ) This function loads the parameters from the yaml files. It is a wrapper for the three functions above. Parameters: Name Type Description Default file_paramVariete type description None file_paramITK type description None file_paramTypeSol type description None Returns: Type Description type description View Source def load_YAML_parameters ( file_paramVariete , file_paramITK , file_paramTypeSol ): \"\"\" This function loads the parameters from the yaml files. It is a wrapper for the three functions above. Args: file_paramVariete (_type_): _description_ file_paramITK (_type_): _description_ file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" paramVariete = load_paramVariete ( file_paramVariete ) paramITK = load_paramITK ( file_paramITK ) paramTypeSol = load_paramTypeSol ( file_paramTypeSol ) if ~ np . isnan ( paramITK [ \"NI\" ]): print ( \"NI NON NULL\" ) paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ])) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ]) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ])) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) return paramVariete , paramITK , paramTypeSol load_iSDA_soil_data def load_iSDA_soil_data ( data , grid_width , grid_height ) This function loads iSDA soil data and crop to the area of interest remark : it would be nice to try to modulate the percentage of runoff according to slope First, this function loads the iSDA soil data, crops it to the area of interest and resamples it to match the grid resolution. The iSDA soil class raster map obtained is passed to the xarray dataset as a new variable. For the sake of example, the file that is used here already has been downsampled at TAMSAT resolution. Its specs are available on the CIRAD Dataverse at the following adress : https://doi.org/10.1038/s41598-021-85639-y Second, a correspondance table matching the iSDA soil classes to the soil physical properties is loaded. Maps of soil physical properties are then created and added to the xarray dataset. Returns: Type Description type description View Source def load_iSDA_soil_data ( data , grid_width , grid_height ): \"\"\" This function loads iSDA soil data and crop to the area of interest remark : it would be nice to try to modulate the percentage of runoff according to slope First, this function loads the iSDA soil data, crops it to the area of interest and resamples it to match the grid resolution. The iSDA soil class raster map obtained is passed to the xarray dataset as a new variable. For the sake of example, the file that is used here already has been downsampled at TAMSAT resolution. Its specs are available on the CIRAD Dataverse at the following adress : https://doi.org/10.1038/s41598-021-85639-y Second, a correspondance table matching the iSDA soil classes to the soil physical properties is loaded. Maps of soil physical properties are then created and added to the xarray dataset. Returns: _type_: _description_ \"\"\" # load raster data soil_type_file_path = \"../data/assets/iSDA_at_TAMSAT_resolution_zeroclass_1E6.tif\" dataarray = rioxarray . open_rasterio ( soil_type_file_path ) # crop to the area of interest area = { 'burkina' : [ 16 , - 6 , 9 , 3 ], #lat,lon lat,lon } selected_area = \"burkina\" dataarray = dataarray . where (( dataarray . y < area [ selected_area ][ 0 ]) & ( dataarray . y > area [ selected_area ][ 2 ]) & ( dataarray . x > area [ selected_area ][ 1 ]) & ( dataarray . x < area [ selected_area ][ 3 ]) ) . dropna ( dim = 'y' , how = 'all' ) . dropna ( dim = 'x' , how = 'all' ) # resample to match the grid resolution dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) dataarray . attrs = { \"units\" : \"arbitrary\" , \"long_name\" : \"soil_type\" } # add soil type identifier to the dataset data [ \"soil_type\" ] = dataarray data [ \"soil_type\" ] = data [ \"soil_type\" ] / 1000000 # conversion from 1E6 to 1E0 # load correspondance table path_soil_type_correspondance = \"../data/assets/TypeSol_Moy13_HWSD.csv\" df_soil_type_correspondance = pd . read_csv ( path_soil_type_correspondance , sep = \";\" , skiprows = 1 ) # correspondance between soil properties naming in the csv file and in the dataset soil_variables = { \"epaisseurProf\" : \"EpaisseurProf\" , \"epaisseurSurf\" : \"EpaisseurSurf\" , \"stockIniProf\" : \"StockIniProf\" , \"stockIniSurf\" : \"StockIniSurf\" , \"seuilRuiss\" : \"SeuilRuiss\" , \"pourcRuiss\" : \"PourcRuiss\" , \"ru\" : \"Ru\" , } # create maps of soil properties and add them to the dataset for soil_variable in soil_variables : dict_values = dict ( zip ( df_soil_type_correspondance [ \"Id\" ], df_soil_type_correspondance [ soil_variables [ soil_variable ]])) dict_values [ 0 ] = np . nan soil_types_converted = np . reshape ([ dict_values [ x . astype ( int )] for x in data [ \"soil_type\" ] . to_numpy () . flatten ()], ( grid_width , grid_height )) data [ soil_variable ] = ( data [ \"soil_type\" ] . dims , soil_types_converted ) # TODO: add dataarray.attrs = {} to precise units and long_name # converting pourcRuiss to decimal % data [ \"pourcRuiss\" ] = data [ \"pourcRuiss\" ] / 100 return data load_paramITK def load_paramITK ( file_paramITK ) This function loads the ITK parameters from the yaml file. Parameters: Name Type Description Default file_paramITK type description None Returns: Type Description type description View Source def load_paramITK ( file_paramITK ): \"\"\" This function loads the ITK parameters from the yaml file. Args: file_paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/itk/' , file_paramITK ), 'r' ) as stream : paramITK = yaml . safe_load ( stream ) paramITK [ \"DateSemis\" ] = datetime . datetime . strptime ( paramITK [ \"DateSemis\" ], \"%Y-%m- %d \" ) . date () return paramITK load_paramTypeSol def load_paramTypeSol ( file_paramTypeSol ) This function loads the soil parameters from the yaml file. Parameters: Name Type Description Default file_paramTypeSol type description None Returns: Type Description type description View Source def load_paramTypeSol ( file_paramTypeSol ): \"\"\" This function loads the soil parameters from the yaml file. Args: file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/soil/' , file_paramTypeSol ), 'r' ) as stream : paramTypeSol = yaml . safe_load ( stream ) return paramTypeSol load_paramVariete def load_paramVariete ( file_paramVariete ) This function loads the parameters of the variety from the yaml file. Parameters: Name Type Description Default file_paramVariete type description None Returns: Type Description type description Raises: Type Description exception description View Source def load_paramVariete ( file_paramVariete ) : \"\"\" This function loads the parameters of the variety from the yaml file. Args: file_paramVariete (_type_): _description_ Raises: exception: _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/variety/' , file_paramVariete ), 'r' ) as stream : paramVariete = yaml . safe_load ( stream ) if paramVariete [ \"feuilAeroBase\" ] == 0.1 : raise Exception () return paramVariete","title":"Data Preparation"},{"location":"reference/sarra_py/data_preparation/#module-sarra_pydata_preparation","text":"View Source from os import listdir from os.path import isfile , join import pandas as pd import datetime import rasterio import os import rioxarray from tqdm import tqdm as tqdm import numpy as np import yaml import xarray as xr import astral from astral.sun import sun from astral import LocationInfo def build_rainfall_files_df ( rainfall_path , date_start , duration ): \"\"\" This function builds a dataframe containing the list of rainfall files from the provided path, and the given date_start and duration. Helper function used in get_grid_size() and load_TAMSAT_data(). Args: rainfall_path (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files = [ f for f in listdir ( rainfall_path ) if isfile ( join ( rainfall_path , f ))] rainfall_files_df = pd . DataFrame ({ \"filename\" : rainfall_files }) rainfall_files_df [ \"date\" ] = rainfall_files_df . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) rainfall_files_df = rainfall_files_df [( rainfall_files_df [ \"date\" ] >= date_start ) & ( rainfall_files_df [ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) return rainfall_files_df def get_grid_size ( rainfall_path , date_start , duration ): \"\"\" This function loads the list of rainfall files corresponding to the given date_start and duration, loads the first rainfall file, and returns its grid size, as dimensions of the rainfall grid define the output resolution of the model. Args: TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files_df = build_rainfall_files_df ( rainfall_path , date_start , duration ) # checking coherence between date_start and duration and available rainfall data if rainfall_files_df [ \"date\" ] . iloc [ - 1 ] != date_start + datetime . timedelta ( days = duration - 1 ) : raise ValueError ( \"The date range may not be covered by the available rainfall data ; please check rainfall entry files.\" ) # loading the first rainfall file to get the grid size src = rasterio . open ( os . path . join ( rainfall_path , rainfall_files_df . loc [ 0 , \"filename\" ])) array = src . read ( 1 ) grid_width = array . shape [ 0 ] grid_height = array . shape [ 1 ] return grid_width , grid_height def load_TAMSAT_data ( data , TAMSAT_path , date_start , duration ): \"\"\" This function loops over the rainfall raster files, and loads them into a xarray DataArray, which is then added to the rain data dictionary. It is tailored to the TAMSAT rainfall data files, hence its name. Args: data (_type_): _description_ TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" TAMSAT_files_df = build_rainfall_files_df ( TAMSAT_path , date_start , duration ) dataarray_full = None for i in range ( len ( TAMSAT_files_df )): dataarray = rioxarray . open_rasterio ( os . path . join ( TAMSAT_path , TAMSAT_files_df . loc [ i , \"filename\" ])) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" , \"spatial_ref\" ]) dataarray . attrs = {} dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full . rio . write_crs ( 4326 , inplace = True ) data [ \"rain\" ] = dataarray_full data [ \"rain\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"rainfall\" } return data def load_AgERA5_data ( data , AgERA5_data_path , date_start , duration ): \"\"\" This function loops over the AgERA5 raster files, and loads them into xarray DataArray, which are then added to the data dictionary. Args: data (_type_): _description_ AgERA5_data_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" # getting list of variables AgERA5_variables = [ path . split ( \"/\" )[ - 1 ] for path in [ x [ 0 ] for x in os . walk ( AgERA5_data_path )][ 1 :]] # building a dictionary of dataframes containing the list of files for each variable AgERA5_files_df_collection = {} for variable in AgERA5_variables : AgERA5_files = [ f for f in listdir ( os . path . join ( AgERA5_data_path , variable )) if isfile ( join ( os . path . join ( AgERA5_data_path , variable ), f ))] AgERA5_files_df_collection [ variable ] = pd . DataFrame ({ \"filename\" : AgERA5_files }) AgERA5_files_df_collection [ variable ][ \"date\" ] = AgERA5_files_df_collection [ variable ] . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) AgERA5_files_df_collection [ variable ] = AgERA5_files_df_collection [ variable ][( AgERA5_files_df_collection [ variable ][ \"date\" ] >= date_start ) & ( AgERA5_files_df_collection [ variable ][ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) # building a dictionary of correspondance between AgERA5 variables and SARRA variables AgERA5_SARRA_correspondance = { '10m_wind_speed_24_hour_mean' : None , '2m_temperature_24_hour_maximum' : None , '2m_temperature_24_hour_mean' : 'tpMoy' , '2m_temperature_24_hour_minimum' : None , 'ET0Hargeaves' : 'ET0' , 'solar_radiation_flux_daily' : 'rg' , 'vapour_pressure_24_hour_mean' : None , } # loading the data for variable in tqdm ( AgERA5_variables ) : if AgERA5_SARRA_correspondance [ variable ] != None : try : del dataarray_full except : pass dataarray_full = None for i in range ( duration ) : dataarray = rioxarray . open_rasterio ( os . path . join ( AgERA5_data_path , variable , AgERA5_files_df_collection [ variable ] . loc [ i , \"filename\" ])) dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) # TODO: add dataarray.attrs = {} to precise units and long_name # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # storing the variable in the data dictionary data [ AgERA5_SARRA_correspondance [ variable ]] = dataarray_full # unit conversion for solar radiation (kJ/m2 as provided by AgERA5 to MJ/m2/day) data [ \"rg\" ] = data [ \"rg\" ] / 1000 return data def load_paramVariete ( file_paramVariete ) : \"\"\" This function loads the parameters of the variety from the yaml file. Args: file_paramVariete (_type_): _description_ Raises: exception: _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/variety/' , file_paramVariete ), 'r' ) as stream : paramVariete = yaml . safe_load ( stream ) if paramVariete [ \"feuilAeroBase\" ] == 0.1 : raise Exception () return paramVariete def load_paramITK ( file_paramITK ): \"\"\" This function loads the ITK parameters from the yaml file. Args: file_paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/itk/' , file_paramITK ), 'r' ) as stream : paramITK = yaml . safe_load ( stream ) paramITK [ \"DateSemis\" ] = datetime . datetime . strptime ( paramITK [ \"DateSemis\" ], \"%Y-%m- %d \" ) . date () return paramITK def load_paramTypeSol ( file_paramTypeSol ): \"\"\" This function loads the soil parameters from the yaml file. Args: file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/soil/' , file_paramTypeSol ), 'r' ) as stream : paramTypeSol = yaml . safe_load ( stream ) return paramTypeSol def load_YAML_parameters ( file_paramVariete , file_paramITK , file_paramTypeSol ): \"\"\" This function loads the parameters from the yaml files. It is a wrapper for the three functions above. Args: file_paramVariete (_type_): _description_ file_paramITK (_type_): _description_ file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" paramVariete = load_paramVariete ( file_paramVariete ) paramITK = load_paramITK ( file_paramITK ) paramTypeSol = load_paramTypeSol ( file_paramTypeSol ) if ~ np . isnan ( paramITK [ \"NI\" ]): print ( \"NI NON NULL\" ) paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ])) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ]) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ])) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) return paramVariete , paramITK , paramTypeSol def initialize_default_irrigation ( data ): # default irrigation scheme data [ \"irrigation\" ] = data [ \"rain\" ] * 0 data [ \"irrigation\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"irrigation\" } return data def load_iSDA_soil_data ( data , grid_width , grid_height ): \"\"\" This function loads iSDA soil data and crop to the area of interest remark : it would be nice to try to modulate the percentage of runoff according to slope First, this function loads the iSDA soil data, crops it to the area of interest and resamples it to match the grid resolution. The iSDA soil class raster map obtained is passed to the xarray dataset as a new variable. For the sake of example, the file that is used here already has been downsampled at TAMSAT resolution. Its specs are available on the CIRAD Dataverse at the following adress : https://doi.org/10.1038/s41598-021-85639-y Second, a correspondance table matching the iSDA soil classes to the soil physical properties is loaded. Maps of soil physical properties are then created and added to the xarray dataset. Returns: _type_: _description_ \"\"\" # load raster data soil_type_file_path = \"../data/assets/iSDA_at_TAMSAT_resolution_zeroclass_1E6.tif\" dataarray = rioxarray . open_rasterio ( soil_type_file_path ) # crop to the area of interest area = { 'burkina' : [ 16 , - 6 , 9 , 3 ], #lat,lon lat,lon } selected_area = \"burkina\" dataarray = dataarray . where (( dataarray . y < area [ selected_area ][ 0 ]) & ( dataarray . y > area [ selected_area ][ 2 ]) & ( dataarray . x > area [ selected_area ][ 1 ]) & ( dataarray . x < area [ selected_area ][ 3 ]) ) . dropna ( dim = 'y' , how = 'all' ) . dropna ( dim = 'x' , how = 'all' ) # resample to match the grid resolution dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) dataarray . attrs = { \"units\" : \"arbitrary\" , \"long_name\" : \"soil_type\" } # add soil type identifier to the dataset data [ \"soil_type\" ] = dataarray data [ \"soil_type\" ] = data [ \"soil_type\" ] / 1000000 # conversion from 1E6 to 1E0 # load correspondance table path_soil_type_correspondance = \"../data/assets/TypeSol_Moy13_HWSD.csv\" df_soil_type_correspondance = pd . read_csv ( path_soil_type_correspondance , sep = \";\" , skiprows = 1 ) # correspondance between soil properties naming in the csv file and in the dataset soil_variables = { \"epaisseurProf\" : \"EpaisseurProf\" , \"epaisseurSurf\" : \"EpaisseurSurf\" , \"stockIniProf\" : \"StockIniProf\" , \"stockIniSurf\" : \"StockIniSurf\" , \"seuilRuiss\" : \"SeuilRuiss\" , \"pourcRuiss\" : \"PourcRuiss\" , \"ru\" : \"Ru\" , } # create maps of soil properties and add them to the dataset for soil_variable in soil_variables : dict_values = dict ( zip ( df_soil_type_correspondance [ \"Id\" ], df_soil_type_correspondance [ soil_variables [ soil_variable ]])) dict_values [ 0 ] = np . nan soil_types_converted = np . reshape ([ dict_values [ x . astype ( int )] for x in data [ \"soil_type\" ] . to_numpy () . flatten ()], ( grid_width , grid_height )) data [ soil_variable ] = ( data [ \"soil_type\" ] . dims , soil_types_converted ) # TODO: add dataarray.attrs = {} to precise units and long_name # converting pourcRuiss to decimal % data [ \"pourcRuiss\" ] = data [ \"pourcRuiss\" ] / 100 return data def calc_day_length ( day , lat ): \"\"\" This function calculates the day length for a given day and latitude. Args: day (_type_): _description_ lat (_type_): _description_ Returns: _type_: _description_ \"\"\" # print(day, lat) coords = LocationInfo ( latitude = float ( lat ), longitude = 0.0 ) daylight = astral . sun . daylight ( coords . observer , date = day ) dureeDuJour = ( daylight [ 1 ] - daylight [ 0 ]) . seconds / 3600 return dureeDuJour def calc_day_length_raster ( data , date_start , duration ): \"\"\" This function calculates the day length raster for a given period of time. Args: data (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" days = [ date_start + datetime . timedelta ( days = i ) for i in range ( duration )] # we will first define an empty array of the same shape as the rain array data [ \"dureeDuJour\" ] = ( data [ \"rain\" ] . dims , np . zeros ( data [ \"rain\" ] . shape )) # we will apply the calc_day_length function using a for loop on the y dimension, as well as on the j dimension for j in tqdm ( range ( duration )): for y in range ( len ( data [ \"y\" ])): data [ \"dureeDuJour\" ][ j , y ,:] = calc_day_length ( date_start + datetime . timedelta ( days = j ), data [ \"y\" ][ y ]) # optional : plot the day length raster # data[\"dureeDuJour\"][:,:,0].plot() return data","title":"Module sarra_py.data_preparation"},{"location":"reference/sarra_py/data_preparation/#functions","text":"","title":"Functions"},{"location":"reference/sarra_py/data_preparation/#build_rainfall_files_df","text":"def build_rainfall_files_df ( rainfall_path , date_start , duration ) This function builds a dataframe containing the list of rainfall files from the provided path, and the given date_start and duration. Helper function used in get_grid_size() and load_TAMSAT_data(). Parameters: Name Type Description Default rainfall_path type description None Returns: Type Description type description View Source def build_rainfall_files_df ( rainfall_path , date_start , duration ): \"\"\" This function builds a dataframe containing the list of rainfall files from the provided path, and the given date_start and duration. Helper function used in get_grid_size() and load_TAMSAT_data(). Args: rainfall_path (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files = [ f for f in listdir ( rainfall_path ) if isfile ( join ( rainfall_path , f ))] rainfall_files_df = pd . DataFrame ({ \"filename\" : rainfall_files }) rainfall_files_df [ \"date\" ] = rainfall_files_df . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) rainfall_files_df = rainfall_files_df [( rainfall_files_df [ \"date\" ] >= date_start ) & ( rainfall_files_df [ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) return rainfall_files_df","title":"build_rainfall_files_df"},{"location":"reference/sarra_py/data_preparation/#calc_day_length","text":"def calc_day_length ( day , lat ) This function calculates the day length for a given day and latitude. Parameters: Name Type Description Default day type description None lat type description None Returns: Type Description type description View Source def calc_day_length ( day , lat ) : \"\"\" This function calculates the day length for a given day and latitude . Args : day ( _type_ ) : _description_ lat ( _type_ ) : _description_ Returns : _type_ : _description_ \"\"\" # print ( day , lat ) coords = LocationInfo ( latitude = float ( lat ) , longitude = 0 . 0 ) daylight = astral . sun . daylight ( coords . observer , date = day ) dureeDuJour = ( daylight [ 1 ] - daylight [ 0 ] ) . seconds / 3600 return dureeDuJour","title":"calc_day_length"},{"location":"reference/sarra_py/data_preparation/#calc_day_length_raster","text":"def calc_day_length_raster ( data , date_start , duration ) This function calculates the day length raster for a given period of time. Parameters: Name Type Description Default data type description None date_start type description None duration type description None Returns: Type Description type description View Source def calc_day_length_raster ( data , date_start , duration ) : \"\"\" This function calculates the day length raster for a given period of time. Args: data (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" days = [ date_start + datetime.timedelta(days=i) for i in range(duration) ] # we will first define an empty array of the same shape as the rain array data [ \"dureeDuJour\" ] = ( data [ \"rain\" ] . dims , np . zeros ( data [ \"rain\" ] . shape )) # we will apply the calc_day_length function using a for loop on the y dimension , as well as on the j dimension for j in tqdm ( range ( duration )) : for y in range ( len ( data [ \"y\" ] )) : data [ \"dureeDuJour\" ][ j,y,: ] = calc_day_length ( date_start + datetime . timedelta ( days = j ), data [ \"y\" ][ y ] ) # optional : plot the day length raster # data [ \"dureeDuJour\" ][ :,:,0 ] . plot () return data","title":"calc_day_length_raster"},{"location":"reference/sarra_py/data_preparation/#get_grid_size","text":"def get_grid_size ( rainfall_path , date_start , duration ) This function loads the list of rainfall files corresponding to the given date_start and duration, loads the first rainfall file, and returns its grid size, as dimensions of the rainfall grid define the output resolution of the model. Parameters: Name Type Description Default TAMSAT_path type description None date_start type description None duration type description None Returns: Type Description type description View Source def get_grid_size ( rainfall_path , date_start , duration ): \"\"\" This function loads the list of rainfall files corresponding to the given date_start and duration, loads the first rainfall file, and returns its grid size, as dimensions of the rainfall grid define the output resolution of the model. Args: TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" rainfall_files_df = build_rainfall_files_df ( rainfall_path , date_start , duration ) # checking coherence between date_start and duration and available rainfall data if rainfall_files_df [ \"date\" ] . iloc [ - 1 ] != date_start + datetime . timedelta ( days = duration - 1 ) : raise ValueError ( \"The date range may not be covered by the available rainfall data ; please check rainfall entry files.\" ) # loading the first rainfall file to get the grid size src = rasterio . open ( os . path . join ( rainfall_path , rainfall_files_df . loc [ 0 , \"filename\" ])) array = src . read ( 1 ) grid_width = array . shape [ 0 ] grid_height = array . shape [ 1 ] return grid_width , grid_height","title":"get_grid_size"},{"location":"reference/sarra_py/data_preparation/#initialize_default_irrigation","text":"def initialize_default_irrigation ( data ) View Source def initialize_default_irrigation ( data ) : # default irrigation scheme data [ \" irrigation \" ] = data [ \" rain \" ] * 0 data [ \" irrigation \" ]. attrs = { \" units \" : \" mm \" , \" long_name \" : \" irrigation \" } return data","title":"initialize_default_irrigation"},{"location":"reference/sarra_py/data_preparation/#load_agera5_data","text":"def load_AgERA5_data ( data , AgERA5_data_path , date_start , duration ) This function loops over the AgERA5 raster files, and loads them into xarray DataArray, which are then added to the data dictionary. Parameters: Name Type Description Default data type description None AgERA5_data_path type description None date_start type description None duration type description None Returns: Type Description type description View Source def load_AgERA5_data ( data , AgERA5_data_path , date_start , duration ): \"\"\" This function loops over the AgERA5 raster files, and loads them into xarray DataArray, which are then added to the data dictionary. Args: data (_type_): _description_ AgERA5_data_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" # getting list of variables AgERA5_variables = [ path . split ( \"/\" )[ - 1 ] for path in [ x [ 0 ] for x in os . walk ( AgERA5_data_path )][ 1 :]] # building a dictionary of dataframes containing the list of files for each variable AgERA5_files_df_collection = {} for variable in AgERA5_variables : AgERA5_files = [ f for f in listdir ( os . path . join ( AgERA5_data_path , variable )) if isfile ( join ( os . path . join ( AgERA5_data_path , variable ), f ))] AgERA5_files_df_collection [ variable ] = pd . DataFrame ({ \"filename\" : AgERA5_files }) AgERA5_files_df_collection [ variable ][ \"date\" ] = AgERA5_files_df_collection [ variable ] . apply ( lambda x : datetime . date ( int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 3 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 2 ]), int ( x [ \"filename\" ] . replace ( \".tif\" , \"\" ) . split ( \"_\" )[ - 1 ]), ), axis = 1 , ) AgERA5_files_df_collection [ variable ] = AgERA5_files_df_collection [ variable ][( AgERA5_files_df_collection [ variable ][ \"date\" ] >= date_start ) & ( AgERA5_files_df_collection [ variable ][ \"date\" ] < date_start + datetime . timedelta ( days = duration ))] . reset_index ( drop = True ) # building a dictionary of correspondance between AgERA5 variables and SARRA variables AgERA5_SARRA_correspondance = { '10m_wind_speed_24_hour_mean' : None , '2m_temperature_24_hour_maximum' : None , '2m_temperature_24_hour_mean' : 'tpMoy' , '2m_temperature_24_hour_minimum' : None , 'ET0Hargeaves' : 'ET0' , 'solar_radiation_flux_daily' : 'rg' , 'vapour_pressure_24_hour_mean' : None , } # loading the data for variable in tqdm ( AgERA5_variables ) : if AgERA5_SARRA_correspondance [ variable ] != None : try : del dataarray_full except : pass dataarray_full = None for i in range ( duration ) : dataarray = rioxarray . open_rasterio ( os . path . join ( AgERA5_data_path , variable , AgERA5_files_df_collection [ variable ] . loc [ i , \"filename\" ])) dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) # TODO: add dataarray.attrs = {} to precise units and long_name # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # storing the variable in the data dictionary data [ AgERA5_SARRA_correspondance [ variable ]] = dataarray_full # unit conversion for solar radiation (kJ/m2 as provided by AgERA5 to MJ/m2/day) data [ \"rg\" ] = data [ \"rg\" ] / 1000 return data","title":"load_AgERA5_data"},{"location":"reference/sarra_py/data_preparation/#load_tamsat_data","text":"def load_TAMSAT_data ( data , TAMSAT_path , date_start , duration ) This function loops over the rainfall raster files, and loads them into a xarray DataArray, which is then added to the rain data dictionary. It is tailored to the TAMSAT rainfall data files, hence its name. Parameters: Name Type Description Default data type description None TAMSAT_path type description None date_start type description None duration type description None Returns: Type Description type description View Source def load_TAMSAT_data ( data , TAMSAT_path , date_start , duration ): \"\"\" This function loops over the rainfall raster files, and loads them into a xarray DataArray, which is then added to the rain data dictionary. It is tailored to the TAMSAT rainfall data files, hence its name. Args: data (_type_): _description_ TAMSAT_path (_type_): _description_ date_start (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" TAMSAT_files_df = build_rainfall_files_df ( TAMSAT_path , date_start , duration ) dataarray_full = None for i in range ( len ( TAMSAT_files_df )): dataarray = rioxarray . open_rasterio ( os . path . join ( TAMSAT_path , TAMSAT_files_df . loc [ i , \"filename\" ])) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" , \"spatial_ref\" ]) dataarray . attrs = {} dataarray_full = xr . concat ([ dataarray_full , dataarray ], \"time\" ) # try: # dataarray_full = xr.concat([dataarray_full, dataarray],\"time\") # except: # dataarray_full = dataarray dataarray_full . rio . write_crs ( 4326 , inplace = True ) data [ \"rain\" ] = dataarray_full data [ \"rain\" ] . attrs = { \"units\" : \"mm\" , \"long_name\" : \"rainfall\" } return data","title":"load_TAMSAT_data"},{"location":"reference/sarra_py/data_preparation/#load_yaml_parameters","text":"def load_YAML_parameters ( file_paramVariete , file_paramITK , file_paramTypeSol ) This function loads the parameters from the yaml files. It is a wrapper for the three functions above. Parameters: Name Type Description Default file_paramVariete type description None file_paramITK type description None file_paramTypeSol type description None Returns: Type Description type description View Source def load_YAML_parameters ( file_paramVariete , file_paramITK , file_paramTypeSol ): \"\"\" This function loads the parameters from the yaml files. It is a wrapper for the three functions above. Args: file_paramVariete (_type_): _description_ file_paramITK (_type_): _description_ file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" paramVariete = load_paramVariete ( file_paramVariete ) paramITK = load_paramITK ( file_paramITK ) paramTypeSol = load_paramTypeSol ( file_paramTypeSol ) if ~ np . isnan ( paramITK [ \"NI\" ]): print ( \"NI NON NULL\" ) paramVariete [ \"txConversion\" ] = paramVariete [ \"NIYo\" ] + paramVariete [ \"NIp\" ] * ( 1 - np . exp ( - paramVariete [ \"NIp\" ] * paramITK [ \"NI\" ])) - ( np . exp ( - 0.5 * (( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ]) * ( paramITK [ \"NI\" ] - paramVariete [ \"LGauss\" ]) / paramVariete [ \"AGauss\" ])) / ( paramVariete [ \"AGauss\" ] * 2.506628274631 ) return paramVariete , paramITK , paramTypeSol","title":"load_YAML_parameters"},{"location":"reference/sarra_py/data_preparation/#load_isda_soil_data","text":"def load_iSDA_soil_data ( data , grid_width , grid_height ) This function loads iSDA soil data and crop to the area of interest remark : it would be nice to try to modulate the percentage of runoff according to slope First, this function loads the iSDA soil data, crops it to the area of interest and resamples it to match the grid resolution. The iSDA soil class raster map obtained is passed to the xarray dataset as a new variable. For the sake of example, the file that is used here already has been downsampled at TAMSAT resolution. Its specs are available on the CIRAD Dataverse at the following adress : https://doi.org/10.1038/s41598-021-85639-y Second, a correspondance table matching the iSDA soil classes to the soil physical properties is loaded. Maps of soil physical properties are then created and added to the xarray dataset. Returns: Type Description type description View Source def load_iSDA_soil_data ( data , grid_width , grid_height ): \"\"\" This function loads iSDA soil data and crop to the area of interest remark : it would be nice to try to modulate the percentage of runoff according to slope First, this function loads the iSDA soil data, crops it to the area of interest and resamples it to match the grid resolution. The iSDA soil class raster map obtained is passed to the xarray dataset as a new variable. For the sake of example, the file that is used here already has been downsampled at TAMSAT resolution. Its specs are available on the CIRAD Dataverse at the following adress : https://doi.org/10.1038/s41598-021-85639-y Second, a correspondance table matching the iSDA soil classes to the soil physical properties is loaded. Maps of soil physical properties are then created and added to the xarray dataset. Returns: _type_: _description_ \"\"\" # load raster data soil_type_file_path = \"../data/assets/iSDA_at_TAMSAT_resolution_zeroclass_1E6.tif\" dataarray = rioxarray . open_rasterio ( soil_type_file_path ) # crop to the area of interest area = { 'burkina' : [ 16 , - 6 , 9 , 3 ], #lat,lon lat,lon } selected_area = \"burkina\" dataarray = dataarray . where (( dataarray . y < area [ selected_area ][ 0 ]) & ( dataarray . y > area [ selected_area ][ 2 ]) & ( dataarray . x > area [ selected_area ][ 1 ]) & ( dataarray . x < area [ selected_area ][ 3 ]) ) . dropna ( dim = 'y' , how = 'all' ) . dropna ( dim = 'x' , how = 'all' ) # resample to match the grid resolution dataarray = dataarray . rio . reproject_match ( data , nodata = np . nan ) dataarray = dataarray . squeeze ( \"band\" ) . drop_vars ([ \"band\" ]) dataarray . attrs = { \"units\" : \"arbitrary\" , \"long_name\" : \"soil_type\" } # add soil type identifier to the dataset data [ \"soil_type\" ] = dataarray data [ \"soil_type\" ] = data [ \"soil_type\" ] / 1000000 # conversion from 1E6 to 1E0 # load correspondance table path_soil_type_correspondance = \"../data/assets/TypeSol_Moy13_HWSD.csv\" df_soil_type_correspondance = pd . read_csv ( path_soil_type_correspondance , sep = \";\" , skiprows = 1 ) # correspondance between soil properties naming in the csv file and in the dataset soil_variables = { \"epaisseurProf\" : \"EpaisseurProf\" , \"epaisseurSurf\" : \"EpaisseurSurf\" , \"stockIniProf\" : \"StockIniProf\" , \"stockIniSurf\" : \"StockIniSurf\" , \"seuilRuiss\" : \"SeuilRuiss\" , \"pourcRuiss\" : \"PourcRuiss\" , \"ru\" : \"Ru\" , } # create maps of soil properties and add them to the dataset for soil_variable in soil_variables : dict_values = dict ( zip ( df_soil_type_correspondance [ \"Id\" ], df_soil_type_correspondance [ soil_variables [ soil_variable ]])) dict_values [ 0 ] = np . nan soil_types_converted = np . reshape ([ dict_values [ x . astype ( int )] for x in data [ \"soil_type\" ] . to_numpy () . flatten ()], ( grid_width , grid_height )) data [ soil_variable ] = ( data [ \"soil_type\" ] . dims , soil_types_converted ) # TODO: add dataarray.attrs = {} to precise units and long_name # converting pourcRuiss to decimal % data [ \"pourcRuiss\" ] = data [ \"pourcRuiss\" ] / 100 return data","title":"load_iSDA_soil_data"},{"location":"reference/sarra_py/data_preparation/#load_paramitk","text":"def load_paramITK ( file_paramITK ) This function loads the ITK parameters from the yaml file. Parameters: Name Type Description Default file_paramITK type description None Returns: Type Description type description View Source def load_paramITK ( file_paramITK ): \"\"\" This function loads the ITK parameters from the yaml file. Args: file_paramITK (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/itk/' , file_paramITK ), 'r' ) as stream : paramITK = yaml . safe_load ( stream ) paramITK [ \"DateSemis\" ] = datetime . datetime . strptime ( paramITK [ \"DateSemis\" ], \"%Y-%m- %d \" ) . date () return paramITK","title":"load_paramITK"},{"location":"reference/sarra_py/data_preparation/#load_paramtypesol","text":"def load_paramTypeSol ( file_paramTypeSol ) This function loads the soil parameters from the yaml file. Parameters: Name Type Description Default file_paramTypeSol type description None Returns: Type Description type description View Source def load_paramTypeSol ( file_paramTypeSol ): \"\"\" This function loads the soil parameters from the yaml file. Args: file_paramTypeSol (_type_): _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/soil/' , file_paramTypeSol ), 'r' ) as stream : paramTypeSol = yaml . safe_load ( stream ) return paramTypeSol","title":"load_paramTypeSol"},{"location":"reference/sarra_py/data_preparation/#load_paramvariete","text":"def load_paramVariete ( file_paramVariete ) This function loads the parameters of the variety from the yaml file. Parameters: Name Type Description Default file_paramVariete type description None Returns: Type Description type description Raises: Type Description exception description View Source def load_paramVariete ( file_paramVariete ) : \"\"\" This function loads the parameters of the variety from the yaml file. Args: file_paramVariete (_type_): _description_ Raises: exception: _description_ Returns: _type_: _description_ \"\"\" with open ( os . path . join ( '../data/params/variety/' , file_paramVariete ), 'r' ) as stream : paramVariete = yaml . safe_load ( stream ) if paramVariete [ \"feuilAeroBase\" ] == 0.1 : raise Exception () return paramVariete","title":"load_paramVariete"},{"location":"reference/sarra_py/models/","text":"Module sarra_py.models View Source from .bilan_pheno import * from .bilan_carbo import * from .bilan_hydro import * from .data_preparation import * from tqdm import tqdm as tqdm def run_model ( paramVariete , paramITK , paramTypeSol , data , duration ): \"\"\" This is the functions list adapted from the procedures of the SARRA-H v42 model. Args: paramVariete (_type_): _description_ paramITK (_type_): _description_ paramTypeSol (_type_): _description_ data (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" for j in tqdm ( range ( duration )): # calculating daily thermal time, independently of sowing date data = calculate_daily_thermal_time ( j , data , paramVariete ) # updating phenological stages data = EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ) # sum of thermal sime is being computed from the day the crop is sown, including the day of sowing data = calculate_sum_of_thermal_time ( j , data , paramVariete ) # water balance # evalIrrigPhase sp&cifique de l'irrigation automatique, on peut presque le conditionner au irrigAuto==True data = EvalIrrigPhase ( j , data , paramITK ) # sums rainfall and irrigation history data = calculate_total_water_availability ( j , data ) # can be conditioned to the presence of mulch data = RempliMc ( j , data , paramITK ) data = EvalRunOff ( j , data , paramTypeSol ) data = EvolRurCstr2 ( j , data , paramITK ) # computation of filling of the tanks is done after other computations related to water, # as we consider filling is taken into consideration at the end of the day data = rempliRes ( j , data ) # transpiration # estimation of the fraction of evaporable soil water (fesw) data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) # water consumption data = ConsoResSep ( j , data ) # ***bileau***; exmodules 1 & 2 # trad O # # phenologie data = update_root_growth_speed ( j , data , paramVariete ) # # bilan carbone data = estimate_ltr ( j , data , paramVariete ) data = estimate_KAssim ( j , data , paramVariete ) data = estimate_conv ( j , data , paramVariete ) # adjusting for sowing densit\u00e9, in data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"in\" ) # ***bilancarbonsarra*** # trad OK data = update_assimPot ( j , data , paramVariete , paramITK ) data = update_assim ( j , data ) data = calculate_maintainance_respiration ( j , data , paramVariete ) data = update_total_biomass ( j , data , paramVariete , paramITK ) data = update_total_biomass_stade_ip ( j , data ) data = update_total_biomass_at_flowering_stage ( j , data ) data = update_potential_yield ( j , data , paramVariete ) data = update_potential_yield_delta ( j , data , paramVariete ) data = update_aboveground_biomass ( j , data , paramVariete ) data = estimate_reallocation ( j , data , paramVariete ) data = update_root_biomass ( j , data ) data = EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) data = update_vegetative_biomass ( j , data ) data = calculate_canopy_specific_leaf_area ( j , data , paramVariete ) data = calculate_leaf_area_index ( j , data ) data = update_yield_during_filling_phase ( j , data ) #phenologie data = update_photoperiodism ( j , data , paramVariete ) # # bilan carbone data = MortaliteSarraV3 ( j , data , paramITK , paramVariete ) data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"out\" ) # data = BiomMcUBTSV3(j, data, paramITK) # ***bilancarbonsarra***, exmodules 2 # data = MAJBiomMcSV3(data) # ***bilancarbonsarra***, exmodules 2 data = estimate_critical_nitrogen_concentration ( j , data ) return data Functions run_model def run_model ( paramVariete , paramITK , paramTypeSol , data , duration ) This is the functions list adapted from the procedures of the SARRA-H v42 model. Parameters: Name Type Description Default paramVariete type description None paramITK type description None paramTypeSol type description None data type description None duration type description None Returns: Type Description type description View Source def run_model ( paramVariete , paramITK , paramTypeSol , data , duration ): \"\"\" This is the functions list adapted from the procedures of the SARRA-H v42 model. Args: paramVariete (_type_): _description_ paramITK (_type_): _description_ paramTypeSol (_type_): _description_ data (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" for j in tqdm ( range ( duration )): # calculating daily thermal time , independently of sowing date data = calculate_daily_thermal_time ( j , data , paramVariete ) # updating phenological stages data = EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ) # sum of thermal sime is being computed from the day the crop is sown , including the day of sowing data = calculate_sum_of_thermal_time ( j , data , paramVariete ) # water balance # evalIrrigPhase sp & cifique de l ' irrigation automatique , on peut presque le conditionner au irrigAuto == True data = EvalIrrigPhase ( j , data , paramITK ) # sums rainfall and irrigation history data = calculate_total_water_availability ( j , data ) # can be conditioned to the presence of mulch data = RempliMc ( j , data , paramITK ) data = EvalRunOff ( j , data , paramTypeSol ) data = EvolRurCstr2 ( j , data , paramITK ) # computation of filling of the tanks is done after other computations related to water , # as we consider filling is taken into consideration at the end of the day data = rempliRes ( j , data ) # transpiration # estimation of the fraction of evaporable soil water ( fesw ) data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) # water consumption data = ConsoResSep ( j , data ) # *** bileau ***; exmodules 1 & 2 # trad O # # phenologie data = update_root_growth_speed ( j , data , paramVariete ) # # bilan carbone data = estimate_ltr ( j , data , paramVariete ) data = estimate_KAssim ( j , data , paramVariete ) data = estimate_conv ( j , data , paramVariete ) # adjusting for sowing densit\u00e9 , in data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"in\" ) # *** bilancarbonsarra *** # trad OK data = update_assimPot ( j , data , paramVariete , paramITK ) data = update_assim ( j , data ) data = calculate_maintainance_respiration ( j , data , paramVariete ) data = update_total_biomass ( j , data , paramVariete , paramITK ) data = update_total_biomass_stade_ip ( j , data ) data = update_total_biomass_at_flowering_stage ( j , data ) data = update_potential_yield ( j , data , paramVariete ) data = update_potential_yield_delta ( j , data , paramVariete ) data = update_aboveground_biomass ( j , data , paramVariete ) data = estimate_reallocation ( j , data , paramVariete ) data = update_root_biomass ( j , data ) data = EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) data = update_vegetative_biomass ( j , data ) data = calculate_canopy_specific_leaf_area ( j , data , paramVariete ) data = calculate_leaf_area_index ( j , data ) data = update_yield_during_filling_phase ( j , data ) # phenologie data = update_photoperiodism ( j , data , paramVariete ) # # bilan carbone data = MortaliteSarraV3 ( j , data , paramITK , paramVariete ) data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"out\" ) # data = BiomMcUBTSV3 ( j , data , paramITK ) # *** bilancarbonsarra ***, exmodules 2 # data = MAJBiomMcSV3 ( data ) # *** bilancarbonsarra ***, exmodules 2 data = estimate_critical_nitrogen_concentration ( j , data ) return data","title":"Models"},{"location":"reference/sarra_py/models/#module-sarra_pymodels","text":"View Source from .bilan_pheno import * from .bilan_carbo import * from .bilan_hydro import * from .data_preparation import * from tqdm import tqdm as tqdm def run_model ( paramVariete , paramITK , paramTypeSol , data , duration ): \"\"\" This is the functions list adapted from the procedures of the SARRA-H v42 model. Args: paramVariete (_type_): _description_ paramITK (_type_): _description_ paramTypeSol (_type_): _description_ data (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" for j in tqdm ( range ( duration )): # calculating daily thermal time, independently of sowing date data = calculate_daily_thermal_time ( j , data , paramVariete ) # updating phenological stages data = EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ) # sum of thermal sime is being computed from the day the crop is sown, including the day of sowing data = calculate_sum_of_thermal_time ( j , data , paramVariete ) # water balance # evalIrrigPhase sp&cifique de l'irrigation automatique, on peut presque le conditionner au irrigAuto==True data = EvalIrrigPhase ( j , data , paramITK ) # sums rainfall and irrigation history data = calculate_total_water_availability ( j , data ) # can be conditioned to the presence of mulch data = RempliMc ( j , data , paramITK ) data = EvalRunOff ( j , data , paramTypeSol ) data = EvolRurCstr2 ( j , data , paramITK ) # computation of filling of the tanks is done after other computations related to water, # as we consider filling is taken into consideration at the end of the day data = rempliRes ( j , data ) # transpiration # estimation of the fraction of evaporable soil water (fesw) data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) # water consumption data = ConsoResSep ( j , data ) # ***bileau***; exmodules 1 & 2 # trad O # # phenologie data = update_root_growth_speed ( j , data , paramVariete ) # # bilan carbone data = estimate_ltr ( j , data , paramVariete ) data = estimate_KAssim ( j , data , paramVariete ) data = estimate_conv ( j , data , paramVariete ) # adjusting for sowing densit\u00e9, in data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"in\" ) # ***bilancarbonsarra*** # trad OK data = update_assimPot ( j , data , paramVariete , paramITK ) data = update_assim ( j , data ) data = calculate_maintainance_respiration ( j , data , paramVariete ) data = update_total_biomass ( j , data , paramVariete , paramITK ) data = update_total_biomass_stade_ip ( j , data ) data = update_total_biomass_at_flowering_stage ( j , data ) data = update_potential_yield ( j , data , paramVariete ) data = update_potential_yield_delta ( j , data , paramVariete ) data = update_aboveground_biomass ( j , data , paramVariete ) data = estimate_reallocation ( j , data , paramVariete ) data = update_root_biomass ( j , data ) data = EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) data = update_vegetative_biomass ( j , data ) data = calculate_canopy_specific_leaf_area ( j , data , paramVariete ) data = calculate_leaf_area_index ( j , data ) data = update_yield_during_filling_phase ( j , data ) #phenologie data = update_photoperiodism ( j , data , paramVariete ) # # bilan carbone data = MortaliteSarraV3 ( j , data , paramITK , paramVariete ) data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"out\" ) # data = BiomMcUBTSV3(j, data, paramITK) # ***bilancarbonsarra***, exmodules 2 # data = MAJBiomMcSV3(data) # ***bilancarbonsarra***, exmodules 2 data = estimate_critical_nitrogen_concentration ( j , data ) return data","title":"Module sarra_py.models"},{"location":"reference/sarra_py/models/#functions","text":"","title":"Functions"},{"location":"reference/sarra_py/models/#run_model","text":"def run_model ( paramVariete , paramITK , paramTypeSol , data , duration ) This is the functions list adapted from the procedures of the SARRA-H v42 model. Parameters: Name Type Description Default paramVariete type description None paramITK type description None paramTypeSol type description None data type description None duration type description None Returns: Type Description type description View Source def run_model ( paramVariete , paramITK , paramTypeSol , data , duration ): \"\"\" This is the functions list adapted from the procedures of the SARRA-H v42 model. Args: paramVariete (_type_): _description_ paramITK (_type_): _description_ paramTypeSol (_type_): _description_ data (_type_): _description_ duration (_type_): _description_ Returns: _type_: _description_ \"\"\" for j in tqdm ( range ( duration )): # calculating daily thermal time , independently of sowing date data = calculate_daily_thermal_time ( j , data , paramVariete ) # updating phenological stages data = EvalPhenoSarrahV3 ( j , data , paramITK , paramVariete ) # sum of thermal sime is being computed from the day the crop is sown , including the day of sowing data = calculate_sum_of_thermal_time ( j , data , paramVariete ) # water balance # evalIrrigPhase sp & cifique de l ' irrigation automatique , on peut presque le conditionner au irrigAuto == True data = EvalIrrigPhase ( j , data , paramITK ) # sums rainfall and irrigation history data = calculate_total_water_availability ( j , data ) # can be conditioned to the presence of mulch data = RempliMc ( j , data , paramITK ) data = EvalRunOff ( j , data , paramTypeSol ) data = EvolRurCstr2 ( j , data , paramITK ) # computation of filling of the tanks is done after other computations related to water , # as we consider filling is taken into consideration at the end of the day data = rempliRes ( j , data ) # transpiration # estimation of the fraction of evaporable soil water ( fesw ) data = estimate_fesw ( j , data ) data = estimate_kce ( j , data , paramITK ) data = estimate_soil_potential_evaporation ( j , data ) data = estimate_soil_evaporation ( j , data ) data = estimate_FEMcW_and_update_mulch_water_stock ( j , data , paramITK ) data = estimate_ftsw ( j , data ) data = estimate_kcp ( j , data , paramVariete ) data = estimate_potential_plant_transpiration ( j , data ) data = estimate_kcTot ( j , data ) data = estimate_pFact ( j , data , paramVariete ) data = estimate_cstr ( j , data ) data = estimate_plant_transpiration ( j , data ) # water consumption data = ConsoResSep ( j , data ) # *** bileau ***; exmodules 1 & 2 # trad O # # phenologie data = update_root_growth_speed ( j , data , paramVariete ) # # bilan carbone data = estimate_ltr ( j , data , paramVariete ) data = estimate_KAssim ( j , data , paramVariete ) data = estimate_conv ( j , data , paramVariete ) # adjusting for sowing densit\u00e9 , in data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"in\" ) # *** bilancarbonsarra *** # trad OK data = update_assimPot ( j , data , paramVariete , paramITK ) data = update_assim ( j , data ) data = calculate_maintainance_respiration ( j , data , paramVariete ) data = update_total_biomass ( j , data , paramVariete , paramITK ) data = update_total_biomass_stade_ip ( j , data ) data = update_total_biomass_at_flowering_stage ( j , data ) data = update_potential_yield ( j , data , paramVariete ) data = update_potential_yield_delta ( j , data , paramVariete ) data = update_aboveground_biomass ( j , data , paramVariete ) data = estimate_reallocation ( j , data , paramVariete ) data = update_root_biomass ( j , data ) data = EvalFeuilleTigeSarrahV4 ( j , data , paramVariete ) data = update_vegetative_biomass ( j , data ) data = calculate_canopy_specific_leaf_area ( j , data , paramVariete ) data = calculate_leaf_area_index ( j , data ) data = update_yield_during_filling_phase ( j , data ) # phenologie data = update_photoperiodism ( j , data , paramVariete ) # # bilan carbone data = MortaliteSarraV3 ( j , data , paramITK , paramVariete ) data = adjust_for_sowing_density ( j , data , paramVariete , direction = \"out\" ) # data = BiomMcUBTSV3 ( j , data , paramITK ) # *** bilancarbonsarra ***, exmodules 2 # data = MAJBiomMcSV3 ( data ) # *** bilancarbonsarra ***, exmodules 2 data = estimate_critical_nitrogen_concentration ( j , data ) return data","title":"run_model"}]}