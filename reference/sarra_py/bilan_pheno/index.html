<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Bilan Pheno - SARRA-Py</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Bilan Pheno";
        var mkdocs_page_input_path = "reference/sarra_py/bilan_pheno.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> SARRA-Py
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../docs/model_formalisms/">Model formalisms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../docs/spatialization_strategy/">Spatialization strategy</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorial</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../docs/tutorial/00_-_Running_a_simulation/">00 - Running a simulation</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Sarra Py</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../bilan_carbo/">Bilan Carbo</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../bilan_hydro/">Bilan Hydro</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Bilan Pheno</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#evalphenosarrahv3">EvalPhenoSarrahV3</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#mortalitesarrav3">MortaliteSarraV3</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#calculate_daily_thermal_time">calculate_daily_thermal_time</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../comparison_tools_old/">Comparison Tools Old</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../data_preparation/">Data Preparation</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../">Index</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../models/">Models</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">SARRA-Py</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Reference &raquo;</li>
          <li>Sarra Py &raquo;</li>
      <li>Bilan Pheno</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/SARRA-cropmodels/SARRA-Py/edit/main/reference/sarra_py/bilan_pheno.md"> Edit on SARRA-Py</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="module-sarra_pybilan_pheno">Module sarra_py.bilan_pheno</h1>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

<span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="kp">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

  <span class="c1"># when reaching stage 7, we reset the main phenological variables to zero</span>

  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span>

  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span>

  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ruRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span>

  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbJourCompte&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span>

  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;startLock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;startLock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span>

  <span class="c1"># and we leave numPhas last</span>

  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span>

  <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">testing_for_initialization</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function tests if the conditions are met to initiate the crop.</span>

<span class="sd">    If numPhase is 0, if the current day is equal or above the sowing date, and</span>

<span class="sd">    if surface_tank_stock is above the threshold for sowing, we initiate the</span>

<span class="sd">    crop :</span>

<span class="sd">    1) we set numPhase to 1 ; we broadcast the value over remaining days.</span>

<span class="sd">    2) we set changePhase of this particular day to 1.</span>

<span class="sd">    3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to</span>

<span class="sd">       be SDJLevee ; we broadcast the value over remaining days.</span>

<span class="sd">    4) we set initPhase to 1 ; we broadcast the value over remaining days.</span>

<span class="sd">    initPhase is only used in update_pheno_phase_1_to_2 function, so that we do</span>

<span class="sd">    not go directly from phase 0 to phase 2. It is used as a specific flag for</span>

<span class="sd">    phase 0 to 1 transition.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! replacing stRuSurf by surface_tank_stock</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sowing_date&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;seuilEauSemis&quot;</span><span class="p">])</span>

        <span class="c1"># &amp; (data[&quot;startLock&quot;][j,:,:] == 0)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJLevee&quot;</span><span class="p">],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>

    <span class="p">)</span>

    <span class="c1">#flagging phase change has been done</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;initPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;initPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function flags the day for phase change.</span>

<span class="sd">    If the phase number is above the num_phase value, and if the sum of thermal</span>

<span class="sd">    time is above the threshold, this function returns changePhase flags.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        num_phase (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># flagging the day for phase change</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">num_phase</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">,</span> <span class="n">thermal_time_threshold</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the sum of thermal time needed to reach the next</span>

<span class="sd">    phase.</span>

<span class="sd">    When numPhase equals the requested phase number, and if changePhase is 1</span>

<span class="sd">    (meaning that we are at a phase transition day), the seuilTempPhaseSuivante</span>

<span class="sd">    is incremented by the thermal_time_threshold value. This value is</span>

<span class="sd">    stage-specific :</span>

<span class="sd">    - 1 to 2 : SDJLevee</span>

<span class="sd">    - 2 to 3 : SDJBVP</span>

<span class="sd">    - 4 to 5 : SDJRPR</span>

<span class="sd">    - 5 to 6 : SDJMatu1</span>

<span class="sd">    - 6 to 7 : SDJMatu2</span>

<span class="sd">    These parameters are passed explicitly when calling this function.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        num_phase (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">num_phase</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">thermal_time_threshold</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function increments the phase number.</span>

<span class="sd">    When the phase number is not 0, and if changePhase is 1 (meaning that we are</span>

<span class="sd">    at a phase transition day), and initPhase is 0 (meaning that the phase</span>

<span class="sd">    number has not been incremented yet this day), the phase number is</span>

<span class="sd">    incremented by 1. Also, the phase change flag initPhase is set to 1.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;initPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># incrementing phase number</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="c1"># flagging this day as having been incremented</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;initPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;initPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function stores the present thermal time threshold in the</span>

<span class="sd">    seuilTempPhasePrec variable.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        num_phase (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">num_phase</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhasePrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhasePrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_pheno_phase_1_to_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 1 to 2.</span>

<span class="sd">    First, it flags the day for phase change : If numPhase is 1 and sum of</span>

<span class="sd">    thermal time is above the threshold (which value comes here from the</span>

<span class="sd">    previous function testing_for_initialization), we set changePhase of this</span>

<span class="sd">    particular day to 1.</span>

<span class="sd">    Second, we update the thermal time to next phase : if numPhase is 1 and</span>

<span class="sd">    changePhase is 1 (meaning that we are at the transition day between phases 1</span>

<span class="sd">    and 2), we set the sum of thermal time to the next phase as SDJLevee ; we</span>

<span class="sd">    broadcast the value over remaining days.</span>

<span class="sd">    We do it before updating phase number because we need to test what is the</span>

<span class="sd">    phase number before updating it</span>

<span class="sd">    Third, we update the phase number : if numPhase is different from 0 and</span>

<span class="sd">    changePhase is 1 (meaning that we are at the transition day between two</span>

<span class="sd">    phases, to the exception of transition day between phases 0 and 1), we</span>

<span class="sd">    increment numPhase by 1 ; we broadcast the value over remaining days.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_phase</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">thermal_time_threshold</span> <span class="o">=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJLevee&quot;</span><span class="p">]</span>

    <span class="c1"># flagging the day for phase change</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># updating thermal time to next phase</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">,</span> <span class="n">thermal_time_threshold</span><span class="p">)</span>

    <span class="c1"># updating phase number and flagging incrementation</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_pheno_phase_2_to_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 2 to 3.</span>

<span class="sd">    It has the same structure as update_pheno_phase_1_to_2, with the exception</span>

<span class="sd">    of update_thermal_time_previous_phase function, which is called to store the</span>

<span class="sd">    present thermal time threshold in the seuilTempPhasePrec variable.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_phase</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">thermal_time_threshold</span> <span class="o">=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJBVP&quot;</span><span class="p">]</span>

    <span class="c1"># flagging the day for phase change</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># saving &quot;previous thermal time to next phase&quot; to be used</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># updating thermal time to next phase</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">,</span> <span class="n">thermal_time_threshold</span><span class="p">)</span>

    <span class="c1"># updating phase number and flagging incrementation</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_pheno_phase_3_to_4</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 3 to 4.</span>

<span class="sd">    It is specific as phase 3 is photoperiodic ; its length is not computed the</span>

<span class="sd">    same way as the other phases. Notably, the phasePhotoper flag is updated</span>

<span class="sd">    with the PhotoperSarrahV3() function.</span>

<span class="sd">    First, this function flags the day for phase change : If numPhase is 3 and</span>

<span class="sd">    the phasePhotoper flag is 0, we set changePhase of this particular day to 1.</span>

<span class="sd">    This means the photoperiodic phase is over.</span>

<span class="sd">    Second, we update the phasePhotoper flag : if numPhase is 3 and changePhase</span>

<span class="sd">    is 1 (meaning that we are at the transition day between phases 3 and 4), we</span>

<span class="sd">    set the phasePhotoper flag to 1.</span>

<span class="sd">    Third, we update the phase number and flag incrementation using</span>

<span class="sd">    increment_phase_number().</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># flagging the day for phase change (specific to phase 3)</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="c1"># updating phasePhotoper (specific to phase 3)</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="c1"># updating phase number and flagging incrementation</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_pheno_phase_4_to_5</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 4 to 5.</span>

<span class="sd">    It has the same structure as update_pheno_phase_2_to_3.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_phase</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="n">thermal_time_threshold</span> <span class="o">=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJRPR&quot;</span><span class="p">]</span>

    <span class="c1"># flagging the day for phase change</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># saving &quot;previous thermal time to next phase&quot; to be used</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># updating thermal time to next phase</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">,</span> <span class="n">thermal_time_threshold</span><span class="p">)</span>

    <span class="c1"># updating phase number and flagging incrementation</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_pheno_phase_5_to_6</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 5 to 6.</span>

<span class="sd">    It has the same structure as update_pheno_phase_2_to_3.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_phase</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">thermal_time_threshold</span> <span class="o">=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJMatu1&quot;</span><span class="p">]</span>

    <span class="c1"># flagging the day for phase change</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># saving &quot;previous thermal time to next phase&quot; to be used</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># updating thermal time to next phase</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">,</span> <span class="n">thermal_time_threshold</span><span class="p">)</span>

    <span class="c1"># updating phase number and flagging incrementation</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_pheno_phase_6_to_7</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 6 to 7.</span>

<span class="sd">    It has the same structure as update_pheno_phase_2_to_3.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_phase</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="n">thermal_time_threshold</span> <span class="o">=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJMatu2&quot;</span><span class="p">]</span>

    <span class="c1"># flagging the day for phase change</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># saving &quot;previous thermal time to next phase&quot; to be used</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">)</span>

    <span class="c1"># updating thermal time to next phase</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num_phase</span><span class="p">,</span> <span class="n">thermal_time_threshold</span><span class="p">)</span>

    <span class="c1"># updating phase number and flagging incrementation</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">EvalPhenoSarrahV3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages the evolution of the phenological phases. It is a</span>

<span class="sd">    wrapper function that calls the specific functions for each phase.</span>

<span class="sd">    This function is called at the beginning of the day and makes the</span>

<span class="sd">    phenological phases evolve. For this, it increments the phase number and</span>

<span class="sd">    changes the value of the thermal time threshold of the next phase.</span>

<span class="sd">    ChangePhase is a boolean informing the model to know if a day is a day of</span>

<span class="sd">    phase change, which is used to initialize specific variables in certain</span>

<span class="sd">    functions. It includes a generic method for the test of the end of the</span>

<span class="sd">    photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase</span>

<span class="sd">    and = 1 at the beginning of the phase.</span>

<span class="sd">    Phenological phases used in this model (as for cereal crops) :</span>

<span class="sd">    0. from the sowing day to the beginning of the conditions favorable for</span>

<span class="sd">       germination, and from the harvest to the end of the simulation (no crop)</span>

<span class="sd">    1. from the beginning of the conditions favorable for germination to the day</span>

<span class="sd">       of germination (du dbut des conditions favorables pour la germination au</span>

<span class="sd">       jour de la leve)</span>

<span class="sd">    2. from the day of germination to the beginning of the photoperiodic phase</span>

<span class="sd">       (du jour de la leve au dbut de la phase photopriodique)</span>

<span class="sd">    3. from the beginning of the photoperiodic phase to the beginning of the</span>

<span class="sd">       reproductive phase</span>

<span class="sd">    4. from the beginning of the reproductive phase to the beginning of the</span>

<span class="sd">       maturation (only for maize and rice)</span>

<span class="sd">    5. from the beginning of the maturation to the grain milk stage (du dbut de</span>

<span class="sd">       la maturation au stade grain laiteux)</span>

<span class="sd">    6. from the grain milk stage to the end of the maturation (du dbut du stade</span>

<span class="sd">       grain laiteux au jour de rcolte)</span>

<span class="sd">    7. the day of the harvest</span>

<span class="sd">    Notes :</span>

<span class="sd">    In the case of multiannual continuous simulations, we do not reinitialize</span>

<span class="sd">    the reservoirs, at harvest we put the moisture front at the depth of the</span>

<span class="sd">    surface reservoir This allows to keep the rooting constraint phenomenon for</span>

<span class="sd">    the following season if there is little rain while having the water stock in</span>

<span class="sd">    depth remaining from the previous season.</span>

<span class="sd">    This function has been originally translated from the EvalPhenoSarrahV3</span>

<span class="sd">    procedure of the phenologie.pas and exmodules.pas files of the Sarra-H</span>

<span class="sd">    model, Pascal version.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">testing_for_initialization</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_pheno_phase_1_to_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_pheno_phase_2_to_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_pheno_phase_3_to_4</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_pheno_phase_4_to_5</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_pheno_phase_5_to_6</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_pheno_phase_6_to_7</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">calculate_daily_thermal_time</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;calculating daily thermal time</span>

<span class="sd">    Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version.</span>

<span class="sd">    Pb de mthode !?</span>

<span class="sd">    v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase);</span>

<span class="sd">    v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2);</span>

<span class="sd">    v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin);</span>

<span class="sd">    DegresDuJour:= v * (TOpt1-TBase);</span>

<span class="sd">    #   If Tmoy &lt;= Topt2 then</span>

<span class="sd">    #      DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase</span>

<span class="sd">    #   else</span>

<span class="sd">    #      DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2)));</span>

<span class="sd">    #    If (Numphase &gt;=1) then</span>

<span class="sd">    #         SomDegresJour := SomDegresJour + DegresDuJour</span>

<span class="sd">    #    else SomDegresJour := 0;</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ddj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tpMoy&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TOpt2&quot;</span><span class="p">],</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TOpt1&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tpMoy&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]),</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TBase&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TBase&quot;</span><span class="p">],</span>

        <span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TOpt1&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TBase&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TLim&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tpMoy&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">-</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TOpt2&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TLim&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;TOpt2&quot;</span><span class="p">]))),</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">calculate_sum_of_thermal_time</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version.</span>

<span class="sd">    calculating sum of thermal time</span>

<span class="sd">sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly</span>

<span class="sd">    Note : in SARRA-H, when numPhase &gt; 7, sdj is set to 0 and sdj stops cumulating</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sowing_date&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ddj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="mi">0</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_root_growth_speed</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the root growth speed (vRac, mm/day) according to the</span>

<span class="sd">    current phase (numPhase).</span>

<span class="sd">    This function has been adapted from the EvalVitesseRacSarraV3 procedure of</span>

<span class="sd">    the phenologie.pas and exmodules 1 &amp; 2.pas files of the Sarra-H model,</span>

<span class="sd">    Pascal version.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">phase_correspondances</span> <span class="o">=</span> <span class="p">{</span>

        <span class="mi">1</span><span class="p">:</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s1">&#39;VRacLevee&#39;</span><span class="p">],</span>

        <span class="mi">2</span><span class="p">:</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s1">&#39;VRacBVP&#39;</span><span class="p">],</span>

        <span class="mi">3</span><span class="p">:</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s1">&#39;VRacPSP&#39;</span><span class="p">],</span>

        <span class="mi">4</span><span class="p">:</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s1">&#39;VRacRPR&#39;</span><span class="p">],</span>

        <span class="mi">5</span><span class="p">:</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s1">&#39;VRacMatu1&#39;</span><span class="p">],</span>

        <span class="mi">6</span><span class="p">:</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s1">&#39;VRacMatu2&#39;</span><span class="p">],</span>

    <span class="p">}</span>

    <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">phase</span><span class="p">,</span>

            <span class="n">phase_correspondances</span><span class="p">[</span><span class="n">phase</span><span class="p">],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="p">)</span>

    <span class="c1"># phase 0 ou 7</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">),</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_photoperiodism</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function aims at managing the photoperiodic sensitivity of the crop.</span>

<span class="sd">    It first updates the sumPP variable : on the transition day between phase 2</span>

<span class="sd">    and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100.</span>

<span class="sd">    Then, we compute the thermal_time_since_previous_phase (thermal time since</span>

<span class="sd">    the transition between phases 2 and 3), and the</span>

<span class="sd">    time_above_critical_day_length, which is the difference between day length</span>

<span class="sd">    and critical day length PPcrit, in decimal hours.</span>

<span class="sd">    On all days with numPhase = 3 (so including the transition day), the sumPP</span>

<span class="sd">    is calculated as a function of thermal_time_since_previous_phase and PPExp</span>

<span class="sd">    (attenuator for progressive PSP response to PP ; rarely used in calibration</span>

<span class="sd">    procedure, a robust value is 0.17), multiplied by a ratio between the daily</span>

<span class="sd">    time above critical day length and the difference between SeuilPP (Upper day</span>

<span class="sd">    length limit of PP response) and PPCrit (Lower day length limit to PP</span>

<span class="sd">    response).</span>

<span class="sd">    Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than</span>

<span class="sd">    PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range</span>

<span class="sd">    0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to</span>

<span class="sd">    1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model)</span>

<span class="sd">    This function has been adapted from the PhotoperSarrahV3 procedure of the</span>

<span class="sd">    phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version.</span>

<span class="sd">    Notes CB :</span>

<span class="sd">    Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite</span>

<span class="sd">    photoperiodique et pour les varietes non photoperiodique. PPsens varie de</span>

<span class="sd">    0,4 a 1,2. Pour PPsens &gt; 2.5 = varit non photoperiodique.</span>

<span class="sd">    SeuilPP = 13.5</span>

<span class="sd">    PPcrit = 12</span>

<span class="sd">    SumPP est dans ce cas une variable quotidienne (et non un cumul)</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thermal_time_since_previous_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhasePrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="n">time_above_critical_day_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dureeDuJour&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPCrit&quot;</span><span class="p">])</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sumPP&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>

            <span class="c1"># if numPhase = 3 and changePhase == 1, sumPP = 100</span>

            <span class="mi">100</span><span class="p">,</span>

            <span class="c1"># if numPhase = 3 and changePhase != 1, sumPP calculated through formula</span>

            <span class="p">((</span><span class="mi">1000</span> <span class="o">/</span> <span class="n">thermal_time_since_previous_phase</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPExp&quot;</span><span class="p">]))</span> \

                <span class="o">*</span> <span class="n">time_above_critical_day_length</span> <span class="o">/</span> <span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SeuilPP&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPCrit&quot;</span><span class="p">]),</span>

        <span class="p">),</span>

        <span class="c1"># if numPhase != 3, sumPP is not updated</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;sumPP&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sumPP&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPsens&quot;</span><span class="p">]),</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">MortaliteSarraV3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This functions tests for death of young plants.</span>

<span class="sd">    First, for numphase = 2 and changePhase = 1, hence at the transition day</span>

<span class="sd">    between phase 1 and 2 at this point of the loop, the nbJourCompte and</span>

<span class="sd">    nbjStress variables are set to 0.</span>

<span class="sd">    Second, for numPhase equal or above 2, on each day nbJourCompte is</span>

<span class="sd">    incremented by 1. Thus this part just count days since emergence.</span>

<span class="sd">    Third, for numPhase equal or above 2, for days where nbJourCompte is lower</span>

<span class="sd">    than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress</span>

<span class="sd">    variable is incremented by 1. Thus, we count the number of days with</span>

<span class="sd">    negative deltaBiomasseAerienne since emergence as stress days.</span>

<span class="sd">    Finally, for days where nbjStress is equal or higher than</span>

<span class="sd">    seuilCstrMortality, the crop is reset by setting numPhase,</span>

<span class="sd">    root_tank_capacity and nbjStress to 0.</span>

<span class="sd">    This all seems a bit simplistic though, and can be improved.</span>

<span class="sd">    This function has been adapted from the MortaliteSarraV3 procedure of the</span>

<span class="sd">    bilancarbonsarra.pas and exmodules 1 &amp; 2.pas codes of the Sarra-H model,</span>

<span class="sd">    Pascal version.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbjStress&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbjStress&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbJourCompte&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;</span> <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;nbjTestSemis&quot;</span><span class="p">])</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;deltaBiomasseAerienne&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;seuilCstrMortality&quot;</span><span class="p">])</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="c1">#! renaming stRurMax with root_tank_capacity</span>

    <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>
</code></pre></div>

</details>
<h2 id="functions">Functions</h2>
<h3 id="evalphenosarrahv3">EvalPhenoSarrahV3</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">EvalPhenoSarrahV3</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages the evolution of the phenological phases. It is a</p>
<p>wrapper function that calls the specific functions for each phase.</p>
<p>This function is called at the beginning of the day and makes the
phenological phases evolve. For this, it increments the phase number and
changes the value of the thermal time threshold of the next phase.
ChangePhase is a boolean informing the model to know if a day is a day of
phase change, which is used to initialize specific variables in certain
functions. It includes a generic method for the test of the end of the
photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase
and = 1 at the beginning of the phase.</p>
<p>Phenological phases used in this model (as for cereal crops) :</p>
<ol>
<li>
<p>from the sowing day to the beginning of the conditions favorable for
   germination, and from the harvest to the end of the simulation (no crop)</p>
</li>
<li>
<p>from the beginning of the conditions favorable for germination to the day
   of germination (du dbut des conditions favorables pour la germination au
   jour de la leve)</p>
</li>
<li>
<p>from the day of germination to the beginning of the photoperiodic phase
   (du jour de la leve au dbut de la phase photopriodique)</p>
</li>
<li>
<p>from the beginning of the photoperiodic phase to the beginning of the
   reproductive phase</p>
</li>
<li>
<p>from the beginning of the reproductive phase to the beginning of the
   maturation (only for maize and rice) </p>
</li>
<li>
<p>from the beginning of the maturation to the grain milk stage (du dbut de
   la maturation au stade grain laiteux)</p>
</li>
<li>
<p>from the grain milk stage to the end of the maturation (du dbut du stade
   grain laiteux au jour de rcolte)</p>
</li>
<li>
<p>the day of the harvest</p>
</li>
</ol>
<p>Notes :</p>
<p>In the case of multiannual continuous simulations, we do not reinitialize
the reservoirs, at harvest we put the moisture front at the depth of the
surface reservoir This allows to keep the rooting constraint phenomenon for
the following season if there is little rain while having the water stock in
depth remaining from the previous season.</p>
<p>This function has been originally translated from the EvalPhenoSarrahV3
procedure of the phenologie.pas and exmodules.pas files of the Sarra-H
model, Pascal version.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">EvalPhenoSarrahV3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages the evolution of the phenological phases. It is a</span>

<span class="sd">    wrapper function that calls the specific functions for each phase.</span>

<span class="sd">    This function is called at the beginning of the day and makes the</span>

<span class="sd">    phenological phases evolve. For this, it increments the phase number and</span>

<span class="sd">    changes the value of the thermal time threshold of the next phase.</span>

<span class="sd">    ChangePhase is a boolean informing the model to know if a day is a day of</span>

<span class="sd">    phase change, which is used to initialize specific variables in certain</span>

<span class="sd">    functions. It includes a generic method for the test of the end of the</span>

<span class="sd">    photoperiodic phase. PhasePhotoper = 0 at the end of the photoperiodic phase</span>

<span class="sd">    and = 1 at the beginning of the phase.</span>

<span class="sd">    Phenological phases used in this model (as for cereal crops) :</span>

<span class="sd">    0. from the sowing day to the beginning of the conditions favorable for</span>

<span class="sd">       germination, and from the harvest to the end of the simulation (no crop)</span>

<span class="sd">    1. from the beginning of the conditions favorable for germination to the day</span>

<span class="sd">       of germination (du dbut des conditions favorables pour la germination au</span>

<span class="sd">       jour de la leve)</span>

<span class="sd">    2. from the day of germination to the beginning of the photoperiodic phase</span>

<span class="sd">       (du jour de la leve au dbut de la phase photopriodique)</span>

<span class="sd">    3. from the beginning of the photoperiodic phase to the beginning of the</span>

<span class="sd">       reproductive phase</span>

<span class="sd">    4. from the beginning of the reproductive phase to the beginning of the</span>

<span class="sd">       maturation (only for maize and rice)</span>

<span class="sd">    5. from the beginning of the maturation to the grain milk stage (du dbut de</span>

<span class="sd">       la maturation au stade grain laiteux)</span>

<span class="sd">    6. from the grain milk stage to the end of the maturation (du dbut du stade</span>

<span class="sd">       grain laiteux au jour de rcolte)</span>

<span class="sd">    7. the day of the harvest</span>

<span class="sd">    Notes :</span>

<span class="sd">    In the case of multiannual continuous simulations, we do not reinitialize</span>

<span class="sd">    the reservoirs, at harvest we put the moisture front at the depth of the</span>

<span class="sd">    surface reservoir This allows to keep the rooting constraint phenomenon for</span>

<span class="sd">    the following season if there is little rain while having the water stock in</span>

<span class="sd">    depth remaining from the previous season.</span>

<span class="sd">    This function has been originally translated from the EvalPhenoSarrahV3</span>

<span class="sd">    procedure of the phenologie.pas and exmodules.pas files of the Sarra-H</span>

<span class="sd">    model, Pascal version.</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">testing_for_initialization</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_pheno_phase_1_to_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_pheno_phase_2_to_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_pheno_phase_3_to_4</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_pheno_phase_4_to_5</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_pheno_phase_5_to_6</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_pheno_phase_6_to_7</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="mortalitesarrav3">MortaliteSarraV3</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">MortaliteSarraV3</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This functions tests for death of young plants.</p>
<p>First, for numphase = 2 and changePhase = 1, hence at the transition day
between phase 1 and 2 at this point of the loop, the nbJourCompte and
nbjStress variables are set to 0.</p>
<p>Second, for numPhase equal or above 2, on each day nbJourCompte is
incremented by 1. Thus this part just count days since emergence.</p>
<p>Third, for numPhase equal or above 2, for days where nbJourCompte is lower
than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress
variable is incremented by 1. Thus, we count the number of days with
negative deltaBiomasseAerienne since emergence as stress days.</p>
<p>Finally, for days where nbjStress is equal or higher than
seuilCstrMortality, the crop is reset by setting numPhase,
root_tank_capacity and nbjStress to 0.</p>
<p>This all seems a bit simplistic though, and can be improved.</p>
<p>This function has been adapted from the MortaliteSarraV3 procedure of the
bilancarbonsarra.pas and exmodules 1 &amp; 2.pas codes of the Sarra-H model,
Pascal version.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">MortaliteSarraV3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This functions tests for death of young plants.</span>

<span class="sd">    First, for numphase = 2 and changePhase = 1, hence at the transition day</span>

<span class="sd">    between phase 1 and 2 at this point of the loop, the nbJourCompte and</span>

<span class="sd">    nbjStress variables are set to 0.</span>

<span class="sd">    Second, for numPhase equal or above 2, on each day nbJourCompte is</span>

<span class="sd">    incremented by 1. Thus this part just count days since emergence.</span>

<span class="sd">    Third, for numPhase equal or above 2, for days where nbJourCompte is lower</span>

<span class="sd">    than nbjTestSemis and where deltaBiomasseAerienne is negative, the nbjStress</span>

<span class="sd">    variable is incremented by 1. Thus, we count the number of days with</span>

<span class="sd">    negative deltaBiomasseAerienne since emergence as stress days.</span>

<span class="sd">    Finally, for days where nbjStress is equal or higher than</span>

<span class="sd">    seuilCstrMortality, the crop is reset by setting numPhase,</span>

<span class="sd">    root_tank_capacity and nbjStress to 0.</span>

<span class="sd">    This all seems a bit simplistic though, and can be improved.</span>

<span class="sd">    This function has been adapted from the MortaliteSarraV3 procedure of the</span>

<span class="sd">    bilancarbonsarra.pas and exmodules 1 &amp; 2.pas codes of the Sarra-H model,</span>

<span class="sd">    Pascal version.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbjStress&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbjStress&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;nbJourCompte&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbJourCompte&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;nbjTestSemis&quot;</span><span class="p">])</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;deltaBiomasseAerienne&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;seuilCstrMortality&quot;</span><span class="p">])</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;][j,:,:] = np.where(</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="c1">#// data[&quot;stRurMax&quot;][j,:,:],</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbjStress&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="calculate_daily_thermal_time">calculate_daily_thermal_time</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">calculate_daily_thermal_time</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>calculating daily thermal time</p>
<p>Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version.
Pb de mthode !?
v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase);
v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2);
v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin);
DegresDuJour:= v * (TOpt1-TBase);</p>
<h1 id="if-tmoy-topt2-then">If Tmoy &lt;= Topt2 then</h1>
<h1 id="degresdujour-maxmintopt1tmoytbase-tbase">DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase</h1>
<h1 id="else">else</h1>
<h1 id="degresdujour-topt1-tbase-1-mintl-tmoy-topt2-tl-topt2">DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2)));</h1>
<h1 id="if-numphase-1-then">If (Numphase &gt;=1) then</h1>
<h1 id="somdegresjour-somdegresjour-degresdujour">SomDegresJour := SomDegresJour + DegresDuJour</h1>
<h1 id="else-somdegresjour-0">else SomDegresJour := 0;</h1>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nt">def</span><span class="w"> </span><span class="nt">calculate_daily_thermal_time</span><span class="o">(</span><span class="nt">j</span><span class="o">,</span><span class="w"> </span><span class="nt">data</span><span class="o">,</span><span class="w"> </span><span class="nt">paramVariete</span><span class="o">):</span><span class="w"></span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;calculating daily thermal time</span>

<span class="s2">    Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of theSarra-H model, Pascal version.</span>

<span class="s2">    Pb de mthode !?</span>

<span class="s2">    v1:= ((Max(TMin,TBase)+Min(TOpt1,TMax))/2 -TBase )/( TOpt1 - TBase);</span>

<span class="s2">    v2:= (TL - max(TMax,TOpt2)) / (TL - TOpt2);</span>

<span class="s2">    v:= (v1 * (min(TMax,TOpt1) - TMin)+(min(TOpt2,max(TOpt1,TMax)) - TOpt1) + v2 * (max(TOpt2,TMax)-TOpt2))/( TMax-TMin);</span>

<span class="s2">    DegresDuJour:= v * (TOpt1-TBase);</span>

<span class="s2">    #   If Tmoy &lt;= Topt2 then</span>

<span class="s2">    #      DegresDuJour:= max(min(TOpt1,TMoy),TBase)-Tbase</span>

<span class="s2">    #   else</span>

<span class="s2">    #      DegresDuJour := (TOpt1-TBase) * (1 - ( (min(TL, TMoy) - TOpt2 )/(TL -TOpt2)));</span>

<span class="s2">    #    If (Numphase &gt;=1) then</span>

<span class="s2">    #         SomDegresJour := SomDegresJour + DegresDuJour</span>

<span class="s2">    #    else SomDegresJour := 0;</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="nt">data</span><span class="cp">[</span><span class="s2">&quot;ddj&quot;</span><span class="cp">][</span><span class="nx">j</span><span class="p">,:,:</span><span class="cp">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">xr</span><span class="p">.</span><span class="nc">where</span><span class="o">(</span><span class="w"></span>

<span class="w">        </span><span class="nt">data</span><span class="cp">[</span><span class="s2">&quot;tpMoy&quot;</span><span class="cp">][</span><span class="nx">j</span><span class="p">,:,:</span><span class="cp">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TOpt2&quot;</span><span class="cp">]</span><span class="o">,</span><span class="w"></span>

<span class="w">        </span><span class="nt">np</span><span class="p">.</span><span class="nc">maximum</span><span class="o">(</span><span class="nt">np</span><span class="p">.</span><span class="nc">minimum</span><span class="o">(</span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TOpt1&quot;</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">data</span><span class="cp">[</span><span class="s2">&quot;tpMoy&quot;</span><span class="cp">][</span><span class="nx">j</span><span class="p">,:,:</span><span class="cp">]</span><span class="o">),</span><span class="w"> </span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TBase&quot;</span><span class="cp">]</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TBase&quot;</span><span class="cp">]</span><span class="o">,</span><span class="w"></span>

<span class="w">        </span><span class="o">(</span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TOpt1&quot;</span><span class="cp">]</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TBase&quot;</span><span class="cp">]</span><span class="o">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="nt">1</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="o">((</span><span class="nt">np</span><span class="p">.</span><span class="nc">minimum</span><span class="o">(</span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TLim&quot;</span><span class="cp">]</span><span class="o">,</span><span class="w"> </span><span class="nt">data</span><span class="cp">[</span><span class="s2">&quot;tpMoy&quot;</span><span class="cp">][</span><span class="nx">j</span><span class="p">,:,:</span><span class="cp">]</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TOpt2&quot;</span><span class="cp">]</span><span class="o">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="o">(</span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TLim&quot;</span><span class="cp">]</span><span class="w"> </span><span class="nt">-</span><span class="w"> </span><span class="nt">paramVariete</span><span class="cp">[</span><span class="s2">&quot;TOpt2&quot;</span><span class="cp">]</span><span class="o">))),</span><span class="w"></span>

<span class="w">    </span><span class="o">)</span><span class="w"></span>

<span class="w">    </span><span class="nt">return</span><span class="w"> </span><span class="nt">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="calculate_sum_of_thermal_time">calculate_sum_of_thermal_time</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">calculate_sum_of_thermal_time</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the EvalDegresJourSarrahV3 procedure of the phenologie.pas and exmodules.pas files of the Sarra-H model, Pascal version.</p>
<p>calculating sum of thermal time
sdj has to be broadcasted or calculated as the first process to be able to use it with pheno correctly</p>
<div class="codehilite"><pre><span></span><code><span class="n">Note</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">SARRA</span><span class="o">-</span><span class="n">H</span><span class="o">,</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">numPhase</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">7</span><span class="o">,</span><span class="w"> </span><span class="n">sdj</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">sdj</span><span class="w"> </span><span class="n">stops</span><span class="w"> </span><span class="n">cumulating</span><span class="w"></span>
<span class="n">Returns</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">_type_</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">calculate_sum_of_thermal_time</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

        <span class="nv">Translated</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">EvalDegresJourSarrahV3</span> <span class="nv">procedure</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">phenologie</span>.<span class="nv">pas</span> <span class="nv">and</span> <span class="nv">exmodules</span>.<span class="nv">pas</span> <span class="nv">files</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Sarra</span><span class="o">-</span><span class="nv">H</span> <span class="nv">model</span>, <span class="nv">Pascal</span> <span class="nv">version</span>.

    <span class="nv">calculating</span> <span class="nv">sum</span> <span class="nv">of</span> <span class="nv">thermal</span> <span class="nv">time</span>

<span class="nv">sdj</span> <span class="nv">has</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">broadcasted</span> <span class="nv">or</span> <span class="nv">calculated</span> <span class="nv">as</span> <span class="nv">the</span> <span class="nv">first</span> <span class="nv">process</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">able</span> <span class="nv">to</span> <span class="nv">use</span> <span class="nv">it</span> <span class="nv">with</span> <span class="nv">pheno</span> <span class="nv">correctly</span>

    <span class="nv">Note</span> : <span class="nv">in</span> <span class="nv">SARRA</span><span class="o">-</span><span class="nv">H</span>, <span class="nv">when</span> <span class="nv">numPhase</span> <span class="o">&gt;</span> <span class="mi">7</span>, <span class="nv">sdj</span> <span class="nv">is</span> <span class="nv">set</span> <span class="nv">to</span> <span class="mi">0</span> <span class="nv">and</span> <span class="nv">sdj</span> <span class="nv">stops</span> <span class="nv">cumulating</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">sdj</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">xr</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="ss">(</span><span class="nv">j</span> <span class="o">&gt;=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">sowing_date</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;=</span> <span class="mi">1</span><span class="ss">)</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">sdj</span><span class="s2">&quot;</span>][<span class="nv">j</span><span class="o">-</span><span class="mi">1</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ddj</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="mi">0</span>,

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="flag_change_phase">flag_change_phase</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">flag_change_phase</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_phase</span>
<span class="p">)</span>
</code></pre></div>

<p>This function flags the day for phase change.</p>
<p>If the phase number is above the num_phase value, and if the sum of thermal
time is above the threshold, this function returns changePhase flags.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>num_phase</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">flag_change_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">flags</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span>.

    <span class="k">If</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">is</span> <span class="nv">above</span> <span class="nv">the</span> <span class="nv">num_phase</span> <span class="nv">value</span>, <span class="nv">and</span> <span class="k">if</span> <span class="nv">the</span> <span class="nv">sum</span> <span class="nv">of</span> <span class="nv">thermal</span>

    <span class="nv">time</span> <span class="nv">is</span> <span class="nv">above</span> <span class="nv">the</span> <span class="nv">threshold</span>, <span class="nv">this</span> <span class="nv">function</span> <span class="nv">returns</span> <span class="nv">changePhase</span> <span class="nv">flags</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">num_phase</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">flagging</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span>

    <span class="nv">condition</span> <span class="o">=</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="nv">num_phase</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">sdj</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">seuilTempPhaseSuivante</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">xr</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="mi">1</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="increment_phase_number">increment_phase_number</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">increment_phase_number</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function increments the phase number.</p>
<p>When the phase number is not 0, and if changePhase is 1 (meaning that we are
at a phase transition day), and initPhase is 0 (meaning that the phase
number has not been incremented yet this day), the phase number is
incremented by 1. Also, the phase change flag initPhase is set to 1.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">increment_phase_number</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">increments</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">number</span>.

    <span class="nv">When</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">is</span> <span class="nv">not</span> <span class="mi">0</span>, <span class="nv">and</span> <span class="k">if</span> <span class="nv">changePhase</span> <span class="nv">is</span> <span class="mi">1</span> <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">we</span> <span class="nv">are</span>

    <span class="nv">at</span> <span class="nv">a</span> <span class="nv">phase</span> <span class="nv">transition</span> <span class="nv">day</span><span class="ss">)</span>, <span class="nv">and</span> <span class="nv">initPhase</span> <span class="nv">is</span> <span class="mi">0</span> <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">the</span> <span class="nv">phase</span>

    <span class="nv">number</span> <span class="nv">has</span> <span class="nv">not</span> <span class="nv">been</span> <span class="nv">incremented</span> <span class="nv">yet</span> <span class="nv">this</span> <span class="nv">day</span><span class="ss">)</span>, <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">is</span>

    <span class="nv">incremented</span> <span class="nv">by</span> <span class="mi">1</span>. <span class="nv">Also</span>, <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">flag</span> <span class="nv">initPhase</span> <span class="nv">is</span> <span class="nv">set</span> <span class="nv">to</span> <span class="mi">1</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">condition</span> <span class="o">=</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">!=</span> <span class="mi">0</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">initPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">!=</span> <span class="mi">1</span><span class="ss">)</span>

    # <span class="nv">incrementing</span> <span class="nv">phase</span> <span class="nv">number</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="mi">1</span> ,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    # <span class="nv">flagging</span> <span class="nv">this</span> <span class="nv">day</span> <span class="nv">as</span> <span class="nv">having</span> <span class="nv">been</span> <span class="nv">incremented</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">initPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">=</span> <span class="nv">xr</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="mi">1</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">initPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="reset">reset</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">reset</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">reset</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">True</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1"># when reaching stage 7, we reset the main phenological variables to zero</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ruRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbJourCompte&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;startLock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;startLock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span><span class="w"></span>

<span class="w">  </span><span class="c1"># and we leave numPhas last</span><span class="w"></span>

<span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[np.newaxis,...]</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="testing_for_initialization">testing_for_initialization</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">testing_for_initialization</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function tests if the conditions are met to initiate the crop.</p>
<p>If numPhase is 0, if the current day is equal or above the sowing date, and
if surface_tank_stock is above the threshold for sowing, we initiate the
crop :</p>
<p>1) we set numPhase to 1 ; we broadcast the value over remaining days.
2) we set changePhase of this particular day to 1.
3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to
   be SDJLevee ; we broadcast the value over remaining days.
4) we set initPhase to 1 ; we broadcast the value over remaining days.</p>
<p>initPhase is only used in update_pheno_phase_1_to_2 function, so that we do
not go directly from phase 0 to phase 2. It is used as a specific flag for
phase 0 to 1 transition.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">testing_for_initialization</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    This function tests if the conditions are met to initiate the crop.</span>

<span class="ss">    If numPhase is 0, if the current day is equal or above the sowing date, and</span>

<span class="ss">    if surface_tank_stock is above the threshold for sowing, we initiate the</span>

<span class="ss">    crop :</span>

<span class="ss">    1) we set numPhase to 1 ; we broadcast the value over remaining days.</span>

<span class="ss">    2) we set changePhase of this particular day to 1.</span>

<span class="ss">    3) set the sum of thermal time to the next phase (seuilTempPhaseSuivante) to</span>

<span class="ss">       be SDJLevee ; we broadcast the value over remaining days.</span>

<span class="ss">    4) we set initPhase to 1 ; we broadcast the value over remaining days.</span>

<span class="ss">    initPhase is only used in update_pheno_phase_1_to_2 function, so that we do</span>

<span class="ss">    not go directly from phase 0 to phase 2. It is used as a specific flag for</span>

<span class="ss">    phase 0 to 1 transition.</span>

<span class="ss">    Args:</span>

<span class="ss">        j (_type_): _description_</span>

<span class="ss">        data (_type_): _description_</span>

<span class="ss">        paramITK (_type_): _description_</span>

<span class="ss">    Returns:</span>

<span class="ss">        _type_: _description_</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="err">#!</span><span class="w"> </span><span class="n">replacing</span><span class="w"> </span><span class="n">stRuSurf</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">surface_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="k">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;sowing_date&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;surface_tank_stock&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">paramITK</span><span class="o">[</span><span class="n">&quot;seuilEauSemis&quot;</span><span class="o">]</span><span class="p">)</span><span class="w"></span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;startLock&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j:, :, :</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;changePhase&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;changePhase&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;seuilTempPhaseSuivante&quot;</span><span class="o">][</span><span class="n">j:, :, :</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&quot;SDJLevee&quot;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;seuilTempPhaseSuivante&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">#flagging</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">done</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;initPhase&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;initPhase&quot;</span><span class="o">][</span><span class="n">j, :, :</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_pheno_phase_1_to_2">update_pheno_phase_1_to_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_pheno_phase_1_to_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages phase change from phases number 1 to 2.</p>
<p>First, it flags the day for phase change : If numPhase is 1 and sum of
thermal time is above the threshold (which value comes here from the
previous function testing_for_initialization), we set changePhase of this
particular day to 1.</p>
<p>Second, we update the thermal time to next phase : if numPhase is 1 and
changePhase is 1 (meaning that we are at the transition day between phases 1
and 2), we set the sum of thermal time to the next phase as SDJLevee ; we
broadcast the value over remaining days.</p>
<p>We do it before updating phase number because we need to test what is the
phase number before updating it</p>
<p>Third, we update the phase number : if numPhase is different from 0 and
changePhase is 1 (meaning that we are at the transition day between two
phases, to the exception of transition day between phases 0 and 1), we
increment numPhase by 1 ; we broadcast the value over remaining days.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_pheno_phase_1_to_2</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">manages</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">from</span> <span class="nv">phases</span> <span class="nv">number</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">2</span>.

    <span class="nv">First</span>, <span class="nv">it</span> <span class="nv">flags</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span> : <span class="k">If</span> <span class="nv">numPhase</span> <span class="nv">is</span> <span class="mi">1</span> <span class="nv">and</span> <span class="nv">sum</span> <span class="nv">of</span>

    <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">is</span> <span class="nv">above</span> <span class="nv">the</span> <span class="nv">threshold</span> <span class="ss">(</span><span class="nv">which</span> <span class="nv">value</span> <span class="nv">comes</span> <span class="nv">here</span> <span class="nv">from</span> <span class="nv">the</span>

    <span class="nv">previous</span> <span class="nv">function</span> <span class="nv">testing_for_initialization</span><span class="ss">)</span>, <span class="nv">we</span> <span class="nv">set</span> <span class="nv">changePhase</span> <span class="nv">of</span> <span class="nv">this</span>

    <span class="nv">particular</span> <span class="nv">day</span> <span class="nv">to</span> <span class="mi">1</span>.

    <span class="nv">Second</span>, <span class="nv">we</span> <span class="nv">update</span> <span class="nv">the</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">to</span> <span class="k">next</span> <span class="nv">phase</span> : <span class="k">if</span> <span class="nv">numPhase</span> <span class="nv">is</span> <span class="mi">1</span> <span class="nv">and</span>

    <span class="nv">changePhase</span> <span class="nv">is</span> <span class="mi">1</span> <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">at</span> <span class="nv">the</span> <span class="nv">transition</span> <span class="nv">day</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">1</span>

    <span class="nv">and</span> <span class="mi">2</span><span class="ss">)</span>, <span class="nv">we</span> <span class="nv">set</span> <span class="nv">the</span> <span class="nv">sum</span> <span class="nv">of</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">to</span> <span class="nv">the</span> <span class="k">next</span> <span class="nv">phase</span> <span class="nv">as</span> <span class="nv">SDJLevee</span> <span class="c1">; we</span>

    <span class="nv">broadcast</span> <span class="nv">the</span> <span class="nv">value</span> <span class="nv">over</span> <span class="nv">remaining</span> <span class="nv">days</span>.

    <span class="nv">We</span> <span class="k">do</span> <span class="nv">it</span> <span class="nv">before</span> <span class="nv">updating</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">because</span> <span class="nv">we</span> <span class="nv">need</span> <span class="nv">to</span> <span class="nv">test</span> <span class="nv">what</span> <span class="nv">is</span> <span class="nv">the</span>

    <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">before</span> <span class="nv">updating</span> <span class="nv">it</span>

    <span class="nv">Third</span>, <span class="nv">we</span> <span class="nv">update</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">number</span> : <span class="k">if</span> <span class="nv">numPhase</span> <span class="nv">is</span> <span class="nv">different</span> <span class="nv">from</span> <span class="mi">0</span> <span class="nv">and</span>

    <span class="nv">changePhase</span> <span class="nv">is</span> <span class="mi">1</span> <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">at</span> <span class="nv">the</span> <span class="nv">transition</span> <span class="nv">day</span> <span class="nv">between</span> <span class="nv">two</span>

    <span class="nv">phases</span>, <span class="nv">to</span> <span class="nv">the</span> <span class="nv">exception</span> <span class="nv">of</span> <span class="nv">transition</span> <span class="nv">day</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">0</span> <span class="nv">and</span> <span class="mi">1</span><span class="ss">)</span>, <span class="nv">we</span>

    <span class="nv">increment</span> <span class="nv">numPhase</span> <span class="nv">by</span> <span class="mi">1</span> <span class="c1">; we broadcast the value over remaining days.</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramVariete</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">num_phase</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="nv">thermal_time_threshold</span> <span class="o">=</span> <span class="nv">paramVariete</span>[<span class="s2">&quot;</span><span class="s">SDJLevee</span><span class="s2">&quot;</span>]

    # <span class="nv">flagging</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">flag_change_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">to</span> <span class="k">next</span> <span class="nv">phase</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_next_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span>, <span class="nv">thermal_time_threshold</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">and</span> <span class="nv">flagging</span> <span class="nv">incrementation</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">increment_phase_number</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_pheno_phase_2_to_3">update_pheno_phase_2_to_3</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_pheno_phase_2_to_3</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages phase change from phases number 2 to 3.</p>
<p>It has the same structure as update_pheno_phase_1_to_2, with the exception
of update_thermal_time_previous_phase function, which is called to store the
present thermal time threshold in the seuilTempPhasePrec variable.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_pheno_phase_2_to_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function manages phase change from phases number 2 to 3.</span>

<span class="sd">    It has the same structure as update_pheno_phase_1_to_2, with the exception</span>

<span class="sd">    of update_thermal_time_previous_phase function, which is called to store the</span>

<span class="sd">    present thermal time threshold in the seuilTempPhasePrec variable.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">num_phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>

<span class="w">    </span><span class="n">thermal_time_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SDJBVP&quot;</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="c1"># flagging the day for phase change</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flag_change_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">num_phase</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># saving &quot;previous thermal time to next phase&quot; to be used</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">num_phase</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># updating thermal time to next phase</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_thermal_time_next_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">num_phase</span><span class="p">,</span><span class="w"> </span><span class="n">thermal_time_threshold</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># updating phase number and flagging incrementation</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">increment_phase_number</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_pheno_phase_3_to_4">update_pheno_phase_3_to_4</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_pheno_phase_3_to_4</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages phase change from phases number 3 to 4.</p>
<p>It is specific as phase 3 is photoperiodic ; its length is not computed the
same way as the other phases. Notably, the phasePhotoper flag is updated
with the PhotoperSarrahV3() function.</p>
<p>First, this function flags the day for phase change : If numPhase is 3 and
the phasePhotoper flag is 0, we set changePhase of this particular day to 1.
This means the photoperiodic phase is over.</p>
<p>Second, we update the phasePhotoper flag : if numPhase is 3 and changePhase
is 1 (meaning that we are at the transition day between phases 3 and 4), we
set the phasePhotoper flag to 1.</p>
<p>Third, we update the phase number and flag incrementation using
increment_phase_number().</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_pheno_phase_3_to_4</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">manages</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">from</span> <span class="nv">phases</span> <span class="nv">number</span> <span class="mi">3</span> <span class="nv">to</span> <span class="mi">4</span>.

    <span class="nv">It</span> <span class="nv">is</span> <span class="nv">specific</span> <span class="nv">as</span> <span class="nv">phase</span> <span class="mi">3</span> <span class="nv">is</span> <span class="nv">photoperiodic</span> <span class="c1">; its length is not computed the</span>

    <span class="nv">same</span> <span class="nv">way</span> <span class="nv">as</span> <span class="nv">the</span> <span class="nv">other</span> <span class="nv">phases</span>. <span class="nv">Notably</span>, <span class="nv">the</span> <span class="nv">phasePhotoper</span> <span class="nv">flag</span> <span class="nv">is</span> <span class="nv">updated</span>

    <span class="nv">with</span> <span class="nv">the</span> <span class="nv">PhotoperSarrahV3</span><span class="ss">()</span> <span class="nv">function</span>.

    <span class="nv">First</span>, <span class="nv">this</span> <span class="nv">function</span> <span class="nv">flags</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span> : <span class="k">If</span> <span class="nv">numPhase</span> <span class="nv">is</span> <span class="mi">3</span> <span class="nv">and</span>

    <span class="nv">the</span> <span class="nv">phasePhotoper</span> <span class="nv">flag</span> <span class="nv">is</span> <span class="mi">0</span>, <span class="nv">we</span> <span class="nv">set</span> <span class="nv">changePhase</span> <span class="nv">of</span> <span class="nv">this</span> <span class="nv">particular</span> <span class="nv">day</span> <span class="nv">to</span> <span class="mi">1</span>.

    <span class="nv">This</span> <span class="nv">means</span> <span class="nv">the</span> <span class="nv">photoperiodic</span> <span class="nv">phase</span> <span class="nv">is</span> <span class="nv">over</span>.

    <span class="nv">Second</span>, <span class="nv">we</span> <span class="nv">update</span> <span class="nv">the</span> <span class="nv">phasePhotoper</span> <span class="nv">flag</span> : <span class="k">if</span> <span class="nv">numPhase</span> <span class="nv">is</span> <span class="mi">3</span> <span class="nv">and</span> <span class="nv">changePhase</span>

    <span class="nv">is</span> <span class="mi">1</span> <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">at</span> <span class="nv">the</span> <span class="nv">transition</span> <span class="nv">day</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">3</span> <span class="nv">and</span> <span class="mi">4</span><span class="ss">)</span>, <span class="nv">we</span>

    <span class="nv">set</span> <span class="nv">the</span> <span class="nv">phasePhotoper</span> <span class="nv">flag</span> <span class="nv">to</span> <span class="mi">1</span>.

    <span class="nv">Third</span>, <span class="nv">we</span> <span class="nv">update</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">and</span> <span class="nv">flag</span> <span class="nv">incrementation</span> <span class="nv">using</span>

    <span class="nv">increment_phase_number</span><span class="ss">()</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramVariete</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">flagging</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="ss">(</span><span class="nv">specific</span> <span class="nv">to</span> <span class="nv">phase</span> <span class="mi">3</span><span class="ss">)</span>

    <span class="nv">condition</span> <span class="o">=</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">3</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">phasePhotoper</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">0</span><span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">xr</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="mi">1</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">phasePhotoper</span> <span class="ss">(</span><span class="nv">specific</span> <span class="nv">to</span> <span class="nv">phase</span> <span class="mi">3</span><span class="ss">)</span>

    <span class="nv">condition</span> <span class="o">=</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">3</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">phasePhotoper</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="mi">1</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">phasePhotoper</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">and</span> <span class="nv">flagging</span> <span class="nv">incrementation</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">increment_phase_number</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_pheno_phase_4_to_5">update_pheno_phase_4_to_5</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_pheno_phase_4_to_5</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages phase change from phases number 4 to 5.</p>
<p>It has the same structure as update_pheno_phase_2_to_3.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_pheno_phase_4_to_5</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">manages</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">from</span> <span class="nv">phases</span> <span class="nv">number</span> <span class="mi">4</span> <span class="nv">to</span> <span class="mi">5</span>.

    <span class="nv">It</span> <span class="nv">has</span> <span class="nv">the</span> <span class="nv">same</span> <span class="nv">structure</span> <span class="nv">as</span> <span class="nv">update_pheno_phase_2_to_3</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramVariete</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">num_phase</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="nv">thermal_time_threshold</span> <span class="o">=</span> <span class="nv">paramVariete</span>[<span class="s2">&quot;</span><span class="s">SDJRPR</span><span class="s2">&quot;</span>]

    # <span class="nv">flagging</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">flag_change_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">saving</span> <span class="s2">&quot;</span><span class="s">previous thermal time to next phase</span><span class="s2">&quot;</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">used</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_previous_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">to</span> <span class="k">next</span> <span class="nv">phase</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_next_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span>, <span class="nv">thermal_time_threshold</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">and</span> <span class="nv">flagging</span> <span class="nv">incrementation</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">increment_phase_number</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_pheno_phase_5_to_6">update_pheno_phase_5_to_6</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_pheno_phase_5_to_6</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages phase change from phases number 5 to 6.</p>
<p>It has the same structure as update_pheno_phase_2_to_3.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_pheno_phase_5_to_6</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">manages</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">from</span> <span class="nv">phases</span> <span class="nv">number</span> <span class="mi">5</span> <span class="nv">to</span> <span class="mi">6</span>.

    <span class="nv">It</span> <span class="nv">has</span> <span class="nv">the</span> <span class="nv">same</span> <span class="nv">structure</span> <span class="nv">as</span> <span class="nv">update_pheno_phase_2_to_3</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramVariete</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">num_phase</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="nv">thermal_time_threshold</span> <span class="o">=</span> <span class="nv">paramVariete</span>[<span class="s2">&quot;</span><span class="s">SDJMatu1</span><span class="s2">&quot;</span>]

    # <span class="nv">flagging</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">flag_change_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">saving</span> <span class="s2">&quot;</span><span class="s">previous thermal time to next phase</span><span class="s2">&quot;</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">used</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_previous_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">to</span> <span class="k">next</span> <span class="nv">phase</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_next_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span>, <span class="nv">thermal_time_threshold</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">and</span> <span class="nv">flagging</span> <span class="nv">incrementation</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">increment_phase_number</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_pheno_phase_6_to_7">update_pheno_phase_6_to_7</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_pheno_phase_6_to_7</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function manages phase change from phases number 6 to 7.</p>
<p>It has the same structure as update_pheno_phase_2_to_3.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_pheno_phase_6_to_7</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">manages</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">from</span> <span class="nv">phases</span> <span class="nv">number</span> <span class="mi">6</span> <span class="nv">to</span> <span class="mi">7</span>.

    <span class="nv">It</span> <span class="nv">has</span> <span class="nv">the</span> <span class="nv">same</span> <span class="nv">structure</span> <span class="nv">as</span> <span class="nv">update_pheno_phase_2_to_3</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramVariete</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">num_phase</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="nv">thermal_time_threshold</span> <span class="o">=</span> <span class="nv">paramVariete</span>[<span class="s2">&quot;</span><span class="s">SDJMatu2</span><span class="s2">&quot;</span>]

    # <span class="nv">flagging</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">phase</span> <span class="nv">change</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">flag_change_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">saving</span> <span class="s2">&quot;</span><span class="s">previous thermal time to next phase</span><span class="s2">&quot;</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">used</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_previous_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">to</span> <span class="k">next</span> <span class="nv">phase</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_thermal_time_next_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span>, <span class="nv">thermal_time_threshold</span><span class="ss">)</span>

    # <span class="nv">updating</span> <span class="nv">phase</span> <span class="nv">number</span> <span class="nv">and</span> <span class="nv">flagging</span> <span class="nv">incrementation</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">increment_phase_number</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_photoperiodism">update_photoperiodism</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_photoperiodism</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function aims at managing the photoperiodic sensitivity of the crop.</p>
<p>It first updates the sumPP variable : on the transition day between phase 2
and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100.</p>
<p>Then, we compute the thermal_time_since_previous_phase (thermal time since
the transition between phases 2 and 3), and the
time_above_critical_day_length, which is the difference between day length
and critical day length PPcrit, in decimal hours.</p>
<p>On all days with numPhase = 3 (so including the transition day), the sumPP
is calculated as a function of thermal_time_since_previous_phase and PPExp
(attenuator for progressive PSP response to PP ; rarely used in calibration
procedure, a robust value is 0.17), multiplied by a ratio between the daily
time above critical day length and the difference between SeuilPP (Upper day
length limit of PP response) and PPCrit (Lower day length limit to PP
response). </p>
<p>Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than
PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range
0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to
1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model)</p>
<p>This function has been adapted from the PhotoperSarrahV3 procedure of the
phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version.</p>
<p>Notes CB : 
Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite
photoperiodique et pour les varietes non photoperiodique. PPsens varie de
0,4 a 1,2. Pour PPsens &gt; 2.5 = varit non photoperiodique.
SeuilPP = 13.5
PPcrit = 12
SumPP est dans ce cas une variable quotidienne (et non un cumul)</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_photoperiodism</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function aims at managing the photoperiodic sensitivity of the crop.</span>

<span class="sd">    It first updates the sumPP variable : on the transition day between phase 2</span>

<span class="sd">    and 3 (numPhase = 3 and changePhase = 1), the sumPP variable is set to 100.</span>

<span class="sd">    Then, we compute the thermal_time_since_previous_phase (thermal time since</span>

<span class="sd">    the transition between phases 2 and 3), and the</span>

<span class="sd">    time_above_critical_day_length, which is the difference between day length</span>

<span class="sd">    and critical day length PPcrit, in decimal hours.</span>

<span class="sd">    On all days with numPhase = 3 (so including the transition day), the sumPP</span>

<span class="sd">    is calculated as a function of thermal_time_since_previous_phase and PPExp</span>

<span class="sd">    (attenuator for progressive PSP response to PP ; rarely used in calibration</span>

<span class="sd">    procedure, a robust value is 0.17), multiplied by a ratio between the daily</span>

<span class="sd">    time above critical day length and the difference between SeuilPP (Upper day</span>

<span class="sd">    length limit of PP response) and PPCrit (Lower day length limit to PP</span>

<span class="sd">    response).</span>

<span class="sd">    Finally, phasePhotoper is updated : when numPhase = 3 and sumPP is lower than</span>

<span class="sd">    PPsens, phasePhotoper is set to 0. PP sensitivity, important variable. Range</span>

<span class="sd">    0.3-0.6 is PP sensitive, sensitivity disappears towards values of 0.7 to</span>

<span class="sd">    1. Described in Dingkuhn et al. 2008; Euro.J.Agron. (Impatience model)</span>

<span class="sd">    This function has been adapted from the PhotoperSarrahV3 procedure of the</span>

<span class="sd">    phenologie.pas and exmodules 1 et 2.pas of the Sarra-H model, Pascal version.</span>

<span class="sd">    Notes CB :</span>

<span class="sd">    Procedure speciale Vaksman Dingkuhn valable pour tous types de sensibilite</span>

<span class="sd">    photoperiodique et pour les varietes non photoperiodique. PPsens varie de</span>

<span class="sd">    0,4 a 1,2. Pour PPsens &gt; 2.5 = varit non photoperiodique.</span>

<span class="sd">    SeuilPP = 13.5</span>

<span class="sd">    PPcrit = 12</span>

<span class="sd">    SumPP est dans ce cas une variable quotidienne (et non un cumul)</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">thermal_time_since_previous_phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sdj&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhasePrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"></span>

<span class="w">    </span><span class="n">time_above_critical_day_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dureeDuJour&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPCrit&quot;</span><span class="p">])</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sumPP&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="c1"># if numPhase = 3 and changePhase == 1, sumPP = 100</span><span class="w"></span>

<span class="w">            </span><span class="mi">100</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="c1"># if numPhase = 3 and changePhase != 1, sumPP calculated through formula</span><span class="w"></span>

<span class="w">            </span><span class="p">((</span><span class="mi">1000</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">thermal_time_since_previous_phase</span><span class="p">)</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPExp&quot;</span><span class="p">]))</span><span class="w"> </span>\<span class="w"></span>

<span class="w">                </span><span class="o">*</span><span class="w"> </span><span class="n">time_above_critical_day_length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;SeuilPP&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPCrit&quot;</span><span class="p">]),</span><span class="w"></span>

<span class="w">        </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="c1"># if numPhase != 3, sumPP is not updated</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sumPP&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sumPP&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PPsens&quot;</span><span class="p">]),</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;phasePhotoper&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_root_growth_speed">update_root_growth_speed</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_growth_speed</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the root growth speed (vRac, mm/day) according to the</p>
<p>current phase (numPhase).</p>
<p>This function has been adapted from the EvalVitesseRacSarraV3 procedure of
the phenologie.pas and exmodules 1 &amp; 2.pas files of the Sarra-H model,
Pascal version.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_root_growth_speed</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    This function updates the root growth speed (vRac, mm/day) according to the</span>

<span class="ss">    current phase (numPhase).</span>

<span class="ss">    This function has been adapted from the EvalVitesseRacSarraV3 procedure of</span>

<span class="ss">    the phenologie.pas and exmodules 1 &amp; 2.pas files of the Sarra-H model,</span>

<span class="ss">    Pascal version.</span>

<span class="ss">    Args:</span>

<span class="ss">        j (_type_): _description_</span>

<span class="ss">        data (_type_): _description_</span>

<span class="ss">        paramVariete (_type_): _description_</span>

<span class="ss">    Returns:</span>

<span class="ss">        _type_: _description_</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">phase_correspondances</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="w"></span>

<span class="w">        </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&#39;VRacLevee&#39;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&#39;VRacBVP&#39;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&#39;VRacPSP&#39;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&#39;VRacRPR&#39;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">5</span><span class="err">:</span><span class="w"> </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&#39;VRacMatu1&#39;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="mi">6</span><span class="err">:</span><span class="w"> </span><span class="n">paramVariete</span><span class="o">[</span><span class="n">&#39;VRacMatu2&#39;</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="err">}</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">        </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;vRac&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">phase</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="n">phase_correspondances</span><span class="o">[</span><span class="n">phase</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;vRac&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">ou</span><span class="w"> </span><span class="mi">7</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;vRac&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;vRac&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_thermal_time_next_phase">update_thermal_time_next_phase</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_thermal_time_next_phase</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_phase</span><span class="p">,</span>
    <span class="n">thermal_time_threshold</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the sum of thermal time needed to reach the next</p>
<p>phase.</p>
<p>When numPhase equals the requested phase number, and if changePhase is 1
(meaning that we are at a phase transition day), the seuilTempPhaseSuivante
is incremented by the thermal_time_threshold value. This value is
stage-specific :</p>
<ul>
<li>1 to 2 : SDJLevee</li>
<li>2 to 3 : SDJBVP</li>
<li>4 to 5 : SDJRPR</li>
<li>5 to 6 : SDJMatu1</li>
<li>6 to 7 : SDJMatu2</li>
</ul>
<p>These parameters are passed explicitly when calling this function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>num_phase</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_thermal_time_next_phase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">num_phase</span>, <span class="nv">thermal_time_threshold</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">sum</span> <span class="nv">of</span> <span class="nv">thermal</span> <span class="nv">time</span> <span class="nv">needed</span> <span class="nv">to</span> <span class="nv">reach</span> <span class="nv">the</span> <span class="k">next</span>

    <span class="nv">phase</span>.

    <span class="nv">When</span> <span class="nv">numPhase</span> <span class="nv">equals</span> <span class="nv">the</span> <span class="nv">requested</span> <span class="nv">phase</span> <span class="nv">number</span>, <span class="nv">and</span> <span class="k">if</span> <span class="nv">changePhase</span> <span class="nv">is</span> <span class="mi">1</span>

    <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">at</span> <span class="nv">a</span> <span class="nv">phase</span> <span class="nv">transition</span> <span class="nv">day</span><span class="ss">)</span>, <span class="nv">the</span> <span class="nv">seuilTempPhaseSuivante</span>

    <span class="nv">is</span> <span class="nv">incremented</span> <span class="nv">by</span> <span class="nv">the</span> <span class="nv">thermal_time_threshold</span> <span class="nv">value</span>. <span class="nv">This</span> <span class="nv">value</span> <span class="nv">is</span>

    <span class="nv">stage</span><span class="o">-</span><span class="nv">specific</span> :

    <span class="o">-</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">2</span> : <span class="nv">SDJLevee</span>

    <span class="o">-</span> <span class="mi">2</span> <span class="nv">to</span> <span class="mi">3</span> : <span class="nv">SDJBVP</span>

    <span class="o">-</span> <span class="mi">4</span> <span class="nv">to</span> <span class="mi">5</span> : <span class="nv">SDJRPR</span>

    <span class="o">-</span> <span class="mi">5</span> <span class="nv">to</span> <span class="mi">6</span> : <span class="nv">SDJMatu1</span>

    <span class="o">-</span> <span class="mi">6</span> <span class="nv">to</span> <span class="mi">7</span> : <span class="nv">SDJMatu2</span>

    <span class="nv">These</span> <span class="nv">parameters</span> <span class="nv">are</span> <span class="nv">passed</span> <span class="nv">explicitly</span> <span class="nv">when</span> <span class="nv">calling</span> <span class="nv">this</span> <span class="nv">function</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">num_phase</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">condition</span> <span class="o">=</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="nv">num_phase</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">seuilTempPhaseSuivante</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">seuilTempPhaseSuivante</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">thermal_time_threshold</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">seuilTempPhaseSuivante</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_thermal_time_previous_phase">update_thermal_time_previous_phase</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_thermal_time_previous_phase</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">num_phase</span>
<span class="p">)</span>
</code></pre></div>

<p>This function stores the present thermal time threshold in the</p>
<p>seuilTempPhasePrec variable.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>num_phase</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_thermal_time_previous_phase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">num_phase</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function stores the present thermal time threshold in the</span>

<span class="sd">    seuilTempPhasePrec variable.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        num_phase (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">num_phase</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhasePrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhaseSuivante&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilTempPhasePrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../bilan_hydro/" class="btn btn-neutral float-left" title="Bilan Hydro"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../comparison_tools_old/" class="btn btn-neutral float-right" title="Comparison Tools Old">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../bilan_hydro/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../comparison_tools_old/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
