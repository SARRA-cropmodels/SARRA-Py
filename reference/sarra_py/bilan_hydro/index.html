<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Bilan Hydro - SARRA-Py</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Bilan Hydro";
        var mkdocs_page_input_path = "reference/sarra_py/bilan_hydro.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> SARRA-Py
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../docs/model_formalisms/">Model formalisms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../docs/spatialization_strategy/">Spatialization strategy</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Sarra Py</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../bilan_carbo/">Bilan Carbo</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Bilan Hydro</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#consoressep">ConsoResSep</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evolrurcstr2">EvolRurCstr2</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#initplotmc">InitPlotMc</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply_humectation_front_boundaries">apply_humectation_front_boundaries</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_daily_irrigation">compute_daily_irrigation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_drainage">compute_drainage</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_irrigation_state">compute_irrigation_state</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_runoff">compute_runoff</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_soil_evaporation">compute_soil_evaporation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_total_available_water">compute_total_available_water</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_transpiration">compute_transpiration</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_water_captured_by_mulch">compute_water_captured_by_mulch</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_femcw_and_update_mulch_water_stock">estimate_FEMcW_and_update_mulch_water_stock</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_cstr">estimate_cstr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_effective_evaporation_from_evaporable_water">estimate_effective_evaporation_from_evaporable_water</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../bilan_pheno/">Bilan Pheno</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../data_preparation/">Data Preparation</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../">Index</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../models/">Models</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">SARRA-Py</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Reference &raquo;</li>
          <li>Sarra Py &raquo;</li>
      <li>Bilan Hydro</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/SARRA-cropmodels/SARRA-Py/edit/main/reference/sarra_py/bilan_hydro.md"> Edit on SARRA-Py</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="module-sarra_pybilan_hydro">Module sarra_py.bilan_hydro</h1>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sarra_py.bilan_carbo</span><span class="w"> </span><span class="kn">import</span><span class="w"> </span><span class="n">estimate_kcp</span>

<span class="k">def</span><span class="w"> </span><span class="nf">InitPlotMc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">grid_width</span><span class="p">,</span><span class="w"> </span><span class="n">grid_height</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramTypeSol</span><span class="p">,</span><span class="w"> </span><span class="n">duration</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Initializes variables related to crop residues boimass (mulch) in the data</span>

<span class="s2">    xarray dataset. This code has been adapted from the original InitPlotMc</span>

<span class="s2">    procedure, Bileau.pas code. Comments with tab indentation are from the</span>

<span class="s2">    original code. As the rain is the first variable to be initialized in the</span>

<span class="s2">    data xarray dataset, its dimensions are used to initialize the other</span>

<span class="s2">    variables.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1"># Soil maximum water storage capacity (mm)</span>

<span class="w">    </span><span class="c1"># Capacit√© maximale de la RU (mm)</span>

<span class="w">    </span><span class="c1">#   StRurMax := Ru * ProfRacIni / 1000;</span>

<span class="w">    </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;] = data[&quot;ru&quot;] * paramITK[&quot;profRacIni&quot;] / 1000</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Soil maximum water storage capacity&quot;}</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Soil maximum water storage capacity&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Maximum water capacity of surface tank (mm)</span>

<span class="w">    </span><span class="c1"># Reserve utile de l&#39;horizon de surface (mm)</span>

<span class="w">    </span><span class="c1">#   RuSurf := EpaisseurSurf / 1000 * Ru;</span>

<span class="w">    </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

<span class="w">    </span><span class="c1">#// data[&quot;ruSurf&quot;] = data[&quot;epaisseurSurf&quot;] / 1000 * data[&quot;ru&quot;]</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="c1">#// data[&quot;ruSurf&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Maximum water capacity of surface tank&quot;}</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Maximum water capacity of surface tank&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># ?</span>

<span class="w">    </span><span class="c1">#   //    PfTranspi := EpaisseurSurf * HumPf;</span>

<span class="w">    </span><span class="c1">#   //    StTot := StockIniSurf - PfTranspi/2 + StockIniProf;</span>

<span class="w">    </span><span class="c1">#   StTot := StockIniSurf  + StockIniProf;</span>

<span class="w">    </span><span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniSurf&quot;] + paramTypeSol[&quot;stockIniProf&quot;]))</span>

<span class="w">    </span><span class="c1">#! modifi√© pour faire correspondre les r√©sultats de simulation, √† remettre en place pour un calcul correct d√®s que possible</span>

<span class="w">    </span><span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniProf&quot;]))</span>

<span class="w">    </span><span class="c1">#! renaming stTot to total_tank_stock</span>

<span class="w">    </span><span class="c1">#// data[&quot;stTot&quot;] = data[&quot;stockIniProf&quot;]</span>

<span class="w">    </span><span class="c1">#//data[&quot;total_tank_stock&quot;] = data[&quot;stockIniProf&quot;]</span>

<span class="w">    </span><span class="c1">#! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;stockIniProf&quot;</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="w">    </span><span class="c1">#// data[&quot;stTot&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;?&quot;}</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;?&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Soil maximal depth (mm)</span>

<span class="w">    </span><span class="c1"># Profondeur maximale de sol (mm)</span>

<span class="w">    </span><span class="c1">#   ProfRU := EpaisseurSurf + EpaisseurProf;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurProf&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Soil maximal depth&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Maximum water capacity to humectation front (mm)</span>

<span class="w">    </span><span class="c1"># Quantit√© d&#39;eau maximum jusqu&#39;au front d&#39;humectation (mm)</span>

<span class="w">    </span><span class="c1">#   // modif 10/06/2015  resilience stock d&#39;eau</span>

<span class="w">    </span><span class="c1">#   // Front d&#39;humectation egal a RuSurf trop de stress initial</span>

<span class="w">    </span><span class="c1">#   //    Hum := max(StTot, StRurMax);</span>

<span class="w">    </span><span class="c1">#   Hum := max(RuSurf, StRurMax);</span>

<span class="w">    </span><span class="c1">#   // Hum mis a profRuSurf</span>

<span class="w">    </span><span class="c1">#   Hum := max(StTot, Hum);</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">grid_width</span><span class="p">,</span><span class="w"> </span><span class="n">grid_height</span><span class="p">),</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">                </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

<span class="w">                </span><span class="c1">#// data[&quot;ruSurf&quot;],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span><span class="n">duration</span><span class="p">}),</span>

<span class="w">                </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span>

<span class="w">                </span><span class="c1">#// data[&quot;stRurMax&quot;],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">            </span><span class="c1">#! renaming stTot with total_tank_stock</span>

<span class="w">            </span><span class="c1">#// data[&quot;stTot&quot;],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="p">)</span>

<span class="w">    </span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Maximum water capacity to humectation front&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Previous value for Maximum water capacity to humectation front (mm)</span>

<span class="w">    </span><span class="c1">#  HumPrec := Hum;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="c1"># ?</span>

<span class="w">    </span><span class="c1">#   StRurPrec := 0;</span>

<span class="w">    </span><span class="c1"># Previous value for stTot</span>

<span class="w">    </span><span class="c1">#   StRurMaxPrec := 0;</span>

<span class="w">    </span><span class="c1">#   //modif 10/06/2015 resilience stock d&#39;eau</span>

<span class="w">    </span><span class="c1">#! renaming stTot with total_tank_stock</span>

<span class="w">    </span><span class="c1">#! renaminog stRuPrec with previous_total_tank_stock</span>

<span class="w">    </span><span class="c1">#// data[&quot;stRuPrec&quot;] =  data[&quot;stTot&quot;]</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_irrigation_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the water stock of the irrigation tank.</span>

<span class="s2">    If the simulation is run with automatic irrigation mode</span>

<span class="s2">    (`data[&quot;irrigAuto&quot;]==True`), if the simulation is between phases 0 and 6,</span>

<span class="s2">    and if `root_tank_capacity` is lower than `surface_tank_capacity` (which</span>

<span class="s2">    indicates that the roots have not yet reached the limit between the surface</span>

<span class="s2">    compartment and deep compartment), `irrigation_tank_stock` will be set to</span>

<span class="s2">    the value of `surface_tank_stock`, which means, it will take the minimum</span>

<span class="s2">    value equal to `surface_tank_stock`. For phase 7, the existing</span>

<span class="s2">    `irrigation_tank_stock` value will be kept unchanged.</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on rainfed conditions.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): Index of time step in data</span>

<span class="s2">        data (xarray Dataset): Dataset that contains various data fields</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">])[</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_irrigation_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the capacity if the irrigation tank.</span>

<span class="s2">    If the simulation is run with automatic irrigation mode</span>

<span class="s2">    (`data[&quot;irrigAuto&quot;]==True`), if the current phase is between 0 and 6, and if</span>

<span class="s2">    the root tank capacity is less than the surface tank capacity (meaning that</span>

<span class="s2">    the roots have not reached the limit between the surface compartment and</span>

<span class="s2">    deep compartment), then `irrigation_tank_capacity` is set to the value of</span>

<span class="s2">    `surface_tank_capacity`, which is given a minimum value equal to the</span>

<span class="s2">    `surface_tank_capacity`. Otherwise, the irrigation tank capacity remains</span>

<span class="s2">    unchanged.</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on rainfed conditions.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): Index of the time step being processed.</span>

<span class="s2">        data (xarray dataset): The input dataset containing all the information necessary to run the model.</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray dataset: The input dataset with updated values of the irrigation tank capacity.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_daily_irrigation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes the total daily irrigation</span>

<span class="s2">    If the simulation is run with automatic irrigation mode</span>

<span class="s2">    (`data[&quot;irrigAuto&quot;]==True`), if the current phase is between 0 and 6, and if</span>

<span class="s2">    the filling rate the irrigation tank is below the target filling value</span>

<span class="s2">    (`irrigAutoTarget`, decimal percentage), we first compute 90</span><span class="si">% o</span><span class="s2">f the</span>

<span class="s2">    difference between the current volume of water in the irrigation tank</span>

<span class="s2">    (`irrigation_tank_stock`) and the total capacity of the irrigation tank</span>

<span class="s2">    (`irrigation_tank_capacity`), bounded by a minimum of 0 and a maximum of</span>

<span class="s2">    `maxIrrig`. This computed value represents the amount of water to be added</span>

<span class="s2">    to the irrigation tank. If the above conditions are not met, the computed</span>

<span class="s2">    value is 0.</span>

<span class="s2">    Then, we calculate the total irrigation of the day by summing the estimated</span>

<span class="s2">    irrigation need (`irrigation`) with the previous irrigation history of the</span>

<span class="s2">    day (`irrigTotDay`).</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on rainfed conditions.</span>

<span class="s2">    Args:</span>

<span class="s2">        j: An integer representing the current day.</span>

<span class="s2">        data: A xarray dataset.</span>

<span class="s2">        paramITK: A dictionary of parameters.</span>

<span class="s2">    Returns:</span>

<span class="s2">        data: A xarray dataset with the updated irrigationTotDay field.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> \</span>

<span class="w">            </span><span class="o">&lt;</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;irrigAutoTarget&quot;</span><span class="p">])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">                </span><span class="mi">0</span><span class="p">,</span>

<span class="w">                </span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.9</span><span class="p">)</span><span class="w"> \</span>

<span class="w">                    </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span>

<span class="w">                </span><span class="p">),</span>

<span class="w">            </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;maxIrrig&quot;</span><span class="p">]</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_irrigation_state</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This wrapper function computes the irrigation state for a given day,</span>

<span class="s2">    including the size and filling of the irrigation tank and the irrigation</span>

<span class="s2">    demand. It is computed only if `paramITK[&quot;irrigAuto&quot;] == True` ; this means</span>

<span class="s2">    that irrigAuto shall be the same all over the grid, which is a reasonable</span>

<span class="s2">    assumption</span>

<span class="s2">    It has been Translated from the procedure EvalIrrigPhase, of the original</span>

<span class="s2">    Pascal codes bileau.pas and exmodules2.pas. Calculation precision is not</span>

<span class="s2">    taken into account anymore.</span>

<span class="s2">    irrigation_tank_stock and irrigation_tank_capacity are only computed in</span>

<span class="s2">    order to avoid issues with very shallow rooting, where calculation of</span>

<span class="s2">    filling of root_tank_capacity by root_tank_stock can be inappropriate and</span>

<span class="s2">    lead to inadapted results for automatic irrigation</span>

<span class="s2">    Notes from CB, 2014 : &quot;Modification due √† la prise en compte effet Mulch</span>

<span class="s2">    Soit on a une irrigation observ√©e, soit on calcul la dose d&#39;irrigation. Elle</span>

<span class="s2">    est calcul√©e en fonction d&#39;un seuil d&#39;humidit√© (IrrigAutoTarget) et de</span>

<span class="s2">    possibilit√© technique ou choix (MaxIrrig, Precision). Dans cette gestion</span>

<span class="s2">    d&#39;irrigation la pluie du jour n&#39;est pas prise en compte.&quot;</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): Index of the day for which the irrigation state is being computed.</span>

<span class="s2">        data (xarray.Dataset): The input data, including the arrays for irrigation and correctedIrrigation.</span>

<span class="s2">        paramITK (dict): The parameters for the ITK model.</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray.Dataset: The updated data, including the computed values for the irrigation state.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">True</span><span class="w"> </span><span class="p">:</span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_irrigation_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_irrigation_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_daily_irrigation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_total_available_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes the total available water for a day (mm) by adding</span>

<span class="s2">    rainfall and irrigation.</span>

<span class="s2">    This calculation is performed to allow for subsequent calculations of the</span>

<span class="s2">    mulch filling and water runoff.</span>

<span class="s2">    The available_water variable is later updated during the same day process</span>

<span class="s2">    list, so its value is not the same at the beginning and the end of the daily</span>

<span class="s2">    computation loop.</span>

<span class="s2">    This function has benn translated from the procedure PluieIrrig, of the</span>

<span class="s2">    original Pascal codes bileau.pas and exmodules2.pas.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): The index of the current day.</span>

<span class="s2">        data (xarray.Dataset): The data set containing information about the rainfall, irrigation, and water availability.</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray.Dataset: The data set with updated information about the total water availability for the current day.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_water_captured_by_mulch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes the height of water captured by the mulch.</span>

<span class="s2">    For this, we multiply the &#39;available_water&#39; (rain + irrigation, in mm) by an</span>

<span class="s2">    exponential function taking both into consideration the mulch covering</span>

<span class="s2">    capacity (surfMc, ha/t) and mulch biomass (biomMc, kg/ha), representing the</span>

<span class="s2">    fraction of soil covered by mulch. If the fraction is 0 (no mulch), the</span>

<span class="s2">    value of water_captured_by_mulch is 0.</span>

<span class="s2">    The value of water_captured_by_mulch is bounded by the maximum capacity of</span>

<span class="s2">    the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of</span>

<span class="s2">    water already present in it (mulch_water_stock, mm).</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on situations without mulch.</span>

<span class="s2">    Notes from CB, 2014 :</span>

<span class="s2">    Hypotheses : A chaque pluie, on estime la quantit√© d&#39;eau pour saturer le</span>

<span class="s2">    couvert. On la retire √† l&#39;eauDispo (pluie + irrig). On calcule la capacit√©</span>

<span class="s2">    maximum de stockage fonction de la biomasse et du taux de saturation</span>

<span class="s2">    rapport√©e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1</span>

<span class="s2">    mm = 1 litre d&#39;eau / m2 1 mm = 10 tonnes d&#39;eau / hectare = 10 000 kg/ha La</span>

<span class="s2">    biomasse est en kg/ha pour se rapporter √† la quantit√© de pluie capt√©e en mm</span>

<span class="s2">    Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha √† humSat 2.8</span>

<span class="s2">    kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit√© √†</span>

<span class="s2">    capter est fonction du taux de couverture du sol calcul√© comme le LTR SurfMc</span>

<span class="s2">    est sp√©cifi√© en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On</span>

<span class="s2">    retire alors les mm d&#39;eau capt√©es √† la pluie incidente. Le ruisselement est</span>

<span class="s2">    ensuite calcul√© avec l&#39;effet de contrainte du mulch</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">        paramITK (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_captured_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;surfMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])),</span>

<span class="w">        </span><span class="p">(</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;humSatMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_available_water_after_mulch_filling</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates available water after mulch filling.</span>

<span class="s2">    As some water is captured by the mulch (rain or irrigation water falling on</span>

<span class="s2">    it), the available_water is updated by subtracting the captured water</span>

<span class="s2">    (water_captured_by_mulch, mm) from the total available water</span>

<span class="s2">    (available_water, mm), to represent the remaining available water after</span>

<span class="s2">    capture by the mulch. This value is bounded by 0, as the available water</span>

<span class="s2">    cannot be negative.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_captured_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the water stock in mulch.</span>

<span class="s2">    The water stock in mulch is updated by adding the captured water (water_captured_by_mulch, mm)</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_captured_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fill_mulch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This wrapper function computes the filling of the mulch for a given day.</span>

<span class="s2">    It has been translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="s2">    bileau.pas and exmodules2.pas</span>

<span class="s2">    For more details, it is advised to refer to the works of Eric Scopel (UR</span>

<span class="s2">    AIDA), and the PhD dissertation of Fernando Maceina.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_water_captured_by_mulch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_available_water_after_mulch_filling</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function evaluates the water runoff (mm).</span>

<span class="s2">    If the quantity of rain (mm) is above the runoff_threshold (mm), runoff is</span>

<span class="s2">    computed as the difference between the available water (mm) and the</span>

<span class="s2">    runoff_threshold  multiplied by the runoff_rate (%). Else, runoff value is</span>

<span class="s2">    set to 0.</span>

<span class="s2">    runoff_threshold and runoff_rate are defined in load_iSDA_soil_data</span>

<span class="s2">    Question : should runoff be computed taking in consideration water captured by</span>

<span class="s2">    mulch to account for mulch effect on runoff mitigation ?</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff_threshold&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff_threshold&quot;</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff_rate&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_available_water_after_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Updating available water (eauDispo, mm) :</span>

<span class="s2">    The available water is updated by subtracting the runoff (lr, mm) from the</span>

<span class="s2">    total available water (eauDispo, mm). This value is broadcasted onto the</span>

<span class="s2">    days axis.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="s2">    bileau.pas, exmodules1.pas and exmodules2.pas</span>

<span class="s2">    Notes from CB, 2014 :</span>

<span class="s2">    On a regroup√© avant la pluie et l&#39;irrigation (a cause de l&#39;effet Mulch)</span>

<span class="s2">    si mulch on a enlev√© l&#39;eau capt√©e</span>

<span class="s2">    oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">        paramTypeSol (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_available_water_after_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">initialize_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function initializes the root tank.</span>

<span class="s2">    If during the considered day j there are pixels in phase 1 (initialisation),</span>

<span class="s2">    we test for pixels at phase change between phases 0 and 1 (&#39;changePhase = 1&#39;</span>

<span class="s2">    and &#39;numPhase = 1&#39;).</span>

<span class="s2">    On these pixels, the maximum root tank water storage (&#39;root_tank_capacity&#39;,</span>

<span class="s2">    mm) is initialised by multiplying the initial root depth (&#39;profRacIni&#39;, mm)</span>

<span class="s2">    with the soil water storage capacity (&#39;ru&#39;, mm/m). This value is broadcasted</span>

<span class="s2">    on the time series. For every other day in the cycle where there are pixels</span>

<span class="s2">    at , the value remains unchanged.</span>

<span class="s2">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_30</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): day identifier</span>

<span class="s2">        data (xarray dataset): an xarray dataset of dimensions (day, width,</span>

<span class="s2">        height) containing the variables &#39;numPhase&#39;, &#39;root_tank_capacity&#39;,</span>

<span class="s2">        &#39;changePhase&#39;, &#39;ru&#39;</span>

<span class="s2">        paramITK (dict): a dictionary containing the ITK parameter &#39;profRacIni&#39;</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">:</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>

<span class="w">            </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">initialize_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function initializes the daily variation in root tank capacity.</span>

<span class="s2">    This variable represents daily variation in water height accessible to</span>

<span class="s2">    roots, in mm.</span>

<span class="s2">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="s2">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;), the daily</span>

<span class="s2">    variation in root tank capacity (delta_root_tank_capacity, mm) is updated.</span>

<span class="s2">    The updated value depends on the daily root growth speed (itself depending</span>

<span class="s2">    on the current development phase of the plant), the drought stress</span>

<span class="s2">    coefficient (&#39;cstr&#39;), and the soil water storage capacity (&#39;ru&#39;, mm/m).</span>

<span class="s2">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_118</span>

<span class="s2">    However, when &#39;root_tank_capacity&#39; is above &#39;surface_tank_capacity&#39;</span>

<span class="s2">    (meaning that the roots are prospecting water deeper than the surface tank),</span>

<span class="s2">    the daily root capacity variation is calculated as the product of soil water</span>

<span class="s2">    storage capacity (&#39;ru&#39;), the daily root growth speed (&#39;vRac&#39;), and a</span>

<span class="s2">    coefficient made from &#39;cstr&#39; shifted by 0.3, capped at 1.0.</span>

<span class="s2">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_71</span>

<span class="s2">    That is to say, when roots are going deep, the root growth speed is</span>

<span class="s2">    modulated by drought stress.</span>

<span class="s2">    The drought stress coefficient &#39;cstr&#39; measures the level of drought stress</span>

<span class="s2">    with 0 being full stress. The root growth speed is assumed to remain</span>

<span class="s2">    non-null during a drought stress as a matter of survival, with a certain</span>

<span class="s2">    level of tolerance given by the [0.3, 1] bound of the coefficient. Using the</span>

<span class="s2">    [0.3, 1] bound is a way to tell that in the [0.7, 1] &#39;cstr&#39; interval, there</span>

<span class="s2">    is no effect of drought stress on the root growth speed, allowing for a</span>

<span class="s2">    certain level of tolerance of the plant.</span>

<span class="s2">    When &#39;root_tank_capacity&#39; is lower than &#39;surface_tank_capacity&#39;, the root growth</span>

<span class="s2">    speed is not modulated by drought stress.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): The current iteration step of the process.</span>

<span class="s2">        data (xarray.Dataset): The input data containing relevant information.</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the daily variation in root tank capacity</span>

<span class="s2">    (delta_root_tank_capacity, mm) depending on the water height to humectation</span>

<span class="s2">    front (hum, mm) and the root tank capacity (root_tank_capacity, mm).</span>

<span class="s2">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="s2">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;), when the</span>

<span class="s2">    difference between the water height to humectation front (hum, mm) and the</span>

<span class="s2">    root_tank_capacity is less than the delta_root_tank_capacity (meaning that</span>

<span class="s2">    the daily variation in root tank capacity is higher that the height of water</span>

<span class="s2">    necessary to reach the height of water of the humectation front),</span>

<span class="s2">    delta_root_tank_capacity is updated to be equal to the difference between</span>

<span class="s2">    the water height to humectation front and the root_tank_capacity.</span>

<span class="s2">    In other words, the change in root tank capacity delta_root_tank_capacity is</span>

<span class="s2">    limited by the water height to humectation front. Which can be interpreted as :</span>

<span class="s2">    the roots cannot grow deeper than the humectation front.</span>

<span class="s2">    ? ...which means the humectation from has to be updated somewhere ?</span>

<span class="s2">    For any other day or if root_tank_capacity is above</span>

<span class="s2">    delta_root_tank_capacity, delta_root_tank_capacity value is unchanged.</span>

<span class="s2">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_161</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the root tank capacity (root_tank_capacity, mm) by</span>

<span class="s2">    adding the daily variation in root tank capacity.</span>

<span class="s2">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="s2">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;),</span>

<span class="s2">    root_tank_capacity is updated to be summed with the change in root water</span>

<span class="s2">    storage capacity delta_root_tank_capacity.</span>

<span class="s2">    In other words, root_tank_capacity is incremented by the change in root</span>

<span class="s2">    water storage capacity related to root growth. Easy, right ?</span>

<span class="s2">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_238</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This functions update the quantity of water of the root tank (&#39;root_tank_stock&#39;, mm).</span>

<span class="s2">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="s2">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;), and for</span>

<span class="s2">    which the &#39;root_tank_capacity&#39; is greater than &#39;surface_tank_capacity&#39; (meaning</span>

<span class="s2">    that roots go beyond the surface water storage capacity), &#39;root_tank_stock&#39;</span>

<span class="s2">    is incremented by delta_root_tank_capacity.</span>

<span class="s2">    However, if &#39;root_tank_capacity&#39; is lesser than &#39;surface_tank_capacity&#39; (meaning</span>

<span class="s2">    that roots do not plunge into the deep reservoir), &#39;root_tank_stock&#39; is</span>

<span class="s2">    updated to be equal to surface_tank_stock minus 1/10th of the</span>

<span class="s2">    surface_tank_capacity, multiplied by the ratio between root_tank_capacity</span>

<span class="s2">    and surface_tank_capacity. That is to say &quot;we take at the prorata of depth</span>

<span class="s2">    and surface stock&quot;.</span>

<span class="s2">    For any other day, root_tank_stock is unchanged.</span>

<span class="s2">    ? Why is the tank stock incremented instead of root tank capacity ? If the</span>

<span class="s2">    ? root tank capacity is incremented, that makes sense as we add to the root</span>

<span class="s2">    ? tank capacity the capacity newly gained through delta_root_tank_capacity.</span>

<span class="s2">    ? There is no sense in incrementing the root tank stock with the</span>

<span class="s2">    ? delta_root_tank_capacity, as the delta root tank capacity, representing</span>

<span class="s2">    ? growing of roots is independant of the quantity of water in the soil.</span>

<span class="s2">    ? However, the delta root tank capacity is blocked by hum the humidity front.</span>

<span class="s2">    ? Still, humidity front only grows and limits the maximum growth of roots, and</span>

<span class="s2">    ? is not involved in root water stock.</span>

<span class="s2">    ? Also, if the roots do not go in the deep reservoir, there is an increase in</span>

<span class="s2">    ? root tank stock. Considering this is a mistake and that root_tank_capacity</span>

<span class="s2">    ? should be increased, this would mean root tank capacity is increased by a</span>

<span class="s2">    ? value that depends on the filling of the surface tank first</span>

<span class="s2">    ? (surface_tank_stock minus 1/10th of the surface_tank_capacity, that would be</span>

<span class="s2">    ? about the bound water), times the ratio between root_tank_capacity and</span>

<span class="s2">    ? surface_tank_capacity. This would mean if when there is few roots the</span>

<span class="s2">    ? increase in root tank capacity is small, and if roots are close to passing</span>

<span class="s2">    ? into the deep reservoir, the increase in root tank capacity nears the</span>

<span class="s2">    ? surface_tank_stock. Again, there is no sense in increasing the root tank</span>

<span class="s2">    ? capacity with such value however this would be ok for root_tank_stock...</span>

<span class="s2">    ? Overall there seems to be a mixup between the objectives of the two parts of</span>

<span class="s2">    ? this function ?</span>

<span class="s2">    ? at the moment this function is applied, root_tank_capacity is already</span>

<span class="s2">    ? updated to take into consideration the root growth from the day, limited by</span>

<span class="s2">    ? both the water stress and the depth of the humectation front. i still do not</span>

<span class="s2">    ? understand why we would increase root tank stock, as we do not have</span>

<span class="s2">    ? supplementary water. it would be like creating water from nowhere.</span>

<span class="s2">    ? so until further notice i will let this function as it is, but i will keep</span>

<span class="s2">    ? in mind that it is probably wrong.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> \</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)),</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">                </span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> \</span>

<span class="w">                </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">])),</span>

<span class="w">                </span><span class="mi">0</span><span class="p">),</span>

<span class="w">        </span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">EvolRurCstr2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function is a legacy wrapper for the functions related to the</span>

<span class="s2">    calculation of the root tank capacity and stock.</span>

<span class="s2">    It has been translated from the procedure EvolRurCstr2, of the original</span>

<span class="s2">    Pascal codes bileau.pas.</span>

<span class="s2">    Notes from CB, 10/06/2015 :</span>

<span class="s2">    Stress trop fort enracinement</span>

<span class="s2">    Trop d&#39;effet de stress en tout d√©but de croissance :</span>

<span class="s2">    1) la plantule a des r√©serves et favorise l&#39;enracinement</span>

<span class="s2">    2) dynamique sp√©cifique sur le r√©servoir de surface</span>

<span class="s2">    Cet effet stress sur l&#39;enracinement ne s&#39;applique que quand l&#39;enracinement</span>

<span class="s2">    est sup√©rieur √© la profondeur du r√©servoir de surface. Effet stres a un</span>

<span class="s2">    effet sur la vitesse de prof d&#39;enracinement au dessus d&#39;un certain seuil de</span>

<span class="s2">    cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur</span>

<span class="s2">    la vitesse) La vitesse d&#39;enracinement potentielle de la plante peut etre</span>

<span class="s2">    bloque par manque d&#39;eau en profondeur (Hum). La profondeur d&#39;humectation est</span>

<span class="s2">    convertie en quantite d&#39;eau maximum equivalente</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1">#! we keep this function for now even though it is probably wrong, it will need further screening</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="c1">####################### list of functions for rempliRes #######################</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_previous_humectation_front_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function saves information about the water height to humectation front</span>

<span class="s2">    to another variable (previous_humectation_front, mm) at the end of season so</span>

<span class="s2">    it can be used in the next cycle.</span>

<span class="s2">    previous_humectation_front is initialized in the function InitPlotMc, and</span>

<span class="s2">    set to be equal to hum. hum itself is initialized to take the maximum value</span>

<span class="s2">    between surface_tank_capacity, root_tank_capacity and total_tank_stock.</span>

<span class="s2">    At the harvest date (numPhase = 7), the previous_humectation_front variable</span>

<span class="s2">    is set to equal the highest value between hum (mm, water height to</span>

<span class="s2">    humectation front) and surface_tank_capacity (mm). This value is broadcasted</span>

<span class="s2">    over the time dimension.</span>

<span class="s2">    At any other point in time, its value is unchanged.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): number of the day</span>

<span class="s2">        data (xarray dataset): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray dataset: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_humectation_front_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the value of water height to humectation front</span>

<span class="s2">    (humectation_front, mm) at the end of season.</span>

<span class="s2">    At the harvest date (numPhase = 7), the humectation_front variable is set to</span>

<span class="s2">    equal the surface_tank_capacity (mm). This value is broadcasted over the</span>

<span class="s2">    time dimension.</span>

<span class="s2">    At any other point in time, its value is unchanged.</span>

<span class="s2">    ? The way of resetting the humectation_front at harvest date hasn&#39;t a real</span>

<span class="s2">    ? agronomical meaning. This function allows for resetting the variable at an</span>

<span class="s2">    ? initial state.</span>

<span class="s2">    ? However it is a way to say that when the plant dies, the new ones will have</span>

<span class="s2">    ? to make up their new humectation fronts starting again from surface_tank_capacity</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_root_tank_capacity_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function saves information about the root_tank_capacity to another</span>

<span class="s2">    variable (previous_root_tank_capacity, mm) at the end of season so it</span>

<span class="s2">    can be used in the next cycle.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_previous_root_tank_stock_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the value of previous stock of water in the root tank</span>

<span class="s2">    (previous_root_tank_stock, mm) at the end of season.</span>

<span class="s2">    When the phase changes from 7 to 1, previous_root_tank_stock is set to equal</span>

<span class="s2">    the ratio between root_tank_stock and root_tank_capacity, that is to say the</span>

<span class="s2">    filling rate of the root reservoir. Otherwise, it stays at its initial value</span>

<span class="s2">    of 0. Its value is broadcasted along j. previous_root_tank_stock is</span>

<span class="s2">    initialized with a value of 0.</span>

<span class="s2">    ? The way of resetting the previous_root_tank_stock at harvest date hasn&#39;t a real</span>

<span class="s2">    ? agronomical meaning.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_previous_total_tank_stock_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the value of previous total stock of water</span>

<span class="s2">    (previous_total_tank_stock, mm) at the end of season.</span>

<span class="s2">    When the phase changes from 7 to 1, previous_total_tank_stock is set to equal</span>

<span class="s2">    the difference between total_tank_stock and surface_tank_stock.</span>

<span class="s2">    Otherwise, it stays at its initial value of 0. Its value is broadcasted</span>

<span class="s2">    along j. previous_total_tank_stock is initialized with a value of 0.</span>

<span class="s2">    ? The way of resetting the previous_total_tank_stock at harvest does not seem to have a real</span>

<span class="s2">    ? agronomical meaning.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="c1"># essai stTot #? what is that ?</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">reset_total_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function resets the value total_tank_capacity at each loop.</span>

<span class="s2">    ? Why redfining stRuMax at each loop ? Neither ru, profRu</span>

<span class="s2">    ? nor total_tank_capacity are modified during the simulation.</span>

<span class="s2">    ? At the same time, its value is initialized at 0, and this function</span>

<span class="s2">    ? is the only place where it is initialized taking ru and profRu into account.</span>

<span class="s2">    ? We modify it so it runs only at day one.</span>

<span class="s2">    ? But it should be moved to the initialization part of the code.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the value of water stock in the surface tank</span>

<span class="s2">    (surface_tank_stock, mm) with the water available for the day</span>

<span class="s2">    (available_water, mm), within the limits of 110</span><span class="si">% s</span><span class="s2">urface_tank_capacity.</span>

<span class="s2">    We update surface_tank_stock by adding the available_water, which as this</span>

<span class="s2">    point in the process list corresponds to the water available from 1) rain,</span>

<span class="s2">    2) irrigation for the day, corrected from 3) intake by mulch (fill_mulch</span>

<span class="s2">    function), and 4) runoff (compute_runoff). However, we do not allow</span>

<span class="s2">    surface_tank_stock to exceed 110</span><span class="si">% o</span><span class="s2">f the surface_tank_capacity.</span>

<span class="s2">    ? This means it is possible that the surface tank fill rate is above 100%,</span>

<span class="s2">    ? which is a rather strange assumption.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="c1"># 1.1 * data[&quot;surface_tank_capacity&quot;]</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_transpirable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the daily height of water available from the surface</span>

<span class="s2">    reservoir for transpiration by the plant (&#39;eauTranspi&#39;, mm).</span>

<span class="s2">    If the filling rate of the surface tank (&#39;surface_tank_stock&#39; /</span>

<span class="s2">    &#39;surface_tank_capacity&#39;) for the previous day is under 10%, we set the</span>

<span class="s2">    quantity of transpirable water as the water available for the day</span>

<span class="s2">    (&#39;eauDispo&#39;) minus the water height necessary to keep the filling rate of</span>

<span class="s2">    the surface tank at 10%.</span>

<span class="s2">    Said otherwise, a part of the water available for the day (&#39;eauDispo&#39;) is used</span>

<span class="s2">    to maintain the surface reservoir at a minimum level of 10</span><span class="si">% o</span><span class="s2">f its capacity,</span>

<span class="s2">    as this water is considered as bound to the surface reservoir and cannot be</span>

<span class="s2">    transpired.</span>

<span class="s2">    Of course, if the filling rate of the previous day is above 10%, the transpirable</span>

<span class="s2">    water is equal to the water available for the day.</span>

<span class="s2">    Furthermore, transpirable water cannot be negative.</span>

<span class="s2">    ? Remark : if the use of j-1 indices is troublesome, it should be feasible to</span>

<span class="s2">    ? run this function just before update_surface_tank_stock.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1"># data[&quot;eauTranspi&quot;][j,:,:] = np.where(</span>

<span class="w">    </span><span class="c1">#     data[&quot;surface_tank_stock&quot;][j-1,:,:] &lt; 0.1 * data[&quot;surface_tank_capacity&quot;],</span>

<span class="w">    </span><span class="c1">#     np.maximum(</span>

<span class="w">    </span><span class="c1">#         0,</span>

<span class="w">    </span><span class="c1">#         data[&quot;available_water&quot;][j,:,:] - (0.1 * data[&quot;surface_tank_capacity&quot;] - data[&quot;surface_tank_stock&quot;][j-1,:,:])</span>

<span class="w">    </span><span class="c1">#         ),</span>

<span class="w">    </span><span class="c1">#     data[&quot;available_water&quot;][j,:,:],</span>

<span class="w">    </span><span class="c1"># )</span>

<span class="w">    </span><span class="c1">#! simplification : we are already working with water height between permanent wilting point and field capacity,</span>

<span class="w">    </span><span class="c1">#! so there is no need to consider bound water as this is already taken into consideration in the calculation of RU</span>

<span class="w">    </span><span class="c1">#! if we want to take this further correctly we have to rewrite everything, so better keep it simple for now</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This functions updates the total height of transpirable water</span>

<span class="s2">    (&#39;total_tank_stock&#39;, mm) with the amount of transpirable water for the day</span>

<span class="s2">    (&#39;eauTranspi&#39;, mm).</span>

<span class="s2">    ? Said differently, &#39;total_tank_stock&#39; represents the total amount of water</span>

<span class="s2">    ? available for the plant in the soil column ?</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_delta_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the positive variation of the total height of</span>

<span class="s2">    transpirable water (&#39;delta_total_tank_stock&#39;, mm).</span>

<span class="s2">    It is computed as the difference between the total_tank_stock and</span>

<span class="s2">    previous_total_tank_stock, bound in 0.</span>

<span class="s2">    &#39;previous_total_tank_stock&#39; is initialized to be equal to &#39;total_tank_stock&#39;</span>

<span class="s2">    at the beginning of the simulation. As &#39;total_tank_stock&#39; is initialized</span>

<span class="s2">    with the &#39;stockIrr&#39; parameter, simulations should start with a 0 value.</span>

<span class="s2">    &#39;previous_total_tank_stock&#39; is updated each day with the &#39;update_struprec&#39;</span>

<span class="s2">    function.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_total_tank_stock_for_second_crop_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the total height of transpirable water</span>

<span class="s2">    (&#39;total_tank_stock&#39;, mm), specifically if a second crop cycle starts.</span>

<span class="s2">    This update is applied only if a second crop cycle starts, as</span>

<span class="s2">    previous_root_tank_capacity and previous_total_tank_stock are initialized as</span>

<span class="s2">    null. That means conditions 2 and 3 of this function will fail during a</span>

<span class="s2">    first crop cycle, leading to no change in total_tank_stock.</span>

<span class="s2">    However, at numPhase = 7, which corresponds to the harvesting date and that</span>

<span class="s2">    opens the possibility for a second crop cycle, previous_root_tank_capacity</span>

<span class="s2">    and previous_total_tank_stock will be updated.</span>

<span class="s2">    From now on, if delta_total_tank_stock is greater than humectation front</span>

<span class="s2">    (condition 1 passed), and previous_root_tank_capacity is greater or equal to</span>

<span class="s2">    the humectation_front (condition 2 passed), and if the humectation_front is</span>

<span class="s2">    below previous_humectation_front (condition 3 passed), then the total tank</span>

<span class="s2">    stock is updated to be increased with the difference between</span>

<span class="s2">    delta_total_tank_stock and humectation_front, times the previous root tank</span>

<span class="s2">    stock.</span>

<span class="s2">    Thus, if the root tank is empty, total_tank_stock will remain unchanged, and</span>

<span class="s2">    if the root tank is full, total_tank_stock will be increased up to the</span>

<span class="s2">    amount of water making the difference between quantity of water for</span>

<span class="s2">    humectation front and the variation in daily transpirable water.</span>

<span class="s2">    Also, if delta_total_tank_stock is greater than humectation front (condition</span>

<span class="s2">    1 passed), but previous_root_tank_capacity is lower than the</span>

<span class="s2">    humectation_front (condition 2 failed), while the humectation_front is below</span>

<span class="s2">    previous_humectation_front (condition 3 passed), we update the total tank</span>

<span class="s2">    stock to be equal to delta_total_tank_stock.</span>

<span class="s2">    In other words, if during the second crop cycle the humectation front is too</span>

<span class="s2">    low, we increase the total tank stock.</span>

<span class="s2">    ? To my opinion, this function is way too complicated for a borderline use case</span>

<span class="s2">    ? (multiple cropping cycles during one simulation).</span>

<span class="s2">    ? We&#39;d want to keep the code for legacy reasons but if really this simulation</span>

<span class="s2">    ? feature is needed we&#39;ll have to simplify it.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">condition_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">condition_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition_1</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="n">condition_2</span><span class="p">,</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">*</span><span class="w"> \</span>

<span class="w">                  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">                </span><span class="n">condition_3</span><span class="p">,</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_previous_total_tank_stock_for_second_crop_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function performs the update of the previous total height of</span>

<span class="s2">    transpirable water (previous_total_tank_stock, mm).</span>

<span class="s2">    It will decrease the previous_total_tank_stock depending on the variation of</span>

<span class="s2">    transpirable water and height of humectation front.</span>

<span class="s2">    This update is applied only if a second crop cycle starts, as</span>

<span class="s2">    previous_root_tank_capacity and previous_total_tank_stock are initialized as</span>

<span class="s2">    null. That means conditions 2 and 3 of this function will fail during a</span>

<span class="s2">    first crop cycle, leading to no change in previous_total_tank_stock.</span>

<span class="s2">    In this function, if the variation of transpirable water</span>

<span class="s2">    (delta_total_tank_stock) increases above humectation_front (condition 1</span>

<span class="s2">    passed), and if humectation_front is above the previous_root_tank_capacity</span>

<span class="s2">    (condition failed), and if the depth of humectation front has decreased</span>

<span class="s2">    since the previous day (condition 3 passed), then previous_total_tank_stock</span>

<span class="s2">    equals 0.</span>

<span class="s2">    Starting from second simulation season (previous_root_tank_capacity != 0),</span>

<span class="s2">    if the variation of transpirable water (delta_total_tank_stock) increases</span>

<span class="s2">    above the depth of humectation front (hum), and if the depth of humectation</span>

<span class="s2">    front stays below or equel to the total soil capacity (conditions 1 and 2</span>

<span class="s2">    passed), then we decrease the value of previous_total_tank_stock by a the</span>

<span class="s2">    difference of water height between the variation of total tank stock</span>

<span class="s2">    (delta_total_tank_stock) and the depth of humectation front (hum),</span>

<span class="s2">    proportionally to the filling of the root tank capacity of previous season</span>

<span class="s2">    (previous_root_tank_stock). Thus, if the root tank is empty,</span>

<span class="s2">    previous_total_tank_stock will remain unchanged, and if the root tank is</span>

<span class="s2">    full, previous_total_tank_stock will be decreased up to the amount of water</span>

<span class="s2">    making the difference between quantity of water for humectation front and</span>

<span class="s2">    the variation in daily transpirable water.</span>

<span class="s2">    ? To my opinion, this function is way too complicated for a borderline use case</span>

<span class="s2">    ? (multiple cropping cycles during one simulation).</span>

<span class="s2">    ? We&#39;d want to keep the code for legacy reasons but if really this simulation</span>

<span class="s2">    ? feature is needed we&#39;ll have to simplify it.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">condition_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">condition_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition_1</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="n">condition_2</span><span class="p">,</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">*</span><span class="w"> \</span>

<span class="w">                       </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]),</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">                </span><span class="n">condition_3</span><span class="p">,</span>

<span class="w">                </span><span class="mi">0</span><span class="p">,</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_delta_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    ? Ok the logic is the same as for the two previous functions</span>

<span class="s2">    ? and i don&#39;t want to document it as it is way too complicated</span>

<span class="s2">    ? and we won&#39;t be using it for now.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">condition_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">condition_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition_1</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="n">condition_2</span><span class="p">,</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">                </span><span class="n">condition_3</span><span class="p">,</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">apply_humectation_front_boundaries</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the water height to humectation front</span>

<span class="s2">    (humectation_front, mm) by bounding it between delta_total_tank_stock and</span>

<span class="s2">    total_tank_capacity.</span>

<span class="s2">    That is to say depth of humectation front can only increase, and that</span>

<span class="s2">    humectation front can not go down indefinitely.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the daily drainage (dr).</span>

<span class="s2">    When total tank overflows (total_tank_stock &gt; total_tank_capacity), the</span>

<span class="s2">    drainage is computed from the difference between total_tank_stock and</span>

<span class="s2">    total_tank_capacity. This means the drainage value will be positive</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;drainage&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_total_tank_stock_after_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the total tank stock (total_tank_stock, mm) when these is overflowing.</span>

<span class="s2">    When capacity of total_tank_stock is exceeded, total_tank_stock value is replaced with</span>

<span class="s2">    total_tank_capacity</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_humectation_front_after_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    We update the depth to humectation front (hum) again, to reflect eventual changes in</span>

<span class="s2">    total_tank_stock values.</span>

<span class="s2">    ? we could have placed the previous hum update function here</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This wrapper function aims to regroup computations related to drainage :</span>

<span class="s2">    - update_drainage</span>

<span class="s2">    - update total_tank_stock</span>

<span class="s2">    - update_humectation_front_after_drainage</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_total_tank_stock_after_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_humectation_front_after_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_root_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the height of water in the tank of water accessible to</span>

<span class="s2">    roots (&quot;root_tank_stock&quot;, mm).</span>

<span class="s2">    It increments root_tank_stock with transpirable water (eauTranspi), within</span>

<span class="s2">    the bounds of root_tank_capacity and total_tank_stock.</span>

<span class="s2">    This means the sum of transpirable water and root tank stock for the day</span>

<span class="s2">    firstly cannot be higher than the root tank capacity, which is fine to represent</span>

<span class="s2">    the height of water accessible to roots. But also, that this sum limited by</span>

<span class="s2">    the root tank capacity cannot be higher than the total tank stock, which seems unlikely.</span>

<span class="s2">    ? This raises the question about where does the potential water in excess go.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fill_tanks</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    Translated from the procedure rempliRes, of the original Pascal codes</span>

<span class="s2">    bileau.pas</span>

<span class="s2">    Main hypotheses :</span>

<span class="s2">    - the water dynamics is represented by a filling from the top and an evolution</span>

<span class="s2">    of the reservoirs sizes when the filling is above the maximum quantity of the</span>

<span class="s2">    current size (humectation front).</span>

<span class="s2">    - when the maximum size is reached by filling, it is considered as drainage.</span>

<span class="s2">    - inside a reservoir, water is distributed homogeneously (may be considered</span>

<span class="s2">    valid up to 2m depth, according to CB, from other sources).</span>

<span class="s2">    3 reservoirs are represented:</span>

<span class="s2">    1) a global reservoir, evolving in depth according to the humectation front</span>

<span class="s2">    2) a surface reservoir (fixed size) where evaporation and a part of the</span>

<span class="s2">    transpiration occurs when roots are present</span>

<span class="s2">    3) a root reservoir, evolving according to the root front (when roots are</span>

<span class="s2">    present)</span>

<span class="s2">    REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks</span>

<span class="s2">    Notes from CB, 10/06/2015 :</span>

<span class="s2">    prise en compte de stock d&#39;eau r√©silient pour les simulation continues</span>

<span class="s2">    Hypoth√®se de la MAJ des stock en fn de l&#39;eau rÔøΩsiliente de l&#39;annÔøΩe prÔøΩcÔøΩdente</span>

<span class="s2">    dans le cas des simulations pluri annuelle en continue (NbAn = 1):</span>

<span class="s2">    A la rÔøΩcolte on recupÔøΩre les stock d&#39;eau (StRuPrec), la prof d&#39;Humectation (Humprec)</span>

<span class="s2">    et la prof d&#39;enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien.</span>

<span class="s2">    On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf)</span>

<span class="s2">    Si le StRu avec l&#39;apport d&#39;eau devinet sup au Hum</span>

<span class="s2">    alors on tient compte dans cette augmentation du stock rÔøΩsilient avec deux cas possible :</span>

<span class="s2">    Si StRu est &lt; ÔøΩ stRurMaxprec</span>

<span class="s2">    alors on ajoute l&#39;eau rÔøΩsiliente contenue dans l&#39;ancienne zone racinaire en fn</span>

<span class="s2">    de la diffÔøΩrence de stock</span>

<span class="s2">    Sinon on a de l&#39;eau rÔøΩsiliente au maximum de la CC jusqu&#39;ÔøΩ l&#39;ancienne HumPrec,</span>

<span class="s2">    on rempli alors StRu de la diffÔøΩrence etre ces deux valeurs puis on fait la MAJ</span>

<span class="s2">    des Dr, StRur, Hum etc...</span>

<span class="s2">    ! simplification : we want to simplify the code, and we don&#39;t want to keep the possibility of multiple crop cycles</span>

<span class="s2">    ! we keep the old code for maintainance and future developments though</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// section 1 : updating the end_of_season memory variables</span>

<span class="w">    </span><span class="c1">#// in order to save resources, we test if there is at least one pixel at phase 7</span>

<span class="w">    </span><span class="c1">#// and one pixel at changePhase 1 in the current time step before applying the &quot;end_of_season&quot; functions</span>

<span class="w">    </span><span class="c1">#// if (np.any(data[&quot;numPhase&quot;][j,:,:] == 7)) &amp; (np.any(data[&quot;changePhase&quot;][j,:,:] == 1)):</span>

<span class="w">    </span><span class="c1">#//     data = update_previous_humectation_front_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_humectation_front_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_root_tank_capacity_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_previous_root_tank_stock_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_previous_total_tank_stock_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// we let this function here, conditioned to work for j0 only, but it should be moved into initialization</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reset_total_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Updates the value of water stock in the surface tank (surface_tank_stock,</span>

<span class="w">    </span><span class="c1"># mm) with the water available for the day (available_water, mm), within the</span>

<span class="w">    </span><span class="c1"># limits of 110% surface_tank_capacity.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Estimates the daily height of water available from the surface reservoir</span>

<span class="w">    </span><span class="c1"># for transpiration by the plant (&#39;eauTranspi&#39;, mm). A part of the water</span>

<span class="w">    </span><span class="c1"># available for the day (&#39;eauDispo&#39;) is used to maintain the surface</span>

<span class="w">    </span><span class="c1"># reservoir at a minimum level of 10% of its capacity, as this water is</span>

<span class="w">    </span><span class="c1"># considered as bound to the surface reservoir and cannot be transpired.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_transpirable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Updates the total height of transpirable water (&#39;total_tank_stock&#39;, mm)</span>

<span class="w">    </span><span class="c1"># with the amount of transpirable water for the day (&#39;eauTranspi&#39;, mm)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// delta_total_tank_stock is used with second cycle computations</span>

<span class="w">    </span><span class="c1">#// estimating positive delta between total_root_tank and stRuPrec</span>

<span class="w">    </span><span class="c1">#// data = update_delta_total_tank_stock(j, data)</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged</span>

<span class="w">    </span><span class="c1">#// data = update_total_tank_stock_for_second_crop_cycle(j, data)# verif ok</span>

<span class="w">    </span><span class="c1">#// # # then previous_total_tank_stock can 1) take 0 or 2) be unchanged</span>

<span class="w">    </span><span class="c1">#// data = update_previous_total_tank_stock_for_second_crop_cycle(j, data)</span>

<span class="w">    </span><span class="c1">#// # # delta_total_tank_stock can 1) be incremented of previous_total_tank_stock or 2) be unchanged</span>

<span class="w">    </span><span class="c1">#//data = update_delta_total_tank_stock_step_2(j, data)</span>

<span class="w">    </span><span class="c1">#// # # here, in case 1, In this function, if the variation of transpirable water</span>

<span class="w">    </span><span class="c1">#// # (delta_total_tank_stock) increases above the depth of humectation front</span>

<span class="w">    </span><span class="c1">#// # (hum), if the depth of humectation front (hum) is above the</span>

<span class="w">    </span><span class="c1">#// # previous_root_tank_capacity (condition 1 passed, and 2 failed,</span>

<span class="w">    </span><span class="c1">#// # which should be the case for most of the simulations that will be</span>

<span class="w">    </span><span class="c1">#// # single-season), and if the depth of humectation front (hum) has decreased</span>

<span class="w">    </span><span class="c1">#// # since the previous day (condition 3 passed), then total_tank_stock takes the value of</span>

<span class="w">    </span><span class="c1">#// # delta_total_tank_stock, previous_total_tank_stock equals 0, and</span>

<span class="w">    </span><span class="c1">#// # delta_total_tank_stock is incremented by previous_total_tank_stock.</span>

<span class="w">    </span><span class="c1">#// #</span>

<span class="w">    </span><span class="c1">#// # in case 2, nothing happens.</span>

<span class="w">    </span><span class="c1"># Updates the water height to humectation front (humectation_front, mm) by</span>

<span class="w">    </span><span class="c1"># bounding it between delta_total_tank_stock and total_tank_capacity, so</span>

<span class="w">    </span><span class="c1"># that humectation front cannot go down indefinitely.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apply_humectation_front_boundaries</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># computes drainage</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Updates the height of water in the tank of water accessible to roots</span>

<span class="w">    </span><span class="c1"># (&quot;root_tank_stock&quot;, mm), so that the transpirable water added to the root</span>

<span class="w">    </span><span class="c1"># tank stock for the day cannot be higher than both the root tank capacity,</span>

<span class="w">    </span><span class="c1"># and the total tank stock.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="c1">########################################################################################</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_fesw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the fraction of evaporable soil water (fesw, mm).</span>

<span class="s2">    fesw is defined as the ratio of water stock in the surface tank over 110</span><span class="si">% o</span><span class="s2">f</span>

<span class="s2">    the surface tank capacity.</span>

<span class="s2">    It is adapted from the EvalFESW procedure, from bileau.pas and</span>

<span class="s2">    bhytypeFAO.pas files from the original FORTRAN code.</span>

<span class="s2">    Depuis th√®se Alhassane : &quot;FESW = fraction d&#39;eau √©vaporable dans le sol (en</span>

<span class="s2">    %), calcul√©e √† partir du taux d&#39;humidit√© du sol (en %) √† la capacit√© de</span>

<span class="s2">    r√©tention et 1/2 du taux d&#39;humidit√© du sol au pF 4.2 (Allen et al., 1998)&quot;</span>

<span class="s2">    in Alhassane thesis, FESW = (Stock CR - 0,5 Stock pF 4,2) x H) so is calculated taking only</span>

<span class="s2">    half of the surface reservoir</span>

<span class="s2">    ? Why is it calculated over 110</span><span class="si">% o</span><span class="s2">f surface_tank_capacity ?</span>

<span class="s2">    ? it seems the 110% thingy comes from the update_surface_tank_stock</span>

<span class="s2">    ? function where it is allowed to fill the surface tank up to 110</span><span class="si">% o</span><span class="s2">f its</span>

<span class="s2">    ? capacity. but this does not make se,se to me.</span>

<span class="s2">    ? in this case, fesw can take values between 0 and 1</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1"># data[&quot;fesw&quot;][j,:,:] = data[&quot;surface_tank_stock&quot;][j,:,:] / (1.1 * data[&quot;surface_tank_capacity&quot;])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;fesw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_kce</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the coefficient of evaporation from the soil (kce).</span>

<span class="s2">    This approach takes into consideration three factors acting on limitation of</span>

<span class="s2">    kce :</span>

<span class="s2">    1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover</span>

<span class="s2">    2) Mulch - permanent covering effect : we consider a value of 1.0 for no</span>

<span class="s2">    covering, and 0.0 is full covering with plastic sheet ; this mulch parameter</span>

<span class="s2">    has been used in previous versions of the model where evolution of mulch</span>

<span class="s2">    biomass was not explicitely taken into consideration, can be used in the</span>

<span class="s2">    case of crops with self-mulching phenomena, where a standard mulch parameter</span>

<span class="s2">    value of 0.7 can be applied.</span>

<span class="s2">    3) Mulch - evolutive covering effect BiomMc : biomass of mulch</span>

<span class="s2">    This function has been adapted from EvalKceMC procedure, bileau.pas and</span>

<span class="s2">    exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like</span>

<span class="s2">    it has been adapted from the dual crop coefficient from the FAO56 paper. But</span>

<span class="s2">    this is still to confirm on a point of view of the history of the model.</span>

<span class="s2">    Depuis th√®se Alhassane : &quot;LTR = fraction de radiation non intercept√©e par le</span>

<span class="s2">    couvert = [exp(-k*LAI)] o√π k = coefficient d&#39;extinction de la lumi√®re qui</span>

<span class="s2">    est fonction des propri√©t√©s g√©om√©triques du couvert et LAI = indice de</span>

<span class="s2">    surface foliaire&quot;</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">        paramITK (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;kce&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ltr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;mulch&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> \</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;coefMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;surfMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_soil_potential_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes estimation of potential soil evaporation (mm,</span>

<span class="s2">    evapPot).</span>

<span class="s2">    It performs its computations solely from the evaporation forcing driven by</span>

<span class="s2">    climatic demand, limited by the coefficient of evaporation from the soil</span>

<span class="s2">    (kce).</span>

<span class="s2">    Note : difference in humectation of the top and bottom tanks is not taken</span>

<span class="s2">    into consideration in this approach.  The</span>

<span class="s2">    This function has been adapted from DemandeSol procedure, from bileau.pas</span>

<span class="s2">    and exmodules 1 &amp; 2.pas file from the original FORTRAN code.</span>

<span class="s2">    in Alhassane thesis, EvapPot = Kmulch x ETo x LTR ; here kce = kmulch x LTR so this formalism is respected</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evapPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;kce&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_soil_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes estimation of soil evaporable water (`evap`, mm). It uses</span>

<span class="s2">    the potential soil evaporation (`evapPot`, mm) and the fraction of evaporable soil</span>

<span class="s2">    water (`fesw`), bounded by the `surface_tank_stock` (mm).</span>

<span class="s2">    We remind `fesw` is defined as the ratio of water stock in the surface tank</span>

<span class="s2">    over 110</span><span class="si">% o</span><span class="s2">f the surface tank capacity, meaning it will be equal to 1 when</span>

<span class="s2">    the surface tank is full, and 0 when the surface tank is empty.</span>

<span class="s2">    This approach is somewhat comparable to the soil evaporation reduction</span>

<span class="s2">    coefficient kr approach presented in FAO56 paper, to the exception the soil</span>

<span class="s2">    evaporation reduction coefficient kr is built using two linear functions</span>

<span class="s2">    where the squared fesw approach uses a square function. Furthermore, the kr</span>

<span class="s2">    approach function is build using REW and TEW values that are specific to the</span>

<span class="s2">    type of soil, whereas the squared fesw approach uses a generic function that</span>

<span class="s2">    is not soil specific.</span>

<span class="s2">    in Alhassane thesis, evap is called EVj for &quot;evaporation journani√®re&quot;, and</span>

<span class="s2">    is calculated as Evj = EvapPot x FESW. More details are available in the PhD</span>

<span class="s2">    dissertation of Alhassane https://hdl.handle.net/20.500.12177/1576</span>

<span class="s2">    The `estimate_effective_evaporation_from_evaporable_water` function computed</span>

<span class="s2">    later in the daily cycle uses the `evap` value to determine the effective</span>

<span class="s2">    evaporation (`consoRur`, mm) on the quantity of water in the surface tank</span>

<span class="s2">    (`surface_tank_stock`, mm).</span>

<span class="s2">    It has been adapted from the EvapRuSurf procedure, from bileau.pas and</span>

<span class="s2">    exmodules 1 &amp; 2.pas file from the original FORTRAN code.</span>

<span class="s2">    ? evaporation is bounded by the surface tank stock, which means it is meant</span>

<span class="s2">    ? to happen only in the depth described by the surface_tank</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evapPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;fesw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_soil_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_fesw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_kce</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_soil_potential_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_soil_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_FEMcW_and_update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function calculates the fraction of evaporable water from the mulch</span>

<span class="s2">    (FEMcW).</span>

<span class="s2">    If the mulch water stock is greater than 0, then we compute FEMcW, which we</span>

<span class="s2">    consider to be equal to the filling ratio of the mulch water capacity. We</span>

<span class="s2">    then update the mulch water stock by removing the water height equivalent to</span>

<span class="s2">    the climate forcing demand, modulated by FEMcW and the plant cover (ltr).</span>

<span class="s2">    This function is adapted from the procedure EvapMC, from bileau.pas and</span>

<span class="s2">    exmodules 2.pas file from the original FORTRAN code.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">        paramITK (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;FEMcW&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="c1">#! inverting the fraction to get stock over capacity, and not the other way round</span>

<span class="w">        </span><span class="c1">#// (paramITK[&quot;humSatMc&quot;] * data[&quot;biomMc&quot;][j,:,:] * 0.001) / data[&quot;stockMc&quot;][j,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;humSatMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;FEMcW&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="c1">#! removing the power of 2 in the equation</span>

<span class="w">        </span><span class="c1">#// data[&quot;stockMc&quot;][j,:,:] - data[&quot;ltr&quot;][j,:,:] * data[&quot;ET0&quot;][j,:,:] * data[&quot;FEMcW&quot;][j,:,:]**2,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ltr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;FEMcW&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_ftsw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the fraction of transpirable soil water (ftsw) from</span>

<span class="s2">    the root reservoir.</span>

<span class="s2">    It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 &amp;</span>

<span class="s2">    2.pas, risocas.pas, riz.pas files from the original FORTRAN code.</span>

<span class="s2">    d&#39;apr√®s alhassane thesis, &quot;La fraction d&#39;eau transpirable par la plante ou</span>

<span class="s2">    &quot;fraction of transpirable soil water (FTSW)&quot; a √©t√© calcul√©e une fois par</span>

<span class="s2">    semaine durant le cycle de la vari√©t√© : FTSW = ((Stock - pF4.2)/(RU x</span>

<span class="s2">    profondeur racinaire)) x profondeur racinaire Avec : Stock = stock d&#39;eau du</span>

<span class="s2">    sol dans la zone racinaire (mm), pF4.2 = point de fl√©trissement et RU =</span>

<span class="s2">    r√©serve utile (mm/msol). Ces variables sont fonction de la profondeur</span>

<span class="s2">    racinaire, donc de la croissance de la culture&quot;</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ftsw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_potential_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes the potential transpiration from the plant.</span>

<span class="s2">    Computation is based on the climate forcing (ET0), as well as the kcp coefficient.</span>

<span class="s2">    This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and</span>

<span class="s2">    exmodules 1 &amp; 2.pas files from the original FORTRAN code.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1"># ggroup 51</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcp&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="c1"># def estimate_kcTot(j, data):</span>

<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     This function computes the total kc coefficient.</span>

<span class="c1">#     Computation is based on the kcp (transpiration coefficient) and kce</span>

<span class="c1">#     (evaporation from the soil) coefficients. Where the crop coefficient is 0</span>

<span class="c1">#     (meaning that there was no emergence yet), kcTot takes the value of kce.</span>

<span class="c1">#     This function is based on the EvalKcTot procedure, from the bileau.pas and</span>

<span class="c1">#     exmodules 1 &amp; 2.pas files, from the original FORTRAN code.</span>

<span class="c1">#     #! Note : code has been modified to match the original SARRA-H behavior.</span>

<span class="c1">#     #! The kcTot function is computed but not used anywhere</span>

<span class="c1">#     Args:</span>

<span class="c1">#         j (_type_): _description_</span>

<span class="c1">#         data (_type_): _description_</span>

<span class="c1">#     Returns:</span>

<span class="c1">#         _type_: _description_</span>

<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     # added a condition on 19/08/22 to match SARRA-H original behavior</span>

<span class="c1">#     data[&quot;kcTot&quot;][j,:,:] = np.where(</span>

<span class="c1">#         data[&quot;kcp&quot;][j,:,:] == 0.0,</span>

<span class="c1">#         data[&quot;kce&quot;][j,:,:],</span>

<span class="c1">#         data[&quot;kce&quot;][j,:,:] + data[&quot;kcp&quot;][j,:,:],</span>

<span class="c1">#     )</span>

<span class="c1">#     return data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_pFact</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;_summary_</span>

<span class="s2">    This function computes the pFactor, which is a bound coefficient used in the</span>

<span class="s2">    computation of cstr from ftsw. This coefficient delimits the portion of the</span>

<span class="s2">    FTSW below which water stress starts to influence the transpiration.</span>

<span class="s2">    FAO reference for critical FTSW value for transpiration response (0 =</span>

<span class="s2">    stomata respond immediately if FTSW&lt;1; 0.5 for most of the crops)</span>

<span class="s2">    pFact is bounded in [0.1, 0.8].</span>

<span class="s2">    For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf</span>

<span class="s2">    This function is based on the CstrPFactor procedure, from bileau.pas,</span>

<span class="s2">    exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</span>

<span class="s2">    d&#39;apr√®s alhassane :</span>

<span class="s2">    &quot;Selon Allen et al., (1998), on peut √©galement appliquer la m√©thode de</span>

<span class="s2">    calculs d√©velopp√©e par la FAO, dite du pFactor, bas√©e sur les notions de</span>

<span class="s2">    r√©serve d&#39;eau facilement utilisable (RFU) et difficilement utilisable (RDU)</span>

<span class="s2">    d√©finies par un point d&#39;inflexion, si on consid√®re que la dynamique de</span>

<span class="s2">    consommation hydrique de la plante diff√®re selon la demande climatique (ETo)</span>

<span class="s2">    et la fraction d&#39;eau du sol transpirable (FTSW). En effet, pfactor est un</span>

<span class="s2">    coefficient utilis√© pour le calcul du taux de transpiration et qui s&#39;obtient</span>

<span class="s2">    en divisant la r√©serve d&#39;eau du sol utilisable par les racines par la</span>

<span class="s2">    r√©serve totale disponible dans la zone racinaire de la plante (Allen et al.,</span>

<span class="s2">    1998). On l&#39;obtient √©galement par la formule suivante :</span>

<span class="s2">    pfactor = parP + 0,04 x (5 - ETM)</span>

<span class="s2">    Avec : parP = param√®tre sp√©cifique √†</span>

<span class="s2">    l&#39;esp√®ce, qui exprime le seuil critique d&#39;humidit√© du sol √† partir duquel le</span>

<span class="s2">    stress hydrique r√©duit lin√©airement la transpiration (Doorenbos et Kassam,</span>

<span class="s2">    1979).&quot;</span>

<span class="s2">    #! this function seems quite arbitrary and would need verifications regarding the underlying assumptions</span>

<span class="s2">    ok so this function comes from FAO56 paper, https://www.fao.org/3/x0490e/x0490e0e.htm#chapter</span><span class="si">%208%</span><span class="s2">20</span><span class="si">%20%</span><span class="s2">20etc</span><span class="si">%20u</span><span class="s2">nder</span><span class="si">%20s</span><span class="s2">oil%20water</span><span class="si">%20s</span><span class="s2">tress</span><span class="si">%20c</span><span class="s2">onditions</span>

<span class="s2">    table 22 annex 2</span>

<span class="s2">    FAO56 uses the RAW/TAW formalism where RAW = p TAW</span>

<span class="s2">    with TAW being the total available water in the root zone TAW = 1000(q FC - q WP) Zr</span>

<span class="s2">    corresponding to the root tank capacity</span>

<span class="s2">    and RAW being calculated as RAW = p TAW</span>

<span class="s2">    p average fraction of Total Available Soil Water (TAW) that can be depleted from the root zone before moisture stress (reduction in ET) occurs</span>

<span class="s2">    &quot;A value of 0.50 for p is commonly used for many crops&quot;</span>

<span class="s2">    &quot;A numerical approximation for adjusting p for ETc rate is p = pTable 22 + 0.04 (5 - ETc) where the adjusted p is limited to 0.1 ¬£ p ¬£ 0.8 and ETc is in mm/day&quot;</span>

<span class="s2">    in the legacy code, ETc is computed with np.maximum(data[&quot;kcp&quot;][j,:,:], 1) * data[&quot;ET0&quot;][j,:,:]</span>

<span class="s2">    however why is kcp bound to 1 ?</span>

<span class="s2">    there seem to be no reason of keeping this bound.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">        paramVariete (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1"># we keep these lines for legacy reference</span>

<span class="w">    </span><span class="c1"># data[&quot;pFact&quot;][j:,:,:] = paramVariete[&quot;PFactor&quot;] + \</span>

<span class="w">    </span><span class="c1">#     0.04 * (5 - np.maximum(data[&quot;kcp&quot;][j,:,:], 1) * data[&quot;ET0&quot;][j,:,:])</span>

<span class="w">    </span><span class="c1"># adjustinf pfactor</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PFactor&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.04</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcp&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="c1"># group 54</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">            </span><span class="mf">0.1</span><span class="p">,</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="mf">0.8</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_cstr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes the water stress coefficient cstr.</span>

<span class="s2">    It uses ftsw and pFact. cstr is bounded in [0, 1].</span>

<span class="s2">    This function is based on the CstrPFactor procedure, from bileau.pas,</span>

<span class="s2">    exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</span>

<span class="s2">    in FAO56 paper RAW being calculated as RAW = p TAW and TAW is</span>

<span class="s2">    p average fraction of Total Available Soil Water (TAW) that can be depleted from the root zone before moisture stress (reduction in ET) occurs</span>

<span class="s2">    donc pour avoir la proportion de remplissage correspondant √† la limite de stress hydrique, il faut faire</span>

<span class="s2">    1 - pFact</span>

<span class="s2">    et donc quand ftsw est inf√©rieur √† 1 - pFact, on est en stress hydrique et cstr est inf√©rieur √† 1</span>

<span class="s2">    et quand ftsw est au dessus de 1 - pFact, on est pas en stress hydrique et cstr est √©gal √† 1</span>

<span class="s2">    en fait cstr correspond au coefficient Ks de FAO56 (figure 42 FAO56)</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1">#group 55</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ftsw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])),</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># group 56</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function computes the adjusted plant transpiration (tr, mm) from the</span>

<span class="s2">    plant, by adjusting the potential transpiration (trPot, mm) with cstr.</span>

<span class="s2">    This function adjusts the potential transpiration (trPot, mm) that was</span>

<span class="s2">    calculated through trPot = kcp * ET0, by adding the stress coefficient cstr</span>

<span class="s2">    (that corresponds to Ks in the FAO56 paper) Thus we obtain an adjusted plant</span>

<span class="s2">    transpiration tr, which corresponds to ETc_adj in the FAO56 (see equation</span>

<span class="s2">    80).</span>

<span class="s2">    This function is based on the EvalTranspi procedure, from bileau.pas,</span>

<span class="s2">    bhytypeFAO.pas, exmodules 1 &amp; 2.pas, from the original FORTRAN code.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">):</span>

<span class="w">    </span><span class="c1"># we can take out the estimate_kcTot function</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_ftsw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_kcp</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_potential_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1">#// data = estimate_kcTot(j, data)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_pFact</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramVariete</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_cstr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">set_evapotranspirable_surface_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function stores the initial value of `surface_tank_stock` in a new</span>

<span class="s2">    variable representing the quantity of evapotranspirable surface water (`trSurf`,</span>

<span class="s2">    mm), as the value `surface_tank_stock` will later be updated.</span>

<span class="s2">    The original function (based on the ConsoResSep procedure, from bileau.pas,</span>

<span class="s2">    exmodules 1 &amp; 2.pas files, from the original FORTRAN code) removed 1/10th of</span>

<span class="s2">    surface tank capacity as water was condidered as bound to the soil.</span>

<span class="s2">    However, as we are working with the water volumes in between permanent</span>

<span class="s2">    wilting point and field capacity - thus already considering water bound to</span>

<span class="s2">    the soil, we will remove all of these arbitrary 10</span><span class="si">% c</span><span class="s2">orrections.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="c1">#// data[&quot;surface_tank_stock&quot;][j,:,:] - data[&quot;surface_tank_capacity&quot;] * 0.1,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subtract_evap_from_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the water stock of the surface tank</span>

<span class="s2">    (`surface_tank_stock`, mm) by subtracting the daily amount of evaporation</span>

<span class="s2">    (`evap`, mm) from it.</span>

<span class="s2">    `evap` is calculated in the `estimate_soil_evaporation` function earlier in</span>

<span class="s2">    the daily loop from the potential soil evaporation (`evapPot`, mm) and the</span>

<span class="s2">    fraction of evaporable soil water (`fesw`), and cannot exceed the value of</span>

<span class="s2">    `surface_tank_stock`. This approach is somewhat comparable to the soil</span>

<span class="s2">    evaporation reduction coefficient kr approach presented in FAO56 paper. See</span>

<span class="s2">    documentation of the `estimate_soil_evaporation` function for further</span>

<span class="s2">    details.</span>

<span class="s2">    #? As `evap` cannot exceed the value of `surface_tank_stock` according to the</span>

<span class="s2">    #? `estimate_soil_evaporation` function and is not modified until this function</span>

<span class="s2">    #? is applied, it is funny to see that the</span>

<span class="s2">    #? `subtract_evap_from_surface_tank_stock` function enforces</span>

<span class="s2">    #? `surface_tank_stock` not to take a negative value. Hence, we could probably</span>

<span class="s2">    #? simplify this function.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">estimate_effective_evaporation_from_evaporable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function estimates the effective evaporation (`consoRur`, mm) from the</span>

<span class="s2">    evaporable water (`evap`, mm) limited by the evapotranspirable surface water</span>

<span class="s2">    (`trSurf`, mm).</span>

<span class="s2">    If `evap` is higher than the quantity of water in the surface tank at the</span>

<span class="s2">    beginning of the daily cycle/before evaporation (`trSurf`), meaning that</span>

<span class="s2">    evaporation will deplete the surface water tank, then water consumption</span>

<span class="s2">    shall take the value of `trSurf`.</span>

<span class="s2">    Else, `consoRur` equals `evap`.</span>

<span class="s2">    It is a way to bound the water consumption by the water available in the</span>

<span class="s2">    surface tank.</span>

<span class="s2">    #? the name of this function is not that great. thinking about something</span>

<span class="s2">    #? about evaporation demand vs evaporated water</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subtract_effective_evaporation_from_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the total quantity of water (`total_tank_stock`, mm)</span>

<span class="s2">    by subtracting the effective evaporation (`consoRur`, mm).</span>

<span class="s2">    `total_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    #? though it seems impossible to have a negative value of `total_tank_stock`</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_effective_evaporation_for_shallow_roots</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the value of effective evaporation (`consoRur`, mm) in</span>

<span class="s2">    order to be used specifically to update the quantity of water in the root</span>

<span class="s2">    tank (`root_tank_stock`, mm).</span>

<span class="s2">    If the root tank capacity is lower than the surface tank capacity, meaning</span>

<span class="s2">    than the roots do not dive into the deep tank yet, then the effective</span>

<span class="s2">    evaporation is updated to equal the evaporable water (`evap`, mm) modulated</span>

<span class="s2">    by the ratio between `root_tank_stock` and `surface_tank_capacity`, that is</span>

<span class="s2">    to say at the prorata of the exploration of surface tank by the roots.</span>

<span class="s2">    Else, `consoRur` keeps it value, which was previously computed by the</span>

<span class="s2">    `estimate_effective_evaporation_from_evaporable_water` function.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subtract_effective_evaporation_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the quantity of water in the root tank</span>

<span class="s2">    (`root_tank_stock`, mm) according to the effective evaporation, taking into</span>

<span class="s2">    consideration potential shallow rooting ( as `consoRur` was calculated</span>

<span class="s2">    through both `estimate_effective_evaporation_from_evaporable_water` and</span>

<span class="s2">    `update_effective_evaporation_for_shallow_roots` functions).</span>

<span class="s2">    `root_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">update_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the value of plant transpiration (`tr`, mm) according</span>

<span class="s2">    to the quantity of water in the root tank (`root_tank_stock`, mm).</span>

<span class="s2">    If the transpiration (which as this point on the daily cycle equals `trPot *</span>

<span class="s2">    cstr`) is higher than the root tank stock (which at this point has been</span>

<span class="s2">    updated to reflect the effective evaporation), then plant transpiration is</span>

<span class="s2">    updated to be equal to the difference between the root tank stock and the</span>

<span class="s2">    plant transpiration.</span>

<span class="s2">    Else, its value is unmodified.</span>

<span class="s2">    #? However, if this test is true, this always leads to transpiration value = 0.</span>

<span class="s2">    #? We may want to rethink it to check if it does what it was supposed to.</span>

<span class="s2">    #? Instead it would make more sense to bound tr by the value of root tank stock,</span>

<span class="s2">    #? meaning the maximum quantity of water that can be transpired by the plant</span>

<span class="s2">    #? is limited by the quantity of water accessible to roots...</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>

<span class="w">        </span><span class="c1">#! il peut √™tre int√©ressant d&#39;introduire dans la prochaine version</span>

<span class="w">        </span><span class="c1">#! le correctif suivant :</span>

<span class="w">        </span><span class="c1"># data[&quot;root_tank_stock&quot;][j,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the surface tank stock to reflect plant transpiration,</span>

<span class="s2">    in accordance with the repartition of water between surface and root tanks.</span>

<span class="s2">    If `root_tank_stock` is above 0, then `surface_tank_stock` is updated by</span>

<span class="s2">    subtracting the plant transpiration modulated by the ratio between the</span>

<span class="s2">    transpirable water `trSurf` (representing the amount of water in surface</span>

<span class="s2">    tank at the beginning of the day) and the root tank stock.</span>

<span class="s2">    This ratio is bounded by 1, meaning that if there is a higher quantity of</span>

<span class="s2">    transpirable water that water accessible to roots, then the ratio is set to</span>

<span class="s2">    1, and `surface_tank_stock` will be updated by being subtracted by `tr`.</span>

<span class="s2">    On the contrary, if transpirable water `trSurf` is much lower than the root</span>

<span class="s2">    tank stock, meaning that there is a lot of water accessible to roots but</span>

<span class="s2">    this water is in the deep tank, then the ratio will be close to 0, and the</span>

<span class="s2">    `surface_tank_stock` will be updated by being subtracted by a very low value</span>

<span class="s2">    of `tr`.</span>

<span class="s2">    #? The rules and underlying assumptions for these transfers seem somewhat</span>

<span class="s2">    #? arbitrary, so we want to be cautious about them.</span>

<span class="s2">    #? Also, it is not clear why we use trSurf instead of surface_tank_stock</span>

<span class="s2">    #? in the calculations.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">                </span><span class="mi">1</span><span class="p">,</span>

<span class="w">            </span><span class="p">)),</span>

<span class="w">            </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subtract_transpiration_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the quantity of water in the root tank</span>

<span class="s2">    (`root_tank_stock`, mm) by subtracting the plant transpiration (`tr`, mm)</span>

<span class="s2">    from it.</span>

<span class="s2">    `root_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subtract_transpiration_from_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function updates the total quantity of water (`total_tank_stock`, mm)</span>

<span class="s2">    by subtracting the plant transpiration (`tr`, mm) from it.</span>

<span class="s2">    `total_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>

<span class="c1"># def update_etr_etm(j, data):</span>

<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     This function computes etm and etr values.</span>

<span class="c1">#     #? However they are not used anywhere else in the code.</span>

<span class="c1">#     #? We may want to deprecate it.</span>

<span class="c1">#     Args:</span>

<span class="c1">#         j (_type_): _description_</span>

<span class="c1">#         data (_type_): _description_</span>

<span class="c1">#     Returns:</span>

<span class="c1">#         _type_: _description_</span>

<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     data[&quot;etr&quot;][j:,:,:] = (data[&quot;tr&quot;][j,:,:] + data[&quot;evap&quot;][j,:,:]).copy()</span>

<span class="c1">#     data[&quot;etm&quot;][j:,:,:] = (data[&quot;trPot&quot;][j,:,:] + data[&quot;evapPot&quot;][j,:,:]).copy()</span>

<span class="c1">#     return data</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ConsoResSep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    This function is a wrapper function, that calls all the functions that take</span>

<span class="s2">    part into the calculation of the water consumption from the soil, hence the</span>

<span class="s2">    different tanks represented by the model.</span>

<span class="s2">    It is based on the ConsoResSep procedure, from bileau.pas original source</span>

<span class="s2">    code. The general spirit of separation of evaporation from transpiration is</span>

<span class="s2">    probably based on the FAO56 paper, but the formalism is different.</span>

<span class="s2">    A few notes on the original assumptions behind these processes :</span>

<span class="s2">    - The order in which the different computations are done is based on the</span>

<span class="s2">    hypothesis that evaporation is the fastest process, and that it will deplete</span>

<span class="s2">    the surface tank stock first.</span>

<span class="s2">    - As surface tank and root tank overlap, we need to take into consideration</span>

<span class="s2">    the effect of the water already depleted by evaporation on the root tank</span>

<span class="s2">    stock.</span>

<span class="s2">    - When root tank depth is lower than surface tank depth, we only evaporate</span>

<span class="s2">    the fraction of water corresponding to the root tank depth over the surface</span>

<span class="s2">    tank depth.</span>

<span class="s2">    Previous notes also stated that as the computations are done separately for</span>

<span class="s2">    evaporation and transpiration, we could end up with a water consumption</span>

<span class="s2">    slightly higher than the available water. In this case, we would decrease</span>

<span class="s2">    transpiration accordingly. However, this statement is dubious as this</span>

<span class="s2">    behavior does not seem to be implemented in the code.</span>

<span class="s2">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">set_evapotranspirable_surface_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtract_evap_from_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_effective_evaporation_from_evaporable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtract_effective_evaporation_from_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_effective_evaporation_for_shallow_roots</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtract_effective_evaporation_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtract_transpiration_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subtract_transpiration_from_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1">#// data = update_etr_etm(j, data)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h2 id="functions">Functions</h2>
<h3 id="consoressep">ConsoResSep</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">ConsoResSep</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function is a wrapper function, that calls all the functions that take</p>
<p>part into the calculation of the water consumption from the soil, hence the
different tanks represented by the model.</p>
<p>It is based on the ConsoResSep procedure, from bileau.pas original source
code. The general spirit of separation of evaporation from transpiration is
probably based on the FAO56 paper, but the formalism is different.</p>
<p>A few notes on the original assumptions behind these processes : </p>
<ul>
<li>The order in which the different computations are done is based on the
hypothesis that evaporation is the fastest process, and that it will deplete
the surface tank stock first.</li>
<li>As surface tank and root tank overlap, we need to take into consideration
the effect of the water already depleted by evaporation on the root tank
stock.</li>
<li>When root tank depth is lower than surface tank depth, we only evaporate 
the fraction of water corresponding to the root tank depth over the surface
tank depth.</li>
</ul>
<p>Previous notes also stated that as the computations are done separately for
evaporation and transpiration, we could end up with a water consumption
slightly higher than the available water. In this case, we would decrease
transpiration accordingly. However, this statement is dubious as this
behavior does not seem to be implemented in the code.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">ConsoResSep</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function is a wrapper function, that calls all the functions that take</span>

<span class="s">    part into the calculation of the water consumption from the soil, hence the</span>

<span class="s">    different tanks represented by the model.</span>

<span class="s">    It is based on the ConsoResSep procedure, from bileau.pas original source</span>

<span class="s">    code. The general spirit of separation of evaporation from transpiration is</span>

<span class="s">    probably based on the FAO56 paper, but the formalism is different.</span>

<span class="s">    A few notes on the original assumptions behind these processes :</span>

<span class="s">    - The order in which the different computations are done is based on the</span>

<span class="s">    hypothesis that evaporation is the fastest process, and that it will deplete</span>

<span class="s">    the surface tank stock first.</span>

<span class="s">    - As surface tank and root tank overlap, we need to take into consideration</span>

<span class="s">    the effect of the water already depleted by evaporation on the root tank</span>

<span class="s">    stock.</span>

<span class="s">    - When root tank depth is lower than surface tank depth, we only evaporate</span>

<span class="s">    the fraction of water corresponding to the root tank depth over the surface</span>

<span class="s">    tank depth.</span>

<span class="s">    Previous notes also stated that as the computations are done separately for</span>

<span class="s">    evaporation and transpiration, we could end up with a water consumption</span>

<span class="s">    slightly higher than the available water. In this case, we would decrease</span>

<span class="s">    transpiration accordingly. However, this statement is dubious as this</span>

<span class="s">    behavior does not seem to be implemented in the code.</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">set_evapotranspirable_surface_water</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">subtract_evap_from_surface_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">estimate_effective_evaporation_from_evaporable_water</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">subtract_effective_evaporation_from_total_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">update_effective_evaporation_for_shallow_roots</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">subtract_effective_evaporation_from_root_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">update_plant_transpiration</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">subtract_transpiration_from_root_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">subtract_transpiration_from_total_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="err">#</span><span class="c1">// data = update_etr_etm(j, data)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="evolrurcstr2">EvolRurCstr2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">EvolRurCstr2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function is a legacy wrapper for the functions related to the</p>
<p>calculation of the root tank capacity and stock.</p>
<p>It has been translated from the procedure EvolRurCstr2, of the original
Pascal codes bileau.pas.</p>
<p>Notes from CB, 10/06/2015 :
Stress trop fort enracinement
Trop d'effet de stress en tout d√©but de croissance :
1) la plantule a des r√©serves et favorise l'enracinement
2) dynamique sp√©cifique sur le r√©servoir de surface
Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement
est sup√©rieur √© la profondeur du r√©servoir de surface. Effet stres a un
effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de
cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur
la vitesse) La vitesse d'enracinement potentielle de la plante peut etre
bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est
convertie en quantite d'eau maximum equivalente</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code>def EvolRurCstr2(j, data, paramITK):

    &quot;&quot;&quot;

    This function is a legacy wrapper for the functions related to the

    calculation of the root tank capacity and stock.

    It has been translated from the procedure EvolRurCstr2, of the original

    Pascal codes bileau.pas.

    Notes from CB, 10/06/2015 :

    Stress trop fort enracinement

    Trop d&#39;effet de stress en tout d√©but de croissance :

    1) la plantule a des r√©serves et favorise l&#39;enracinement

    2) dynamique sp√©cifique sur le r√©servoir de surface

    Cet effet stress sur l&#39;enracinement ne s&#39;applique que quand l&#39;enracinement

    est sup√©rieur √© la profondeur du r√©servoir de surface. Effet stres a un

    effet sur la vitesse de prof d&#39;enracinement au dessus d&#39;un certain seuil de

    cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur

    la vitesse) La vitesse d&#39;enracinement potentielle de la plante peut etre

    bloque par manque d&#39;eau en profondeur (Hum). La profondeur d&#39;humectation est

    convertie en quantite d&#39;eau maximum equivalente

    &quot;&quot;&quot;

    data = initialize_root_tank_capacity(j, data, paramITK)

    data = initialize_delta_root_tank_capacity(j, data)

    data = update_delta_root_tank_capacity(j, data)

    data = update_root_tank_capacity(j, data)

    data = update_root_tank_stock(j, data) #! we keep this function for now even though it is probably wrong, it will need further screening

    return data
</code></pre></div>

</details>
<h3 id="initplotmc">InitPlotMc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">InitPlotMc</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">grid_width</span><span class="p">,</span>
    <span class="n">grid_height</span><span class="p">,</span>
    <span class="n">paramITK</span><span class="p">,</span>
    <span class="n">paramTypeSol</span><span class="p">,</span>
    <span class="n">duration</span>
<span class="p">)</span>
</code></pre></div>

<p>Initializes variables related to crop residues boimass (mulch) in the data</p>
<p>xarray dataset. This code has been adapted from the original InitPlotMc
procedure, Bileau.pas code. Comments with tab indentation are from the
original code. As the rain is the first variable to be initialized in the
data xarray dataset, its dimensions are used to initialize the other
variables.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">InitPlotMc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">grid_width</span><span class="p">,</span><span class="w"> </span><span class="n">grid_height</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramTypeSol</span><span class="p">,</span><span class="w"> </span><span class="n">duration</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initializes variables related to crop residues boimass (mulch) in the data</span>

<span class="sd">    xarray dataset. This code has been adapted from the original InitPlotMc</span>

<span class="sd">    procedure, Bileau.pas code. Comments with tab indentation are from the</span>

<span class="sd">    original code. As the rain is the first variable to be initialized in the</span>

<span class="sd">    data xarray dataset, its dimensions are used to initialize the other</span>

<span class="sd">    variables.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1"># Soil maximum water storage capacity (mm)</span>

<span class="w">    </span><span class="c1"># Capacit√© maximale de la RU (mm)</span>

<span class="w">    </span><span class="c1">#   StRurMax := Ru * ProfRacIni / 1000;</span>

<span class="w">    </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;] = data[&quot;ru&quot;] * paramITK[&quot;profRacIni&quot;] / 1000</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Soil maximum water storage capacity&quot;}</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Soil maximum water storage capacity&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Maximum water capacity of surface tank (mm)</span>

<span class="w">    </span><span class="c1"># Reserve utile de l&#39;horizon de surface (mm)</span>

<span class="w">    </span><span class="c1">#   RuSurf := EpaisseurSurf / 1000 * Ru;</span>

<span class="w">    </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

<span class="w">    </span><span class="c1">#// data[&quot;ruSurf&quot;] = data[&quot;epaisseurSurf&quot;] / 1000 * data[&quot;ru&quot;]</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="c1">#// data[&quot;ruSurf&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Maximum water capacity of surface tank&quot;}</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Maximum water capacity of surface tank&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># ?</span>

<span class="w">    </span><span class="c1">#   //    PfTranspi := EpaisseurSurf * HumPf;</span>

<span class="w">    </span><span class="c1">#   //    StTot := StockIniSurf - PfTranspi/2 + StockIniProf;</span>

<span class="w">    </span><span class="c1">#   StTot := StockIniSurf  + StockIniProf;</span>

<span class="w">    </span><span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniSurf&quot;] + paramTypeSol[&quot;stockIniProf&quot;]))</span>

<span class="w">    </span><span class="c1">#! modifi√© pour faire correspondre les r√©sultats de simulation, √† remettre en place pour un calcul correct d√®s que possible</span>

<span class="w">    </span><span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniProf&quot;]))</span>

<span class="w">    </span><span class="c1">#! renaming stTot to total_tank_stock</span>

<span class="w">    </span><span class="c1">#// data[&quot;stTot&quot;] = data[&quot;stockIniProf&quot;]</span>

<span class="w">    </span><span class="c1">#//data[&quot;total_tank_stock&quot;] = data[&quot;stockIniProf&quot;]</span>

<span class="w">    </span><span class="c1">#! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;stockIniProf&quot;</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="w">    </span><span class="c1">#// data[&quot;stTot&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;?&quot;}</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;?&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Soil maximal depth (mm)</span>

<span class="w">    </span><span class="c1"># Profondeur maximale de sol (mm)</span>

<span class="w">    </span><span class="c1">#   ProfRU := EpaisseurSurf + EpaisseurProf;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurProf&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Soil maximal depth&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Maximum water capacity to humectation front (mm)</span>

<span class="w">    </span><span class="c1"># Quantit√© d&#39;eau maximum jusqu&#39;au front d&#39;humectation (mm)</span>

<span class="w">    </span><span class="c1">#   // modif 10/06/2015  resilience stock d&#39;eau</span>

<span class="w">    </span><span class="c1">#   // Front d&#39;humectation egal a RuSurf trop de stress initial</span>

<span class="w">    </span><span class="c1">#   //    Hum := max(StTot, StRurMax);</span>

<span class="w">    </span><span class="c1">#   Hum := max(RuSurf, StRurMax);</span>

<span class="w">    </span><span class="c1">#   // Hum mis a profRuSurf</span>

<span class="w">    </span><span class="c1">#   Hum := max(StTot, Hum);</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">grid_width</span><span class="p">,</span><span class="w"> </span><span class="n">grid_height</span><span class="p">),</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">                </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

<span class="w">                </span><span class="c1">#// data[&quot;ruSurf&quot;],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span><span class="n">duration</span><span class="p">}),</span>

<span class="w">                </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span>

<span class="w">                </span><span class="c1">#// data[&quot;stRurMax&quot;],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">            </span><span class="c1">#! renaming stTot with total_tank_stock</span>

<span class="w">            </span><span class="c1">#// data[&quot;stTot&quot;],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="p">)</span>

<span class="w">    </span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Maximum water capacity to humectation front&quot;</span><span class="p">}</span>

<span class="w">    </span><span class="c1"># Previous value for Maximum water capacity to humectation front (mm)</span>

<span class="w">    </span><span class="c1">#  HumPrec := Hum;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="c1"># ?</span>

<span class="w">    </span><span class="c1">#   StRurPrec := 0;</span>

<span class="w">    </span><span class="c1"># Previous value for stTot</span>

<span class="w">    </span><span class="c1">#   StRurMaxPrec := 0;</span>

<span class="w">    </span><span class="c1">#   //modif 10/06/2015 resilience stock d&#39;eau</span>

<span class="w">    </span><span class="c1">#! renaming stTot with total_tank_stock</span>

<span class="w">    </span><span class="c1">#! renaminog stRuPrec with previous_total_tank_stock</span>

<span class="w">    </span><span class="c1">#// data[&quot;stRuPrec&quot;] =  data[&quot;stTot&quot;]</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="apply_humectation_front_boundaries">apply_humectation_front_boundaries</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">apply_humectation_front_boundaries</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the water height to humectation front</p>
<p>(humectation_front, mm) by bounding it between delta_total_tank_stock and
total_tank_capacity.</p>
<p>That is to say depth of humectation front can only increase, and that
humectation front can not go down indefinitely.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">apply_humectation_front_boundaries</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the water height to humectation front</span>

<span class="s">    (humectation_front, mm) by bounding it between delta_total_tank_stock and</span>

<span class="s">    total_tank_capacity.</span>

<span class="s">    That is to say depth of humectation front can only increase, and that</span>

<span class="s">    humectation front can not go down indefinitely.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="compute_daily_irrigation">compute_daily_irrigation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_daily_irrigation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the total daily irrigation</p>
<p>If the simulation is run with automatic irrigation mode
(<code>data["irrigAuto"]==True</code>), if the current phase is between 0 and 6, and if
the filling rate the irrigation tank is below the target filling value
(<code>irrigAutoTarget</code>, decimal percentage), we first compute 90% of the
difference between the current volume of water in the irrigation tank
(<code>irrigation_tank_stock</code>) and the total capacity of the irrigation tank
(<code>irrigation_tank_capacity</code>), bounded by a minimum of 0 and a maximum of
<code>maxIrrig</code>. This computed value represents the amount of water to be added
to the irrigation tank. If the above conditions are not met, the computed
value is 0.</p>
<p>Then, we calculate the total irrigation of the day by summing the estimated
irrigation need (<code>irrigation</code>) with the previous irrigation history of the
day (<code>irrigTotDay</code>).</p>
<p>Note : the logic of this function has not yet been validated in SARRA-Py, as
simulations are mainly based on rainfed conditions.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>None</td>
<td>An integer representing the current day.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>None</td>
<td>A xarray dataset.</td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td>None</td>
<td>A dictionary of parameters.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>A xarray dataset with the updated irrigationTotDay field.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">compute_daily_irrigation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function computes the total daily irrigation</span>

<span class="s2">    If the simulation is run with automatic irrigation mode</span>

<span class="s2">    (`data[&quot;</span><span class="n">irrigAuto</span><span class="s2">&quot;]==True`), if the current phase is between 0 and 6, and if</span>

<span class="s2">    the filling rate the irrigation tank is below the target filling value</span>

<span class="s2">    (`irrigAutoTarget`, decimal percentage), we first compute 90% of the</span>

<span class="s2">    difference between the current volume of water in the irrigation tank</span>

<span class="s2">    (`irrigation_tank_stock`) and the total capacity of the irrigation tank</span>

<span class="s2">    (`irrigation_tank_capacity`), bounded by a minimum of 0 and a maximum of</span>

<span class="s2">    `maxIrrig`. This computed value represents the amount of water to be added</span>

<span class="s2">    to the irrigation tank. If the above conditions are not met, the computed</span>

<span class="s2">    value is 0.</span>

<span class="s2">    Then, we calculate the total irrigation of the day by summing the estimated</span>

<span class="s2">    irrigation need (`irrigation`) with the previous irrigation history of the</span>

<span class="s2">    day (`irrigTotDay`).</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on rainfed conditions.</span>

<span class="s2">    Args:</span>

<span class="s2">        j: An integer representing the current day.</span>

<span class="s2">        data: A xarray dataset.</span>

<span class="s2">        paramITK: A dictionary of parameters.</span>

<span class="s2">    Returns:</span>

<span class="s2">        data: A xarray dataset with the updated irrigationTotDay field.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;numPhase&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;numPhase&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="err">\</span>

<span class="w">            </span><span class="o">&lt;</span><span class="w"> </span><span class="n">paramITK</span><span class="err">[</span><span class="s2">&quot;irrigAutoTarget&quot;</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">                </span><span class="mi">0</span><span class="p">,</span>

<span class="w">                </span><span class="p">((</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.9</span><span class="p">)</span><span class="w"> </span><span class="err">\</span>

<span class="w">                    </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span>

<span class="w">                </span><span class="p">),</span>

<span class="w">            </span><span class="n">paramITK</span><span class="err">[</span><span class="s2">&quot;maxIrrig&quot;</span><span class="err">]</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="compute_drainage">compute_drainage</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_drainage</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This wrapper function aims to regroup computations related to drainage :</p>
<ul>
<li>update_drainage</li>
<li>update total_tank_stock</li>
<li>update_humectation_front_after_drainage</li>
</ul>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">compute_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This wrapper function aims to regroup computations related to drainage :</span>

<span class="s">    - update_drainage</span>

<span class="s">    - update total_tank_stock</span>

<span class="s">    - update_humectation_front_after_drainage</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">update_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">update_total_tank_stock_after_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">update_humectation_front_after_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="compute_irrigation_state">compute_irrigation_state</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_irrigation_state</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This wrapper function computes the irrigation state for a given day,</p>
<p>including the size and filling of the irrigation tank and the irrigation
demand. It is computed only if <code>paramITK["irrigAuto"] == True</code> ; this means
that irrigAuto shall be the same all over the grid, which is a reasonable
assumption</p>
<p>It has been Translated from the procedure EvalIrrigPhase, of the original
Pascal codes bileau.pas and exmodules2.pas. Calculation precision is not
taken into account anymore.</p>
<p>irrigation_tank_stock and irrigation_tank_capacity are only computed in
order to avoid issues with very shallow rooting, where calculation of
filling of root_tank_capacity by root_tank_stock can be inappropriate and
lead to inadapted results for automatic irrigation</p>
<p>Notes from CB, 2014 : "Modification due √† la prise en compte effet Mulch
Soit on a une irrigation observ√©e, soit on calcul la dose d'irrigation. Elle
est calcul√©e en fonction d'un seuil d'humidit√© (IrrigAutoTarget) et de
possibilit√© technique ou choix (MaxIrrig, Precision). Dans cette gestion
d'irrigation la pluie du jour n'est pas prise en compte."</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>Index of the day for which the irrigation state is being computed.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray.Dataset</td>
<td>The input data, including the arrays for irrigation and correctedIrrigation.</td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td>dict</td>
<td>The parameters for the ITK model.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xarray.Dataset</td>
<td>The updated data, including the computed values for the irrigation state.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code>def compute_irrigation_state(j, data, paramITK):

    &quot;&quot;&quot;

    This wrapper function computes the irrigation state for a given day,

    including the size and filling of the irrigation tank and the irrigation

    demand. It is computed only if <span class="sb">`paramITK[&quot;irrigAuto&quot;] == True`</span> ; this means

    that irrigAuto shall be the same all over the grid, which is a reasonable

    assumption

    It has been Translated from the procedure EvalIrrigPhase, of the original

    Pascal codes bileau.pas and exmodules2.pas. Calculation precision is not

    taken into account anymore.

    irrigation_tank_stock and irrigation_tank_capacity are only computed in

    order to avoid issues with very shallow rooting, where calculation of

    filling of root_tank_capacity by root_tank_stock can be inappropriate and

    lead to inadapted results for automatic irrigation

    Notes from CB, 2014 : &quot;Modification due √† la prise en compte effet Mulch

    Soit on a une irrigation observ√©e, soit on calcul la dose d&#39;irrigation. Elle

    est calcul√©e en fonction d&#39;un seuil d&#39;humidit√© (IrrigAutoTarget) et de

    possibilit√© technique ou choix (MaxIrrig, Precision). Dans cette gestion

    d&#39;irrigation la pluie du jour n&#39;est pas prise en compte.&quot;

    Args:

        j (int): Index of the day for which the irrigation state is being computed.

        data (xarray.Dataset): The input data, including the arrays for irrigation and correctedIrrigation.

        paramITK (dict): The parameters for the ITK model.

    Returns:

        xarray.Dataset: The updated data, including the computed values for the irrigation state.

    &quot;&quot;&quot;

    if paramITK[&quot;irrigAuto&quot;] == True :

        data = update_irrigation_tank_stock(j, data)

        data = update_irrigation_tank_capacity(j, data)

        data = compute_daily_irrigation(j, data, paramITK)

    return data
</code></pre></div>

</details>
<h3 id="compute_runoff">compute_runoff</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_runoff</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the procedure PluieIrrig, of the original Pascal codes</p>
<p>bileau.pas, exmodules1.pas and exmodules2.pas</p>
<p>Notes from CB, 2014 :
On a regroup√© avant la pluie et l'irrigation (a cause de l'effet Mulch)
si mulch on a enlev√© l'eau capt√©e
oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramTypeSol</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">compute_runoff</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="s">    bileau.pas, exmodules1.pas and exmodules2.pas</span>

<span class="s">    Notes from CB, 2014 :</span>

<span class="s">    On a regroup√© avant la pluie et l&#39;irrigation (a cause de l&#39;effet Mulch)</span>

<span class="s">    si mulch on a enlev√© l&#39;eau capt√©e</span>

<span class="s">    oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">        paramTypeSol (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">estimate_runoff</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">update_available_water_after_runoff</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="compute_soil_evaporation">compute_soil_evaporation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_soil_evaporation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code>def compute_soil_evaporation(j, data, paramITK):

    data = estimate_fesw(j, data)

    data = estimate_kce(j, data, paramITK)

    data = estimate_soil_potential_evaporation(j, data)

    data = estimate_soil_evaporation(j, data)

    return data
</code></pre></div>

</details>
<h3 id="compute_total_available_water">compute_total_available_water</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_total_available_water</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the total available water for a day (mm) by adding</p>
<p>rainfall and irrigation.</p>
<p>This calculation is performed to allow for subsequent calculations of the
mulch filling and water runoff.</p>
<p>The available_water variable is later updated during the same day process
list, so its value is not the same at the beginning and the end of the daily
computation loop.</p>
<p>This function has benn translated from the procedure PluieIrrig, of the
original Pascal codes bileau.pas and exmodules2.pas.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>The index of the current day.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray.Dataset</td>
<td>The data set containing information about the rainfall, irrigation, and water availability.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xarray.Dataset</td>
<td>The data set with updated information about the total water availability for the current day.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">compute_total_available_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes the total available water for a day (mm) by adding</span>

<span class="sd">    rainfall and irrigation.</span>

<span class="sd">    This calculation is performed to allow for subsequent calculations of the</span>

<span class="sd">    mulch filling and water runoff.</span>

<span class="sd">    The available_water variable is later updated during the same day process</span>

<span class="sd">    list, so its value is not the same at the beginning and the end of the daily</span>

<span class="sd">    computation loop.</span>

<span class="sd">    This function has benn translated from the procedure PluieIrrig, of the</span>

<span class="sd">    original Pascal codes bileau.pas and exmodules2.pas.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): The index of the current day.</span>

<span class="sd">        data (xarray.Dataset): The data set containing information about the rainfall, irrigation, and water availability.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray.Dataset: The data set with updated information about the total water availability for the current day.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="compute_transpiration">compute_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code>def compute_transpiration(j, data, paramVariete):

    # we can take out the estimate_kcTot function

    data = estimate_ftsw(j, data)

    data = estimate_kcp(j, data, paramVariete)

    data = estimate_potential_plant_transpiration(j, data)

    #// data = estimate_kcTot(j, data)

    data = estimate_pFact(j, data, paramVariete)

    data = estimate_cstr(j, data)

    data = estimate_plant_transpiration(j, data)

    return data
</code></pre></div>

</details>
<h3 id="compute_water_captured_by_mulch">compute_water_captured_by_mulch</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_water_captured_by_mulch</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the height of water captured by the mulch.</p>
<p>For this, we multiply the 'available_water' (rain + irrigation, in mm) by an
exponential function taking both into consideration the mulch covering
capacity (surfMc, ha/t) and mulch biomass (biomMc, kg/ha), representing the
fraction of soil covered by mulch. If the fraction is 0 (no mulch), the
value of water_captured_by_mulch is 0. </p>
<p>The value of water_captured_by_mulch is bounded by the maximum capacity of
the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of
water already present in it (mulch_water_stock, mm).</p>
<p>Note : the logic of this function has not yet been validated in SARRA-Py, as
simulations are mainly based on situations without mulch.</p>
<p>Notes from CB, 2014 :
Hypotheses : A chaque pluie, on estime la quantit√© d'eau pour saturer le
couvert. On la retire √† l'eauDispo (pluie + irrig). On calcule la capacit√©
maximum de stockage fonction de la biomasse et du taux de saturation
rapport√©e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1
mm = 1 litre d'eau / m2 1 mm = 10 tonnes d'eau / hectare = 10 000 kg/ha La
biomasse est en kg/ha pour se rapporter √† la quantit√© de pluie capt√©e en mm
Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha √† humSat 2.8
kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit√© √†
capter est fonction du taux de couverture du sol calcul√© comme le LTR SurfMc
est sp√©cifi√© en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On
retire alors les mm d'eau capt√©es √† la pluie incidente. Le ruisselement est
ensuite calcul√© avec l'effet de contrainte du mulch</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">compute_water_captured_by_mulch</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function computes the height of water captured by the mulch.</span>

<span class="s">    For this, we multiply the &#39;available_water&#39; (rain + irrigation, in mm) by an</span>

<span class="s">    exponential function taking both into consideration the mulch covering</span>

<span class="s">    capacity (surfMc, ha/t) and mulch biomass (biomMc, kg/ha), representing the</span>

<span class="s">    fraction of soil covered by mulch. If the fraction is 0 (no mulch), the</span>

<span class="s">    value of water_captured_by_mulch is 0.</span>

<span class="s">    The value of water_captured_by_mulch is bounded by the maximum capacity of</span>

<span class="s">    the mulch to gather water (humSatMc, kg H2O/kg biomass), minus stock of</span>

<span class="s">    water already present in it (mulch_water_stock, mm).</span>

<span class="s">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s">    simulations are mainly based on situations without mulch.</span>

<span class="s">    Notes from CB, 2014 :</span>

<span class="s">    Hypotheses : A chaque pluie, on estime la quantit√© d&#39;eau pour saturer le</span>

<span class="s">    couvert. On la retire √† l&#39;eauDispo (pluie + irrig). On calcule la capacit√©</span>

<span class="s">    maximum de stockage fonction de la biomasse et du taux de saturation</span>

<span class="s">    rapport√©e en mm (humSatMc en kg H2O/kg de biomasse). La pluie est en mm : 1</span>

<span class="s">    mm = 1 litre d&#39;eau / m2 1 mm = 10 tonnes d&#39;eau / hectare = 10 000 kg/ha La</span>

<span class="s">    biomasse est en kg/ha pour se rapporter √† la quantit√© de pluie capt√©e en mm</span>

<span class="s">    Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha √† humSat 2.8</span>

<span class="s">    kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacit√© √†</span>

<span class="s">    capter est fonction du taux de couverture du sol calcul√© comme le LTR SurfMc</span>

<span class="s">    est sp√©cifi√© en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On</span>

<span class="s">    retire alors les mm d&#39;eau capt√©es √† la pluie incidente. Le ruisselement est</span>

<span class="s">    ensuite calcul√© avec l&#39;effet de contrainte du mulch</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">        paramITK (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;water_captured_by_mulch&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="o">-</span><span class="nx">paramITK</span><span class="p">[</span><span class="s">&quot;surfMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;biomMc&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])),</span>

<span class="w">        </span><span class="p">(</span><span class="nx">paramITK</span><span class="p">[</span><span class="s">&quot;humSatMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;biomMc&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_femcw_and_update_mulch_water_stock">estimate_FEMcW_and_update_mulch_water_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_FEMcW_and_update_mulch_water_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function calculates the fraction of evaporable water from the mulch</p>
<p>(FEMcW).</p>
<p>If the mulch water stock is greater than 0, then we compute FEMcW, which we
consider to be equal to the filling ratio of the mulch water capacity. We
then update the mulch water stock by removing the water height equivalent to
the climate forcing demand, modulated by FEMcW and the plant cover (ltr).</p>
<p>This function is adapted from the procedure EvapMC, from bileau.pas and
exmodules 2.pas file from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_FEMcW_and_update_mulch_water_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function calculates the fraction of evaporable water from the mulch</span>

<span class="s">    (FEMcW).</span>

<span class="s">    If the mulch water stock is greater than 0, then we compute FEMcW, which we</span>

<span class="s">    consider to be equal to the filling ratio of the mulch water capacity. We</span>

<span class="s">    then update the mulch water stock by removing the water height equivalent to</span>

<span class="s">    the climate forcing demand, modulated by FEMcW and the plant cover (ltr).</span>

<span class="s">    This function is adapted from the procedure EvapMC, from bileau.pas and</span>

<span class="s">    exmodules 2.pas file from the original FORTRAN code.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">        paramITK (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;FEMcW&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="err">#</span><span class="p">!</span><span class="w"> </span><span class="nx">inverting</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">fraction</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">get</span><span class="w"> </span><span class="nx">stock</span><span class="w"> </span><span class="nx">over</span><span class="w"> </span><span class="nx">capacity</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">other</span><span class="w"> </span><span class="nx">way</span><span class="w"> </span><span class="nx">round</span>

<span class="w">        </span><span class="err">#</span><span class="c1">// (paramITK[&quot;humSatMc&quot;] * data[&quot;biomMc&quot;][j,:,:] * 0.001) / data[&quot;stockMc&quot;][j,:,:],</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="nx">paramITK</span><span class="p">[</span><span class="s">&quot;humSatMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;biomMc&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">),</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;FEMcW&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="err">#</span><span class="p">!</span><span class="w"> </span><span class="nx">removing</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">power</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">equation</span>

<span class="w">        </span><span class="err">#</span><span class="c1">// data[&quot;stockMc&quot;][j,:,:] - data[&quot;ltr&quot;][j,:,:] * data[&quot;ET0&quot;][j,:,:] * data[&quot;FEMcW&quot;][j,:,:]**2,</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ltr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ET0&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;FEMcW&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_cstr">estimate_cstr</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_cstr</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the water stress coefficient cstr.</p>
<p>It uses ftsw and pFact. cstr is bounded in [0, 1].</p>
<p>This function is based on the CstrPFactor procedure, from bileau.pas,
exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</p>
<p>in FAO56 paper RAW being calculated as RAW = p TAW and TAW is 
p average fraction of Total Available Soil Water (TAW) that can be depleted from the root zone before moisture stress (reduction in ET) occurs</p>
<p>donc pour avoir la proportion de remplissage correspondant √† la limite de stress hydrique, il faut faire
1 - pFact</p>
<p>et donc quand ftsw est inf√©rieur √† 1 - pFact, on est en stress hydrique et cstr est inf√©rieur √† 1
et quand ftsw est au dessus de 1 - pFact, on est pas en stress hydrique et cstr est √©gal √† 1</p>
<p>en fait cstr correspond au coefficient Ks de FAO56 (figure 42 FAO56)</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_cstr</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function computes the water stress coefficient cstr.</span>

<span class="s">    It uses ftsw and pFact. cstr is bounded in [0, 1].</span>

<span class="s">    This function is based on the CstrPFactor procedure, from bileau.pas,</span>

<span class="s">    exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</span>

<span class="s">    in FAO56 paper RAW being calculated as RAW = p TAW and TAW is</span>

<span class="s">    p average fraction of Total Available Soil Water (TAW) that can be depleted from the root zone before moisture stress (reduction in ET) occurs</span>

<span class="s">    donc pour avoir la proportion de remplissage correspondant √† la limite de stress hydrique, il faut faire</span>

<span class="s">    1 - pFact</span>

<span class="s">    et donc quand ftsw est inf√©rieur √† 1 - pFact, on est en stress hydrique et cstr est inf√©rieur √† 1</span>

<span class="s">    et quand ftsw est au dessus de 1 - pFact, on est pas en stress hydrique et cstr est √©gal √† 1</span>

<span class="s">    en fait cstr correspond au coefficient Ks de FAO56 (figure 42 FAO56)</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="err">#</span><span class="nx">group</span><span class="w"> </span><span class="mi">55</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;cstr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">((</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ftsw&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;pFact&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])),</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="mi">56</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;cstr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;cstr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_effective_evaporation_from_evaporable_water">estimate_effective_evaporation_from_evaporable_water</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_effective_evaporation_from_evaporable_water</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the effective evaporation (<code>consoRur</code>, mm) from the</p>
<p>evaporable water (<code>evap</code>, mm) limited by the evapotranspirable surface water
(<code>trSurf</code>, mm).</p>
<p>If <code>evap</code> is higher than the quantity of water in the surface tank at the
beginning of the daily cycle/before evaporation (<code>trSurf</code>), meaning that
evaporation will deplete the surface water tank, then water consumption
shall take the value of <code>trSurf</code>. </p>
<p>Else, <code>consoRur</code> equals <code>evap</code>.</p>
<p>It is a way to bound the water consumption by the water available in the
surface tank.</p>
<h1 id="the-name-of-this-function-is-not-that-great-thinking-about-something">? the name of this function is not that great. thinking about something</h1>
<h1 id="about-evaporation-demand-vs-evaporated-water">? about evaporation demand vs evaporated water</h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_effective_evaporation_from_evaporable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function estimates the effective evaporation (`consoRur`, mm) from the</span>

<span class="s2">    evaporable water (`evap`, mm) limited by the evapotranspirable surface water</span>

<span class="s2">    (`trSurf`, mm).</span>

<span class="s2">    If `evap` is higher than the quantity of water in the surface tank at the</span>

<span class="s2">    beginning of the daily cycle/before evaporation (`trSurf`), meaning that</span>

<span class="s2">    evaporation will deplete the surface water tank, then water consumption</span>

<span class="s2">    shall take the value of `trSurf`.</span>

<span class="s2">    Else, `consoRur` equals `evap`.</span>

<span class="s2">    It is a way to bound the water consumption by the water available in the</span>

<span class="s2">    surface tank.</span>

<span class="s2">    #? the name of this function is not that great. thinking about something</span>

<span class="s2">    #? about evaporation demand vs evaporated water</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;consoRur&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;evap&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;trSurf&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;trSurf&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;evap&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="estimate_fesw">estimate_fesw</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_fesw</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the fraction of evaporable soil water (fesw, mm).</p>
<p>fesw is defined as the ratio of water stock in the surface tank over 110% of
the surface tank capacity.</p>
<p>It is adapted from the EvalFESW procedure, from bileau.pas and
bhytypeFAO.pas files from the original FORTRAN code.</p>
<p>Depuis th√®se Alhassane : "FESW = fraction d'eau √©vaporable dans le sol (en
%), calcul√©e √† partir du taux d'humidit√© du sol (en %) √† la capacit√© de
r√©tention et 1/2 du taux d'humidit√© du sol au pF 4.2 (Allen et al., 1998)"</p>
<p>in Alhassane thesis, FESW = (Stock CR - 0,5 Stock pF 4,2) x H) so is calculated taking only 
half of the surface reservoir </p>
<p>? Why is it calculated over 110% of surface_tank_capacity ?</p>
<p>? it seems the 110% thingy comes from the update_surface_tank_stock
? function where it is allowed to fill the surface tank up to 110% of its
? capacity. but this does not make se,se to me.</p>
<p>? in this case, fesw can take values between 0 and 1</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="s">estimate_fesw(j,</span><span class="w"> </span><span class="s">data):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function estimates the fraction of evaporable soil water (fesw, mm).</span>

<span class="s">    fesw is defined as the ratio of water stock in the surface tank over 110% of</span>

<span class="s">    the surface tank capacity.</span>

<span class="s">    It is adapted from the EvalFESW procedure, from bileau.pas and</span>

<span class="s">    bhytypeFAO.pas files from the original FORTRAN code.</span>

<span class="s">    Depuis th√®se Alhassane : &quot;</span><span class="n">FESW</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">fraction</span><span class="w"> </span><span class="n">d</span><span class="o">&#39;</span><span class="n">eau</span><span class="w"> </span>√©<span class="n">vaporable</span><span class="w"> </span><span class="n">dans</span><span class="w"> </span><span class="n">le</span><span class="w"> </span><span class="n">sol</span><span class="w"> </span><span class="p">(</span><span class="n">en</span>

<span class="w">    </span><span class="c">%), calcul√©e √† partir du taux d&#39;humidit√© du sol (en %) √† la capacit√© de</span>

<span class="w">    </span><span class="n">r√©tention</span><span class="w"> </span><span class="n">et</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">du</span><span class="w"> </span><span class="n">taux</span><span class="w"> </span><span class="n">d</span><span class="o">&#39;</span><span class="n">humidit√©</span><span class="w"> </span><span class="n">du</span><span class="w"> </span><span class="n">sol</span><span class="w"> </span><span class="n">au</span><span class="w"> </span><span class="n">pF</span><span class="w"> </span><span class="mf">4.2</span><span class="w"> </span><span class="p">(</span><span class="n">Allen</span><span class="w"> </span><span class="n">et</span><span class="w"> </span><span class="n">al</span><span class="p">.,</span><span class="w"> </span><span class="mi">1998</span><span class="p">)</span><span class="s">&quot;</span>

<span class="s">    in Alhassane thesis, FESW = (Stock CR - 0,5 Stock pF 4,2) x H) so is calculated taking only</span>

<span class="s">    half of the surface reservoir</span>

<span class="s">    ? Why is it calculated over 110% of surface_tank_capacity ?</span>

<span class="s">    ? it seems the 110% thingy comes from the update_surface_tank_stock</span>

<span class="s">    ? function where it is allowed to fill the surface tank up to 110% of its</span>

<span class="s">    ? capacity. but this does not make se,se to me.</span>

<span class="s">    ? in this case, fesw can take values between 0 and 1</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span>#<span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;fesw&quot;</span><span class="p">][</span><span class="nb">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nb">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">1.1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">])</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;fesw&quot;</span><span class="p">][</span><span class="nb">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nb">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="estimate_ftsw">estimate_ftsw</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_ftsw</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the fraction of transpirable soil water (ftsw) from</p>
<p>the root reservoir. </p>
<p>It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 &amp;
2.pas, risocas.pas, riz.pas files from the original FORTRAN code.</p>
<p>d'apr√®s alhassane thesis, "La fraction d'eau transpirable par la plante ou
"fraction of transpirable soil water (FTSW)" a √©t√© calcul√©e une fois par
semaine durant le cycle de la vari√©t√© : FTSW = ((Stock - pF4.2)/(RU x
profondeur racinaire)) x profondeur racinaire Avec : Stock = stock d'eau du
sol dans la zone racinaire (mm), pF4.2 = point de fl√©trissement et RU =
r√©serve utile (mm/msol). Ces variables sont fonction de la profondeur
racinaire, donc de la croissance de la culture"</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_ftsw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the fraction of transpirable soil water (ftsw) from</span>

<span class="sd">    the root reservoir.</span>

<span class="sd">    It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 &amp;</span>

<span class="sd">    2.pas, risocas.pas, riz.pas files from the original FORTRAN code.</span>

<span class="sd">    d&#39;apr√®s alhassane thesis, &quot;La fraction d&#39;eau transpirable par la plante ou</span>

<span class="sd">    &quot;fraction of transpirable soil water (FTSW)&quot; a √©t√© calcul√©e une fois par</span>

<span class="sd">    semaine durant le cycle de la vari√©t√© : FTSW = ((Stock - pF4.2)/(RU x</span>

<span class="sd">    profondeur racinaire)) x profondeur racinaire Avec : Stock = stock d&#39;eau du</span>

<span class="sd">    sol dans la zone racinaire (mm), pF4.2 = point de fl√©trissement et RU =</span>

<span class="sd">    r√©serve utile (mm/msol). Ces variables sont fonction de la profondeur</span>

<span class="sd">    racinaire, donc de la croissance de la culture&quot;</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ftsw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="estimate_kce">estimate_kce</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_kce</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the coefficient of evaporation from the soil (kce).</p>
<p>This approach takes into consideration three factors acting on limitation of
kce :</p>
<p>1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover
2) Mulch - permanent covering effect : we consider a value of 1.0 for no
covering, and 0.0 is full covering with plastic sheet ; this mulch parameter
has been used in previous versions of the model where evolution of mulch
biomass was not explicitely taken into consideration, can be used in the
case of crops with self-mulching phenomena, where a standard mulch parameter
value of 0.7 can be applied.
3) Mulch - evolutive covering effect BiomMc : biomass of mulch  </p>
<p>This function has been adapted from EvalKceMC procedure, bileau.pas and
exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like
it has been adapted from the dual crop coefficient from the FAO56 paper. But
this is still to confirm on a point of view of the history of the model.</p>
<p>Depuis th√®se Alhassane : "LTR = fraction de radiation non intercept√©e par le
couvert = [exp(-k*LAI)] o√π k = coefficient d'extinction de la lumi√®re qui
est fonction des propri√©t√©s g√©om√©triques du couvert et LAI = indice de
surface foliaire"</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_kce</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function estimates the coefficient of evaporation from the soil (kce).</span>

<span class="s">    This approach takes into consideration three factors acting on limitation of</span>

<span class="s">    kce :</span>

<span class="s">    1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover</span>

<span class="s">    2) Mulch - permanent covering effect : we consider a value of 1.0 for no</span>

<span class="s">    covering, and 0.0 is full covering with plastic sheet ; this mulch parameter</span>

<span class="s">    has been used in previous versions of the model where evolution of mulch</span>

<span class="s">    biomass was not explicitely taken into consideration, can be used in the</span>

<span class="s">    case of crops with self-mulching phenomena, where a standard mulch parameter</span>

<span class="s">    value of 0.7 can be applied.</span>

<span class="s">    3) Mulch - evolutive covering effect BiomMc : biomass of mulch</span>

<span class="s">    This function has been adapted from EvalKceMC procedure, bileau.pas and</span>

<span class="s">    exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like</span>

<span class="s">    it has been adapted from the dual crop coefficient from the FAO56 paper. But</span>

<span class="s">    this is still to confirm on a point of view of the history of the model.</span>

<span class="s">    Depuis th√®se Alhassane : &quot;</span><span class="nx">LTR</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">fraction</span><span class="w"> </span><span class="nx">de</span><span class="w"> </span><span class="nx">radiation</span><span class="w"> </span><span class="nx">non</span><span class="w"> </span><span class="nx">intercept√©e</span><span class="w"> </span><span class="nx">par</span><span class="w"> </span><span class="nx">le</span>

<span class="w">    </span><span class="nx">couvert</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="nx">exp</span><span class="p">(</span><span class="o">-</span><span class="nx">k</span><span class="o">*</span><span class="nx">LAI</span><span class="p">)]</span><span class="w"> </span><span class="nx">o√π</span><span class="w"> </span><span class="nx">k</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">coefficient</span><span class="w"> </span><span class="nx">d</span><span class="err">&#39;</span><span class="nx">extinction</span><span class="w"> </span><span class="nx">de</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">lumi√®re</span><span class="w"> </span><span class="nx">qui</span>

<span class="w">    </span><span class="nx">est</span><span class="w"> </span><span class="nx">fonction</span><span class="w"> </span><span class="nx">des</span><span class="w"> </span><span class="nx">propri√©t√©s</span><span class="w"> </span><span class="nx">g√©om√©triques</span><span class="w"> </span><span class="nx">du</span><span class="w"> </span><span class="nx">couvert</span><span class="w"> </span><span class="nx">et</span><span class="w"> </span><span class="nx">LAI</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">indice</span><span class="w"> </span><span class="nx">de</span>

<span class="w">    </span><span class="nx">surface</span><span class="w"> </span><span class="nx">foliaire</span><span class="s">&quot;</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">        paramITK (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;kce&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ltr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">paramITK</span><span class="p">[</span><span class="s">&quot;mulch&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>\

<span class="w">        </span><span class="nx">np</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="o">-</span><span class="nx">paramITK</span><span class="p">[</span><span class="s">&quot;coefMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">paramITK</span><span class="p">[</span><span class="s">&quot;surfMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;biomMc&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_pfact">estimate_pFact</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_pFact</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p><em>summary</em></p>
<p>This function computes the pFactor, which is a bound coefficient used in the
computation of cstr from ftsw. This coefficient delimits the portion of the
FTSW below which water stress starts to influence the transpiration.</p>
<p>FAO reference for critical FTSW value for transpiration response (0 =
stomata respond immediately if FTSW&lt;1; 0.5 for most of the crops)</p>
<p>pFact is bounded in [0.1, 0.8].</p>
<p>For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf</p>
<p>This function is based on the CstrPFactor procedure, from bileau.pas,
exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</p>
<p>d'apr√®s alhassane :</p>
<p>"Selon Allen et al., (1998), on peut √©galement appliquer la m√©thode de
calculs d√©velopp√©e par la FAO, dite du pFactor, bas√©e sur les notions de
r√©serve d'eau facilement utilisable (RFU) et difficilement utilisable (RDU)
d√©finies par un point d'inflexion, si on consid√®re que la dynamique de
consommation hydrique de la plante diff√®re selon la demande climatique (ETo)
et la fraction d'eau du sol transpirable (FTSW). En effet, pfactor est un
coefficient utilis√© pour le calcul du taux de transpiration et qui s'obtient
en divisant la r√©serve d'eau du sol utilisable par les racines par la
r√©serve totale disponible dans la zone racinaire de la plante (Allen et al.,
1998). On l'obtient √©galement par la formule suivante :</p>
<p>pfactor = parP + 0,04 x (5 - ETM)</p>
<p>Avec : parP = param√®tre sp√©cifique √†
l'esp√®ce, qui exprime le seuil critique d'humidit√© du sol √† partir duquel le
stress hydrique r√©duit lin√©airement la transpiration (Doorenbos et Kassam,
1979)."</p>
<h1 id="this-function-seems-quite-arbitrary-and-would-need-verifications-regarding-the-underlying-assumptions">! this function seems quite arbitrary and would need verifications regarding the underlying assumptions</h1>
<p>ok so this function comes from FAO56 paper, https://www.fao.org/3/x0490e/x0490e0e.htm#chapter%208%20%20%20etc%20under%20soil%20water%20stress%20conditions
table 22 annex 2</p>
<p>FAO56 uses the RAW/TAW formalism where RAW = p TAW 
with TAW being the total available water in the root zone TAW = 1000(q FC - q WP) Zr 
corresponding to the root tank capacity
and RAW being calculated as RAW = p TAW 
p average fraction of Total Available Soil Water (TAW) that can be depleted from the root zone before moisture stress (reduction in ET) occurs</p>
<p>"A value of 0.50 for p is commonly used for many crops"
"A numerical approximation for adjusting p for ETc rate is p = pTable 22 + 0.04 (5 - ETc) where the adjusted p is limited to 0.1 ¬£ p ¬£ 0.8 and ETc is in mm/day"</p>
<p>in the legacy code, ETc is computed with np.maximum(data["kcp"][j,:,:], 1) * data["ET0"][j,:,:]
however why is kcp bound to 1 ?
there seem to be no reason of keeping this bound.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_pFact</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">,</span><span class="w"> </span><span class="nx">paramVariete</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;_summary_</span>

<span class="s">    This function computes the pFactor, which is a bound coefficient used in the</span>

<span class="s">    computation of cstr from ftsw. This coefficient delimits the portion of the</span>

<span class="s">    FTSW below which water stress starts to influence the transpiration.</span>

<span class="s">    FAO reference for critical FTSW value for transpiration response (0 =</span>

<span class="s">    stomata respond immediately if FTSW&lt;1; 0.5 for most of the crops)</span>

<span class="s">    pFact is bounded in [0.1, 0.8].</span>

<span class="s">    For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf</span>

<span class="s">    This function is based on the CstrPFactor procedure, from bileau.pas,</span>

<span class="s">    exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</span>

<span class="s">    d&#39;apr√®s alhassane :</span>

<span class="s">    &quot;</span><span class="nx">Selon</span><span class="w"> </span><span class="nx">Allen</span><span class="w"> </span><span class="nx">et</span><span class="w"> </span><span class="nx">al</span><span class="p">.,</span><span class="w"> </span><span class="p">(</span><span class="mi">1998</span><span class="p">),</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">peut</span><span class="w"> </span><span class="nx">√©galement</span><span class="w"> </span><span class="nx">appliquer</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">m√©thode</span><span class="w"> </span><span class="nx">de</span>

<span class="w">    </span><span class="nx">calculs</span><span class="w"> </span><span class="nx">d√©velopp√©e</span><span class="w"> </span><span class="nx">par</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">FAO</span><span class="p">,</span><span class="w"> </span><span class="nx">dite</span><span class="w"> </span><span class="nx">du</span><span class="w"> </span><span class="nx">pFactor</span><span class="p">,</span><span class="w"> </span><span class="nx">bas√©e</span><span class="w"> </span><span class="nx">sur</span><span class="w"> </span><span class="nx">les</span><span class="w"> </span><span class="nx">notions</span><span class="w"> </span><span class="nx">de</span>

<span class="w">    </span><span class="nx">r√©serve</span><span class="w"> </span><span class="nx">d</span><span class="err">&#39;</span><span class="nx">eau</span><span class="w"> </span><span class="nx">facilement</span><span class="w"> </span><span class="nx">utilisable</span><span class="w"> </span><span class="p">(</span><span class="nx">RFU</span><span class="p">)</span><span class="w"> </span><span class="nx">et</span><span class="w"> </span><span class="nx">difficilement</span><span class="w"> </span><span class="nx">utilisable</span><span class="w"> </span><span class="p">(</span><span class="nx">RDU</span><span class="p">)</span>

<span class="w">    </span><span class="nx">d√©finies</span><span class="w"> </span><span class="nx">par</span><span class="w"> </span><span class="nx">un</span><span class="w"> </span><span class="nx">point</span><span class="w"> </span><span class="nx">d</span><span class="err">&#39;</span><span class="nx">inflexion</span><span class="p">,</span><span class="w"> </span><span class="nx">si</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">consid√®re</span><span class="w"> </span><span class="nx">que</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">dynamique</span><span class="w"> </span><span class="nx">de</span>

<span class="w">    </span><span class="nx">consommation</span><span class="w"> </span><span class="nx">hydrique</span><span class="w"> </span><span class="nx">de</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">plante</span><span class="w"> </span><span class="nx">diff√®re</span><span class="w"> </span><span class="nx">selon</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">demande</span><span class="w"> </span><span class="nx">climatique</span><span class="w"> </span><span class="p">(</span><span class="nx">ETo</span><span class="p">)</span>

<span class="w">    </span><span class="nx">et</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">fraction</span><span class="w"> </span><span class="nx">d</span><span class="err">&#39;</span><span class="nx">eau</span><span class="w"> </span><span class="nx">du</span><span class="w"> </span><span class="nx">sol</span><span class="w"> </span><span class="nx">transpirable</span><span class="w"> </span><span class="p">(</span><span class="nx">FTSW</span><span class="p">).</span><span class="w"> </span><span class="nx">En</span><span class="w"> </span><span class="nx">effet</span><span class="p">,</span><span class="w"> </span><span class="nx">pfactor</span><span class="w"> </span><span class="nx">est</span><span class="w"> </span><span class="nx">un</span>

<span class="w">    </span><span class="nx">coefficient</span><span class="w"> </span><span class="nx">utilis√©</span><span class="w"> </span><span class="nx">pour</span><span class="w"> </span><span class="nx">le</span><span class="w"> </span><span class="nx">calcul</span><span class="w"> </span><span class="nx">du</span><span class="w"> </span><span class="nx">taux</span><span class="w"> </span><span class="nx">de</span><span class="w"> </span><span class="nx">transpiration</span><span class="w"> </span><span class="nx">et</span><span class="w"> </span><span class="nx">qui</span><span class="w"> </span><span class="nx">s</span><span class="err">&#39;</span><span class="nx">obtient</span>

<span class="w">    </span><span class="nx">en</span><span class="w"> </span><span class="nx">divisant</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">r√©serve</span><span class="w"> </span><span class="nx">d</span><span class="err">&#39;</span><span class="nx">eau</span><span class="w"> </span><span class="nx">du</span><span class="w"> </span><span class="nx">sol</span><span class="w"> </span><span class="nx">utilisable</span><span class="w"> </span><span class="nx">par</span><span class="w"> </span><span class="nx">les</span><span class="w"> </span><span class="nx">racines</span><span class="w"> </span><span class="nx">par</span><span class="w"> </span><span class="nx">la</span>

<span class="w">    </span><span class="nx">r√©serve</span><span class="w"> </span><span class="nx">totale</span><span class="w"> </span><span class="nx">disponible</span><span class="w"> </span><span class="nx">dans</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">zone</span><span class="w"> </span><span class="nx">racinaire</span><span class="w"> </span><span class="nx">de</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">plante</span><span class="w"> </span><span class="p">(</span><span class="nx">Allen</span><span class="w"> </span><span class="nx">et</span><span class="w"> </span><span class="nx">al</span><span class="p">.,</span>

<span class="w">    </span><span class="mi">1998</span><span class="p">).</span><span class="w"> </span><span class="nx">On</span><span class="w"> </span><span class="nx">l</span><span class="err">&#39;</span><span class="nx">obtient</span><span class="w"> </span><span class="nx">√©galement</span><span class="w"> </span><span class="nx">par</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">formule</span><span class="w"> </span><span class="nx">suivante</span><span class="w"> </span><span class="p">:</span>

<span class="w">    </span><span class="nx">pfactor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">parP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="mi">04</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">ETM</span><span class="p">)</span>

<span class="w">    </span><span class="nx">Avec</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">parP</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">param√®tre</span><span class="w"> </span><span class="nx">sp√©cifique</span><span class="w"> </span><span class="nx">√†</span>

<span class="w">    </span><span class="nx">l</span><span class="err">&#39;</span><span class="nx">esp√®ce</span><span class="p">,</span><span class="w"> </span><span class="nx">qui</span><span class="w"> </span><span class="nx">exprime</span><span class="w"> </span><span class="nx">le</span><span class="w"> </span><span class="nx">seuil</span><span class="w"> </span><span class="nx">critique</span><span class="w"> </span><span class="nx">d</span><span class="err">&#39;</span><span class="nx">humidit√©</span><span class="w"> </span><span class="nx">du</span><span class="w"> </span><span class="nx">sol</span><span class="w"> </span><span class="nx">√†</span><span class="w"> </span><span class="nx">partir</span><span class="w"> </span><span class="nx">duquel</span><span class="w"> </span><span class="nx">le</span>

<span class="w">    </span><span class="nx">stress</span><span class="w"> </span><span class="nx">hydrique</span><span class="w"> </span><span class="nx">r√©duit</span><span class="w"> </span><span class="nx">lin√©airement</span><span class="w"> </span><span class="nx">la</span><span class="w"> </span><span class="nx">transpiration</span><span class="w"> </span><span class="p">(</span><span class="nx">Doorenbos</span><span class="w"> </span><span class="nx">et</span><span class="w"> </span><span class="nx">Kassam</span><span class="p">,</span>

<span class="w">    </span><span class="mi">1979</span><span class="p">).</span><span class="s">&quot;</span>

<span class="s">    #! this function seems quite arbitrary and would need verifications regarding the underlying assumptions</span>

<span class="s">    ok so this function comes from FAO56 paper, https://www.fao.org/3/x0490e/x0490e0e.htm#chapter%208%20%20%20etc%20under%20soil%20water%20stress%20conditions</span>

<span class="s">    table 22 annex 2</span>

<span class="s">    FAO56 uses the RAW/TAW formalism where RAW = p TAW</span>

<span class="s">    with TAW being the total available water in the root zone TAW = 1000(q FC - q WP) Zr</span>

<span class="s">    corresponding to the root tank capacity</span>

<span class="s">    and RAW being calculated as RAW = p TAW</span>

<span class="s">    p average fraction of Total Available Soil Water (TAW) that can be depleted from the root zone before moisture stress (reduction in ET) occurs</span>

<span class="s">    &quot;</span><span class="nx">A</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="m m-Double">0.50</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">commonly</span><span class="w"> </span><span class="nx">used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">many</span><span class="w"> </span><span class="nx">crops</span><span class="s">&quot;</span>

<span class="s">    &quot;</span><span class="nx">A</span><span class="w"> </span><span class="nx">numerical</span><span class="w"> </span><span class="nx">approximation</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">adjusting</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">ETc</span><span class="w"> </span><span class="nx">rate</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">pTable</span><span class="w"> </span><span class="mi">22</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Double">0.04</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">ETc</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">adjusted</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">limited</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="m m-Double">0.1</span><span class="w"> </span><span class="err">¬£</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="err">¬£</span><span class="w"> </span><span class="m m-Double">0.8</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">ETc</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">mm</span><span class="o">/</span><span class="nx">day</span><span class="s">&quot;</span>

<span class="s">    in the legacy code, ETc is computed with np.maximum(data[&quot;</span><span class="nx">kcp</span><span class="s">&quot;][j,:,:], 1) * data[&quot;</span><span class="nx">ET0</span><span class="s">&quot;][j,:,:]</span>

<span class="s">    however why is kcp bound to 1 ?</span>

<span class="s">    there seem to be no reason of keeping this bound.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">        paramVariete (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">we</span><span class="w"> </span><span class="nx">keep</span><span class="w"> </span><span class="nx">these</span><span class="w"> </span><span class="nx">lines</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">legacy</span><span class="w"> </span><span class="nx">reference</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;pFact&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">paramVariete</span><span class="p">[</span><span class="s">&quot;PFactor&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>\

<span class="w">    </span><span class="err">#</span><span class="w">     </span><span class="m m-Double">0.04</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;kcp&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ET0&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">adjustinf</span><span class="w"> </span><span class="nx">pfactor</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;pFact&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">paramVariete</span><span class="p">[</span><span class="s">&quot;PFactor&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m m-Double">0.04</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">5</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;kcp&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ET0&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="mi">54</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;pFact&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span>

<span class="w">            </span><span class="m m-Double">0.1</span><span class="p">,</span>

<span class="w">            </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;pFact&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="m m-Double">0.8</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_plant_transpiration">estimate_plant_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_plant_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the adjusted plant transpiration (tr, mm) from the</p>
<p>plant, by adjusting the potential transpiration (trPot, mm) with cstr.</p>
<p>This function adjusts the potential transpiration (trPot, mm) that was
calculated through trPot = kcp * ET0, by adding the stress coefficient cstr
(that corresponds to Ks in the FAO56 paper) Thus we obtain an adjusted plant
transpiration tr, which corresponds to ETc_adj in the FAO56 (see equation
80).</p>
<p>This function is based on the EvalTranspi procedure, from bileau.pas,
bhytypeFAO.pas, exmodules 1 &amp; 2.pas, from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_plant_transpiration</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function computes the adjusted plant transpiration (tr, mm) from the</span>

<span class="s">    plant, by adjusting the potential transpiration (trPot, mm) with cstr.</span>

<span class="s">    This function adjusts the potential transpiration (trPot, mm) that was</span>

<span class="s">    calculated through trPot = kcp * ET0, by adding the stress coefficient cstr</span>

<span class="s">    (that corresponds to Ks in the FAO56 paper) Thus we obtain an adjusted plant</span>

<span class="s">    transpiration tr, which corresponds to ETc_adj in the FAO56 (see equation</span>

<span class="s">    80).</span>

<span class="s">    This function is based on the EvalTranspi procedure, from bileau.pas,</span>

<span class="s">    bhytypeFAO.pas, exmodules 1 &amp; 2.pas, from the original FORTRAN code.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;tr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;trPot&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;cstr&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_potential_plant_transpiration">estimate_potential_plant_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_potential_plant_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the potential transpiration from the plant.</p>
<p>Computation is based on the climate forcing (ET0), as well as the kcp coefficient.</p>
<p>This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and
exmodules 1 &amp; 2.pas files from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_potential_plant_transpiration</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function computes the potential transpiration from the plant.</span>

<span class="s">    Computation is based on the climate forcing (ET0), as well as the kcp coefficient.</span>

<span class="s">    This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and</span>

<span class="s">    exmodules 1 &amp; 2.pas files from the original FORTRAN code.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">ggroup</span><span class="w"> </span><span class="mi">51</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;trPot&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;kcp&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ET0&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_runoff">estimate_runoff</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_runoff</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function evaluates the water runoff (mm).</p>
<p>If the quantity of rain (mm) is above the runoff_threshold (mm), runoff is
computed as the difference between the available water (mm) and the
runoff_threshold  multiplied by the runoff_rate (%). Else, runoff value is
set to 0.</p>
<p>runoff_threshold and runoff_rate are defined in load_iSDA_soil_data</p>
<p>Question : should runoff be computed taking in consideration water captured by
mulch to account for mulch effect on runoff mitigation ?</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function evaluates the water runoff (mm).</span>

<span class="sd">    If the quantity of rain (mm) is above the runoff_threshold (mm), runoff is</span>

<span class="sd">    computed as the difference between the available water (mm) and the</span>

<span class="sd">    runoff_threshold  multiplied by the runoff_rate (%). Else, runoff value is</span>

<span class="sd">    set to 0.</span>

<span class="sd">    runoff_threshold and runoff_rate are defined in load_iSDA_soil_data</span>

<span class="sd">    Question : should runoff be computed taking in consideration water captured by</span>

<span class="sd">    mulch to account for mulch effect on runoff mitigation ?</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff_threshold&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;available_water&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff_threshold&quot;</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;runoff_rate&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="estimate_soil_evaporation">estimate_soil_evaporation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_soil_evaporation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes estimation of soil evaporable water (<code>evap</code>, mm). It uses</p>
<p>the potential soil evaporation (<code>evapPot</code>, mm) and the fraction of evaporable soil
water (<code>fesw</code>), bounded by the <code>surface_tank_stock</code> (mm).</p>
<p>We remind <code>fesw</code> is defined as the ratio of water stock in the surface tank
over 110% of the surface tank capacity, meaning it will be equal to 1 when
the surface tank is full, and 0 when the surface tank is empty.</p>
<p>This approach is somewhat comparable to the soil evaporation reduction
coefficient kr approach presented in FAO56 paper, to the exception the soil
evaporation reduction coefficient kr is built using two linear functions
where the squared fesw approach uses a square function. Furthermore, the kr
approach function is build using REW and TEW values that are specific to the
type of soil, whereas the squared fesw approach uses a generic function that
is not soil specific.</p>
<p>in Alhassane thesis, evap is called EVj for "evaporation journani√®re", and
is calculated as Evj = EvapPot x FESW. More details are available in the PhD
dissertation of Alhassane https://hdl.handle.net/20.500.12177/1576 </p>
<p>The <code>estimate_effective_evaporation_from_evaporable_water</code> function computed
later in the daily cycle uses the <code>evap</code> value to determine the effective
evaporation (<code>consoRur</code>, mm) on the quantity of water in the surface tank
(<code>surface_tank_stock</code>, mm). </p>
<p>It has been adapted from the EvapRuSurf procedure, from bileau.pas and
exmodules 1 &amp; 2.pas file from the original FORTRAN code.</p>
<p>? evaporation is bounded by the surface tank stock, which means it is meant
? to happen only in the depth described by the surface_tank</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_soil_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function computes estimation of soil evaporable water (`evap`, mm). It uses</span>

<span class="s2">    the potential soil evaporation (`evapPot`, mm) and the fraction of evaporable soil</span>

<span class="s2">    water (`fesw`), bounded by the `surface_tank_stock` (mm).</span>

<span class="s2">    We remind `fesw` is defined as the ratio of water stock in the surface tank</span>

<span class="s2">    over 110% of the surface tank capacity, meaning it will be equal to 1 when</span>

<span class="s2">    the surface tank is full, and 0 when the surface tank is empty.</span>

<span class="s2">    This approach is somewhat comparable to the soil evaporation reduction</span>

<span class="s2">    coefficient kr approach presented in FAO56 paper, to the exception the soil</span>

<span class="s2">    evaporation reduction coefficient kr is built using two linear functions</span>

<span class="s2">    where the squared fesw approach uses a square function. Furthermore, the kr</span>

<span class="s2">    approach function is build using REW and TEW values that are specific to the</span>

<span class="s2">    type of soil, whereas the squared fesw approach uses a generic function that</span>

<span class="s2">    is not soil specific.</span>

<span class="s2">    in Alhassane thesis, evap is called EVj for &quot;</span><span class="n">evaporation</span><span class="w"> </span><span class="n">journani√®re</span><span class="s2">&quot;, and</span>

<span class="s2">    is calculated as Evj = EvapPot x FESW. More details are available in the PhD</span>

<span class="s2">    dissertation of Alhassane https://hdl.handle.net/20.500.12177/1576</span>

<span class="s2">    The `estimate_effective_evaporation_from_evaporable_water` function computed</span>

<span class="s2">    later in the daily cycle uses the `evap` value to determine the effective</span>

<span class="s2">    evaporation (`consoRur`, mm) on the quantity of water in the surface tank</span>

<span class="s2">    (`surface_tank_stock`, mm).</span>

<span class="s2">    It has been adapted from the EvapRuSurf procedure, from bileau.pas and</span>

<span class="s2">    exmodules 1 &amp; 2.pas file from the original FORTRAN code.</span>

<span class="s2">    ? evaporation is bounded by the surface tank stock, which means it is meant</span>

<span class="s2">    ? to happen only in the depth described by the surface_tank</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;evap&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;evapPot&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;fesw&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="estimate_soil_potential_evaporation">estimate_soil_potential_evaporation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_soil_potential_evaporation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes estimation of potential soil evaporation (mm,</p>
<p>evapPot). </p>
<p>It performs its computations solely from the evaporation forcing driven by
climatic demand, limited by the coefficient of evaporation from the soil
(kce).</p>
<p>Note : difference in humectation of the top and bottom tanks is not taken
into consideration in this approach.  The</p>
<p>This function has been adapted from DemandeSol procedure, from bileau.pas
and exmodules 1 &amp; 2.pas file from the original FORTRAN code.</p>
<p>in Alhassane thesis, EvapPot = Kmulch x ETo x LTR ; here kce = kmulch x LTR so this formalism is respected</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_soil_potential_evaporation</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function computes estimation of potential soil evaporation (mm,</span>

<span class="s">    evapPot).</span>

<span class="s">    It performs its computations solely from the evaporation forcing driven by</span>

<span class="s">    climatic demand, limited by the coefficient of evaporation from the soil</span>

<span class="s">    (kce).</span>

<span class="s">    Note : difference in humectation of the top and bottom tanks is not taken</span>

<span class="s">    into consideration in this approach.  The</span>

<span class="s">    This function has been adapted from DemandeSol procedure, from bileau.pas</span>

<span class="s">    and exmodules 1 &amp; 2.pas file from the original FORTRAN code.</span>

<span class="s">    in Alhassane thesis, EvapPot = Kmulch x ETo x LTR ; here kce = kmulch x LTR so this formalism is respected</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;evapPot&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ET0&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;kce&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="estimate_transpirable_water">estimate_transpirable_water</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_transpirable_water</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the daily height of water available from the surface</p>
<p>reservoir for transpiration by the plant ('eauTranspi', mm).</p>
<p>If the filling rate of the surface tank ('surface_tank_stock' /
'surface_tank_capacity') for the previous day is under 10%, we set the
quantity of transpirable water as the water available for the day
('eauDispo') minus the water height necessary to keep the filling rate of
the surface tank at 10%. </p>
<p>Said otherwise, a part of the water available for the day ('eauDispo') is used
to maintain the surface reservoir at a minimum level of 10% of its capacity,
as this water is considered as bound to the surface reservoir and cannot be
transpired. </p>
<p>Of course, if the filling rate of the previous day is above 10%, the transpirable
water is equal to the water available for the day.</p>
<p>Furthermore, transpirable water cannot be negative.</p>
<p>? Remark : if the use of j-1 indices is troublesome, it should be feasible to
? run this function just before update_surface_tank_stock.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">estimate_transpirable_water</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function estimates the daily height of water available from the surface</span>

<span class="s">    reservoir for transpiration by the plant (&#39;eauTranspi&#39;, mm).</span>

<span class="s">    If the filling rate of the surface tank (&#39;surface_tank_stock&#39; /</span>

<span class="s">    &#39;surface_tank_capacity&#39;) for the previous day is under 10%, we set the</span>

<span class="s">    quantity of transpirable water as the water available for the day</span>

<span class="s">    (&#39;eauDispo&#39;) minus the water height necessary to keep the filling rate of</span>

<span class="s">    the surface tank at 10%.</span>

<span class="s">    Said otherwise, a part of the water available for the day (&#39;eauDispo&#39;) is used</span>

<span class="s">    to maintain the surface reservoir at a minimum level of 10% of its capacity,</span>

<span class="s">    as this water is considered as bound to the surface reservoir and cannot be</span>

<span class="s">    transpired.</span>

<span class="s">    Of course, if the filling rate of the previous day is above 10%, the transpirable</span>

<span class="s">    water is equal to the water available for the day.</span>

<span class="s">    Furthermore, transpirable water cannot be negative.</span>

<span class="s">    ? Remark : if the use of j-1 indices is troublesome, it should be feasible to</span>

<span class="s">    ? run this function just before update_surface_tank_stock.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">    </span><span class="err">#</span><span class="w">     </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="m m-Double">0.1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">    </span><span class="err">#</span><span class="w">     </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span>

<span class="w">    </span><span class="err">#</span><span class="w">         </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="err">#</span><span class="w">         </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="m m-Double">0.1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="err">#</span><span class="w">         </span><span class="p">),</span>

<span class="w">    </span><span class="err">#</span><span class="w">     </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="p">)</span>

<span class="w">    </span><span class="err">#</span><span class="p">!</span><span class="w"> </span><span class="nx">simplification</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nx">we</span><span class="w"> </span><span class="nx">are</span><span class="w"> </span><span class="nx">already</span><span class="w"> </span><span class="nx">working</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">water</span><span class="w"> </span><span class="nx">height</span><span class="w"> </span><span class="nx">between</span><span class="w"> </span><span class="nx">permanent</span><span class="w"> </span><span class="nx">wilting</span><span class="w"> </span><span class="nx">point</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nx">field</span><span class="w"> </span><span class="nx">capacity</span><span class="p">,</span>

<span class="w">    </span><span class="err">#</span><span class="p">!</span><span class="w"> </span><span class="nx">so</span><span class="w"> </span><span class="nx">there</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">no</span><span class="w"> </span><span class="nx">need</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">consider</span><span class="w"> </span><span class="nx">bound</span><span class="w"> </span><span class="nx">water</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">already</span><span class="w"> </span><span class="nx">taken</span><span class="w"> </span><span class="nx">into</span><span class="w"> </span><span class="nx">consideration</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">calculation</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">RU</span>

<span class="w">    </span><span class="err">#</span><span class="p">!</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nx">we</span><span class="w"> </span><span class="nx">want</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">take</span><span class="w"> </span><span class="nx">this</span><span class="w"> </span><span class="nx">further</span><span class="w"> </span><span class="nx">correctly</span><span class="w"> </span><span class="nx">we</span><span class="w"> </span><span class="nx">have</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">rewrite</span><span class="w"> </span><span class="nx">everything</span><span class="p">,</span><span class="w"> </span><span class="nx">so</span><span class="w"> </span><span class="nx">better</span><span class="w"> </span><span class="nx">keep</span><span class="w"> </span><span class="nx">it</span><span class="w"> </span><span class="nx">simple</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">now</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="fill_mulch">fill_mulch</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">fill_mulch</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This wrapper function computes the filling of the mulch for a given day.</p>
<p>It has been translated from the procedure PluieIrrig, of the original Pascal codes
bileau.pas and exmodules2.pas</p>
<p>For more details, it is advised to refer to the works of Eric Scopel (UR
AIDA), and the PhD dissertation of Fernando Maceina.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code>def fill_mulch(j, data, paramITK):

    &quot;&quot;&quot;

    This wrapper function computes the filling of the mulch for a given day.

    It has been translated from the procedure PluieIrrig, of the original Pascal codes

    bileau.pas and exmodules2.pas

    For more details, it is advised to refer to the works of Eric Scopel (UR

    AIDA), and the PhD dissertation of Fernando Maceina.

    &quot;&quot;&quot;

    data = compute_water_captured_by_mulch(j, data, paramITK)

    data = update_available_water_after_mulch_filling(j, data)

    data = update_mulch_water_stock(j, data)

    return data
</code></pre></div>

</details>
<h3 id="fill_tanks">fill_tanks</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">fill_tanks</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the procedure rempliRes, of the original Pascal codes</p>
<p>bileau.pas</p>
<p>Main hypotheses : 
- the water dynamics is represented by a filling from the top and an evolution 
of the reservoirs sizes when the filling is above the maximum quantity of the
current size (humectation front).
- when the maximum size is reached by filling, it is considered as drainage.
- inside a reservoir, water is distributed homogeneously (may be considered
valid up to 2m depth, according to CB, from other sources).</p>
<p>3 reservoirs are represented:
1) a global reservoir, evolving in depth according to the humectation front
2) a surface reservoir (fixed size) where evaporation and a part of the
transpiration occurs when roots are present
3) a root reservoir, evolving according to the root front (when roots are
present)</p>
<p>REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks</p>
<p>Notes from CB, 10/06/2015 :
prise en compte de stock d'eau r√©silient pour les simulation continues
Hypoth√®se de la MAJ des stock en fn de l'eau rÔøΩsiliente de l'annÔøΩe prÔøΩcÔøΩdente
dans le cas des simulations pluri annuelle en continue (NbAn = 1):
A la rÔøΩcolte on recupÔøΩre les stock d'eau (StRuPrec), la prof d'Humectation (Humprec)
et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien.
On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf)
Si le StRu avec l'apport d'eau devinet sup au Hum
alors on tient compte dans cette augmentation du stock rÔøΩsilient avec deux cas possible :
Si StRu est &lt; ÔøΩ stRurMaxprec
alors on ajoute l'eau rÔøΩsiliente contenue dans l'ancienne zone racinaire en fn
de la diffÔøΩrence de stock
Sinon on a de l'eau rÔøΩsiliente au maximum de la CC jusqu'ÔøΩ l'ancienne HumPrec,
on rempli alors StRu de la diffÔøΩrence etre ces deux valeurs puis on fait la MAJ
des Dr, StRur, Hum etc...</p>
<p>! simplification : we want to simplify the code, and we don't want to keep the possibility of multiple crop cycles
! we keep the old code for maintainance and future developments though</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">fill_tanks</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure rempliRes, of the original Pascal codes</span>

<span class="sd">    bileau.pas</span>

<span class="sd">    Main hypotheses :</span>

<span class="sd">    - the water dynamics is represented by a filling from the top and an evolution</span>

<span class="sd">    of the reservoirs sizes when the filling is above the maximum quantity of the</span>

<span class="sd">    current size (humectation front).</span>

<span class="sd">    - when the maximum size is reached by filling, it is considered as drainage.</span>

<span class="sd">    - inside a reservoir, water is distributed homogeneously (may be considered</span>

<span class="sd">    valid up to 2m depth, according to CB, from other sources).</span>

<span class="sd">    3 reservoirs are represented:</span>

<span class="sd">    1) a global reservoir, evolving in depth according to the humectation front</span>

<span class="sd">    2) a surface reservoir (fixed size) where evaporation and a part of the</span>

<span class="sd">    transpiration occurs when roots are present</span>

<span class="sd">    3) a root reservoir, evolving according to the root front (when roots are</span>

<span class="sd">    present)</span>

<span class="sd">    REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks</span>

<span class="sd">    Notes from CB, 10/06/2015 :</span>

<span class="sd">    prise en compte de stock d&#39;eau r√©silient pour les simulation continues</span>

<span class="sd">    Hypoth√®se de la MAJ des stock en fn de l&#39;eau rÔøΩsiliente de l&#39;annÔøΩe prÔøΩcÔøΩdente</span>

<span class="sd">    dans le cas des simulations pluri annuelle en continue (NbAn = 1):</span>

<span class="sd">    A la rÔøΩcolte on recupÔøΩre les stock d&#39;eau (StRuPrec), la prof d&#39;Humectation (Humprec)</span>

<span class="sd">    et la prof d&#39;enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien.</span>

<span class="sd">    On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf)</span>

<span class="sd">    Si le StRu avec l&#39;apport d&#39;eau devinet sup au Hum</span>

<span class="sd">    alors on tient compte dans cette augmentation du stock rÔøΩsilient avec deux cas possible :</span>

<span class="sd">    Si StRu est &lt; ÔøΩ stRurMaxprec</span>

<span class="sd">    alors on ajoute l&#39;eau rÔøΩsiliente contenue dans l&#39;ancienne zone racinaire en fn</span>

<span class="sd">    de la diffÔøΩrence de stock</span>

<span class="sd">    Sinon on a de l&#39;eau rÔøΩsiliente au maximum de la CC jusqu&#39;ÔøΩ l&#39;ancienne HumPrec,</span>

<span class="sd">    on rempli alors StRu de la diffÔøΩrence etre ces deux valeurs puis on fait la MAJ</span>

<span class="sd">    des Dr, StRur, Hum etc...</span>

<span class="sd">    ! simplification : we want to simplify the code, and we don&#39;t want to keep the possibility of multiple crop cycles</span>

<span class="sd">    ! we keep the old code for maintainance and future developments though</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// section 1 : updating the end_of_season memory variables</span>

<span class="w">    </span><span class="c1">#// in order to save resources, we test if there is at least one pixel at phase 7</span>

<span class="w">    </span><span class="c1">#// and one pixel at changePhase 1 in the current time step before applying the &quot;end_of_season&quot; functions</span>

<span class="w">    </span><span class="c1">#// if (np.any(data[&quot;numPhase&quot;][j,:,:] == 7)) &amp; (np.any(data[&quot;changePhase&quot;][j,:,:] == 1)):</span>

<span class="w">    </span><span class="c1">#//     data = update_previous_humectation_front_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_humectation_front_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_root_tank_capacity_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_previous_root_tank_stock_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#//     data = update_previous_total_tank_stock_at_end_of_season(j, data)</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// we let this function here, conditioned to work for j0 only, but it should be moved into initialization</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reset_total_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Updates the value of water stock in the surface tank (surface_tank_stock,</span>

<span class="w">    </span><span class="c1"># mm) with the water available for the day (available_water, mm), within the</span>

<span class="w">    </span><span class="c1"># limits of 110% surface_tank_capacity.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Estimates the daily height of water available from the surface reservoir</span>

<span class="w">    </span><span class="c1"># for transpiration by the plant (&#39;eauTranspi&#39;, mm). A part of the water</span>

<span class="w">    </span><span class="c1"># available for the day (&#39;eauDispo&#39;) is used to maintain the surface</span>

<span class="w">    </span><span class="c1"># reservoir at a minimum level of 10% of its capacity, as this water is</span>

<span class="w">    </span><span class="c1"># considered as bound to the surface reservoir and cannot be transpired.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_transpirable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Updates the total height of transpirable water (&#39;total_tank_stock&#39;, mm)</span>

<span class="w">    </span><span class="c1"># with the amount of transpirable water for the day (&#39;eauTranspi&#39;, mm)</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// delta_total_tank_stock is used with second cycle computations</span>

<span class="w">    </span><span class="c1">#// estimating positive delta between total_root_tank and stRuPrec</span>

<span class="w">    </span><span class="c1">#// data = update_delta_total_tank_stock(j, data)</span>

<span class="w">    </span><span class="c1">#! simplification</span>

<span class="w">    </span><span class="c1">#// # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged</span>

<span class="w">    </span><span class="c1">#// data = update_total_tank_stock_for_second_crop_cycle(j, data)# verif ok</span>

<span class="w">    </span><span class="c1">#// # # then previous_total_tank_stock can 1) take 0 or 2) be unchanged</span>

<span class="w">    </span><span class="c1">#// data = update_previous_total_tank_stock_for_second_crop_cycle(j, data)</span>

<span class="w">    </span><span class="c1">#// # # delta_total_tank_stock can 1) be incremented of previous_total_tank_stock or 2) be unchanged</span>

<span class="w">    </span><span class="c1">#//data = update_delta_total_tank_stock_step_2(j, data)</span>

<span class="w">    </span><span class="c1">#// # # here, in case 1, In this function, if the variation of transpirable water</span>

<span class="w">    </span><span class="c1">#// # (delta_total_tank_stock) increases above the depth of humectation front</span>

<span class="w">    </span><span class="c1">#// # (hum), if the depth of humectation front (hum) is above the</span>

<span class="w">    </span><span class="c1">#// # previous_root_tank_capacity (condition 1 passed, and 2 failed,</span>

<span class="w">    </span><span class="c1">#// # which should be the case for most of the simulations that will be</span>

<span class="w">    </span><span class="c1">#// # single-season), and if the depth of humectation front (hum) has decreased</span>

<span class="w">    </span><span class="c1">#// # since the previous day (condition 3 passed), then total_tank_stock takes the value of</span>

<span class="w">    </span><span class="c1">#// # delta_total_tank_stock, previous_total_tank_stock equals 0, and</span>

<span class="w">    </span><span class="c1">#// # delta_total_tank_stock is incremented by previous_total_tank_stock.</span>

<span class="w">    </span><span class="c1">#// #</span>

<span class="w">    </span><span class="c1">#// # in case 2, nothing happens.</span>

<span class="w">    </span><span class="c1"># Updates the water height to humectation front (humectation_front, mm) by</span>

<span class="w">    </span><span class="c1"># bounding it between delta_total_tank_stock and total_tank_capacity, so</span>

<span class="w">    </span><span class="c1"># that humectation front cannot go down indefinitely.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apply_humectation_front_boundaries</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># computes drainage</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compute_drainage</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="c1"># Updates the height of water in the tank of water accessible to roots</span>

<span class="w">    </span><span class="c1"># (&quot;root_tank_stock&quot;, mm), so that the transpirable water added to the root</span>

<span class="w">    </span><span class="c1"># tank stock for the day cannot be higher than both the root tank capacity,</span>

<span class="w">    </span><span class="c1"># and the total tank stock.</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="initialize_delta_root_tank_capacity">initialize_delta_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">initialize_delta_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function initializes the daily variation in root tank capacity. </p>
<p>This variable represents daily variation in water height accessible to
roots, in mm.</p>
<p>For each pixel at a developmental stage different from zero, and that is not
at initialization phase ('changePhase = 1' and 'numPhase = 1'), the daily
variation in root tank capacity (delta_root_tank_capacity, mm) is updated.</p>
<p>The updated value depends on the daily root growth speed (itself depending
on the current development phase of the plant), the drought stress
coefficient ('cstr'), and the soil water storage capacity ('ru', mm/m). </p>
<p>https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_118</p>
<p>However, when 'root_tank_capacity' is above 'surface_tank_capacity'
(meaning that the roots are prospecting water deeper than the surface tank),
the daily root capacity variation is calculated as the product of soil water
storage capacity ('ru'), the daily root growth speed ('vRac'), and a
coefficient made from 'cstr' shifted by 0.3, capped at 1.0. </p>
<p>https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_71</p>
<p>That is to say, when roots are going deep, the root growth speed is
modulated by drought stress.</p>
<p>The drought stress coefficient 'cstr' measures the level of drought stress
with 0 being full stress. The root growth speed is assumed to remain
non-null during a drought stress as a matter of survival, with a certain
level of tolerance given by the [0.3, 1] bound of the coefficient. Using the
[0.3, 1] bound is a way to tell that in the [0.7, 1] 'cstr' interval, there
is no effect of drought stress on the root growth speed, allowing for a
certain level of tolerance of the plant.</p>
<p>When 'root_tank_capacity' is lower than 'surface_tank_capacity', the root growth
speed is not modulated by drought stress.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>The current iteration step of the process.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray.Dataset</td>
<td>The input data containing relevant information.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xarray.Dataset</td>
<td>The updated input data with the daily root capacity variation calculated and stored.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">initialize_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function initializes the daily variation in root tank capacity.</span>

<span class="sd">    This variable represents daily variation in water height accessible to</span>

<span class="sd">    roots, in mm.</span>

<span class="sd">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="sd">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;), the daily</span>

<span class="sd">    variation in root tank capacity (delta_root_tank_capacity, mm) is updated.</span>

<span class="sd">    The updated value depends on the daily root growth speed (itself depending</span>

<span class="sd">    on the current development phase of the plant), the drought stress</span>

<span class="sd">    coefficient (&#39;cstr&#39;), and the soil water storage capacity (&#39;ru&#39;, mm/m).</span>

<span class="sd">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_118</span>

<span class="sd">    However, when &#39;root_tank_capacity&#39; is above &#39;surface_tank_capacity&#39;</span>

<span class="sd">    (meaning that the roots are prospecting water deeper than the surface tank),</span>

<span class="sd">    the daily root capacity variation is calculated as the product of soil water</span>

<span class="sd">    storage capacity (&#39;ru&#39;), the daily root growth speed (&#39;vRac&#39;), and a</span>

<span class="sd">    coefficient made from &#39;cstr&#39; shifted by 0.3, capped at 1.0.</span>

<span class="sd">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_71</span>

<span class="sd">    That is to say, when roots are going deep, the root growth speed is</span>

<span class="sd">    modulated by drought stress.</span>

<span class="sd">    The drought stress coefficient &#39;cstr&#39; measures the level of drought stress</span>

<span class="sd">    with 0 being full stress. The root growth speed is assumed to remain</span>

<span class="sd">    non-null during a drought stress as a matter of survival, with a certain</span>

<span class="sd">    level of tolerance given by the [0.3, 1] bound of the coefficient. Using the</span>

<span class="sd">    [0.3, 1] bound is a way to tell that in the [0.7, 1] &#39;cstr&#39; interval, there</span>

<span class="sd">    is no effect of drought stress on the root growth speed, allowing for a</span>

<span class="sd">    certain level of tolerance of the plant.</span>

<span class="sd">    When &#39;root_tank_capacity&#39; is lower than &#39;surface_tank_capacity&#39;, the root growth</span>

<span class="sd">    speed is not modulated by drought stress.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): The current iteration step of the process.</span>

<span class="sd">        data (xarray.Dataset): The input data containing relevant information.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="initialize_root_tank_capacity">initialize_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">initialize_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function initializes the root tank.</p>
<p>If during the considered day j there are pixels in phase 1 (initialisation),
we test for pixels at phase change between phases 0 and 1 ('changePhase = 1'
and 'numPhase = 1').</p>
<p>On these pixels, the maximum root tank water storage ('root_tank_capacity',
mm) is initialised by multiplying the initial root depth ('profRacIni', mm)
with the soil water storage capacity ('ru', mm/m). This value is broadcasted
on the time series. For every other day in the cycle where there are pixels
at , the value remains unchanged.</p>
<p>https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_30</p>
<p>Args:
    j (int): day identifier
    data (xarray dataset): an xarray dataset of dimensions (day, width,
    height) containing the variables 'numPhase', 'root_tank_capacity',
    'changePhase', 'ru'
    paramITK (dict): a dictionary containing the ITK parameter 'profRacIni'</p>
<p>Returns:
    <em>type</em>: <em>description</em></p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">initialize_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function initializes the root tank.</span>

<span class="sd">    If during the considered day j there are pixels in phase 1 (initialisation),</span>

<span class="sd">    we test for pixels at phase change between phases 0 and 1 (&#39;changePhase = 1&#39;</span>

<span class="sd">    and &#39;numPhase = 1&#39;).</span>

<span class="sd">    On these pixels, the maximum root tank water storage (&#39;root_tank_capacity&#39;,</span>

<span class="sd">    mm) is initialised by multiplying the initial root depth (&#39;profRacIni&#39;, mm)</span>

<span class="sd">    with the soil water storage capacity (&#39;ru&#39;, mm/m). This value is broadcasted</span>

<span class="sd">    on the time series. For every other day in the cycle where there are pixels</span>

<span class="sd">    at , the value remains unchanged.</span>

<span class="sd">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_30</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): day identifier</span>

<span class="sd">        data (xarray dataset): an xarray dataset of dimensions (day, width,</span>

<span class="sd">        height) containing the variables &#39;numPhase&#39;, &#39;root_tank_capacity&#39;,</span>

<span class="sd">        &#39;changePhase&#39;, &#39;ru&#39;</span>

<span class="sd">        paramITK (dict): a dictionary containing the ITK parameter &#39;profRacIni&#39;</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">:</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>

<span class="w">            </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="reset_total_tank_capacity">reset_total_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">reset_total_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function resets the value total_tank_capacity at each loop.</p>
<p>? Why redfining stRuMax at each loop ? Neither ru, profRu 
? nor total_tank_capacity are modified during the simulation.
? At the same time, its value is initialized at 0, and this function 
? is the only place where it is initialized taking ru and profRu into account.</p>
<p>? We modify it so it runs only at day one.
? But it should be moved to the initialization part of the code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">reset_total_tank_capacity</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function resets the value total_tank_capacity at each loop.</span>

<span class="s">    ? Why redfining stRuMax at each loop ? Neither ru, profRu</span>

<span class="s">    ? nor total_tank_capacity are modified during the simulation.</span>

<span class="s">    ? At the same time, its value is initialized at 0, and this function</span>

<span class="s">    ? is the only place where it is initialized taking ru and profRu into account.</span>

<span class="s">    ? We modify it so it runs only at day one.</span>

<span class="s">    ? But it should be moved to the initialization part of the code.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nx">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;ru&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;profRu&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="set_evapotranspirable_surface_water">set_evapotranspirable_surface_water</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">set_evapotranspirable_surface_water</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function stores the initial value of <code>surface_tank_stock</code> in a new</p>
<p>variable representing the quantity of evapotranspirable surface water (<code>trSurf</code>,
mm), as the value <code>surface_tank_stock</code> will later be updated.</p>
<p>The original function (based on the ConsoResSep procedure, from bileau.pas,
exmodules 1 &amp; 2.pas files, from the original FORTRAN code) removed 1/10th of
surface tank capacity as water was condidered as bound to the soil.</p>
<p>However, as we are working with the water volumes in between permanent
wilting point and field capacity - thus already considering water bound to
the soil, we will remove all of these arbitrary 10% corrections.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="k">set</span><span class="n">_evapotranspirable_surface_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function stores the initial value of `surface_tank_stock` in a new</span>

<span class="s2">    variable representing the quantity of evapotranspirable surface water (`trSurf`,</span>

<span class="s2">    mm), as the value `surface_tank_stock` will later be updated.</span>

<span class="s2">    The original function (based on the ConsoResSep procedure, from bileau.pas,</span>

<span class="s2">    exmodules 1 &amp; 2.pas files, from the original FORTRAN code) removed 1/10th of</span>

<span class="s2">    surface tank capacity as water was condidered as bound to the soil.</span>

<span class="s2">    However, as we are working with the water volumes in between permanent</span>

<span class="s2">    wilting point and field capacity - thus already considering water bound to</span>

<span class="s2">    the soil, we will remove all of these arbitrary 10% corrections.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;trSurf&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="c1">#// data[&quot;surface_tank_stock&quot;][j,:,:] - data[&quot;surface_tank_capacity&quot;] * 0.1,</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="subtract_effective_evaporation_from_root_tank_stock">subtract_effective_evaporation_from_root_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subtract_effective_evaporation_from_root_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the quantity of water in the root tank</p>
<p>(<code>root_tank_stock</code>, mm) according to the effective evaporation, taking into
consideration potential shallow rooting ( as <code>consoRur</code> was calculated
through both <code>estimate_effective_evaporation_from_evaporable_water</code> and
<code>update_effective_evaporation_for_shallow_roots</code> functions).</p>
<p><code>root_tank_stock</code> value cannot be negative, so it is bound by 0.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">subtract_effective_evaporation_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the quantity of water in the root tank</span>

<span class="s2">    (`root_tank_stock`, mm) according to the effective evaporation, taking into</span>

<span class="s2">    consideration potential shallow rooting ( as `consoRur` was calculated</span>

<span class="s2">    through both `estimate_effective_evaporation_from_evaporable_water` and</span>

<span class="s2">    `update_effective_evaporation_for_shallow_roots` functions).</span>

<span class="s2">    `root_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;consoRur&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="subtract_effective_evaporation_from_total_tank_stock">subtract_effective_evaporation_from_total_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subtract_effective_evaporation_from_total_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the total quantity of water (<code>total_tank_stock</code>, mm)</p>
<p>by subtracting the effective evaporation (<code>consoRur</code>, mm).</p>
<p><code>total_tank_stock</code> value cannot be negative, so it is bound by 0.</p>
<h1 id="though-it-seems-impossible-to-have-a-negative-value-of-total_tank_stock">? though it seems impossible to have a negative value of <code>total_tank_stock</code></h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">subtract_effective_evaporation_from_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the total quantity of water (`total_tank_stock`, mm)</span>

<span class="s2">    by subtracting the effective evaporation (`consoRur`, mm).</span>

<span class="s2">    `total_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    #? though it seems impossible to have a negative value of `total_tank_stock`</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;consoRur&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="subtract_evap_from_surface_tank_stock">subtract_evap_from_surface_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subtract_evap_from_surface_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the water stock of the surface tank</p>
<p>(<code>surface_tank_stock</code>, mm) by subtracting the daily amount of evaporation
(<code>evap</code>, mm) from it.</p>
<p><code>evap</code> is calculated in the <code>estimate_soil_evaporation</code> function earlier in
the daily loop from the potential soil evaporation (<code>evapPot</code>, mm) and the
fraction of evaporable soil water (<code>fesw</code>), and cannot exceed the value of
<code>surface_tank_stock</code>. This approach is somewhat comparable to the soil
evaporation reduction coefficient kr approach presented in FAO56 paper. See
documentation of the <code>estimate_soil_evaporation</code> function for further
details.</p>
<h1 id="as-evap-cannot-exceed-the-value-of-surface_tank_stock-according-to-the">? As <code>evap</code> cannot exceed the value of <code>surface_tank_stock</code> according to the</h1>
<h1 id="estimate_soil_evaporation-function-and-is-not-modified-until-this-function">? <code>estimate_soil_evaporation</code> function and is not modified until this function</h1>
<h1 id="is-applied-it-is-funny-to-see-that-the">? is applied, it is funny to see that the</h1>
<h1 id="subtract_evap_from_surface_tank_stock-function-enforces">? <code>subtract_evap_from_surface_tank_stock</code> function enforces</h1>
<h1 id="surface_tank_stock-not-to-take-a-negative-value-hence-we-could-probably">? <code>surface_tank_stock</code> not to take a negative value. Hence, we could probably</h1>
<h1 id="simplify-this-function">? simplify this function.</h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">subtract_evap_from_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the water stock of the surface tank</span>

<span class="s2">    (`surface_tank_stock`, mm) by subtracting the daily amount of evaporation</span>

<span class="s2">    (`evap`, mm) from it.</span>

<span class="s2">    `evap` is calculated in the `estimate_soil_evaporation` function earlier in</span>

<span class="s2">    the daily loop from the potential soil evaporation (`evapPot`, mm) and the</span>

<span class="s2">    fraction of evaporable soil water (`fesw`), and cannot exceed the value of</span>

<span class="s2">    `surface_tank_stock`. This approach is somewhat comparable to the soil</span>

<span class="s2">    evaporation reduction coefficient kr approach presented in FAO56 paper. See</span>

<span class="s2">    documentation of the `estimate_soil_evaporation` function for further</span>

<span class="s2">    details.</span>

<span class="s2">    #? As `evap` cannot exceed the value of `surface_tank_stock` according to the</span>

<span class="s2">    #? `estimate_soil_evaporation` function and is not modified until this function</span>

<span class="s2">    #? is applied, it is funny to see that the</span>

<span class="s2">    #? `subtract_evap_from_surface_tank_stock` function enforces</span>

<span class="s2">    #? `surface_tank_stock` not to take a negative value. Hence, we could probably</span>

<span class="s2">    #? simplify this function.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;evap&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="subtract_transpiration_from_root_tank_stock">subtract_transpiration_from_root_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subtract_transpiration_from_root_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the quantity of water in the root tank</p>
<p>(<code>root_tank_stock</code>, mm) by subtracting the plant transpiration (<code>tr</code>, mm)
from it.</p>
<p><code>root_tank_stock</code> value cannot be negative, so it is bound by 0.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">subtract_transpiration_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the quantity of water in the root tank</span>

<span class="s2">    (`root_tank_stock`, mm) by subtracting the plant transpiration (`tr`, mm)</span>

<span class="s2">    from it.</span>

<span class="s2">    `root_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock">subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the surface tank stock to reflect plant transpiration,</p>
<p>in accordance with the repartition of water between surface and root tanks.</p>
<p>If <code>root_tank_stock</code> is above 0, then <code>surface_tank_stock</code> is updated by
subtracting the plant transpiration modulated by the ratio between the
transpirable water <code>trSurf</code> (representing the amount of water in surface
tank at the beginning of the day) and the root tank stock.</p>
<p>This ratio is bounded by 1, meaning that if there is a higher quantity of
transpirable water that water accessible to roots, then the ratio is set to
1, and <code>surface_tank_stock</code> will be updated by being subtracted by <code>tr</code>.</p>
<p>On the contrary, if transpirable water <code>trSurf</code> is much lower than the root
tank stock, meaning that there is a lot of water accessible to roots but
this water is in the deep tank, then the ratio will be close to 0, and the
<code>surface_tank_stock</code> will be updated by being subtracted by a very low value
of <code>tr</code>.</p>
<h1 id="the-rules-and-underlying-assumptions-for-these-transfers-seem-somewhat">? The rules and underlying assumptions for these transfers seem somewhat</h1>
<h1 id="arbitrary-so-we-want-to-be-cautious-about-them">? arbitrary, so we want to be cautious about them.</h1>
<h1 id="also-it-is-not-clear-why-we-use-trsurf-instead-of-surface_tank_stock">? Also, it is not clear why we use trSurf instead of surface_tank_stock</h1>
<h1 id="in-the-calculations">? in the calculations.</h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">subtract_transpiration_from_surface_tank_stock_according_to_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the surface tank stock to reflect plant transpiration,</span>

<span class="s2">    in accordance with the repartition of water between surface and root tanks.</span>

<span class="s2">    If `root_tank_stock` is above 0, then `surface_tank_stock` is updated by</span>

<span class="s2">    subtracting the plant transpiration modulated by the ratio between the</span>

<span class="s2">    transpirable water `trSurf` (representing the amount of water in surface</span>

<span class="s2">    tank at the beginning of the day) and the root tank stock.</span>

<span class="s2">    This ratio is bounded by 1, meaning that if there is a higher quantity of</span>

<span class="s2">    transpirable water that water accessible to roots, then the ratio is set to</span>

<span class="s2">    1, and `surface_tank_stock` will be updated by being subtracted by `tr`.</span>

<span class="s2">    On the contrary, if transpirable water `trSurf` is much lower than the root</span>

<span class="s2">    tank stock, meaning that there is a lot of water accessible to roots but</span>

<span class="s2">    this water is in the deep tank, then the ratio will be close to 0, and the</span>

<span class="s2">    `surface_tank_stock` will be updated by being subtracted by a very low value</span>

<span class="s2">    of `tr`.</span>

<span class="s2">    #? The rules and underlying assumptions for these transfers seem somewhat</span>

<span class="s2">    #? arbitrary, so we want to be cautious about them.</span>

<span class="s2">    #? Also, it is not clear why we use trSurf instead of surface_tank_stock</span>

<span class="s2">    #? in the calculations.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span>

<span class="w">            </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span>

<span class="w">                </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;trSurf&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">                </span><span class="mi">1</span><span class="p">,</span>

<span class="w">            </span><span class="p">)),</span>

<span class="w">            </span><span class="mi">0</span><span class="p">,</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="subtract_transpiration_from_total_tank_stock">subtract_transpiration_from_total_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subtract_transpiration_from_total_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the total quantity of water (<code>total_tank_stock</code>, mm)</p>
<p>by subtracting the plant transpiration (<code>tr</code>, mm) from it.</p>
<p><code>total_tank_stock</code> value cannot be negative, so it is bound by 0.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">subtract_transpiration_from_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the total quantity of water (`total_tank_stock`, mm)</span>

<span class="s2">    by subtracting the plant transpiration (`tr`, mm) from it.</span>

<span class="s2">    `total_tank_stock` value cannot be negative, so it is bound by 0.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="update_available_water_after_mulch_filling">update_available_water_after_mulch_filling</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_available_water_after_mulch_filling</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates available water after mulch filling.</p>
<p>As some water is captured by the mulch (rain or irrigation water falling on
it), the available_water is updated by subtracting the captured water
(water_captured_by_mulch, mm) from the total available water
(available_water, mm), to represent the remaining available water after
capture by the mulch. This value is bounded by 0, as the available water
cannot be negative.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_available_water_after_mulch_filling</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates available water after mulch filling.</span>

<span class="s">    As some water is captured by the mulch (rain or irrigation water falling on</span>

<span class="s">    it), the available_water is updated by subtracting the captured water</span>

<span class="s">    (water_captured_by_mulch, mm) from the total available water</span>

<span class="s">    (available_water, mm), to represent the remaining available water after</span>

<span class="s">    capture by the mulch. This value is bounded by 0, as the available water</span>

<span class="s">    cannot be negative.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w">  </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;water_captured_by_mulch&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_available_water_after_runoff">update_available_water_after_runoff</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_available_water_after_runoff</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Updating available water (eauDispo, mm) :</p>
<p>The available water is updated by subtracting the runoff (lr, mm) from the
total available water (eauDispo, mm). This value is broadcasted onto the
days axis.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_available_water_after_runoff</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    Updating available water (eauDispo, mm) :</span>

<span class="s">    The available water is updated by subtracting the runoff (lr, mm) from the</span>

<span class="s">    total available water (eauDispo, mm). This value is broadcasted onto the</span>

<span class="s">    days axis.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;runoff&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_delta_root_tank_capacity">update_delta_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_delta_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the daily variation in root tank capacity</p>
<p>(delta_root_tank_capacity, mm) depending on the water height to humectation
front (hum, mm) and the root tank capacity (root_tank_capacity, mm).</p>
<p>For each pixel at a developmental stage different from zero, and that is not
at initialization phase ('changePhase = 1' and 'numPhase = 1'), when the
difference between the water height to humectation front (hum, mm) and the
root_tank_capacity is less than the delta_root_tank_capacity (meaning that
the daily variation in root tank capacity is higher that the height of water
necessary to reach the height of water of the humectation front),
delta_root_tank_capacity is updated to be equal to the difference between
the water height to humectation front and the root_tank_capacity.</p>
<p>In other words, the change in root tank capacity delta_root_tank_capacity is
limited by the water height to humectation front. Which can be interpreted as :
the roots cannot grow deeper than the humectation front.</p>
<p>? ...which means the humectation from has to be updated somewhere ?</p>
<p>For any other day or if root_tank_capacity is above
delta_root_tank_capacity, delta_root_tank_capacity value is unchanged.</p>
<p>https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_161</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the daily variation in root tank capacity</span>

<span class="sd">    (delta_root_tank_capacity, mm) depending on the water height to humectation</span>

<span class="sd">    front (hum, mm) and the root tank capacity (root_tank_capacity, mm).</span>

<span class="sd">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="sd">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;), when the</span>

<span class="sd">    difference between the water height to humectation front (hum, mm) and the</span>

<span class="sd">    root_tank_capacity is less than the delta_root_tank_capacity (meaning that</span>

<span class="sd">    the daily variation in root tank capacity is higher that the height of water</span>

<span class="sd">    necessary to reach the height of water of the humectation front),</span>

<span class="sd">    delta_root_tank_capacity is updated to be equal to the difference between</span>

<span class="sd">    the water height to humectation front and the root_tank_capacity.</span>

<span class="sd">    In other words, the change in root tank capacity delta_root_tank_capacity is</span>

<span class="sd">    limited by the water height to humectation front. Which can be interpreted as :</span>

<span class="sd">    the roots cannot grow deeper than the humectation front.</span>

<span class="sd">    ? ...which means the humectation from has to be updated somewhere ?</span>

<span class="sd">    For any other day or if root_tank_capacity is above</span>

<span class="sd">    delta_root_tank_capacity, delta_root_tank_capacity value is unchanged.</span>

<span class="sd">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_161</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="update_delta_total_tank_stock">update_delta_total_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_delta_total_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the positive variation of the total height of</p>
<p>transpirable water ('delta_total_tank_stock', mm).</p>
<p>It is computed as the difference between the total_tank_stock and
previous_total_tank_stock, bound in 0. </p>
<p>'previous_total_tank_stock' is initialized to be equal to 'total_tank_stock'
at the beginning of the simulation. As 'total_tank_stock' is initialized
with the 'stockIrr' parameter, simulations should start with a 0 value.</p>
<p>'previous_total_tank_stock' is updated each day with the 'update_struprec'
function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_delta_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the positive variation of the total height of</span>

<span class="sd">    transpirable water (&#39;delta_total_tank_stock&#39;, mm).</span>

<span class="sd">    It is computed as the difference between the total_tank_stock and</span>

<span class="sd">    previous_total_tank_stock, bound in 0.</span>

<span class="sd">    &#39;previous_total_tank_stock&#39; is initialized to be equal to &#39;total_tank_stock&#39;</span>

<span class="sd">    at the beginning of the simulation. As &#39;total_tank_stock&#39; is initialized</span>

<span class="sd">    with the &#39;stockIrr&#39; parameter, simulations should start with a 0 value.</span>

<span class="sd">    &#39;previous_total_tank_stock&#39; is updated each day with the &#39;update_struprec&#39;</span>

<span class="sd">    function.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="update_delta_total_tank_stock_step_2">update_delta_total_tank_stock_step_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_delta_total_tank_stock_step_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>? Ok the logic is the same as for the two previous functions </p>
<p>? and i don't want to document it as it is way too complicated
? and we won't be using it for now.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_delta_total_tank_stock_step_2</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    ? Ok the logic is the same as for the two previous functions</span>

<span class="s">    ? and i don&#39;t want to document it as it is way too complicated</span>

<span class="s">    ? and we won&#39;t be using it for now.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition_1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">condition_2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">condition_3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition_1</span><span class="p">,</span>

<span class="w">        </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">            </span><span class="nx">condition_2</span><span class="p">,</span>

<span class="w">            </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">                </span><span class="nx">condition_3</span><span class="p">,</span>

<span class="w">                </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">                </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_drainage">update_drainage</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_drainage</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the daily drainage (dr).</p>
<p>When total tank overflows (total_tank_stock &gt; total_tank_capacity), the
drainage is computed from the difference between total_tank_stock and
total_tank_capacity. This means the drainage value will be positive</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function estimates the daily drainage (dr).</span>

<span class="s">    When total tank overflows (total_tank_stock &gt; total_tank_capacity), the</span>

<span class="s">    drainage is computed from the difference between total_tank_stock and</span>

<span class="s">    total_tank_capacity. This means the drainage value will be positive</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;drainage&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition</span><span class="p">,</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_effective_evaporation_for_shallow_roots">update_effective_evaporation_for_shallow_roots</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_effective_evaporation_for_shallow_roots</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of effective evaporation (<code>consoRur</code>, mm) in</p>
<p>order to be used specifically to update the quantity of water in the root
tank (<code>root_tank_stock</code>, mm).</p>
<p>If the root tank capacity is lower than the surface tank capacity, meaning
than the roots do not dive into the deep tank yet, then the effective
evaporation is updated to equal the evaporable water (<code>evap</code>, mm) modulated
by the ratio between <code>root_tank_stock</code> and <code>surface_tank_capacity</code>, that is
to say at the prorata of the exploration of surface tank by the roots.</p>
<p>Else, <code>consoRur</code> keeps it value, which was previously computed by the
<code>estimate_effective_evaporation_from_evaporable_water</code> function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_effective_evaporation_for_shallow_roots</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the value of effective evaporation (`consoRur`, mm) in</span>

<span class="s2">    order to be used specifically to update the quantity of water in the root</span>

<span class="s2">    tank (`root_tank_stock`, mm).</span>

<span class="s2">    If the root tank capacity is lower than the surface tank capacity, meaning</span>

<span class="s2">    than the roots do not dive into the deep tank yet, then the effective</span>

<span class="s2">    evaporation is updated to equal the evaporable water (`evap`, mm) modulated</span>

<span class="s2">    by the ratio between `root_tank_stock` and `surface_tank_capacity`, that is</span>

<span class="s2">    to say at the prorata of the exploration of surface tank by the roots.</span>

<span class="s2">    Else, `consoRur` keeps it value, which was previously computed by the</span>

<span class="s2">    `estimate_effective_evaporation_from_evaporable_water` function.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;consoRur&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;evap&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;consoRur&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="update_humectation_front_after_drainage">update_humectation_front_after_drainage</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_humectation_front_after_drainage</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>We update the depth to humectation front (hum) again, to reflect eventual changes in</p>
<p>total_tank_stock values.</p>
<p>? we could have placed the previous hum update function here</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_humectation_front_after_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    We update the depth to humectation front (hum) again, to reflect eventual changes in</span>

<span class="s">    total_tank_stock values.</span>

<span class="s">    ? we could have placed the previous hum update function here</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_humectation_front_at_end_of_season">update_humectation_front_at_end_of_season</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_humectation_front_at_end_of_season</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of water height to humectation front</p>
<p>(humectation_front, mm) at the end of season.</p>
<p>At the harvest date (numPhase = 7), the humectation_front variable is set to
equal the surface_tank_capacity (mm). This value is broadcasted over the
time dimension.</p>
<p>At any other point in time, its value is unchanged.</p>
<p>? The way of resetting the humectation_front at harvest date hasn't a real
? agronomical meaning. This function allows for resetting the variable at an
? initial state.</p>
<p>? However it is a way to say that when the plant dies, the new ones will have
? to make up their new humectation fronts starting again from surface_tank_capacity</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_humectation_front_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the value of water height to humectation front</span>

<span class="sd">    (humectation_front, mm) at the end of season.</span>

<span class="sd">    At the harvest date (numPhase = 7), the humectation_front variable is set to</span>

<span class="sd">    equal the surface_tank_capacity (mm). This value is broadcasted over the</span>

<span class="sd">    time dimension.</span>

<span class="sd">    At any other point in time, its value is unchanged.</span>

<span class="sd">    ? The way of resetting the humectation_front at harvest date hasn&#39;t a real</span>

<span class="sd">    ? agronomical meaning. This function allows for resetting the variable at an</span>

<span class="sd">    ? initial state.</span>

<span class="sd">    ? However it is a way to say that when the plant dies, the new ones will have</span>

<span class="sd">    ? to make up their new humectation fronts starting again from surface_tank_capacity</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="update_irrigation_tank_capacity">update_irrigation_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_irrigation_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the capacity if the irrigation tank.</p>
<p>If the simulation is run with automatic irrigation mode
(<code>data["irrigAuto"]==True</code>), if the current phase is between 0 and 6, and if
the root tank capacity is less than the surface tank capacity (meaning that
the roots have not reached the limit between the surface compartment and
deep compartment), then <code>irrigation_tank_capacity</code> is set to the value of
<code>surface_tank_capacity</code>, which is given a minimum value equal to the
<code>surface_tank_capacity</code>. Otherwise, the irrigation tank capacity remains
unchanged.</p>
<p>Note : the logic of this function has not yet been validated in SARRA-Py, as
simulations are mainly based on rainfed conditions.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>Index of the time step being processed.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray dataset</td>
<td>The input dataset containing all the information necessary to run the model.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>xarray dataset: The input dataset with updated values of the irrigation tank capacity.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_irrigation_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the capacity if the irrigation tank.</span>

<span class="s2">    If the simulation is run with automatic irrigation mode</span>

<span class="s2">    (`data[&quot;</span><span class="n">irrigAuto</span><span class="s2">&quot;]==True`), if the current phase is between 0 and 6, and if</span>

<span class="s2">    the root tank capacity is less than the surface tank capacity (meaning that</span>

<span class="s2">    the roots have not reached the limit between the surface compartment and</span>

<span class="s2">    deep compartment), then `irrigation_tank_capacity` is set to the value of</span>

<span class="s2">    `surface_tank_capacity`, which is given a minimum value equal to the</span>

<span class="s2">    `surface_tank_capacity`. Otherwise, the irrigation tank capacity remains</span>

<span class="s2">    unchanged.</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on rainfed conditions.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): Index of the time step being processed.</span>

<span class="s2">        data (xarray dataset): The input dataset containing all the information necessary to run the model.</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray dataset: The input dataset with updated values of the irrigation tank capacity.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;numPhase&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;numPhase&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">            </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="err">]</span><span class="p">,</span>

<span class="w">            </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="err">]</span><span class="p">,</span>

<span class="w">            </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="update_irrigation_tank_stock">update_irrigation_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_irrigation_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the water stock of the irrigation tank.</p>
<p>If the simulation is run with automatic irrigation mode
(<code>data["irrigAuto"]==True</code>), if the simulation is between phases 0 and 6,
and if <code>root_tank_capacity</code> is lower than <code>surface_tank_capacity</code> (which
indicates that the roots have not yet reached the limit between the surface
compartment and deep compartment), <code>irrigation_tank_stock</code> will be set to
the value of <code>surface_tank_stock</code>, which means, it will take the minimum
value equal to <code>surface_tank_stock</code>. For phase 7, the existing
<code>irrigation_tank_stock</code> value will be kept unchanged.</p>
<p>Note : the logic of this function has not yet been validated in SARRA-Py, as
simulations are mainly based on rainfed conditions.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>Index of time step in data</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray Dataset</td>
<td>Dataset that contains various data fields</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_irrigation_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the water stock of the irrigation tank.</span>

<span class="s2">    If the simulation is run with automatic irrigation mode</span>

<span class="s2">    (`data[&quot;</span><span class="n">irrigAuto</span><span class="s2">&quot;]==True`), if the simulation is between phases 0 and 6,</span>

<span class="s2">    and if `root_tank_capacity` is lower than `surface_tank_capacity` (which</span>

<span class="s2">    indicates that the roots have not yet reached the limit between the surface</span>

<span class="s2">    compartment and deep compartment), `irrigation_tank_stock` will be set to</span>

<span class="s2">    the value of `surface_tank_stock`, which means, it will take the minimum</span>

<span class="s2">    value equal to `surface_tank_stock`. For phase 7, the existing</span>

<span class="s2">    `irrigation_tank_stock` value will be kept unchanged.</span>

<span class="s2">    Note : the logic of this function has not yet been validated in SARRA-Py, as</span>

<span class="s2">    simulations are mainly based on rainfed conditions.</span>

<span class="s2">    Args:</span>

<span class="s2">        j (int): Index of time step in data</span>

<span class="s2">        data (xarray Dataset): Dataset that contains various data fields</span>

<span class="s2">    Returns:</span>

<span class="s2">        xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions.</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;numPhase&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">\</span>

<span class="w">        </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;numPhase&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="err">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="err">]</span><span class="p">)</span><span class="err">[</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">            </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">            </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="p">,</span><span class="w"> </span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="update_mulch_water_stock">update_mulch_water_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_mulch_water_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the water stock in mulch.</p>
<p>The water stock in mulch is updated by adding the captured water (water_captured_by_mulch, mm)</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_mulch_water_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the water stock in mulch.</span>

<span class="s">    The water stock in mulch is updated by adding the captured water (water_captured_by_mulch, mm)</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;water_captured_by_mulch&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_plant_transpiration">update_plant_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_plant_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of plant transpiration (<code>tr</code>, mm) according</p>
<p>to the quantity of water in the root tank (<code>root_tank_stock</code>, mm).</p>
<p>If the transpiration (which as this point on the daily cycle equals <code>trPot *
cstr</code>) is higher than the root tank stock (which at this point has been
updated to reflect the effective evaporation), then plant transpiration is
updated to be equal to the difference between the root tank stock and the
plant transpiration.</p>
<p>Else, its value is unmodified.</p>
<h1 id="however-if-this-test-is-true-this-always-leads-to-transpiration-value-0">? However, if this test is true, this always leads to transpiration value = 0.</h1>
<h1 id="we-may-want-to-rethink-it-to-check-if-it-does-what-it-was-supposed-to">? We may want to rethink it to check if it does what it was supposed to.</h1>
<h1 id="instead-it-would-make-more-sense-to-bound-tr-by-the-value-of-root-tank-stock">? Instead it would make more sense to bound tr by the value of root tank stock,</h1>
<h1 id="meaning-the-maximum-quantity-of-water-that-can-be-transpired-by-the-plant">? meaning the maximum quantity of water that can be transpired by the plant</h1>
<h1 id="is-limited-by-the-quantity-of-water-accessible-to-roots">? is limited by the quantity of water accessible to roots...</h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="o">:</span>

<span class="w">    </span><span class="s2">&quot;</span><span class="se">&quot;&quot;</span>

<span class="s2">    This function updates the value of plant transpiration (`tr`, mm) according</span>

<span class="s2">    to the quantity of water in the root tank (`root_tank_stock`, mm).</span>

<span class="s2">    If the transpiration (which as this point on the daily cycle equals `trPot *</span>

<span class="s2">    cstr`) is higher than the root tank stock (which at this point has been</span>

<span class="s2">    updated to reflect the effective evaporation), then plant transpiration is</span>

<span class="s2">    updated to be equal to the difference between the root tank stock and the</span>

<span class="s2">    plant transpiration.</span>

<span class="s2">    Else, its value is unmodified.</span>

<span class="s2">    #? However, if this test is true, this always leads to transpiration value = 0.</span>

<span class="s2">    #? We may want to rethink it to check if it does what it was supposed to.</span>

<span class="s2">    #? Instead it would make more sense to bound tr by the value of root tank stock,</span>

<span class="s2">    #? meaning the maximum quantity of water that can be transpired by the plant</span>

<span class="s2">    #? is limited by the quantity of water accessible to roots...</span>

<span class="s2">    Args:</span>

<span class="s2">        j (_type_): _description_</span>

<span class="s2">        data (_type_): _description_</span>

<span class="s2">    Returns:</span>

<span class="s2">        _type_: _description_</span>

<span class="s2">    </span><span class="se">&quot;&quot;</span><span class="s2">&quot;</span>

<span class="w">    </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>

<span class="w">        </span><span class="c1">#! il peut √™tre int√©ressant d&#39;introduire dans la prochaine version</span>

<span class="w">        </span><span class="c1">#! le correctif suivant :</span>

<span class="w">        </span><span class="c1"># data[&quot;root_tank_stock&quot;][j,:,:],</span>

<span class="w">        </span><span class="k">data</span><span class="err">[</span><span class="s2">&quot;tr&quot;</span><span class="err">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="err">]</span><span class="p">,</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span>
</code></pre></div>

</details>
<h3 id="update_previous_humectation_front_at_end_of_season">update_previous_humectation_front_at_end_of_season</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_previous_humectation_front_at_end_of_season</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function saves information about the water height to humectation front</p>
<p>to another variable (previous_humectation_front, mm) at the end of season so
it can be used in the next cycle.</p>
<p>previous_humectation_front is initialized in the function InitPlotMc, and
set to be equal to hum. hum itself is initialized to take the maximum value
between surface_tank_capacity, root_tank_capacity and total_tank_stock.</p>
<p>At the harvest date (numPhase = 7), the previous_humectation_front variable
is set to equal the highest value between hum (mm, water height to
humectation front) and surface_tank_capacity (mm). This value is broadcasted
over the time dimension.</p>
<p>At any other point in time, its value is unchanged.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>number of the day</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray dataset</td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>xarray dataset: <em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_previous_humectation_front_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function saves information about the water height to humectation front</span>

<span class="sd">    to another variable (previous_humectation_front, mm) at the end of season so</span>

<span class="sd">    it can be used in the next cycle.</span>

<span class="sd">    previous_humectation_front is initialized in the function InitPlotMc, and</span>

<span class="sd">    set to be equal to hum. hum itself is initialized to take the maximum value</span>

<span class="sd">    between surface_tank_capacity, root_tank_capacity and total_tank_stock.</span>

<span class="sd">    At the harvest date (numPhase = 7), the previous_humectation_front variable</span>

<span class="sd">    is set to equal the highest value between hum (mm, water height to</span>

<span class="sd">    humectation front) and surface_tank_capacity (mm). This value is broadcasted</span>

<span class="sd">    over the time dimension.</span>

<span class="sd">    At any other point in time, its value is unchanged.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): number of the day</span>

<span class="sd">        data (xarray dataset): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray dataset: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="update_previous_root_tank_stock_at_end_of_season">update_previous_root_tank_stock_at_end_of_season</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_previous_root_tank_stock_at_end_of_season</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of previous stock of water in the root tank</p>
<p>(previous_root_tank_stock, mm) at the end of season.</p>
<p>When the phase changes from 7 to 1, previous_root_tank_stock is set to equal
the ratio between root_tank_stock and root_tank_capacity, that is to say the
filling rate of the root reservoir. Otherwise, it stays at its initial value
of 0. Its value is broadcasted along j. previous_root_tank_stock is
initialized with a value of 0.</p>
<p>? The way of resetting the previous_root_tank_stock at harvest date hasn't a real
? agronomical meaning.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_previous_root_tank_stock_at_end_of_season</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the value of previous stock of water in the root tank</span>

<span class="s">    (previous_root_tank_stock, mm) at the end of season.</span>

<span class="s">    When the phase changes from 7 to 1, previous_root_tank_stock is set to equal</span>

<span class="s">    the ratio between root_tank_stock and root_tank_capacity, that is to say the</span>

<span class="s">    filling rate of the root reservoir. Otherwise, it stays at its initial value</span>

<span class="s">    of 0. Its value is broadcasted along j. previous_root_tank_stock is</span>

<span class="s">    initialized with a value of 0.</span>

<span class="s">    ? The way of resetting the previous_root_tank_stock at harvest date hasn&#39;t a real</span>

<span class="s">    ? agronomical meaning.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;numPhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;changePhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition</span><span class="p">,</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_previous_total_tank_stock_at_end_of_season">update_previous_total_tank_stock_at_end_of_season</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_previous_total_tank_stock_at_end_of_season</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of previous total stock of water</p>
<p>(previous_total_tank_stock, mm) at the end of season.</p>
<p>When the phase changes from 7 to 1, previous_total_tank_stock is set to equal
the difference between total_tank_stock and surface_tank_stock.</p>
<p>Otherwise, it stays at its initial value of 0. Its value is broadcasted
along j. previous_total_tank_stock is initialized with a value of 0.</p>
<p>? The way of resetting the previous_total_tank_stock at harvest does not seem to have a real
? agronomical meaning.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_previous_total_tank_stock_at_end_of_season</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the value of previous total stock of water</span>

<span class="s">    (previous_total_tank_stock, mm) at the end of season.</span>

<span class="s">    When the phase changes from 7 to 1, previous_total_tank_stock is set to equal</span>

<span class="s">    the difference between total_tank_stock and surface_tank_stock.</span>

<span class="s">    Otherwise, it stays at its initial value of 0. Its value is broadcasted</span>

<span class="s">    along j. previous_total_tank_stock is initialized with a value of 0.</span>

<span class="s">    ? The way of resetting the previous_total_tank_stock at harvest does not seem to have a real</span>

<span class="s">    ? agronomical meaning.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;numPhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;changePhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition</span><span class="p">,</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">essai</span><span class="w"> </span><span class="nx">stTot</span><span class="w"> </span><span class="err">#</span><span class="p">?</span><span class="w"> </span><span class="nx">what</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">that</span><span class="w"> </span><span class="p">?</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_previous_total_tank_stock_for_second_crop_cycle">update_previous_total_tank_stock_for_second_crop_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_previous_total_tank_stock_for_second_crop_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function performs the update of the previous total height of</p>
<p>transpirable water (previous_total_tank_stock, mm).</p>
<p>It will decrease the previous_total_tank_stock depending on the variation of
transpirable water and height of humectation front.</p>
<p>This update is applied only if a second crop cycle starts, as
previous_root_tank_capacity and previous_total_tank_stock are initialized as
null. That means conditions 2 and 3 of this function will fail during a
first crop cycle, leading to no change in previous_total_tank_stock.</p>
<p>In this function, if the variation of transpirable water
(delta_total_tank_stock) increases above humectation_front (condition 1
passed), and if humectation_front is above the previous_root_tank_capacity
(condition failed), and if the depth of humectation front has decreased
since the previous day (condition 3 passed), then previous_total_tank_stock
equals 0.</p>
<p>Starting from second simulation season (previous_root_tank_capacity != 0),
if the variation of transpirable water (delta_total_tank_stock) increases
above the depth of humectation front (hum), and if the depth of humectation
front stays below or equel to the total soil capacity (conditions 1 and 2
passed), then we decrease the value of previous_total_tank_stock by a the
difference of water height between the variation of total tank stock
(delta_total_tank_stock) and the depth of humectation front (hum),
proportionally to the filling of the root tank capacity of previous season
(previous_root_tank_stock). Thus, if the root tank is empty,
previous_total_tank_stock will remain unchanged, and if the root tank is
full, previous_total_tank_stock will be decreased up to the amount of water
making the difference between quantity of water for humectation front and
the variation in daily transpirable water.</p>
<p>? To my opinion, this function is way too complicated for a borderline use case
? (multiple cropping cycles during one simulation).
? We'd want to keep the code for legacy reasons but if really this simulation
? feature is needed we'll have to simplify it.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_previous_total_tank_stock_for_second_crop_cycle</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function performs the update of the previous total height of</span>

<span class="s">    transpirable water (previous_total_tank_stock, mm).</span>

<span class="s">    It will decrease the previous_total_tank_stock depending on the variation of</span>

<span class="s">    transpirable water and height of humectation front.</span>

<span class="s">    This update is applied only if a second crop cycle starts, as</span>

<span class="s">    previous_root_tank_capacity and previous_total_tank_stock are initialized as</span>

<span class="s">    null. That means conditions 2 and 3 of this function will fail during a</span>

<span class="s">    first crop cycle, leading to no change in previous_total_tank_stock.</span>

<span class="s">    In this function, if the variation of transpirable water</span>

<span class="s">    (delta_total_tank_stock) increases above humectation_front (condition 1</span>

<span class="s">    passed), and if humectation_front is above the previous_root_tank_capacity</span>

<span class="s">    (condition failed), and if the depth of humectation front has decreased</span>

<span class="s">    since the previous day (condition 3 passed), then previous_total_tank_stock</span>

<span class="s">    equals 0.</span>

<span class="s">    Starting from second simulation season (previous_root_tank_capacity != 0),</span>

<span class="s">    if the variation of transpirable water (delta_total_tank_stock) increases</span>

<span class="s">    above the depth of humectation front (hum), and if the depth of humectation</span>

<span class="s">    front stays below or equel to the total soil capacity (conditions 1 and 2</span>

<span class="s">    passed), then we decrease the value of previous_total_tank_stock by a the</span>

<span class="s">    difference of water height between the variation of total tank stock</span>

<span class="s">    (delta_total_tank_stock) and the depth of humectation front (hum),</span>

<span class="s">    proportionally to the filling of the root tank capacity of previous season</span>

<span class="s">    (previous_root_tank_stock). Thus, if the root tank is empty,</span>

<span class="s">    previous_total_tank_stock will remain unchanged, and if the root tank is</span>

<span class="s">    full, previous_total_tank_stock will be decreased up to the amount of water</span>

<span class="s">    making the difference between quantity of water for humectation front and</span>

<span class="s">    the variation in daily transpirable water.</span>

<span class="s">    ? To my opinion, this function is way too complicated for a borderline use case</span>

<span class="s">    ? (multiple cropping cycles during one simulation).</span>

<span class="s">    ? We&#39;d want to keep the code for legacy reasons but if really this simulation</span>

<span class="s">    ? feature is needed we&#39;ll have to simplify it.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition_1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">condition_2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">condition_3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition_1</span><span class="p">,</span>

<span class="w">        </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">            </span><span class="nx">condition_2</span><span class="p">,</span>

<span class="w">            </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>\

<span class="w">                       </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]),</span>

<span class="w">            </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">                </span><span class="nx">condition_3</span><span class="p">,</span>

<span class="w">                </span><span class="mi">0</span><span class="p">,</span>

<span class="w">                </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_capacity">update_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the root tank capacity (root_tank_capacity, mm) by</p>
<p>adding the daily variation in root tank capacity.</p>
<p>For each pixel at a developmental stage different from zero, and that is not
at initialization phase ('changePhase = 1' and 'numPhase = 1'),
root_tank_capacity is updated to be summed with the change in root water
storage capacity delta_root_tank_capacity.</p>
<p>In other words, root_tank_capacity is incremented by the change in root
water storage capacity related to root growth. Easy, right ?</p>
<p>https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_238</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the root tank capacity (root_tank_capacity, mm) by</span>

<span class="sd">    adding the daily variation in root tank capacity.</span>

<span class="sd">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="sd">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;),</span>

<span class="sd">    root_tank_capacity is updated to be summed with the change in root water</span>

<span class="sd">    storage capacity delta_root_tank_capacity.</span>

<span class="sd">    In other words, root_tank_capacity is incremented by the change in root</span>

<span class="sd">    water storage capacity related to root growth. Easy, right ?</span>

<span class="sd">    https://docs.google.com/presentation/d/1QHhbNjF9ysCG_yZzWXb7ns0vOFlGfNhYw8AYrotm0fY/edit#slide=id.g27a6b3e8a72_0_238</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_capacity_at_end_of_season">update_root_tank_capacity_at_end_of_season</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_capacity_at_end_of_season</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function saves information about the root_tank_capacity to another</p>
<p>variable (previous_root_tank_capacity, mm) at the end of season so it
can be used in the next cycle.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_root_tank_capacity_at_end_of_season</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function saves information about the root_tank_capacity to another</span>

<span class="sd">    variable (previous_root_tank_capacity, mm) at the end of season so it</span>

<span class="sd">    can be used in the next cycle.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_stock">update_root_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This functions update the quantity of water of the root tank ('root_tank_stock', mm).</p>
<p>For each pixel at a developmental stage different from zero, and that is not
at initialization phase ('changePhase = 1' and 'numPhase = 1'), and for
which the 'root_tank_capacity' is greater than 'surface_tank_capacity' (meaning
that roots go beyond the surface water storage capacity), 'root_tank_stock'
is incremented by delta_root_tank_capacity.</p>
<p>However, if 'root_tank_capacity' is lesser than 'surface_tank_capacity' (meaning
that roots do not plunge into the deep reservoir), 'root_tank_stock' is
updated to be equal to surface_tank_stock minus 1/10th of the
surface_tank_capacity, multiplied by the ratio between root_tank_capacity
and surface_tank_capacity. That is to say "we take at the prorata of depth
and surface stock".</p>
<p>For any other day, root_tank_stock is unchanged.</p>
<p>? Why is the tank stock incremented instead of root tank capacity ? If the
? root tank capacity is incremented, that makes sense as we add to the root
? tank capacity the capacity newly gained through delta_root_tank_capacity.
? There is no sense in incrementing the root tank stock with the
? delta_root_tank_capacity, as the delta root tank capacity, representing
? growing of roots is independant of the quantity of water in the soil.
? However, the delta root tank capacity is blocked by hum the humidity front.
? Still, humidity front only grows and limits the maximum growth of roots, and
? is not involved in root water stock.</p>
<p>? Also, if the roots do not go in the deep reservoir, there is an increase in
? root tank stock. Considering this is a mistake and that root_tank_capacity
? should be increased, this would mean root tank capacity is increased by a
? value that depends on the filling of the surface tank first
? (surface_tank_stock minus 1/10th of the surface_tank_capacity, that would be
? about the bound water), times the ratio between root_tank_capacity and
? surface_tank_capacity. This would mean if when there is few roots the
? increase in root tank capacity is small, and if roots are close to passing
? into the deep reservoir, the increase in root tank capacity nears the
? surface_tank_stock. Again, there is no sense in increasing the root tank
? capacity with such value however this would be ok for root_tank_stock...</p>
<p>? Overall there seems to be a mixup between the objectives of the two parts of
? this function ?</p>
<p>? at the moment this function is applied, root_tank_capacity is already
? updated to take into consideration the root growth from the day, limited by
? both the water stress and the depth of the humectation front. i still do not
? understand why we would increase root tank stock, as we do not have
? supplementary water. it would be like creating water from nowhere.</p>
<p>? so until further notice i will let this function as it is, but i will keep
? in mind that it is probably wrong.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_root_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This functions update the quantity of water of the root tank (&#39;root_tank_stock&#39;, mm).</span>

<span class="s">    For each pixel at a developmental stage different from zero, and that is not</span>

<span class="s">    at initialization phase (&#39;changePhase = 1&#39; and &#39;numPhase = 1&#39;), and for</span>

<span class="s">    which the &#39;root_tank_capacity&#39; is greater than &#39;surface_tank_capacity&#39; (meaning</span>

<span class="s">    that roots go beyond the surface water storage capacity), &#39;root_tank_stock&#39;</span>

<span class="s">    is incremented by delta_root_tank_capacity.</span>

<span class="s">    However, if &#39;root_tank_capacity&#39; is lesser than &#39;surface_tank_capacity&#39; (meaning</span>

<span class="s">    that roots do not plunge into the deep reservoir), &#39;root_tank_stock&#39; is</span>

<span class="s">    updated to be equal to surface_tank_stock minus 1/10th of the</span>

<span class="s">    surface_tank_capacity, multiplied by the ratio between root_tank_capacity</span>

<span class="s">    and surface_tank_capacity. That is to say &quot;</span><span class="nx">we</span><span class="w"> </span><span class="nx">take</span><span class="w"> </span><span class="nx">at</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">prorata</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">depth</span>

<span class="w">    </span><span class="k">and</span><span class="w"> </span><span class="nx">surface</span><span class="w"> </span><span class="nx">stock</span><span class="s">&quot;.</span>

<span class="s">    For any other day, root_tank_stock is unchanged.</span>

<span class="s">    ? Why is the tank stock incremented instead of root tank capacity ? If the</span>

<span class="s">    ? root tank capacity is incremented, that makes sense as we add to the root</span>

<span class="s">    ? tank capacity the capacity newly gained through delta_root_tank_capacity.</span>

<span class="s">    ? There is no sense in incrementing the root tank stock with the</span>

<span class="s">    ? delta_root_tank_capacity, as the delta root tank capacity, representing</span>

<span class="s">    ? growing of roots is independant of the quantity of water in the soil.</span>

<span class="s">    ? However, the delta root tank capacity is blocked by hum the humidity front.</span>

<span class="s">    ? Still, humidity front only grows and limits the maximum growth of roots, and</span>

<span class="s">    ? is not involved in root water stock.</span>

<span class="s">    ? Also, if the roots do not go in the deep reservoir, there is an increase in</span>

<span class="s">    ? root tank stock. Considering this is a mistake and that root_tank_capacity</span>

<span class="s">    ? should be increased, this would mean root tank capacity is increased by a</span>

<span class="s">    ? value that depends on the filling of the surface tank first</span>

<span class="s">    ? (surface_tank_stock minus 1/10th of the surface_tank_capacity, that would be</span>

<span class="s">    ? about the bound water), times the ratio between root_tank_capacity and</span>

<span class="s">    ? surface_tank_capacity. This would mean if when there is few roots the</span>

<span class="s">    ? increase in root tank capacity is small, and if roots are close to passing</span>

<span class="s">    ? into the deep reservoir, the increase in root tank capacity nears the</span>

<span class="s">    ? surface_tank_stock. Again, there is no sense in increasing the root tank</span>

<span class="s">    ? capacity with such value however this would be ok for root_tank_stock...</span>

<span class="s">    ? Overall there seems to be a mixup between the objectives of the two parts of</span>

<span class="s">    ? this function ?</span>

<span class="s">    ? at the moment this function is applied, root_tank_capacity is already</span>

<span class="s">    ? updated to take into consideration the root growth from the day, limited by</span>

<span class="s">    ? both the water stress and the depth of the humectation front. i still do not</span>

<span class="s">    ? understand why we would increase root tank stock, as we do not have</span>

<span class="s">    ? supplementary water. it would be like creating water from nowhere.</span>

<span class="s">    ? so until further notice i will let this function as it is, but i will keep</span>

<span class="s">    ? in mind that it is probably wrong.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;numPhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\

<span class="w">        </span><span class="nx">np</span><span class="p">.</span><span class="nx">invert</span><span class="p">((</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;changePhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;numPhase&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)),</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition</span><span class="p">,</span>

<span class="w">        </span><span class="nx">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">            </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

<span class="w">            </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="nx">np</span><span class="p">.</span><span class="nx">maximum</span><span class="p">(</span>

<span class="w">                </span><span class="p">((</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>\

<span class="w">                </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">])),</span>

<span class="w">                </span><span class="mi">0</span><span class="p">),</span>

<span class="w">        </span><span class="p">).</span><span class="nx">expand_dims</span><span class="p">(</span><span class="s">&quot;time&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">axis</span><span class="p">=</span><span class="mi">0</span><span class="p">),</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_stock_step_2">update_root_tank_stock_step_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_stock_step_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the height of water in the tank of water accessible to</p>
<p>roots ("root_tank_stock", mm).</p>
<p>It increments root_tank_stock with transpirable water (eauTranspi), within
the bounds of root_tank_capacity and total_tank_stock.</p>
<p>This means the sum of transpirable water and root tank stock for the day
firstly cannot be higher than the root tank capacity, which is fine to represent 
the height of water accessible to roots. But also, that this sum limited by
the root tank capacity cannot be higher than the total tank stock, which seems unlikely.  </p>
<p>? This raises the question about where does the potential water in excess go.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_root_tank_stock_step_2</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the height of water in the tank of water accessible to</span>

<span class="s">    roots (&quot;</span><span class="nx">root_tank_stock</span><span class="s">&quot;, mm).</span>

<span class="s">    It increments root_tank_stock with transpirable water (eauTranspi), within</span>

<span class="s">    the bounds of root_tank_capacity and total_tank_stock.</span>

<span class="s">    This means the sum of transpirable water and root tank stock for the day</span>

<span class="s">    firstly cannot be higher than the root tank capacity, which is fine to represent</span>

<span class="s">    the height of water accessible to roots. But also, that this sum limited by</span>

<span class="s">    the root tank capacity cannot be higher than the total tank stock, which seems unlikely.</span>

<span class="s">    ? This raises the question about where does the potential water in excess go.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_surface_tank_stock">update_surface_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_surface_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of water stock in the surface tank</p>
<p>(surface_tank_stock, mm) with the water available for the day
(available_water, mm), within the limits of 110% surface_tank_capacity.</p>
<p>We update surface_tank_stock by adding the available_water, which as this
point in the process list corresponds to the water available from 1) rain,
2) irrigation for the day, corrected from 3) intake by mulch (fill_mulch
function), and 4) runoff (compute_runoff). However, we do not allow
surface_tank_stock to exceed 110% of the surface_tank_capacity.</p>
<p>? This means it is possible that the surface tank fill rate is above 100%,
? which is a rather strange assumption.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_surface_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the value of water stock in the surface tank</span>

<span class="s">    (surface_tank_stock, mm) with the water available for the day</span>

<span class="s">    (available_water, mm), within the limits of 110% surface_tank_capacity.</span>

<span class="s">    We update surface_tank_stock by adding the available_water, which as this</span>

<span class="s">    point in the process list corresponds to the water available from 1) rain,</span>

<span class="s">    2) irrigation for the day, corrected from 3) intake by mulch (fill_mulch</span>

<span class="s">    function), and 4) runoff (compute_runoff). However, we do not allow</span>

<span class="s">    surface_tank_stock to exceed 110% of the surface_tank_capacity.</span>

<span class="s">    ? This means it is possible that the surface tank fill rate is above 100%,</span>

<span class="s">    ? which is a rather strange assumption.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="nx">minimum</span><span class="p">(</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;available_water&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="m m-Double">1.1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">]</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;surface_tank_capacity&quot;</span><span class="p">]</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock">update_total_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This functions updates the total height of transpirable water</p>
<p>('total_tank_stock', mm) with the amount of transpirable water for the day
('eauTranspi', mm). </p>
<p>? Said differently, 'total_tank_stock' represents the total amount of water
? available for the plant in the soil column ?</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_total_tank_stock</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This functions updates the total height of transpirable water</span>

<span class="s">    (&#39;total_tank_stock&#39;, mm) with the amount of transpirable water for the day</span>

<span class="s">    (&#39;eauTranspi&#39;, mm).</span>

<span class="s">    ? Said differently, &#39;total_tank_stock&#39; represents the total amount of water</span>

<span class="s">    ? available for the plant in the soil column ?</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock_after_drainage">update_total_tank_stock_after_drainage</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock_after_drainage</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the total tank stock (total_tank_stock, mm) when these is overflowing.</p>
<p>When capacity of total_tank_stock is exceeded, total_tank_stock value is replaced with 
total_tank_capacity</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_total_tank_stock_after_drainage</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the total tank stock (total_tank_stock, mm) when these is overflowing.</span>

<span class="s">    When capacity of total_tank_stock is exceeded, total_tank_stock value is replaced with</span>

<span class="s">    total_tank_capacity</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition</span><span class="p">,</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock_for_second_crop_cycle">update_total_tank_stock_for_second_crop_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock_for_second_crop_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the total height of transpirable water</p>
<p>('total_tank_stock', mm), specifically if a second crop cycle starts.</p>
<p>This update is applied only if a second crop cycle starts, as
previous_root_tank_capacity and previous_total_tank_stock are initialized as
null. That means conditions 2 and 3 of this function will fail during a
first crop cycle, leading to no change in total_tank_stock.</p>
<p>However, at numPhase = 7, which corresponds to the harvesting date and that
opens the possibility for a second crop cycle, previous_root_tank_capacity
and previous_total_tank_stock will be updated.</p>
<p>From now on, if delta_total_tank_stock is greater than humectation front
(condition 1 passed), and previous_root_tank_capacity is greater or equal to
the humectation_front (condition 2 passed), and if the humectation_front is
below previous_humectation_front (condition 3 passed), then the total tank
stock is updated to be increased with the difference between
delta_total_tank_stock and humectation_front, times the previous root tank
stock.  </p>
<p>Thus, if the root tank is empty, total_tank_stock will remain unchanged, and
if the root tank is full, total_tank_stock will be increased up to the
amount of water making the difference between quantity of water for
humectation front and the variation in daily transpirable water.</p>
<p>Also, if delta_total_tank_stock is greater than humectation front (condition
1 passed), but previous_root_tank_capacity is lower than the
humectation_front (condition 2 failed), while the humectation_front is below
previous_humectation_front (condition 3 passed), we update the total tank
stock to be equal to delta_total_tank_stock.</p>
<p>In other words, if during the second crop cycle the humectation front is too
low, we increase the total tank stock.</p>
<p>? To my opinion, this function is way too complicated for a borderline use case
? (multiple cropping cycles during one simulation).
? We'd want to keep the code for legacy reasons but if really this simulation
? feature is needed we'll have to simplify it.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">update_total_tank_stock_for_second_crop_cycle</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="w"> </span><span class="nx">data</span><span class="p">):</span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="s">    This function updates the total height of transpirable water</span>

<span class="s">    (&#39;total_tank_stock&#39;, mm), specifically if a second crop cycle starts.</span>

<span class="s">    This update is applied only if a second crop cycle starts, as</span>

<span class="s">    previous_root_tank_capacity and previous_total_tank_stock are initialized as</span>

<span class="s">    null. That means conditions 2 and 3 of this function will fail during a</span>

<span class="s">    first crop cycle, leading to no change in total_tank_stock.</span>

<span class="s">    However, at numPhase = 7, which corresponds to the harvesting date and that</span>

<span class="s">    opens the possibility for a second crop cycle, previous_root_tank_capacity</span>

<span class="s">    and previous_total_tank_stock will be updated.</span>

<span class="s">    From now on, if delta_total_tank_stock is greater than humectation front</span>

<span class="s">    (condition 1 passed), and previous_root_tank_capacity is greater or equal to</span>

<span class="s">    the humectation_front (condition 2 passed), and if the humectation_front is</span>

<span class="s">    below previous_humectation_front (condition 3 passed), then the total tank</span>

<span class="s">    stock is updated to be increased with the difference between</span>

<span class="s">    delta_total_tank_stock and humectation_front, times the previous root tank</span>

<span class="s">    stock.</span>

<span class="s">    Thus, if the root tank is empty, total_tank_stock will remain unchanged, and</span>

<span class="s">    if the root tank is full, total_tank_stock will be increased up to the</span>

<span class="s">    amount of water making the difference between quantity of water for</span>

<span class="s">    humectation front and the variation in daily transpirable water.</span>

<span class="s">    Also, if delta_total_tank_stock is greater than humectation front (condition</span>

<span class="s">    1 passed), but previous_root_tank_capacity is lower than the</span>

<span class="s">    humectation_front (condition 2 failed), while the humectation_front is below</span>

<span class="s">    previous_humectation_front (condition 3 passed), we update the total tank</span>

<span class="s">    stock to be equal to delta_total_tank_stock.</span>

<span class="s">    In other words, if during the second crop cycle the humectation front is too</span>

<span class="s">    low, we increase the total tank stock.</span>

<span class="s">    ? To my opinion, this function is way too complicated for a borderline use case</span>

<span class="s">    ? (multiple cropping cycles during one simulation).</span>

<span class="s">    ? We&#39;d want to keep the code for legacy reasons but if really this simulation</span>

<span class="s">    ? feature is needed we&#39;ll have to simplify it.</span>

<span class="s">    Args:</span>

<span class="s">        j (_type_): _description_</span>

<span class="s">        data (_type_): _description_</span>

<span class="s">    Returns:</span>

<span class="s">        _type_: _description_</span>

<span class="s">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="nx">condition_1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">condition_2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_capacity&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">condition_3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span>

<span class="w">    </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">        </span><span class="nx">condition_1</span><span class="p">,</span>

<span class="w">        </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">            </span><span class="nx">condition_2</span><span class="p">,</span>

<span class="w">            </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;humectation_front&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>\

<span class="w">                  </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;previous_root_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="nx">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span>

<span class="w">                </span><span class="nx">condition_3</span><span class="p">,</span>

<span class="w">                </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">                </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">            </span><span class="p">),</span>

<span class="w">        </span><span class="p">),</span>

<span class="w">        </span><span class="nx">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="nx">j</span><span class="p">,:,:],</span>

<span class="w">    </span><span class="p">)</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">data</span>
</code></pre></div>

</details>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../bilan_carbo/" class="btn btn-neutral float-left" title="Bilan Carbo"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../bilan_pheno/" class="btn btn-neutral float-right" title="Bilan Pheno">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../bilan_carbo/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../bilan_pheno/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
