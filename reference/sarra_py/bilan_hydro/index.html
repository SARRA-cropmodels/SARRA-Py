<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Bilan Hydro - SARRA-Py</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Bilan Hydro";
        var mkdocs_page_input_path = "reference/sarra_py/bilan_hydro.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> SARRA-Py
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../docs/model_formalisms/">Model formalisms</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../../docs/spatialization_strategy/">Spatialization strategy</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorial</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../docs/tutorial/00_-_Running_a_simulation/">00 - Running a simulation</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Sarra Py</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../bilan_carbo/">Bilan Carbo</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Bilan Hydro</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#consoressep">ConsoResSep</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evalirrigphase">EvalIrrigPhase</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evalrunoff">EvalRunOff</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#evolrurcstr2">EvolRurCstr2</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#initplotmc">InitPlotMc</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#remplimc">RempliMc</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#apply_evaporation_on_surface_tank_stock">apply_evaporation_on_surface_tank_stock</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#calculate_total_water_availability">calculate_total_water_availability</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_daily_irrigation">compute_daily_irrigation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#compute_evapotranspiration">compute_evapotranspiration</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#condition_end_of_cycle">condition_end_of_cycle</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#condition_total_tank_overflow">condition_total_tank_overflow</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#conditions_remplires">conditions_rempliRes</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_femcw_and_update_mulch_water_stock">estimate_FEMcW_and_update_mulch_water_stock</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_cstr">estimate_cstr</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_delta_root_tank_capacity">estimate_delta_root_tank_capacity</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_fesw">estimate_fesw</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_ftsw">estimate_ftsw</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#estimate_kctot">estimate_kcTot</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../bilan_pheno/">Bilan Pheno</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../comparison_tools_old/">Comparison Tools Old</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../data_preparation/">Data Preparation</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../">Index</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../models/">Models</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">SARRA-Py</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Reference &raquo;</li>
          <li>Sarra Py &raquo;</li>
      <li>Bilan Hydro</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="module-sarra_pybilan_hydro">Module sarra_py.bilan_hydro</h1>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

<span class="kn">from</span> <span class="nn">sarra_py.bilan_carbo</span> <span class="kn">import</span> <span class="n">estimate_kcp</span>

<span class="k">def</span> <span class="nf">InitPlotMc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">grid_width</span><span class="p">,</span> <span class="n">grid_height</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">,</span> <span class="n">paramTypeSol</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initializes variables related to crop residues boimass (mulch) in the data</span>

<span class="sd">    xarray dataset. This code has been adapted from the original InitPlotMc</span>

<span class="sd">    procedure, Bileau.pas code. Comments with tab indentation are from the</span>

<span class="sd">    original code. As the rain is the first variable to be initialized in the</span>

<span class="sd">    data xarray dataset, its dimensions are used to initialize the other</span>

<span class="sd">    variables.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Soil maximum water storage capacity (mm)</span>

    <span class="c1"># Capacité maximale de la RU (mm)</span>

    <span class="c1">#   StRurMax := Ru * ProfRacIni / 1000;</span>

    <span class="c1">#! renaming stRurMax with root_tank_capacity</span>

    <span class="c1">#// data[&quot;stRurMax&quot;] = data[&quot;ru&quot;] * paramITK[&quot;profRacIni&quot;] / 1000</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="kp">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="kp">newaxis</span><span class="p">,:,:],</span> <span class="n">duration</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1">#// data[&quot;stRurMax&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Soil maximum water storage capacity&quot;}</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Soil maximum water storage capacity&quot;</span><span class="p">}</span>

    <span class="c1"># Maximum water capacity of surface tank (mm)</span>

    <span class="c1"># Reserve utile de l&#39;horizon de surface (mm)</span>

    <span class="c1">#   RuSurf := EpaisseurSurf / 1000 * Ru;</span>

    <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

    <span class="c1">#// data[&quot;ruSurf&quot;] = data[&quot;epaisseurSurf&quot;] / 1000 * data[&quot;ru&quot;]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span>

    <span class="c1">#// data[&quot;ruSurf&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Maximum water capacity of surface tank&quot;}</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Maximum water capacity of surface tank&quot;</span><span class="p">}</span>

    <span class="c1"># ?</span>

    <span class="c1">#   //    PfTranspi := EpaisseurSurf * HumPf;</span>

    <span class="c1">#   //    StTot := StockIniSurf - PfTranspi/2 + StockIniProf;</span>

    <span class="c1">#   StTot := StockIniSurf  + StockIniProf;</span>

    <span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniSurf&quot;] + paramTypeSol[&quot;stockIniProf&quot;]))</span>

    <span class="c1">#! modifié pour faire correspondre les résultats de simulation, à remettre en place pour un calcul correct dès que possible</span>

    <span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniProf&quot;]))</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#// data[&quot;stTot&quot;] = data[&quot;stockIniProf&quot;]</span>

    <span class="c1">#//data[&quot;total_tank_stock&quot;] = data[&quot;stockIniProf&quot;]</span>

    <span class="c1">#! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="kp">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="kp">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;stockIniProf&quot;</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="kp">newaxis</span><span class="p">,:,:],</span> <span class="n">duration</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1">#// data[&quot;stTot&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;?&quot;}</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;?&quot;</span><span class="p">}</span>

    <span class="c1"># Soil maximal depth (mm)</span>

    <span class="c1"># Profondeur maximale de sol (mm)</span>

    <span class="c1">#   ProfRU := EpaisseurSurf + EpaisseurProf;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurProf&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Soil maximal depth&quot;</span><span class="p">}</span>

    <span class="c1"># Maximum water capacity to humectation front (mm)</span>

    <span class="c1"># Quantité d&#39;eau maximum jusqu&#39;au front d&#39;humectation (mm)</span>

    <span class="c1">#   // modif 10/06/2015  resilience stock d&#39;eau</span>

    <span class="c1">#   // Front d&#39;humectation egal a RuSurf trop de stress initial</span>

    <span class="c1">#   //    Hum := max(StTot, StRurMax);</span>

    <span class="c1">#   Hum := max(RuSurf, StRurMax);</span>

    <span class="c1">#   // Hum mis a profRuSurf</span>

    <span class="c1">#   Hum := max(StTot, Hum);</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">duration</span><span class="p">,</span> <span class="n">grid_width</span><span class="p">,</span> <span class="n">grid_height</span><span class="p">),</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

                <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

                <span class="c1">#// data[&quot;ruSurf&quot;],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="kp">expand_dims</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span><span class="n">duration</span><span class="p">}),</span>

                <span class="c1">#! renaming stRurMax with root_tank_capacity</span>

                <span class="c1">#// data[&quot;stRurMax&quot;],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">],</span>

            <span class="p">),</span>

            <span class="c1">#! renaming stTot with total_tank_stock</span>

            <span class="c1">#// data[&quot;stTot&quot;],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">],</span>

        <span class="p">)</span>

    <span class="p">))</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;long_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Maximum water capacity to humectation front&quot;</span><span class="p">}</span>

    <span class="c1"># Previous value for Maximum water capacity to humectation front (mm)</span>

    <span class="c1">#  HumPrec := Hum;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">]</span>

    <span class="c1"># ?</span>

    <span class="c1">#   StRurPrec := 0;</span>

    <span class="c1"># Previous value for stTot</span>

    <span class="c1">#   StRurMaxPrec := 0;</span>

    <span class="c1">#   //modif 10/06/2015 resilience stock d&#39;eau</span>

    <span class="c1">#! renaming stTot with total_tank_stock</span>

    <span class="c1">#! renaminog stRuPrec with total_tank_stock_previous_value</span>

    <span class="c1">#// data[&quot;stRuPrec&quot;] =  data[&quot;stTot&quot;]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_irrigation_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Update the Irrigation Tank Stock</span>

<span class="sd">    In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and</span>

<span class="sd">    root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet</span>

<span class="sd">    reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock</span>

<span class="sd">    will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to</span>

<span class="sd">    surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): Index of time step in data</span>

<span class="sd">        data (xarray Dataset): Dataset that contains various data fields</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>

    <span class="c1"># group 1</span>

    <span class="c1">#! renaming stockIrr with irrigation_tank_stock</span>

    <span class="c1">#//data[&quot;stockIrr&quot;][j, :, :] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

            <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

            <span class="c1">#// (data[&quot;stRurMax&quot;] &lt; data[&quot;ruSurf&quot;]),</span>

            <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">])[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>

            <span class="c1">#! renaming stRuSurf to surface_tank_stock</span>

            <span class="c1">#// data[&quot;stRuSurf&quot;][j, :, :],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>

            <span class="c1">#! renaming stRur to root_tank_stock</span>

            <span class="c1">#// data[&quot;stRur&quot;][j, :, :],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>

        <span class="p">),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_irrigation_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Update Irrigation Tank Capacity</span>

<span class="sd">    The function updates the maximum water capacity of irrigation tank based on</span>

<span class="sd">    the conditions specified in the function. If the automatic irrigation mode</span>

<span class="sd">    is ON, and if the current phase is between 0 and 6, and if the root tank</span>

<span class="sd">    capacity is less than the surface tank capacity, meaning that the roots have</span>

<span class="sd">    not reached the limit between the surface compartment and deep compartment,</span>

<span class="sd">    then the irrigation tank capacity is set to the surface tank capacity, which</span>

<span class="sd">    is given a minimum value equal to the surface tank capacity. Otherwise, the</span>

<span class="sd">    irrigation tank capacity remains unchanged.</span>

<span class="sd">    If we are in automatic irrigation mode, and between phases 0 and 6, and if</span>

<span class="sd">    root_tank_capacity is less than surface_tank_capacity, meaning that roots</span>

<span class="sd">    haven&#39;t reached the limit between the surface compartment and deep</span>

<span class="sd">    compartment, then we define irrigation_tank_capacity as equal to</span>

<span class="sd">    surface_tank_capacity, that is to say, we give to irrigation_tank_capacity a</span>

<span class="sd">    minimum value that equals surface_tank_capacity. else, we do not modify</span>

<span class="sd">    irrigation_tank_capacity value</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): Index of the time step being processed.</span>

<span class="sd">        data (xarray dataset): The input dataset containing all the information necessary to run the model.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray dataset: The input dataset with updated values of the irrigation tank capacity.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 2</span>

    <span class="n">condition</span> <span class="o">=</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>

    <span class="c1"># renaming ruIrr with irrigation_tank_capacity</span>

    <span class="c1">#// data[&quot;ruIrr&quot;][j, :, :] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

            <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

            <span class="c1">#// (data[&quot;stRurMax&quot;] &lt; data[&quot;ruSurf&quot;]),</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

            <span class="c1">#// data[&quot;ruSurf&quot;],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

            <span class="c1">#// data[&quot;stRurMax&quot;],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="p">),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">compute_daily_irrigation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Computes the Total Daily Irrigation (mm)</span>

<span class="sd">    If we are in the automatic irrigation mode, and between phases 0 and 6, and if</span>

<span class="sd">    the filling of the irrigation tank is below the target filling value</span>

<span class="sd">    (irrigAutoTarget, decimal percentage), we first compute 90% of the difference</span>

<span class="sd">    between the current volume of water in the irrigation tank (irrigation_tank_stock)</span>

<span class="sd">    and the total capacity of the irrigation tank (irrigation_tank_capacity),</span>

<span class="sd">    bounded by a minimum of 0 and a maximum of maxIrrig.</span>

<span class="sd">    This computed value represents the amount of water to be added to the irrigation tank.</span>

<span class="sd">    If the above conditions are not met, the computed value is 0.</span>

<span class="sd">    Then, we calculate the total irrigation of the day by summing the</span>

<span class="sd">    estimated irrigation need (irrigation) with the previous irrigation history of the day</span>

<span class="sd">    (irrigTotDay).</span>

<span class="sd">    irrigTotDay : &quot;total irrigation of the day, both from the irrigation history</span>

<span class="sd">    and the estimated irrigation need&quot; (mm) // irrigation_total_day</span>

<span class="sd">    if we are in automatic irrigation mode, and between phases 0 and 6, and if</span>

<span class="sd">    the filling of the irrigation tank is below the target filling value</span>

<span class="sd">    (irrigAutoTarget, decimal percentage), we first compute 90% of the difference</span>

<span class="sd">    between irrigation_tank_stock and irrigation_tank_capacity (that is to say,</span>

<span class="sd">    90% of the volume needed to fill the irrigation tank), bounded by a minimum</span>

<span class="sd">    of 0 and a maximum of maxIrrig. Else, the computed value is 0.</span>

<span class="sd">    Then, we calculate the total irrigation of the day by summing the</span>

<span class="sd">    estimated irrigation need with the irrigation history of the day.</span>

<span class="sd">    Args:</span>

<span class="sd">        j: An integer representing the current day.</span>

<span class="sd">        data: A xarray dataset.</span>

<span class="sd">        paramITK: A dictionary of parameters.</span>

<span class="sd">    Returns:</span>

<span class="sd">        data: A xarray dataset with the updated irrigationTotDay field.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! renaming stockIrr with irrigation_tank_stock</span>

    <span class="c1">#! renaming ruIrr with irrigation_tank_capacity</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&amp;</span> \

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> \

            <span class="o">&lt;</span> <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;irrigAutoTarget&quot;</span><span class="p">])</span>

    <span class="c1"># group 3</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

                <span class="mi">0</span><span class="p">,</span>

                <span class="c1"># ! replacing correctedIrrigation by irrigation</span>

                <span class="c1">#! renaming stockIrr with irrigation_tank_stock</span>

                <span class="c1">#! renaming ruIrr with irrigation_tank_capacity</span>

                <span class="c1"># // ((data[&quot;ruIrr&quot;][j, :, :] - data[&quot;stockIrr&quot;][j, :, :]) * 0.9) - data[&quot;correctedIrrigation&quot;][j, :, :]),</span>

                <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span> \

                    <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

                <span class="p">),</span>

            <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;maxIrrig&quot;</span><span class="p">]</span>

        <span class="p">),</span>

        <span class="mi">0</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="c1"># group 4</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>

        <span class="c1"># ! replacing correctedIrrigation by irrigation</span>

        <span class="c1"># // data[&quot;correctedIrrigation&quot;][j, :, :] + data[&quot;irrigTotDay&quot;][j, :, :]).copy()</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">EvalIrrigPhase</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Computes the irrigation state for a given day, including the size and</span>

<span class="sd">    filling of the irrigation tank and the irrigation demand.</span>

<span class="sd">    The computation of the irrigation state is based on the irrigation target</span>

<span class="sd">    (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), the size and</span>

<span class="sd">    filling of the root zone (stRurMax, stRur) and the surface reservoir</span>

<span class="sd">    (stRuSurf, ruSurf). The water stock in the irrigation tank (stockIrr) and</span>

<span class="sd">    the maximum water capacity of the irrigation tank (ruIrr) are first</span>

<span class="sd">    calculated, with minimum boundaries determined by properties of the surface</span>

<span class="sd">    reservoir. The irrigation demand (irrigTotDay) is then computed.</span>

<span class="sd">    The irrigation tank stock and capacity are only computed to avoid issues</span>

<span class="sd">    with very shallow rooting, where the calculation of the filling of</span>

<span class="sd">    root_tank_capacity by root_tank_stock can be inappropriate and result in</span>

<span class="sd">    inadapted results for automatic irrigation.</span>

<span class="sd">    Note: In this irrigation management, the daily rainfall is not taken into</span>

<span class="sd">    account.</span>

<span class="sd">    Translated from the procedure EvalIrrigPhase, of the original Pascal codes</span>

<span class="sd">    bileau.pas and exmodules2.pas.</span>

<span class="sd">    In irrigAuto mode, this function computes the size and filling of the</span>

<span class="sd">    irrigation tank, and the irrigation demand, according to the irrigation</span>

<span class="sd">    target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), and</span>

<span class="sd">    the size and filling of the root zone (stRurMax, stRur) and the surface</span>

<span class="sd">    reservoir (stRuSurf, ruSurf).</span>

<span class="sd">    It first calculates stockIrr, the water stock in the irrigation tank, and</span>

<span class="sd">    ruIrr, the maximum water capacity of irrigation tank. Both stockIrr and</span>

<span class="sd">    ruIrr are given minimum boundaries related to properties of the surface</span>

<span class="sd">    reservoir. Then, it calculates the irrigation demand, irrigTotDay.</span>

<span class="sd">    irrigation_tank_stock and irrigation_tank_capacity are only computed in</span>

<span class="sd">    order to avoid issues with very shallow rooting, where calculation of</span>

<span class="sd">    filling of root_tank_capacity by root_tank_stock can be inappropriate and</span>

<span class="sd">    lead to inadapted results for automatic irrigation</span>

<span class="sd">    Notes from CB, 2014 :</span>

<span class="sd">    Modification due à la prise en compte effet Mulch Soit on a une irrigation</span>

<span class="sd">    observée, soit on calcul la dose d&#39;irrigation Elle est calculée en fonction</span>

<span class="sd">    d&#39;un seuil d&#39;humidité (IrrigAutoTarget) et de possibilité technique ou choix</span>

<span class="sd">    (MaxIrrig, Precision) Dans cette gestion d&#39;irrigation la pluie du jour n&#39;est</span>

<span class="sd">    pas prise en compte</span>

<span class="sd">    N.B.: here, precision is not taken into account anymore</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): Index of the day for which the irrigation state is being computed.</span>

<span class="sd">        data (xarray.Dataset): The input data, including the arrays for irrigation and correctedIrrigation.</span>

<span class="sd">        paramITK (dict): The parameters for the ITK model.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray.Dataset: The updated data, including the computed values for the irrigation state.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First, we store initial irrigation value of the day in the</span>

    <span class="c1"># correctedIrrigation array</span>

    <span class="c1"># ! it does not seem definition and use of correctedIrrigation is useful</span>

    <span class="c1"># ! instead we will just use the already defined irrigation array</span>

    <span class="c1"># // data[&quot;correctedIrrigation&quot;][j, :, :] = data[&quot;irrigation&quot;][j, :, :].copy(deep=True)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_irrigation_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_irrigation_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">compute_daily_irrigation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">calculate_total_water_availability</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculates the total water available for a day by adding the rainfall and</span>

<span class="sd">    the irrigation.</span>

<span class="sd">    The total water available is computed by adding the rainfall for the day,</span>

<span class="sd">    which is stored in the &quot;rain&quot; array, and the total daily irrigation, which</span>

<span class="sd">    is stored in the &quot;irrigTotDay&quot; array.</span>

<span class="sd">    This calculation is performed to allow for subsequent calculations of the</span>

<span class="sd">    mulch filling and runoff. The mulch layer is considered to be directly under</span>

<span class="sd">    the rainfall and irrigation, which is represented by the &quot;irrigTotDay&quot;</span>

<span class="sd">    value.</span>

<span class="sd">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="sd">    bileau.pas and exmodules2.pas</span>

<span class="sd">    This function computes the total water available for the day, by summing the</span>

<span class="sd">    rain and the irrigation.</span>

<span class="sd">    Notes from CB, 2014 :</span>

<span class="sd">    Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig, ici</span>

<span class="sd">    irrigTotDay qui est l&#39;irrigation observée ou calculée, d&#39;où on regroupe les</span>

<span class="sd">    deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): The index of the current day.</span>

<span class="sd">        data (xarray.Dataset): The data set containing information about the rainfall, irrigation, and water availability.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray.Dataset: The data set with updated information about the total water availability for the current day.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_water_captured_by_mulch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Determination of water gathered by the mulch (eauCaptee, mm):</span>

<span class="sd">    We determine the quantity of water gathered by mulch by multiplying the</span>

<span class="sd">    available water (eauDispo, from rain and irrigation, mm) with a</span>

<span class="sd">    exponential function of covering capacity of the considered mulch</span>

<span class="sd">    (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the</span>

<span class="sd">    fraction of soil covered by mulch. The value of eauCaptee is bounded by</span>

<span class="sd">    the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg</span>

<span class="sd">    biomass), minus stock of water already present in it (stockMc, mm).</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 7</span>

    <span class="c1">#! modyfing variable names to improve readability</span>

    <span class="c1">#! replacing eauCaptee by water_gathered_by_mulch</span>

    <span class="c1">#! replacing stockMc by mulch_water_stock</span>

    <span class="c1">#// data[&quot;eauCaptee&quot;][j,:,:] = np.minimum(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_gathered_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="kp">exp</span><span class="p">(</span><span class="o">-</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;surfMc&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])),</span>

        <span class="c1">#// (paramITK[&quot;humSatMc&quot;] * data[&quot;biomMc&quot;][j,:,:] / 10000) - data[&quot;stockMc&quot;][j,:,:],</span>

        <span class="p">(</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;humSatMc&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_available_water_after_mulch_filling</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updating available water (eauDispo, mm) :</span>

<span class="sd">    As some water is gathered by the mulch, the available water is updated by</span>

<span class="sd">    subtracting the gathered water (eauCaptee, mm) from the total available</span>

<span class="sd">    water (eauDispo, mm). This value is bounded by 0, as the available water</span>

<span class="sd">    cannot be negative.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ! correction as broadcasting on xarray seems less constrained than on numpy</span>

    <span class="c1">#! modyfing variable names to improve readability</span>

    <span class="c1">#! replacing eauCaptee by water_gathered_by_mulch</span>

    <span class="c1"># group 8</span>

    <span class="c1">#// data[&quot;eauDispo&quot;][j:,:,:] =  np.maximum(data[&quot;eauDispo&quot;][j,:,:] - data[&quot;eauCaptee&quot;][j,:,:], 0) # //[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_gathered_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># //[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updating water stock in mulch (stockMc, mm) :</span>

<span class="sd">    The water stock in mulch is updated by adding the gathered water (eauCaptee, mm)</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ! correction as broadcasting on xarray seems less constrained than on numpy</span>

    <span class="c1"># group 9</span>

    <span class="c1">#! replacing eauCaptee by water_gathered_by_mulch</span>

    <span class="c1">#! replacing stockMc by mulch_water_stock</span>

    <span class="c1">#// data[&quot;stockMc&quot;][j:,:,:] = (data[&quot;stockMc&quot;][j,:,:] + data[&quot;eauCaptee&quot;][j,:,:]) # //[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_gathered_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="c1"># //[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">RempliMc</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="sd">    bileau.pas and exmodules2.pas</span>

<span class="sd">    wrapper function,</span>

<span class="sd">    updates water_gathered_by_mulch, eauDispo, and mulch_water_stock</span>

<span class="sd">    For more details, it is advised to refer to the works of Eric Scopel (UR</span>

<span class="sd">    AIDA), and the PhD dissertation of Fernando Maceina.</span>

<span class="sd">    Notes from CB, 2014 :</span>

<span class="sd">    Hypotheses :</span>

<span class="sd">    A chaque pluie, on estime la quantité d&#39;eau pour saturer le couvert. On la</span>

<span class="sd">    retire à l&#39;eauDispo (pluie + irrig). On calcule la capacité maximum de</span>

<span class="sd">    stockage fonction de la biomasse et du taux de saturation rapportée en mm</span>

<span class="sd">    (humSatMc en kg H2O/kg de biomasse).</span>

<span class="sd">    La pluie est en mm :</span>

<span class="sd">    1 mm = 1 litre d&#39;eau / m2</span>

<span class="sd">    1 mm = 10 tonnes d&#39;eau / hectare = 10 000 kg/ha</span>

<span class="sd">    La biomasse est en kg/ha pour se rapporter à la quantité de pluie captée en</span>

<span class="sd">    mm Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha à humSat</span>

<span class="sd">    2.8 kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacité à</span>

<span class="sd">    capter est fonction du taux de couverture du sol calculé comme le LTR SurfMc</span>

<span class="sd">    est spécifié en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On</span>

<span class="sd">    retire alors les mm d&#39;eau captées à la pluie incidente. Le ruisselement est</span>

<span class="sd">    ensuite calculé avec l&#39;effet de contrainte du mulch</span>

<span class="sd">    group 10</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_water_captured_by_mulch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_available_water_after_mulch_filling</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Evaluation of runoff (&quot;lame de ruissellement&quot;, lr, mm) :</span>

<span class="sd">    If the quantity of rain (mm) is above the runoff threshold (seuilRuiss,</span>

<span class="sd">    mm), runoff is computed as the difference between the available water</span>

<span class="sd">    (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by</span>

<span class="sd">    the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0.</span>

<span class="sd">    seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data</span>

<span class="sd">    Question : should runoff be computed taking in consideration water captured by</span>

<span class="sd">    mulch to account for mulch effect on runoff mitigation ?</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 11</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilRuiss&quot;</span><span class="p">],</span>

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>  <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilRuiss&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pourcRuiss&quot;</span><span class="p">],</span>

        <span class="mi">0</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_available_water_after_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updating available water (eauDispo, mm) :</span>

<span class="sd">    The available water is updated by subtracting the runoff (lr, mm) from the</span>

<span class="sd">    total available water (eauDispo, mm). This value is broadcasted onto the</span>

<span class="sd">    days axis.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 12</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">EvalRunOff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramTypeSol</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="sd">    bileau.pas, exmodules1.pas and exmodules2.pas</span>

<span class="sd">    Notes from CB, 2014 :</span>

<span class="sd">    On a regroupé avant la pluie et l&#39;irrigation (a cause de l&#39;effet Mulch)</span>

<span class="sd">    si mulch on a enlevé l&#39;eau captée</span>

<span class="sd">    oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramTypeSol (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_available_water_after_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">initialize_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    updating stRurMax/root_tank_capacity, step 1 :</span>

<span class="sd">    stRurMax, also called ruRac in some versions of the model, is the root_tank_capacity.</span>

<span class="sd">    At the phase change between phases 0 and 1 (initialisation), the maximum</span>

<span class="sd">    root water storage is initialised by multiplying the initial root depth</span>

<span class="sd">    (profRacIni, mm) with the soil water storage capacity (ru, mm/m). This</span>

<span class="sd">    value is broadcasted on the time series. For every other day in the cycle,</span>

<span class="sd">    the value remains unchanged.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 14</span>

    <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

    <span class="c1">#// data[&quot;stRurMax&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>

        <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updates daily root capacity variation (delta_root_tank_capacity, in mm</span>

<span class="sd">    water/day) based on the current phase of the plant, the daily root growth</span>

<span class="sd">    speed, and the drought stress coefficient.</span>

<span class="sd">    The daily root capacity variation is calculated as the product of soil water</span>

<span class="sd">    storage capacity (ru), the daily root growth speed (vRac), and a coefficient</span>

<span class="sd">    (cstr + 0.3). This coefficient is capped at 1.0.</span>

<span class="sd">    The daily root capacity variation is modulated by drought stress only when the</span>

<span class="sd">    root tank capacity is greater than the surface tank capacity and the current</span>

<span class="sd">    phase is strictly greater than 1 and at the day of phase change. If the root</span>

<span class="sd">    tank capacity is lower than the surface tank capacity or if the current phase is</span>

<span class="sd">    1 or below or not at the day of phase change, the daily root capacity variation</span>

<span class="sd">    remains unchanged.</span>

<span class="sd">    The drought stress coefficient, cstr, measures the level of drought stress with</span>

<span class="sd">    0 being full stress. The root growth speed is assumed to still occur during a</span>

<span class="sd">    drought stress as a matter of survival, with a certain level of tolerance given</span>

<span class="sd">    by the [0.3, 1] bound of the coefficient.</span>

<span class="sd">    Updating delta_root_tank_capacity / dayVrac (daily variation in water height</span>

<span class="sd">    accessible to roots, mm water/day) :</span>

<span class="sd">    At the day of phase change, for phases strictly above 1, and for which</span>

<span class="sd">    root_tank_capacity is greater than surface_tank_capacity, the variation of</span>

<span class="sd">    root tank capacity delta_root_tank_capacity is computed as the product of</span>

<span class="sd">    soil water storage capacity (ru, mm/m), the daily root growth speed (vRac,</span>

<span class="sd">    mm/day), and a coefficient, the latter being equal to the drought stress</span>

<span class="sd">    coefficient (cstr) plus 0.3, with a maximum bound of 1.0.</span>

<span class="sd">    That is to say, when the root_tank_capacity is greater than</span>

<span class="sd">    surface_tank_capacity, the root growth speed is modulated by drought stress.</span>

<span class="sd">    When root_tank_capacity is lower than surface_tank_capacity, the root growth</span>

<span class="sd">    speed is not modulated by drought stress.</span>

<span class="sd">    When we are not at the day of phase change, or if we are at phase of 1 and</span>

<span class="sd">    below, delta_root_change_capacity is unchanged.</span>

<span class="sd">    cstr is the drought stress coefficient, with a value of 0 meaning full stress.</span>

<span class="sd">    Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian</span>

<span class="sd">    BARON, this is based on the hypothesis that during a drought stress (cstr =</span>

<span class="sd">    0), the plant will still grow roots as a matter of survival. Furthermore,</span>

<span class="sd">    using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr</span>

<span class="sd">    interval, there is no effect of drought stress on the root growth speed,</span>

<span class="sd">    allowing for a certain level of tolerance of the plant.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): The current iteration step of the process.</span>

<span class="sd">        data (xarray.Dataset): The input data containing relevant information.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 15</span>

    <span class="c1"># ! simplified conditions</span>

    <span class="c1"># // condition = (data[&quot;numPhase&quot;][j,:,:] &gt; 0) &amp; \</span>

    <span class="c1"># //       np.invert((data[&quot;numPhase&quot;][j,:,:] == 1) &amp; (data[&quot;changePhase&quot;][j,:,:] == 1))</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1">#! renaming dayVrac to delta_root_tank_capacity</span>

    <span class="c1">#// data[&quot;dayVrac&quot;][j,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

            <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

            <span class="c1">#// (data[&quot;stRurMax&quot;][j,:,:] &gt; data[&quot;ruSurf&quot;][j,:,:]),</span>

            <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

            <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span>

        <span class="p">),</span>

        <span class="c1">#// data[&quot;dayVrac&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    updating delta_root_tank_capacity :</span>

<span class="sd">    At the day of phase change, for phases strictly above 1, and for which the</span>

<span class="sd">    difference between the water height to humectation front (hum, mm) and the</span>

<span class="sd">    root_tank_capacity is less than the delta_root_tank_capacity,</span>

<span class="sd">    delta_root_tank_capacity is updated to be equal to the difference between</span>

<span class="sd">    the water height to humectation front and the root_tank_capacity. In other</span>

<span class="sd">    words, the change in root tank capacity delta_root_tank_capacity is limited</span>

<span class="sd">    by the water height to humectation front.</span>

<span class="sd">    For any other day or if root_tank_capacity is above</span>

<span class="sd">    delta_root_tank_capacity, delta_root_tank_capacity value is unchanged.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 16</span>

    <span class="c1"># ! simplified conditions</span>

    <span class="c1"># // condition = (data[&quot;numPhase&quot;][j,:,:] &gt; 0) &amp; \</span>

    <span class="c1"># //       np.invert((data[&quot;numPhase&quot;][j,:,:] == 1) &amp; (data[&quot;changePhase&quot;][j,:,:] == 1))</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1">#! renaming deltaRur with delta_root_tank_capacity</span>

    <span class="c1">#// data[&quot;deltaRur&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

            <span class="c1">#! renaming dayVrac to delta_root_tank_capacity</span>

            <span class="c1">#// (data[&quot;hum&quot;][j,:,:] - data[&quot;stRurMax&quot;][j,:,:]) &lt; data[&quot;dayVrac&quot;][j,:,:],</span>

            <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="c1">#// data[&quot;hum&quot;][j,:,:] - data[&quot;stRurMax&quot;][j,:,:],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="c1">#! renaming dayVrac to delta_root_tank_capacity</span>

            <span class="c1">#// data[&quot;dayVrac&quot;][j,:,:],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="p">),</span>

        <span class="c1">#// data[&quot;deltaRur&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    updating root_tank_capacity/stRurMax/ruRac, step 2 :</span>

<span class="sd">    At the day of phase change, for phases strictly above 1, root_tank_capacity</span>

<span class="sd">    is updated to be summed with the change in root water storage capacity delta_root_tank_capacity.</span>

<span class="sd">    In other words, root_tank_capacity is incremented by the change in root water</span>

<span class="sd">    storage capacity linked to root growth.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 17</span>

    <span class="c1"># ! simplified conditions</span>

    <span class="c1"># // data[&quot;stRurMax&quot;][j:,:,:] = np.where(</span>

    <span class="c1"># //     (data[&quot;numPhase&quot;][j,:,:] &gt; 0),</span>

    <span class="c1"># //     np.where(</span>

    <span class="c1"># //         np.invert((data[&quot;changePhase&quot;][j,:,:] == 1) &amp; (data[&quot;numPhase&quot;][j,:,:] == 1)),</span>

    <span class="c1"># //         data[&quot;stRurMax&quot;][j,:,:] + data[&quot;deltaRur&quot;][j,:,:],</span>

    <span class="c1"># //         data[&quot;stRurMax&quot;][j,:,:],</span>

    <span class="c1"># //     ),</span>

    <span class="c1"># //     data[&quot;stRurMax&quot;][j,:,:],</span>

    <span class="c1"># // )#[...,np.newaxis]</span>

    <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

    <span class="c1">#! renaming deltaRur to delta_root_tank_capacity</span>

    <span class="c1">#// data[&quot;stRurMax&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:] + data[&quot;deltaRur&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    updating root_tank_stock/stRur/stockrac :</span>

<span class="sd">    At the day of phase change, for phases strictly above 1, and for which</span>

<span class="sd">    the root_tank_capacity is above surface_tank_capacity (meaning that</span>

<span class="sd">    roots go beyond the surface water storage capacity), root_tank_stock</span>

<span class="sd">     is incremented by delta_root_tank_capacity.</span>

<span class="sd">    However, if root_tank_capacity is BELOW surface_tank_capacity (meaning</span>

<span class="sd">    that roots do not plunge into the deep reservoir), root_tank_stock is</span>

<span class="sd">    updated to be equal to surface_tank_stock minus 1/10th of the</span>

<span class="sd">    surface_tank_capacity, multiplied by the ratio between</span>

<span class="sd">    root_tank_capacity and surface_tank_capacity. That is to say &quot;we take at</span>

<span class="sd">    the prorata of depth and surface stock&quot;.</span>

<span class="sd">    For any other day, root_tank_stock is unchanged.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 18</span>

    <span class="c1"># ! simplified conditions</span>

    <span class="c1"># // condition = (data[&quot;numPhase&quot;][j,:,:] &gt; 0) &amp; np.invert((data[&quot;changePhase&quot;][j,:,:] == 1) &amp; (data[&quot;numPhase&quot;][j,:,:] == 1)),</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>

    <span class="c1">#! renaming stRur to root_tank_stock</span>

    <span class="c1">#// data[&quot;stRur&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="n">xr</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

            <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

            <span class="c1">#// (data[&quot;stRurMax&quot;][j,:,:] &gt; data[&quot;ruSurf&quot;][j,:,:]),</span>

            <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

            <span class="c1">#! renaming stRur to root_tank_stock</span>

            <span class="c1">#! renaming deltaRur to delta_root_tank_capacity</span>

            <span class="c1">#// data[&quot;stRur&quot;][j,:,:] + data[&quot;deltaRur&quot;][j,:,:],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="c1">#! renaming stRur to root_tank_stock</span>

            <span class="c1">#! renaming stRuSurf to surface_tank_stock</span>

            <span class="c1">#// np.maximum((data[&quot;stRuSurf&quot;][j,:,:] - data[&quot;ruSurf&quot;][j,:,:] * 1/10) * (data[&quot;stRurMax&quot;][j,:,:] / data[&quot;ruSurf&quot;][j,:,:]), 0),</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span> <span class="mi">0</span><span class="p">),</span>

        <span class="p">)</span><span class="o">.</span><span class="kp">expand_dims</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>

        <span class="c1">#! renaming stRur to root_tank_stock</span>

        <span class="c1">#// data[&quot;stRur&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">EvolRurCstr2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="sd">    bileau.pas</span>

<span class="sd">    Notes from CB, 10/06/2015 :</span>

<span class="sd">    Stress trop fort enracinement</span>

<span class="sd">    Trop d&#39;effet de stress en tout début de croissance :</span>

<span class="sd">    1) la plantule a des réserves et favorise l&#39;enracinement</span>

<span class="sd">    2) dynamique spécifique sur le réservoir de surface</span>

<span class="sd">    Cet effet stress sur l&#39;enracinement ne s&#39;applique que quand l&#39;enracinement</span>

<span class="sd">    est supérieur é la profondeur du réservoir de surface. Effet stres a un</span>

<span class="sd">    effet sur la vitesse de prof d&#39;enracinement au dessus d&#39;un certain seuil de</span>

<span class="sd">    cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur</span>

<span class="sd">    la vitesse) La vitesse d&#39;enracinement potentielle de la plante peut etre</span>

<span class="sd">    bloque par manque d&#39;eau en profondeur (Hum). La profondeur d&#39;humectation est</span>

<span class="sd">    convertie en quantite d&#39;eau maximum equivalente</span>

<span class="sd">    IN:</span>

<span class="sd">    Vrac : mm (en mm/jour) : Vitesse racinaire journalière §§ Daily root depth</span>

<span class="sd">    Hum : mm Quantité d&#39;eau maximum jusqu&#39;au front d&#39;humectation §§ Maximum</span>

<span class="sd">    water capacity to humectation front</span>

<span class="sd">    StRuSurf : mm</span>

<span class="sd">    RU : mm/m</span>

<span class="sd">    RuSurf : mm/m</span>

<span class="sd">    INOUT:</span>

<span class="sd">    stRurMax : mm ==== ruRac</span>

<span class="sd">    stRur : mm ==== stockRac</span>

<span class="sd">    NB : on remet le nom de variables de CB plutôt que celles utilisées par MC dans le code Java</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ! dayvrac et deltarur reset à chaque itération ; on traine donc le j sur les autres variables</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">initialize_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="c1">####################### list of functions for rempliRes #######################</span>

<span class="k">def</span> <span class="nf">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Returns conditions needed to apply functions related to end of cycle.</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">condition</span>

<span class="k">def</span> <span class="nf">update_humPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function saves information about the humectation front depth at the end</span>

<span class="sd">    of a growth cycle so it can be used in the next cycle.</span>

<span class="sd">    humPrec is initialized in the function InitPlotMc, and set to be equal to</span>

<span class="sd">    hum, itself being initialized to take the maximum value between</span>

<span class="sd">    surface_tank_capacity, root_tank_capacity and total_tank_stock.</span>

<span class="sd">    At the harvest date (numPhase = 7), the humPrec variable is set to equal the</span>

<span class="sd">    highest value between hum (mm, humectation front depth) and</span>

<span class="sd">    surface_tank_capacity (mm). This value is broadcasted over the time</span>

<span class="sd">    dimension.</span>

<span class="sd">    At any other point in time, its value is unchanged.</span>

<span class="sd">    This means...</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): number of the day</span>

<span class="sd">        data (xarray dataset): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray dataset: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 20</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

        <span class="c1">#// np.maximum(data[&quot;hum&quot;][j,:,:], data[&quot;ruSurf&quot;][j,:,:]),</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_hum_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates information about the humectation front depth at the end</span>

<span class="sd">    of a growth cycle.</span>

<span class="sd">    At the harvest date (numPhase = 7), the hum variable is set to equal the</span>

<span class="sd">    surface_tank_capacity (mm). This value is broadcasted over the time</span>

<span class="sd">    dimension.</span>

<span class="sd">    At any other point in time, its value is unchanged.</span>

<span class="sd">    This means...</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 21</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

        <span class="c1">#// data[&quot;ruSurf&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_stRurMaxPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    When the phase changes from 7 to 1, the stRurMaxPrec (mm, previous</span>

<span class="sd">    maximum water capacity to root front) is set to equal root_tank_capacity</span>

<span class="sd">    (mm). Value is broadcasted along time dimension.</span>

<span class="sd">    For every other day, it keeps its initial value of 0.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 22</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1">#! renaming stRurMaxPrec to root_tank_capacity_previous_season</span>

    <span class="c1">#// data[&quot;stRurMaxPrec&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity_previous_season&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="c1">#! renaming stRurMaxPrec to root_tank_capacity_previous_season</span>

        <span class="c1">#// data[&quot;stRurMaxPrec&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity_previous_season&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_stRurPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    when the phase changes from 7 to 1, stRurPrec is set to equal</span>

<span class="sd">    stRur/stRurMax, that is to say the ratio of the water storage capacity of</span>

<span class="sd">    the root reservoir. Otherwise, it stays at its initial value of 0. Its value</span>

<span class="sd">    is broadcasted along j.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 23</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#! renaming stRur to root_tank_stock</span>

        <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

        <span class="c1">#// data[&quot;stRur&quot;][j,:,:]/data[&quot;stRurMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">/</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_stRuPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    when the phase changes from 7 to 1, the stRuPrec (mm, previous water</span>

<span class="sd">    storage capacity of the global reservoir) is set to equal the differe,ce</span>

<span class="sd">    between stTot (mm, total water storage capacity of the global reservoir)</span>

<span class="sd">    and stRurSurf (mm, water storage capacity of the surface reservoir)</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 24</span>

    <span class="c1">#! stRurSurf is not defined... we may want to drop this group</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1">#! renaming stRuPrec to total_tank_stock_previous_value</span>

    <span class="c1">#// data[&quot;stRuPrec&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#! renaming stTot to total_tank_stock</span>

        <span class="c1">#! renaming stRuSurf with surface_tank_stock</span>

        <span class="c1">#// data[&quot;stRu&quot;][j,:,:] - data[&quot;stRurSurf&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="c1"># essai stTot</span>

        <span class="c1">#! renaming stRuPrec to total_tank_stock_previous_value</span>

        <span class="c1">#// data[&quot;stRuPrec&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">reset_total_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function resets the value total_tank_capacity/stRuMax at each loop.</span>

<span class="sd">    ? Why redfining stRuMax at each loop ? Neither ru, profRu</span>

<span class="sd">    ? nor total_tank_capacity are modified during the simulation.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 25</span>

    <span class="c1">#! renaming stRuMax to total_tank_capacity</span>

    <span class="c1">#// data[&quot;stRuMax&quot;][j:,:,:] = (data[&quot;ru&quot;] * data[&quot;profRu&quot;] / 1000) #.copy()#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the value of surface_tank_stock.</span>

<span class="sd">    We update surface_tank_stock by adding the eauDispo, which as this point is</span>

<span class="sd">    the water available from 1) rain, 2) irrigation for the day after estimation</span>

<span class="sd">    of intake by mulch, and 3) runoff. However, we do not allow</span>

<span class="sd">    surface_tank_stock to exceed 110% of the surface_tank_capacity.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 27</span>

    <span class="c1">#! renaming stRuSurf to surface_tank_stock</span>

    <span class="c1">#// data[&quot;stRuSurf&quot;][j:,:,:] = np.minimum(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span>

        <span class="c1">#// data[&quot;stRuSurf&quot;][j,:,:] + data[&quot;eauDispo&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

        <span class="c1">#// 1.1 * data[&quot;ruSurf&quot;][j,:,:]</span>

        <span class="mf">1.1</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_transpirable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the daily volume of transpirable water.</span>

<span class="sd">    eauTranspi (mm, water transpirable) is the water available for</span>

<span class="sd">    transpiration from the surface reservoir.</span>

<span class="sd">    If surface_tank_stock at the end of the previous day (index j-1) is</span>

<span class="sd">    lower than 10% of the surface_tank_capacity, the water available for</span>

<span class="sd">    transpirable water equals the water available for the day (eauDispo),</span>

<span class="sd">    minus the difference between 1/10th of the surface_tank_capacity and</span>

<span class="sd">    surface_tank_stock. This transpirable water has a min bound at 0 mm.</span>

<span class="sd">    Said otherwise, a part of the water available for the day (eauDispo) is</span>

<span class="sd">    considered as bound to the surface reservoir and cannot be transpired.</span>

<span class="sd">    If surface_tank_stock at the end of the previous day (index j-1) is</span>

<span class="sd">    upper than 10% of the surface_tank_capacity, transpirable water equals</span>

<span class="sd">    eauDispo.</span>

<span class="sd">    Remark : if the use of j-1 indices is too problematic, it seems feasible to</span>

<span class="sd">    run this function just before update_surface_tank_stock.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 28</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="c1"># ! modifying to replace stRuSurfPrec by stRuSurf at undex j-1</span>

        <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

        <span class="c1">#! renaming stRuSurfPrec to surface_tank_stock</span>

        <span class="c1"># // data[&quot;stRuSurfPrec&quot;][j,:,:] &lt; data[&quot;ruSurf&quot;][j,:,:]/10,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:]</span> <span class="o">&lt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

            <span class="mi">0</span><span class="p">,</span>

            <span class="c1"># ! modifying to replace stRuSurfPrec by stRuSurf at iundex j-1</span>

            <span class="c1">#! renaming ruSurf to surface_tank_capacity</span>

            <span class="c1">#! renaming stRuSurf to surface_tank_stock</span>

            <span class="c1"># //data[&quot;eauDispo&quot;][j,:,:] - (data[&quot;ruSurf&quot;][j,:,:]/10 - data[&quot;stRuSurfPrec&quot;][j,:,:])</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,:,:])</span>

            <span class="p">),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This functions updates the value of total_tank_stock with the value of</span>

<span class="sd">    transpirable water.</span>

<span class="sd">    ? why incrementing stTot by eauTranspi ?</span>

<span class="sd">    ? we then consider that transpirable water is the water that fills the total_tank_stock ?</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 29</span>

    <span class="c1">#! renaming stTot with total_tank_stock</span>

    <span class="c1">#// data[&quot;stTot&quot;][j:,:,:] = (data[&quot;stTot&quot;][j,:,:] + data[&quot;eauTranspi&quot;][j,:,:]).copy()#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_delta_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates delta_total_tank_stock</span>

<span class="sd">    delta_total_tank_stock is the positive variation of transpirable water</span>

<span class="sd">    stock. It is computed as the difference between the total_tank_stock and</span>

<span class="sd">    stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is</span>

<span class="sd">    initialized to be equal to total_tank_stock at the beginning of the</span>

<span class="sd">    simulation. total_tank_stock is initialized with stockIrr parameter. Thus,</span>

<span class="sd">    simulations should start with a 0 value.</span>

<span class="sd">    stRuPrec is updated at each cycle with the update_struprec function.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 30</span>

    <span class="c1">#! we propose a different version based on stTot</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#! renaming stRuVar to delta_total_tank_stock</span>

    <span class="c1">#! renaming stRuPrec to total_tank_stock_previous_value</span>

    <span class="c1">#// data[&quot;stRuVar&quot;][j:,:,:] = np.maximum(0, data[&quot;stTot&quot;][j,:,:] - data[&quot;stRuPrec&quot;][j,:,:])[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">conditions_rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

    <span class="c1">#//condition_1 = (data[&quot;stRuVar&quot;][j,:,:] &gt; data[&quot;hum&quot;][j,:,:])</span>

    <span class="n">condition_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="c1">#! renaming stRurMaxPrec to root_tank_capacity_previous_season</span>

    <span class="c1">#// condition_2 = (data[&quot;hum&quot;][j,:,:] &lt;= data[&quot;stRurMaxPrec&quot;][j,:,:])</span>

    <span class="n">condition_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity_previous_season&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="c1">#! we replace humPrec by hum with indice j-1</span>

    <span class="c1">#// condition_3 = (data[&quot;hum&quot;][j,:,:] &lt; data[&quot;humPrec&quot;][j,:,:])</span>

    <span class="n">condition_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">condition_1</span><span class="p">,</span> <span class="n">condition_2</span><span class="p">,</span> <span class="n">condition_3</span>

<span class="k">def</span> <span class="nf">update_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function performs the second update of total_tank_stock/stTot/stRu in the</span>

<span class="sd">    reservoir filling wrapper function. It will increase the total_tank_stock</span>

<span class="sd">    depending on the variation of transpirable water and height of humectation</span>

<span class="sd">    front.</span>

<span class="sd">    test image markdown</span>

<span class="sd">    ![Drag Racing](Dragster.jpg)</span>

<span class="sd">    In this function, if the variation of transpirable water</span>

<span class="sd">    (delta_total_tank_stock) increases above the depth of humectation front</span>

<span class="sd">    (hum), if the depth of humectation front (hum) is above the</span>

<span class="sd">    root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which</span>

<span class="sd">    should be the case for most of the simulations that will be single-season),</span>

<span class="sd">    and if the depth of humectation front (hum) has decreased since the previous</span>

<span class="sd">    day, then total_tank_stock takes delta_total_tank_stock as value. If the</span>

<span class="sd">    depth of humectation front did not change or increased since the previous</span>

<span class="sd">    day (humPrec), then total_tank_stock is unchanged.</span>

<span class="sd">    Notably, root_tank_capacity_previous_season is initialized at 0, and takes</span>

<span class="sd">    another value only at end of cycle ; hum is initialized at a value different</span>

<span class="sd">    from 0 and evolves daily between delta_total_tank_stock and</span>

<span class="sd">    total_tank_capacity.</span>

<span class="sd">    humPrec is initialized with the same value as hum. However, in the</span>

<span class="sd">    update_humPrec_for_end_of_cycle function, at the day of transition between</span>

<span class="sd">    phase 7 and phase 0, it takes hum as value, with a minimum bound of</span>

<span class="sd">    surface_tank_capacity.</span>

<span class="sd">    Starting from second simulation season (root_tank_capacity_previous_season</span>

<span class="sd">    != 0), if the variation of transpirable water (delta_total_tank_stock)</span>

<span class="sd">    increases above the depth of humectation front (hum), and if the depth of</span>

<span class="sd">    humectation front stays below or equel to the total soil capacity</span>

<span class="sd">    (conditions 1 and 2 passed), then we increase the value of total_tank_stock</span>

<span class="sd">    by a the difference of water height between the variation of total tank</span>

<span class="sd">    stock (delta_total_tank_stock) and the depth of humectation front (hum),</span>

<span class="sd">    proportionally to the filling of the root tank capacity of previous season</span>

<span class="sd">    (stRurPrec). Thus, if the root tank is empty, total_tank_stock will remain</span>

<span class="sd">    unchanged, and if the root tank is full, total_tank_stock will be increased</span>

<span class="sd">    up to the amount of water making the difference between quantity of water</span>

<span class="sd">    for humectation front and the variation in daily transpirable water.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition_1</span><span class="p">,</span> <span class="n">condition_2</span><span class="p">,</span> <span class="n">condition_3</span> <span class="o">=</span> <span class="n">conditions_rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#// data[&quot;stTot&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition_1</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="c1">#!</span>

            <span class="n">condition_2</span><span class="p">,</span>

            <span class="c1">#! we replace stRurPrec with stRur at indice j-1</span>

            <span class="c1">#! renaming stRur to root_tank_stock</span>

            <span class="c1">#! renaming stTot to total_tank_stock</span>

            <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

            <span class="c1">#// data[&quot;stTot&quot;][j,:,:] + (data[&quot;stRuVar&quot;][j,:,:] - data[&quot;hum&quot;][j,:,:]) * data[&quot;stRurPrec&quot;][j,:,:],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

                <span class="n">condition_3</span><span class="p">,</span>

                <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

                <span class="c1">#//data[&quot;stRuVar&quot;][j,:,:],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

                <span class="c1">#! renaming stTot to total_tank_stock</span>

                <span class="c1">#// data[&quot;stTot&quot;][j,:,:],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="p">),</span>

        <span class="p">),</span>

        <span class="c1">#! renaming stTot to total_tank_stock</span>

        <span class="c1">#// data[&quot;stTot&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_stRuPrec</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function performs the update of</span>

<span class="sd">    total_tank_stock_previous_value/stRuPrec in the reservoir filling wrapper</span>

<span class="sd">    function. It will decrease the total_tank_stock_previous_value depending on</span>

<span class="sd">    the variation of transpirable water and height of humectation front.</span>

<span class="sd">    test image markdown ![Drag Racing](Dragster.jpg)</span>

<span class="sd">    In this function, if the variation of transpirable water</span>

<span class="sd">    (delta_total_tank_stock) increases above the depth of humectation front</span>

<span class="sd">    (hum), if the depth of humectation front (hum) is above the</span>

<span class="sd">    root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which</span>

<span class="sd">    should be the case for most of the simulations that will be single-season),</span>

<span class="sd">    and if the depth of humectation front (hum) has decreased since the previous</span>

<span class="sd">    day (condition 3 passed), then total_tank_stock_previous_value equals 0. If</span>

<span class="sd">    the depth of humectation front did not change or increased since the</span>

<span class="sd">    previous day (humPrec), then total_tank_stock_previous_value is unchanged.</span>

<span class="sd">    Notably, root_tank_capacity_previous_season is initialized at 0, and takes</span>

<span class="sd">    another value only at end of cycle ; hum is initialized at a value different</span>

<span class="sd">    from 0 and evolves daily between delta_total_tank_stock and</span>

<span class="sd">    total_tank_capacity.</span>

<span class="sd">    humPrec is initialized with the same value as hum. However, in the</span>

<span class="sd">    update_humPrec_for_end_of_cycle function, at the day of transition between</span>

<span class="sd">    phase 7 and phase 0, it takes hum as value, with a minimum bound of</span>

<span class="sd">    surface_tank_capacity.</span>

<span class="sd">    Starting from second simulation season (root_tank_capacity_previous_season</span>

<span class="sd">    != 0), if the variation of transpirable water (delta_total_tank_stock)</span>

<span class="sd">    increases above the depth of humectation front (hum), and if the depth of</span>

<span class="sd">    humectation front stays below or equel to the total soil capacity</span>

<span class="sd">    (conditions 1 and 2 passed), then we decrease the value of</span>

<span class="sd">    total_tank_stock_previous_value by a the difference of water height between</span>

<span class="sd">    the variation of total tank stock (delta_total_tank_stock) and the depth of</span>

<span class="sd">    humectation front (hum), proportionally to the filling of the root tank</span>

<span class="sd">    capacity of previous season (stRurPrec). Thus, if the root tank is empty,</span>

<span class="sd">    total_tank_stock_previous_value will remain unchanged, and if the root tank</span>

<span class="sd">    is full, total_tank_stock_previous_value will be decreased up to the amount</span>

<span class="sd">    of water making the difference between quantity of water for humectation</span>

<span class="sd">    front and the variation in daily transpirable water.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition_1</span><span class="p">,</span> <span class="n">condition_2</span><span class="p">,</span> <span class="n">condition_3</span> <span class="o">=</span> <span class="n">conditions_rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># group 32</span>

    <span class="c1">#! renaming stRuPrec with total_tank_stock_previous_value</span>

    <span class="c1">#// data[&quot;stRuPrec&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition_1</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="n">condition_2</span><span class="p">,</span>

            <span class="c1">#! replacing stRurPrec with ratio formula</span>

            <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

            <span class="c1">#! renaming stRuPrec with total_tank_stock_previous_value</span>

            <span class="c1">#//np.maximum(0, data[&quot;stRuPrec&quot;][j,:,:] - (data[&quot;stRuVar&quot;][j,:,:] - data[&quot;hum&quot;][j,:,:]) * data[&quot;stRurPrec&quot;][j,:,:]),</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]),</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

                <span class="n">condition_3</span><span class="p">,</span>

                <span class="mi">0</span><span class="p">,</span>

                <span class="c1">#! renaming stRuPrec with total_tank_stock_previous_value</span>

                <span class="c1">#// data[&quot;stRuPrec&quot;][j,:,:],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="p">),</span>

        <span class="p">),</span>

        <span class="c1">#! renaming stRuPrec with total_tank_stock_previous_value</span>

        <span class="c1">#// data[&quot;stRuPrec&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_delta_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition_1</span><span class="p">,</span> <span class="n">condition_2</span><span class="p">,</span> <span class="n">condition_3</span> <span class="o">=</span> <span class="n">conditions_rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># groupe 33</span>

    <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

    <span class="c1">#// data[&quot;stRuVar&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition_1</span><span class="p">,</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

            <span class="n">condition_2</span><span class="p">,</span>

            <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

            <span class="c1">#// data[&quot;stRuVar&quot;][j,:,:] + (data[&quot;stRuVar&quot;][j,:,:] - data[&quot;hum&quot;][j,:,:]) * data[&quot;stRurPrec&quot;][j,:,:],</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

                <span class="n">condition_3</span><span class="p">,</span>

                <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

                <span class="c1">#! renaming stRuPrec with total_tank_stock_previous_value</span>

                <span class="c1">#// data[&quot;stRuVar&quot;][j,:,:] + data[&quot;stRuPrec&quot;][j,:,:],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

                <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

                <span class="c1">#// data[&quot;stRuVar&quot;][j,:,:],</span>

                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

            <span class="p">),</span>

        <span class="p">),</span>

        <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

        <span class="c1">#// data[&quot;stRuVar&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_hum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the depth to humectation front (hum) to be the maximum</span>

<span class="sd">    value between the depth to humectation front (hum) and</span>

<span class="sd">    delta_total_tank_stock (that is to say depth of humectation front can only</span>

<span class="sd">    increase), bounded by total_tank_capacity (that is to say humectation front</span>

<span class="sd">    can not go deep indefinitely).</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># groupe 34</span>

    <span class="c1">#! renaming stRuVar with delta_total_tank_stock</span>

    <span class="c1">#// data[&quot;hum&quot;][j:,:,:] = np.maximum(data[&quot;stRuVar&quot;][j,:,:], data[&quot;hum&quot;][j,:,:])#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="c1"># groupe 35</span>

    <span class="c1">#! renaming stRuMax to total_tank_capacity</span>

    <span class="c1">#// data[&quot;hum&quot;][j:,:,:] = np.minimum(data[&quot;stRuMax&quot;][j,:,:], data[&quot;hum&quot;][j,:,:])#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">condition_total_tank_overflow</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">condition</span>

<span class="k">def</span> <span class="nf">update_dr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the daily drainage (dr). When total tank overflows, it</span>

<span class="sd">    computes drainage from the differences between the total_tank_stock (that is</span>

<span class="sd">    to say the total and total_tank_capacity.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#! renaming stRuMax to total_tank_capacity</span>

    <span class="c1">#// condition = (data[&quot;stTot&quot;][j,:,:] &gt; data[&quot;stRuMax&quot;][j,:,:])</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_total_tank_overflow</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># groupe 36</span>

    <span class="c1"># essais stTot</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#! renaming stTot to total_tank_stock</span>

        <span class="c1">#! renaming stRuMax to total_tank_capacity</span>

        <span class="c1">#// data[&quot;stRu&quot;][j,:,:] - data[&quot;stRuMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="mi">0</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_total_tank_stock_step_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the total tank stock where these is overflow occuring.</span>

<span class="sd">    When capacity of total tank is exceeded, it corrects the stock value with</span>

<span class="sd">    maximum capacity of total tank.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#! renaming stRuMax to total_tank_capacity</span>

    <span class="c1">#// condition = (data[&quot;stTot&quot;][j,:,:] &gt; data[&quot;stRuMax&quot;][j,:,:])</span>

    <span class="n">condition</span> <span class="o">=</span> <span class="n">condition_total_tank_overflow</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># groupe 37</span>

    <span class="c1"># essais stTot</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#! renaming stRuMax to total_tank_capacity</span>

    <span class="c1">#// data[&quot;stRu&quot;][j,:,:] = np.where(</span>

    <span class="c1">#// data[&quot;stTot&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">condition</span><span class="p">,</span>

        <span class="c1">#// data[&quot;stRuMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="c1"># data[&quot;stRu&quot;][j,:,:],</span>

        <span class="c1">#// data[&quot;stTot&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span><span class="c1">#[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_hum_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    We update the depth to humectation front (hum) again, to reflect eventual changes in</span>

<span class="sd">    total_tank_stock values.</span>

<span class="sd">    ? we could have placed the previous hum update function here</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># groupe 38</span>

    <span class="c1"># // avant modif 10/06/2015</span>

    <span class="c1"># data[&quot;hum&quot;][j:,:,:] = np.maximum(data[&quot;hum&quot;][j,:,:], data[&quot;stRu&quot;][j,:,:])</span>

    <span class="c1"># essais stTot</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#// data[&quot;hum&quot;][j:,:,:] = np.maximum(data[&quot;hum&quot;][j,:,:], data[&quot;stTot&quot;][j,:,:])[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[...,np.newaxis]</span>

    <span class="c1">#! en conflit avec le calcul précédent de hum</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_root_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Finally, we update root tank stock (root_tank_stock) with the computed</span>

<span class="sd">    values First we increment root_tank_stock with transpirable water</span>

<span class="sd">    (eauTranspi), within the limits of root_tank_capacity. Then, we limit the</span>

<span class="sd">    value of root_tank_stock within total_tank_stock</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># groupe 39</span>

    <span class="c1"># Rempli res racines</span>

    <span class="c1">#! renaming stRur to root_tank_stock</span>

    <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

    <span class="c1">#// data[&quot;stRur&quot;][j:,:,:] = np.minimum(data[&quot;stRur&quot;][j,:,:] + data[&quot;eauTranspi&quot;][j,:,:], data[&quot;stRurMax&quot;][j,:,:])[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauTranspi&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[...,np.newaxis]</span>

    <span class="c1"># groupe 40</span>

    <span class="c1"># essais stTot</span>

    <span class="c1">#! renaming stRur to root_tank_stock</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#// data[&quot;stRur&quot;][j,:,:] = np.minimum(data[&quot;stRur&quot;][j,:,:], data[&quot;stRu&quot;][j,:,:])</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure rempliRes, of the original Pascal codes</span>

<span class="sd">    bileau.pas</span>

<span class="sd">    Main hypotheses :</span>

<span class="sd">    - the water dynamics is represented by a filling from the top and an evolution</span>

<span class="sd">    of the reservoirs sizes when the filling is above the maximum quantity of the</span>

<span class="sd">    current size (humectation front).</span>

<span class="sd">    - when the maximum size is reached by filling, it is considered as drainage.</span>

<span class="sd">    - inside a reservoir, water is distributed homogeneously (may be considered</span>

<span class="sd">    valid up to 2m depth, according to CB, from other sources).</span>

<span class="sd">    3 reservoirs are represented:</span>

<span class="sd">    1) a global reservoir, evolving in depth according to the humectation front</span>

<span class="sd">    2) a surface reservoir (fixed size) where evaporation and a part of the</span>

<span class="sd">    transpiration occurs when roots are present</span>

<span class="sd">    3) a root reservoir, evolving according to the root front (when roots are</span>

<span class="sd">    present)</span>

<span class="sd">    REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks</span>

<span class="sd">    Notes from CB, 10/06/2015 :</span>

<span class="sd">    prise en compte de stock d&#39;eau résilient pour les simulation continues</span>

<span class="sd">    Hypothèse de la MAJ des stock en fn de l&#39;eau r�siliente de l&#39;ann�e pr�c�dente</span>

<span class="sd">    dans le cas des simulations pluri annuelle en continue (NbAn = 1):</span>

<span class="sd">    A la r�colte on recup�re les stock d&#39;eau (StRuPrec), la prof d&#39;Humectation (Humprec)</span>

<span class="sd">    et la prof d&#39;enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien.</span>

<span class="sd">    On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf)</span>

<span class="sd">    Si le StRu avec l&#39;apport d&#39;eau devinet sup au Hum</span>

<span class="sd">    alors on tient compte dans cette augmentation du stock r�silient avec deux cas possible :</span>

<span class="sd">    Si StRu est &lt; � stRurMaxprec</span>

<span class="sd">    alors on ajoute l&#39;eau r�siliente contenue dans l&#39;ancienne zone racinaire en fn</span>

<span class="sd">    de la diff�rence de stock</span>

<span class="sd">    Sinon on a de l&#39;eau r�siliente au maximum de la CC jusqu&#39;� l&#39;ancienne HumPrec,</span>

<span class="sd">    on rempli alors StRu de la diff�rence etre ces deux valeurs puis on fait la MAJ</span>

<span class="sd">    des Dr, StRur, Hum etc...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># section 1 : updating the end_of_cycle memory variables</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_humPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_hum_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_stRurMaxPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_stRurPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_stRuPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">reset_total_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># verif ok</span>

    <span class="c1"># # filling the surface tank with available water</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># verif ok</span>

    <span class="c1"># # estimates transpirable water</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_transpirable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># verif ok</span>

    <span class="c1"># # increments total tank stock with transpirable water</span>

    <span class="c1"># # (meaning that total tank stock may represent a transpirable water tank)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># verif ok</span>

    <span class="c1"># # estimating positive delta between total_root_tank and stRuPrec</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_delta_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1"># verif ok</span>

    <span class="c1"># # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span><span class="c1"># verif ok</span>

    <span class="c1"># # then total_tank_stock_previous_value can 1) take 0 or 2) be unchanged</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_stRuPrec</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="c1">#????</span>

    <span class="c1"># # delta_total_tank_stock can 1) be incremented of total_tank_stock_previous_value or 2) be unchanged</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_delta_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># # # here, in case 1, In this function, if the variation of transpirable water</span>

    <span class="c1"># # (delta_total_tank_stock) increases above the depth of humectation front</span>

    <span class="c1"># # (hum), if the depth of humectation front (hum) is above the</span>

    <span class="c1"># # root_tank_capacity_previous_season (condition 1 passed, and 2 failed,</span>

    <span class="c1"># # which should be the case for most of the simulations that will be</span>

    <span class="c1"># # single-season), and if the depth of humectation front (hum) has decreased</span>

    <span class="c1"># # since the previous day (condition 3 passed), then total_tank_stock takes the value of</span>

    <span class="c1"># # delta_total_tank_stock, total_tank_stock_previous_value equals 0, and</span>

    <span class="c1"># # delta_total_tank_stock is incremented by total_tank_stock_previous_value.</span>

    <span class="c1"># #</span>

    <span class="c1"># # in case 2, nothing happens.</span>

    <span class="c1"># # update_hum manages increase in hum</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_hum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># # in case of overflowing...</span>

    <span class="c1"># # calculating drainage</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_dr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># # limiting the total_tank_stock to the total_tank_capacity (when overflowing)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_total_tank_stock_step_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># # update again hum value, but we could merge functions with update_hum</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_hum_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># # filling root_tank_stock with transpirable water, within the limits of total_tank_stock</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_root_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="c1">########################################################################################</span>

<span class="k">def</span> <span class="nf">estimate_fesw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the fraction of evaporable soil water (fesw, mm).</span>

<span class="sd">    fesw is defined as the ratio of water stock in the surface tank over 110% of</span>

<span class="sd">    the surface tank capacity.</span>

<span class="sd">    It is adapted from the EvalFESW procedure, from bileau.pas and</span>

<span class="sd">    bhytypeFAO.pas files from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! renaming stRuSurf to surface_tank_stock</span>

    <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

    <span class="c1">#// data[&quot;fesw&quot;][j,:,:] = data[&quot;stRuSurf&quot;][j,:,:] / (data[&quot;ruSurf&quot;][j,:,:] + data[&quot;ruSurf&quot;][j,:,:] / 10)</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;fesw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_kce</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the coefficient of evaporation from the soil (kce).</span>

<span class="sd">    This approach takes into consideration three factors acting on limitation of</span>

<span class="sd">    kce :</span>

<span class="sd">    1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover</span>

<span class="sd">    2) Mulch - permanent covering effect : we consider a value of 1.0 for no</span>

<span class="sd">    covering, and 0.0 is full covering with plastic sheet ; this mulch parameter</span>

<span class="sd">    has been used in previous versions of the model where evolution of mulch</span>

<span class="sd">    biomass was not explicitely taken into consideration, can be used in the</span>

<span class="sd">    case of crops with self-mulching phenomena, where a standard mulch parameter</span>

<span class="sd">    value of 0.7 can be applied.</span>

<span class="sd">    3) Mulch - evolutive covering effect BiomMc : biomass of mulch</span>

<span class="sd">    This function has been adapted from EvalKceMC procedure, bileau.pas and</span>

<span class="sd">    exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like</span>

<span class="sd">    it has been adapted from the dual crop coefficient from the FAO56 paper. But</span>

<span class="sd">    this is still to confirm on a point of view of the history of the model.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kce&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ltr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;mulch&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> \

        <span class="n">np</span><span class="o">.</span><span class="kp">exp</span><span class="p">(</span><span class="o">-</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;coefMc&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;surfMc&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_soil_potential_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes estimation of potential soil evaporation (mm,</span>

<span class="sd">    evapPot).</span>

<span class="sd">    It performs its computations solely from the evaporation forcing driven by</span>

<span class="sd">    climatic demand, limited by the coefficient of evaporation from the soil</span>

<span class="sd">    (kce).</span>

<span class="sd">    Note : difference in humectation of the top and bottom tanks is not taken</span>

<span class="sd">    into consideration in this approach.  The</span>

<span class="sd">    This function has been adapted from DemandeSol procedure, from bileau.pas</span>

<span class="sd">    and exmodules 1 &amp; 2.pas file from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 44</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evapPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kce&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_soil_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes estimation of soil evaporation (mm, evap). It uses</span>

<span class="sd">    the potential soil evaporation (evapPot) and the fraction of evaporable soil</span>

<span class="sd">    water (fesw), bounded by the surface tank stock.</span>

<span class="sd">    It has been adapted from the EvapRuSurf procedure, from bileau.pas and</span>

<span class="sd">    exmodules 1 &amp; 2.pas file from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#! replacing stRuSurf by surface_tank_stock</span>

    <span class="c1">#// data[&quot;evap&quot;][j:,:,:] = np.minimum(data[&quot;evapPot&quot;][j,:,:] * data[&quot;fesw&quot;][j,:,:]**2, data[&quot;stRuSurf&quot;][j,:,:])[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evapPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;fesw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_FEMcW_and_update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function calculates the fraction of evaporable water from the mulch</span>

<span class="sd">    (FEMcW).</span>

<span class="sd">    If the mulch water stock is greater than 0, then we compute FEMcW, which we</span>

<span class="sd">    consider to be equal to the filling ratio of the mulch water capacity. We</span>

<span class="sd">    then update the mulch water stock by removing the water height equivalent to</span>

<span class="sd">    the climate forcing demand, modulated by FEMcW and the plant cover (ltr).</span>

<span class="sd">    This function is adapted from the procedure EvapMC, from bileau.pas and</span>

<span class="sd">    exmodules 2.pas file from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 45</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;FEMcW&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="c1">#! replacing stockMc with mulch_water_stock</span>

        <span class="c1">#// data[&quot;stockMc&quot;][j,:,:] &gt; 0,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>

        <span class="c1">#! inverting the fraction to get stock over capacity, and not the other way round</span>

        <span class="c1">#// (paramITK[&quot;humSatMc&quot;] * data[&quot;biomMc&quot;][j,:,:] * 0.001) / data[&quot;stockMc&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="p">(</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;humSatMc&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;FEMcW&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="c1"># group 46</span>

    <span class="c1">#! replacing stockMc with mulch_water_stock</span>

    <span class="c1">#// data[&quot;stockMc&quot;][j:,:,:] = np.maximum(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="c1">#! removing the power of 2 in the equation</span>

        <span class="c1">#// data[&quot;stockMc&quot;][j,:,:] - data[&quot;ltr&quot;][j,:,:] * data[&quot;ET0&quot;][j,:,:] * data[&quot;FEMcW&quot;][j,:,:]**2,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ltr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;FEMcW&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_ftsw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the fraction of evaporable soil water (fesw) from</span>

<span class="sd">    the root reservoir.</span>

<span class="sd">    It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 &amp;</span>

<span class="sd">    2.pas, risocas.pas, riz.pas files from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ftsw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:] &gt; 0,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>

        <span class="c1">#! renaming stRur to root_tank_stock</span>

        <span class="c1">#! renaming stRurMax to root_tank_capacity</span>

        <span class="c1">#// data[&quot;stRur&quot;][j,:,:] / data[&quot;stRurMax&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="mi">0</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_potential_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes the potential transpiration from the plant.</span>

<span class="sd">    Computation is based on the climate forcing (ET0), as well as the kcp coefficient.</span>

<span class="sd">    This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and</span>

<span class="sd">    exmodules 1 &amp; 2.pas files from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ggroup 51</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;trPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcp&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_kcTot</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes the total kc coefficient.</span>

<span class="sd">    Computation is based on the kcp (transpiration coefficient) and kce</span>

<span class="sd">    (evaporation from the soil) coefficients. Where the crop coefficient is 0</span>

<span class="sd">    (meaning that there was no emergence yet), kcTot takes the value of kce.</span>

<span class="sd">    This function is based on the EvalKcTot procedure, from the bileau.pas and</span>

<span class="sd">    exmodules 1 &amp; 2.pas files, from the original FORTRAN code.</span>

<span class="sd">    #! Note : code has been modified to match the original SARRA-H behavior.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># added a condition on 19/08/22 to match SARRA-H original behavior</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcTot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcp&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kce&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kce&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcp&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_pFact</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    This function computes the pFactor, which is a bound coefficient used in the</span>

<span class="sd">    computation of cstr from ftsw. This coefficient delimits the portion of the</span>

<span class="sd">    FTSW below which water stress starts to influence the transpiration.</span>

<span class="sd">    FAO reference for critical FTSW value for transpiration response (0 =</span>

<span class="sd">    stomata respond immediately if FTSW&lt;1; 0.5 for most of the crops)</span>

<span class="sd">    pFact is bounded in [0.1, 0.8].</span>

<span class="sd">    For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf</span>

<span class="sd">    This function is based on the CstrPFactor procedure, from bileau.pas,</span>

<span class="sd">    exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramVariete (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 53</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">paramVariete</span><span class="p">[</span><span class="s2">&quot;PFactor&quot;</span><span class="p">]</span> <span class="o">+</span> \

        <span class="mf">0.04</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;kcp&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ET0&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="c1"># group 54</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

            <span class="mf">0.1</span><span class="p">,</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="p">),</span>

        <span class="mf">0.8</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_cstr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes the water stress coefficient cstr.</span>

<span class="sd">    It uses ftsw and pFact. cstr is bounded in [0, 1].</span>

<span class="sd">    This function is based on the CstrPFactor procedure, from bileau.pas,</span>

<span class="sd">    exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#group 55</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ftsw&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pFact&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># group 56</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function computes the transpiration from the plant.</span>

<span class="sd">    This function is based on the EvalTranspi procedure, from bileau.pas,</span>

<span class="sd">    bhytypeFAO.pas, exmodules 1 &amp; 2.pas, from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 58</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">compute_evapotranspiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">):</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_fesw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_kce</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_soil_potential_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_soil_evaporation</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_FEMcW_and_update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramITK</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_ftsw</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_kcp</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_potential_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_kcTot</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_pFact</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">paramVariete</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_cstr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_transpirable_surface_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates the transpirable surface water. It removes</span>

<span class="sd">    1/10th of surface tank capacity as water is condidered as bound.</span>

<span class="sd">    This function is based on the ConsoResSep procedure, from bileau.pas,</span>

<span class="sd">    exmodules 1 &amp; 2.pas files, from the original FORTRAN code.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 59</span>

    <span class="c1">#! replacing stRuSurf by surface_tank_stock</span>

    <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

    <span class="c1">#// data[&quot;trSurf&quot;][j:,:,:] = np.maximum(0, data[&quot;stRuSurf&quot;][j,:,:] - data[&quot;ruSurf&quot;][j,:,:] / 10)[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

        <span class="mi">0</span><span class="p">,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">,</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">apply_evaporation_on_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="c1"># qte d&#39;eau evapore a consommer sur le reservoir de surface</span>

    <span class="c1"># group 60</span>

    <span class="c1">#! replacing stRuSurf by surface_tank_stock</span>

    <span class="c1">#// data[&quot;stRuSurf&quot;][j:,:,:] = np.maximum(0, data[&quot;stRuSurf&quot;][j,:,:] - data[&quot;evap&quot;][j,:,:])[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">estimate_water_consumption_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates consoRur, which is the water to be consumed from</span>

<span class="sd">    the root tank stock.</span>

<span class="sd">    If soil evaporation (evap) is higher than transpirable surface water</span>

<span class="sd">    (trSurf), then consumption from root tank stock equals trSurf. Else, it</span>

<span class="sd">    equals evap.</span>

<span class="sd">    #? how to interpret this ?</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_total_tank_stock_with_water_consumption</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the total tank stock by subtracting the lower water consumption</span>

<span class="sd">    value from estimate_water_consumption_from_root_tank_stock</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 62</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#// data[&quot;stTot&quot;][j:,:,:] = np.maximum(0, data[&quot;stTot&quot;][j,:,:] - data[&quot;consoRur&quot;][j,:,:])[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_water_consumption_according_to_rooting</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the water consumption consoRur according to</span>

<span class="sd">    rooting depth.</span>

<span class="sd">    If the root tank capacity is lower than the surface tank capacity,</span>

<span class="sd">    meaning than the roots did not dive into the deep tank yet, then the</span>

<span class="sd">    water consumption is updated to equal the evaporation at the prorata of</span>

<span class="sd">    the exploration of surface tank by the roots.</span>

<span class="sd">    Else, consoRur keeps it value, which was previously computed by</span>

<span class="sd">    estimate_water_consumption_from_root_tank_stock.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#  fraction d&#39;eau evapore sur la part transpirable qd les racines sont moins</span>

    <span class="c1">#  profondes que le reservoir de surface, mise a jour des stocks transpirables</span>

    <span class="c1"># group 63</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="c1">#! renaming stRurMax with root_tank_capacity</span>

        <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

        <span class="c1">#// data[&quot;stRurMax&quot;][j,:,:] &lt; data[&quot;ruSurf&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

        <span class="c1">#! renaming stRur to root_tank_stock</span>

        <span class="c1">#! renaming ruSurf with surface_tank_capacity</span>

        <span class="c1">#// data[&quot;evap&quot;][j,:,:] * data[&quot;stRur&quot;][j,:,:] / data[&quot;ruSurf&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_root_tank_stock_with_water_consumption</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates root tank stock according to water consumption.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 64</span>

    <span class="c1">#! renaming stRur to root_tank_stock</span>

    <span class="c1">#// data[&quot;stRur&quot;][j:,:,:] = np.maximum(0, data[&quot;stRur&quot;][j,:,:] - data[&quot;consoRur&quot;][j,:,:])#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;consoRur&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    reajustement de la qte transpirable considerant que l&#39;evap a eu lieu avant</span>

<span class="sd">    mise a jour des stocks transpirables</span>

<span class="sd">    if plant transpiration is higher than the root tank stock, then plant</span>

<span class="sd">    transpiration is updated to be equal to the difference between the root tank stock and the</span>

<span class="sd">    plant transpiration. Else, its value is unmodified.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 65</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="c1">#! renaming stRur to root_tank_stock</span>

        <span class="c1">#// data[&quot;tr&quot;][j,:,:] &gt; data[&quot;stRur&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

        <span class="c1">#// np.maximum(data[&quot;stRur&quot;][j,:,:] - data[&quot;tr&quot;][j,:,:], 0),</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="mi">0</span><span class="p">),</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_surface_tank_stock_according_to_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates the surface tank stock to reflect plant</span>

<span class="sd">    transpiration.</span>

<span class="sd">    if the root tank stock is above 0, then surface tank stock is updated by</span>

<span class="sd">    subtracting the plant transpiration modulated by the ratio between the</span>

<span class="sd">    transpirable water and the root tank stock.</span>

<span class="sd">    That is to say, the more transpirable water is close to the root tank stock,</span>

<span class="sd">    the more of transpirated water by plant will be removed from surface tank stock.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 66</span>

    <span class="c1">#! renaming stRuSurf with surface_tank_stock</span>

    <span class="c1">#// data[&quot;stRuSurf&quot;][j:,:,:] = np.where(</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">where</span><span class="p">(</span>

        <span class="c1">#! renaming stRur to surface_tank_stock</span>

        <span class="c1">#// data[&quot;stRur&quot;][j,:,:] &gt; 0,</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>

        <span class="c1">#// np.maximum(data[&quot;stRuSurf&quot;][j,:,:] - (data[&quot;tr&quot;][j,:,:] * np.minimum(data[&quot;trSurf&quot;][j,:,:]/data[&quot;stRur&quot;][j,:,:], 1)), 0),</span>

        <span class="c1">#! renaming stRuSurf with surface_tank_stock</span>

        <span class="c1">#// np.maximum(data[&quot;stRuSurf&quot;][j,:,:] - (data[&quot;tr&quot;][j,:,:] * np.minimum(data[&quot;trSurf&quot;][j,:,:]/data[&quot;root_tank_stock&quot;][j,:,:], 1)), 0),</span>

        <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span>

            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> \

                <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="kp">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trSurf&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="o">/</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span> <span class="mi">1</span><span class="p">)),</span>

            <span class="mi">0</span><span class="p">,</span>

        <span class="p">),</span>

        <span class="c1">#// data[&quot;stRuSurf&quot;][j,:,:],</span>

        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span>

    <span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_root_tank_stock_with_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;_summary_</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># group 67</span>

    <span class="c1">#! renaming stRur to root_tank_stock</span>

    <span class="c1">#// data[&quot;stRur&quot;][j:,:,:] = np.maximum(0, data[&quot;stRur&quot;][j,:,:] - data[&quot;tr&quot;][j,:,:])#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_total_tank_stock_with_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="c1"># data[&quot;stRu&quot;][j:,:,:] = np.maximum(0, data[&quot;stRu&quot;][j,:,:] - data[&quot;tr&quot;][j,:,:])</span>

    <span class="c1"># essais stTot</span>

    <span class="c1"># group 68</span>

    <span class="c1">#! renaming stTot to total_tank_stock</span>

    <span class="c1">#// data[&quot;stTot&quot;][j:,:,:] = np.maximum(0, data[&quot;stTot&quot;][j,:,:] - data[&quot;tr&quot;][j,:,:])#[...,np.newaxis]</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="kp">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="c1">#[...,np.newaxis] ## ok</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">update_etr_etm</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="c1"># group 69</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;etr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evap&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="o">.</span><span class="kp">copy</span><span class="p">()</span><span class="c1">#[...,np.newaxis]</span>

    <span class="c1"># group 70</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;etm&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;trPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;evapPot&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="o">.</span><span class="kp">copy</span><span class="p">()</span><span class="c1">#[...,np.newaxis]</span>

    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">ConsoResSep</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    d&#39;après bileau.pas</span>

<span class="sd">    group 71</span>

<span class="sd">    Separation de tr et evap. Consommation de l&#39;eau sur les reservoirs</span>

<span class="sd">    Hypothese : l&#39;evaporation est le processus le plus rapide, retranche</span>

<span class="sd">    en premier sur le reservoir de surface. Comme reservoir de surface</span>

<span class="sd">    et reservoirs racinaires se chevauchent, il nous faut aussi calcule sur</span>

<span class="sd">    le reservoir ayant des racines la part deja extraite pour l&#39;evaporation.</span>

<span class="sd">    Quand la profondeur des racines est inferieur au reservoir de surface</span>

<span class="sd">    on ne consomme en evaporation que la fraction correspondant a cette</span>

<span class="sd">    profondeur sur celle du reservoir de surface (consoRur).</span>

<span class="sd">    Les estimations d&#39;evaporation et de transpirations sont effectues</span>

<span class="sd">    separemment, on peut ainsi avoir une consommation legerement superieure</span>

<span class="sd">    a l&#39;eau disponible. On diminuera donc la transpiration en consequence.</span>

<span class="sd">    Modif : Pour les stock d&#39;eau on tient compte de la partie rajoutee au</span>

<span class="sd">    reservoir de surface qui ne peut etre que evapore (air dry)</span>

<span class="sd">    // Parametres</span>

<span class="sd">    IN:</span>

<span class="sd">    stRurMax : mm</span>

<span class="sd">    RuSurf : mm</span>

<span class="sd">    evap : mm</span>

<span class="sd">    trPot : mm</span>

<span class="sd">    evaPot : mm</span>

<span class="sd">    INOUT :</span>

<span class="sd">    stRuSurf : mm</span>

<span class="sd">    tr : mm</span>

<span class="sd">    stRur : mm</span>

<span class="sd">    stRu : mm</span>

<span class="sd">    OUT:</span>

<span class="sd">    etr : mm</span>

<span class="sd">    etm : mm</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_transpirable_surface_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">apply_evaporation_on_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">estimate_water_consumption_from_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_total_tank_stock_with_water_consumption</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_water_consumption_according_to_rooting</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_root_tank_stock_with_water_consumption</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_plant_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_surface_tank_stock_according_to_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_root_tank_stock_with_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_total_tank_stock_with_transpiration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">update_etr_etm</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span>
</code></pre></div>

</details>
<h2 id="functions">Functions</h2>
<h3 id="consoressep">ConsoResSep</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">ConsoResSep</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>d'après bileau.pas</p>
<p>group 71</p>
<p>Separation de tr et evap. Consommation de l'eau sur les reservoirs
Hypothese : l'evaporation est le processus le plus rapide, retranche
en premier sur le reservoir de surface. Comme reservoir de surface
et reservoirs racinaires se chevauchent, il nous faut aussi calcule sur
le reservoir ayant des racines la part deja extraite pour l'evaporation.
Quand la profondeur des racines est inferieur au reservoir de surface
on ne consomme en evaporation que la fraction correspondant a cette
profondeur sur celle du reservoir de surface (consoRur).
Les estimations d'evaporation et de transpirations sont effectues
separemment, on peut ainsi avoir une consommation legerement superieure
a l'eau disponible. On diminuera donc la transpiration en consequence.</p>
<p>Modif : Pour les stock d'eau on tient compte de la partie rajoutee au
reservoir de surface qui ne peut etre que evapore (air dry)
// Parametres
IN:
stRurMax : mm
RuSurf : mm
evap : mm
trPot : mm
evaPot : mm
INOUT :</p>
<p>stRuSurf : mm
tr : mm
stRur : mm
stRu : mm
OUT:
etr : mm
etm : mm</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">ConsoResSep</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">d</span><span class="s1">&#39;</span><span class="s">après bileau.pas</span>

    <span class="nv">group</span> <span class="mi">71</span>

    <span class="nv">Separation</span> <span class="nv">de</span> <span class="nv">tr</span> <span class="nv">et</span> <span class="nv">evap</span>. <span class="nv">Consommation</span> <span class="nv">de</span> <span class="nv">l</span><span class="s1">&#39;</span><span class="s">eau sur les reservoirs</span>

    <span class="nv">Hypothese</span> : <span class="nv">l</span><span class="s1">&#39;</span><span class="s">evaporation est le processus le plus rapide, retranche</span>

    <span class="nv">en</span> <span class="nv">premier</span> <span class="nv">sur</span> <span class="nv">le</span> <span class="nv">reservoir</span> <span class="nv">de</span> <span class="nv">surface</span>. <span class="nv">Comme</span> <span class="nv">reservoir</span> <span class="nv">de</span> <span class="nv">surface</span>

    <span class="nv">et</span> <span class="nv">reservoirs</span> <span class="nv">racinaires</span> <span class="nv">se</span> <span class="nv">chevauchent</span>, <span class="nv">il</span> <span class="nv">nous</span> <span class="nv">faut</span> <span class="nv">aussi</span> <span class="nv">calcule</span> <span class="nv">sur</span>

    <span class="nv">le</span> <span class="nv">reservoir</span> <span class="nv">ayant</span> <span class="nv">des</span> <span class="nv">racines</span> <span class="nv">la</span> <span class="nv">part</span> <span class="nv">deja</span> <span class="nv">extraite</span> <span class="nv">pour</span> <span class="nv">l</span><span class="s1">&#39;</span><span class="s">evaporation.</span>

    <span class="nv">Quand</span> <span class="nv">la</span> <span class="nv">profondeur</span> <span class="nv">des</span> <span class="nv">racines</span> <span class="nv">est</span> <span class="nv">inferieur</span> <span class="nv">au</span> <span class="nv">reservoir</span> <span class="nv">de</span> <span class="nv">surface</span>

    <span class="nv">on</span> <span class="nv">ne</span> <span class="nv">consomme</span> <span class="nv">en</span> <span class="nv">evaporation</span> <span class="nv">que</span> <span class="nv">la</span> <span class="nv">fraction</span> <span class="nv">correspondant</span> <span class="nv">a</span> <span class="nv">cette</span>

    <span class="nv">profondeur</span> <span class="nv">sur</span> <span class="nv">celle</span> <span class="nv">du</span> <span class="nv">reservoir</span> <span class="nv">de</span> <span class="nv">surface</span> <span class="ss">(</span><span class="nv">consoRur</span><span class="ss">)</span>.

    <span class="nv">Les</span> <span class="nv">estimations</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">evaporation et de transpirations sont effectues</span>

    <span class="nv">separemment</span>, <span class="nv">on</span> <span class="nv">peut</span> <span class="nv">ainsi</span> <span class="nv">avoir</span> <span class="nv">une</span> <span class="nv">consommation</span> <span class="nv">legerement</span> <span class="nv">superieure</span>

    <span class="nv">a</span> <span class="nv">l</span><span class="s1">&#39;</span><span class="s">eau disponible. On diminuera donc la transpiration en consequence.</span>

    <span class="nv">Modif</span> : <span class="nv">Pour</span> <span class="nv">les</span> <span class="nv">stock</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau on tient compte de la partie rajoutee au</span>

    <span class="nv">reservoir</span> <span class="nv">de</span> <span class="nv">surface</span> <span class="nv">qui</span> <span class="nv">ne</span> <span class="nv">peut</span> <span class="nv">etre</span> <span class="nv">que</span> <span class="nv">evapore</span> <span class="ss">(</span><span class="nv">air</span> <span class="nv">dry</span><span class="ss">)</span>

    <span class="o">//</span> <span class="nv">Parametres</span>

    <span class="nv">IN</span>:

    <span class="nv">stRurMax</span> : <span class="nv">mm</span>

    <span class="nv">RuSurf</span> : <span class="nv">mm</span>

    <span class="nv">evap</span> : <span class="nv">mm</span>

    <span class="nv">trPot</span> : <span class="nv">mm</span>

    <span class="nv">evaPot</span> : <span class="nv">mm</span>

    <span class="nv">INOUT</span> :

    <span class="nv">stRuSurf</span> : <span class="nv">mm</span>

    <span class="nv">tr</span> : <span class="nv">mm</span>

    <span class="nv">stRur</span> : <span class="nv">mm</span>

    <span class="nv">stRu</span> : <span class="nv">mm</span>

    <span class="nv">OUT</span>:

    <span class="nv">etr</span> : <span class="nv">mm</span>

    <span class="nv">etm</span> : <span class="nv">mm</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_transpirable_surface_water</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">apply_evaporation_on_surface_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_water_consumption_from_root_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_total_tank_stock_with_water_consumption</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_water_consumption_according_to_rooting</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_root_tank_stock_with_water_consumption</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_plant_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_surface_tank_stock_according_to_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_root_tank_stock_with_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_total_tank_stock_with_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_etr_etm</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="evalirrigphase">EvalIrrigPhase</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">EvalIrrigPhase</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>Computes the irrigation state for a given day, including the size and</p>
<p>filling of the irrigation tank and the irrigation demand.</p>
<p>The computation of the irrigation state is based on the irrigation target
(irrigAutoTarget), the maximum irrigation capacity (maxIrrig), the size and
filling of the root zone (stRurMax, stRur) and the surface reservoir
(stRuSurf, ruSurf). The water stock in the irrigation tank (stockIrr) and
the maximum water capacity of the irrigation tank (ruIrr) are first
calculated, with minimum boundaries determined by properties of the surface
reservoir. The irrigation demand (irrigTotDay) is then computed.</p>
<p>The irrigation tank stock and capacity are only computed to avoid issues
with very shallow rooting, where the calculation of the filling of
root_tank_capacity by root_tank_stock can be inappropriate and result in
inadapted results for automatic irrigation.</p>
<p>Note: In this irrigation management, the daily rainfall is not taken into
account.</p>
<p>Translated from the procedure EvalIrrigPhase, of the original Pascal codes
bileau.pas and exmodules2.pas.</p>
<p>In irrigAuto mode, this function computes the size and filling of the
irrigation tank, and the irrigation demand, according to the irrigation
target (irrigAutoTarget), the maximum irrigation capacity (maxIrrig), and
the size and filling of the root zone (stRurMax, stRur) and the surface
reservoir (stRuSurf, ruSurf).</p>
<p>It first calculates stockIrr, the water stock in the irrigation tank, and
ruIrr, the maximum water capacity of irrigation tank. Both stockIrr and
ruIrr are given minimum boundaries related to properties of the surface
reservoir. Then, it calculates the irrigation demand, irrigTotDay.</p>
<p>irrigation_tank_stock and irrigation_tank_capacity are only computed in
order to avoid issues with very shallow rooting, where calculation of
filling of root_tank_capacity by root_tank_stock can be inappropriate and
lead to inadapted results for automatic irrigation</p>
<p>Notes from CB, 2014 :
Modification due à la prise en compte effet Mulch Soit on a une irrigation
observée, soit on calcul la dose d'irrigation Elle est calculée en fonction
d'un seuil d'humidité (IrrigAutoTarget) et de possibilité technique ou choix
(MaxIrrig, Precision) Dans cette gestion d'irrigation la pluie du jour n'est
pas prise en compte</p>
<p>N.B.: here, precision is not taken into account anymore</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>Index of the day for which the irrigation state is being computed.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray.Dataset</td>
<td>The input data, including the arrays for irrigation and correctedIrrigation.</td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td>dict</td>
<td>The parameters for the ITK model.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xarray.Dataset</td>
<td>The updated data, including the computed values for the irrigation state.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">EvalIrrigPhase</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Computes</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">state</span> <span class="k">for</span> <span class="nv">a</span> <span class="nv">given</span> <span class="nv">day</span>, <span class="nv">including</span> <span class="nv">the</span> <span class="nv">size</span> <span class="nv">and</span>

    <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">demand</span>.

    <span class="nv">The</span> <span class="nv">computation</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">state</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">target</span>

    <span class="ss">(</span><span class="nv">irrigAutoTarget</span><span class="ss">)</span>, <span class="nv">the</span> <span class="nv">maximum</span> <span class="nv">irrigation</span> <span class="nv">capacity</span> <span class="ss">(</span><span class="nv">maxIrrig</span><span class="ss">)</span>, <span class="nv">the</span> <span class="nv">size</span> <span class="nv">and</span>

    <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">zone</span> <span class="ss">(</span><span class="nv">stRurMax</span>, <span class="nv">stRur</span><span class="ss">)</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">reservoir</span>

    <span class="ss">(</span><span class="nv">stRuSurf</span>, <span class="nv">ruSurf</span><span class="ss">)</span>. <span class="nv">The</span> <span class="nv">water</span> <span class="nv">stock</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="ss">(</span><span class="nv">stockIrr</span><span class="ss">)</span> <span class="nv">and</span>

    <span class="nv">the</span> <span class="nv">maximum</span> <span class="nv">water</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="ss">(</span><span class="nv">ruIrr</span><span class="ss">)</span> <span class="nv">are</span> <span class="nv">first</span>

    <span class="nv">calculated</span>, <span class="nv">with</span> <span class="nv">minimum</span> <span class="nv">boundaries</span> <span class="nv">determined</span> <span class="nv">by</span> <span class="nv">properties</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface</span>

    <span class="nv">reservoir</span>. <span class="nv">The</span> <span class="nv">irrigation</span> <span class="nv">demand</span> <span class="ss">(</span><span class="nv">irrigTotDay</span><span class="ss">)</span> <span class="nv">is</span> <span class="k">then</span> <span class="nv">computed</span>.

    <span class="nv">The</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">and</span> <span class="nv">capacity</span> <span class="nv">are</span> <span class="nv">only</span> <span class="nv">computed</span> <span class="nv">to</span> <span class="nv">avoid</span> <span class="nv">issues</span>

    <span class="nv">with</span> <span class="nv">very</span> <span class="nv">shallow</span> <span class="nv">rooting</span>, <span class="nv">where</span> <span class="nv">the</span> <span class="nv">calculation</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">filling</span> <span class="nv">of</span>

    <span class="nv">root_tank_capacity</span> <span class="nv">by</span> <span class="nv">root_tank_stock</span> <span class="nv">can</span> <span class="nv">be</span> <span class="nv">inappropriate</span> <span class="nv">and</span> <span class="nb">result</span> <span class="nv">in</span>

    <span class="nv">inadapted</span> <span class="nv">results</span> <span class="k">for</span> <span class="nv">automatic</span> <span class="nv">irrigation</span>.

    <span class="nv">Note</span>: <span class="nv">In</span> <span class="nv">this</span> <span class="nv">irrigation</span> <span class="nv">management</span>, <span class="nv">the</span> <span class="nv">daily</span> <span class="nv">rainfall</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">taken</span> <span class="nv">into</span>

    <span class="nv">account</span>.

    <span class="nv">Translated</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">procedure</span> <span class="nv">EvalIrrigPhase</span>, <span class="nv">of</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">Pascal</span> <span class="nv">codes</span>

    <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span> <span class="nv">exmodules2</span>.<span class="nv">pas</span>.

    <span class="nv">In</span> <span class="nv">irrigAuto</span> <span class="nv">mode</span>, <span class="nv">this</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">the</span> <span class="nv">size</span> <span class="nv">and</span> <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">the</span>

    <span class="nv">irrigation</span> <span class="nv">tank</span>, <span class="nv">and</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">demand</span>, <span class="nv">according</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">irrigation</span>

    <span class="nv">target</span> <span class="ss">(</span><span class="nv">irrigAutoTarget</span><span class="ss">)</span>, <span class="nv">the</span> <span class="nv">maximum</span> <span class="nv">irrigation</span> <span class="nv">capacity</span> <span class="ss">(</span><span class="nv">maxIrrig</span><span class="ss">)</span>, <span class="nv">and</span>

    <span class="nv">the</span> <span class="nv">size</span> <span class="nv">and</span> <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">zone</span> <span class="ss">(</span><span class="nv">stRurMax</span>, <span class="nv">stRur</span><span class="ss">)</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">surface</span>

    <span class="nv">reservoir</span> <span class="ss">(</span><span class="nv">stRuSurf</span>, <span class="nv">ruSurf</span><span class="ss">)</span>.

    <span class="nv">It</span> <span class="nv">first</span> <span class="nv">calculates</span> <span class="nv">stockIrr</span>, <span class="nv">the</span> <span class="nv">water</span> <span class="nv">stock</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span>, <span class="nv">and</span>

    <span class="nv">ruIrr</span>, <span class="nv">the</span> <span class="nv">maximum</span> <span class="nv">water</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">irrigation</span> <span class="nv">tank</span>. <span class="nv">Both</span> <span class="nv">stockIrr</span> <span class="nv">and</span>

    <span class="nv">ruIrr</span> <span class="nv">are</span> <span class="nv">given</span> <span class="nv">minimum</span> <span class="nv">boundaries</span> <span class="nv">related</span> <span class="nv">to</span> <span class="nv">properties</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface</span>

    <span class="nv">reservoir</span>. <span class="k">Then</span>, <span class="nv">it</span> <span class="nv">calculates</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">demand</span>, <span class="nv">irrigTotDay</span>.

    <span class="nv">irrigation_tank_stock</span> <span class="nv">and</span> <span class="nv">irrigation_tank_capacity</span> <span class="nv">are</span> <span class="nv">only</span> <span class="nv">computed</span> <span class="nv">in</span>

    <span class="nv">order</span> <span class="nv">to</span> <span class="nv">avoid</span> <span class="nv">issues</span> <span class="nv">with</span> <span class="nv">very</span> <span class="nv">shallow</span> <span class="nv">rooting</span>, <span class="nv">where</span> <span class="nv">calculation</span> <span class="nv">of</span>

    <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">root_tank_capacity</span> <span class="nv">by</span> <span class="nv">root_tank_stock</span> <span class="nv">can</span> <span class="nv">be</span> <span class="nv">inappropriate</span> <span class="nv">and</span>

    <span class="nv">lead</span> <span class="nv">to</span> <span class="nv">inadapted</span> <span class="nv">results</span> <span class="k">for</span> <span class="nv">automatic</span> <span class="nv">irrigation</span>

    <span class="nv">Notes</span> <span class="nv">from</span> <span class="nv">CB</span>, <span class="mi">2014</span> :

    <span class="nv">Modification</span> <span class="nv">due</span> à <span class="nv">la</span> <span class="nv">prise</span> <span class="nv">en</span> <span class="nv">compte</span> <span class="nv">effet</span> <span class="nv">Mulch</span> <span class="nv">Soit</span> <span class="nv">on</span> <span class="nv">a</span> <span class="nv">une</span> <span class="nv">irrigation</span>

    <span class="nv">observ</span>é<span class="nv">e</span>, <span class="nv">soit</span> <span class="nv">on</span> <span class="nv">calcul</span> <span class="nv">la</span> <span class="nv">dose</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">irrigation Elle est calculée en fonction</span>

    <span class="nv">d</span><span class="s1">&#39;</span><span class="s">un seuil d</span><span class="s1">&#39;</span><span class="nv">humidit</span>é <span class="ss">(</span><span class="nv">IrrigAutoTarget</span><span class="ss">)</span> <span class="nv">et</span> <span class="nv">de</span> <span class="nv">possibilit</span>é <span class="nv">technique</span> <span class="nv">ou</span> <span class="nv">choix</span>

    <span class="ss">(</span><span class="nv">MaxIrrig</span>, <span class="nv">Precision</span><span class="ss">)</span> <span class="nv">Dans</span> <span class="nv">cette</span> <span class="nv">gestion</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">irrigation la pluie du jour n</span><span class="s1">&#39;</span><span class="nv">est</span>

    <span class="nv">pas</span> <span class="nv">prise</span> <span class="nv">en</span> <span class="nv">compte</span>

    <span class="nv">N</span>.<span class="nv">B</span>.: <span class="nv">here</span>, <span class="nv">precision</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">taken</span> <span class="nv">into</span> <span class="nv">account</span> <span class="nv">anymore</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">int</span><span class="ss">)</span>: <span class="nv">Index</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">day</span> <span class="k">for</span> <span class="nv">which</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">state</span> <span class="nv">is</span> <span class="nv">being</span> <span class="nv">computed</span>.

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">xarray</span>.<span class="nv">Dataset</span><span class="ss">)</span>: <span class="nv">The</span> <span class="nv">input</span> <span class="nv">data</span>, <span class="nv">including</span> <span class="nv">the</span> <span class="nv">arrays</span> <span class="k">for</span> <span class="nv">irrigation</span> <span class="nv">and</span> <span class="nv">correctedIrrigation</span>.

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">dict</span><span class="ss">)</span>: <span class="nv">The</span> <span class="nv">parameters</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">ITK</span> <span class="nv">model</span>.

    <span class="nv">Returns</span>:

        <span class="nv">xarray</span>.<span class="nv">Dataset</span>: <span class="nv">The</span> <span class="nv">updated</span> <span class="nv">data</span>, <span class="nv">including</span> <span class="nv">the</span> <span class="nv">computed</span> <span class="nv">values</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">state</span>.

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">First</span>, <span class="nv">we</span> <span class="nv">store</span> <span class="nv">initial</span> <span class="nv">irrigation</span> <span class="nv">value</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">day</span> <span class="nv">in</span> <span class="nv">the</span>

    # <span class="nv">correctedIrrigation</span> <span class="nv">array</span>

    # <span class="o">!</span> <span class="nv">it</span> <span class="nv">does</span> <span class="nv">not</span> <span class="nv">seem</span> <span class="nv">definition</span> <span class="nv">and</span> <span class="nv">use</span> <span class="nv">of</span> <span class="nv">correctedIrrigation</span> <span class="nv">is</span> <span class="nv">useful</span>

    # <span class="o">!</span> <span class="nv">instead</span> <span class="nv">we</span> <span class="nv">will</span> <span class="nv">just</span> <span class="nv">use</span> <span class="nv">the</span> <span class="nv">already</span> <span class="nv">defined</span> <span class="nv">irrigation</span> <span class="nv">array</span>

    # <span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">correctedIrrigation</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :].<span class="nv">copy</span><span class="ss">(</span><span class="nv">deep</span><span class="o">=</span><span class="nv">True</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_irrigation_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_irrigation_tank_capacity</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">compute_daily_irrigation</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="evalrunoff">EvalRunOff</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">EvalRunOff</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramTypeSol</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the procedure PluieIrrig, of the original Pascal codes</p>
<p>bileau.pas, exmodules1.pas and exmodules2.pas</p>
<p>Notes from CB, 2014 :
On a regroupé avant la pluie et l'irrigation (a cause de l'effet Mulch)
si mulch on a enlevé l'eau captée
oN CALCUL SIMPLEMENT LE RUISSELLEMENT EN FN DE SEUILS</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramTypeSol</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">EvalRunOff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramTypeSol</span><span class="p">)</span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">Translated</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">procedure</span><span class="w"> </span><span class="n">PluieIrrig</span><span class="p">,</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="n">Pascal</span><span class="w"> </span><span class="n">codes</span><span class="w"></span>

<span class="w">    </span><span class="n">bileau</span><span class="p">.</span><span class="n">pas</span><span class="p">,</span><span class="w"> </span><span class="n">exmodules1</span><span class="p">.</span><span class="n">pas</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">exmodules2</span><span class="p">.</span><span class="n">pas</span><span class="w"></span>

<span class="w">    </span><span class="n">Notes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">CB</span><span class="p">,</span><span class="w"> </span><span class="mh">2014</span><span class="w"> </span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="n">On</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">regroupé</span><span class="w"> </span><span class="n">avant</span><span class="w"> </span><span class="n">la</span><span class="w"> </span><span class="n">pluie</span><span class="w"> </span><span class="n">et</span><span class="w"> </span><span class="n">l</span><span class="p">&#39;</span><span class="n">irrigation</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">cause</span><span class="w"> </span><span class="n">de</span><span class="w"> </span><span class="n">l</span><span class="p">&#39;</span><span class="n">effet</span><span class="w"> </span><span class="n">Mulch</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">si</span><span class="w"> </span><span class="n">mulch</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">enlevé</span><span class="w"> </span><span class="n">l</span><span class="p">&#39;</span><span class="n">eau</span><span class="w"> </span><span class="n">captée</span><span class="w"></span>

<span class="w">    </span><span class="n">oN</span><span class="w"> </span><span class="n">CALCUL</span><span class="w"> </span><span class="n">SIMPLEMENT</span><span class="w"> </span><span class="n">LE</span><span class="w"> </span><span class="n">RUISSELLEMENT</span><span class="w"> </span><span class="n">EN</span><span class="w"> </span><span class="n">FN</span><span class="w"> </span><span class="n">DE</span><span class="w"> </span><span class="n">SEUILS</span><span class="w"></span>

<span class="w">    </span><span class="nl">Args:</span><span class="w"></span>

<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">        </span><span class="n">paramTypeSol</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">    </span><span class="nl">Returns:</span><span class="w"></span>

<span class="w">        </span><span class="nl">_type_:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_available_water_after_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="evolrurcstr2">EvolRurCstr2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">EvolRurCstr2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the procedure PluieIrrig, of the original Pascal codes</p>
<p>bileau.pas</p>
<p>Notes from CB, 10/06/2015 :
Stress trop fort enracinement
Trop d'effet de stress en tout début de croissance :
1) la plantule a des réserves et favorise l'enracinement
2) dynamique spécifique sur le réservoir de surface
Cet effet stress sur l'enracinement ne s'applique que quand l'enracinement
est supérieur é la profondeur du réservoir de surface. Effet stres a un
effet sur la vitesse de prof d'enracinement au dessus d'un certain seuil de
cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur
la vitesse) La vitesse d'enracinement potentielle de la plante peut etre
bloque par manque d'eau en profondeur (Hum). La profondeur d'humectation est
convertie en quantite d'eau maximum equivalente</p>
<p>IN:
Vrac : mm (en mm/jour) : Vitesse racinaire journalière §§ Daily root depth
Hum : mm Quantité d'eau maximum jusqu'au front d'humectation §§ Maximum
water capacity to humectation front
StRuSurf : mm
RU : mm/m
RuSurf : mm/m</p>
<p>INOUT:
stRurMax : mm ==== ruRac
stRur : mm ==== stockRac</p>
<p>NB : on remet le nom de variables de CB plutôt que celles utilisées par MC dans le code Java</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">EvolRurCstr2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure PluieIrrig, of the original Pascal codes</span>

<span class="sd">    bileau.pas</span>

<span class="sd">    Notes from CB, 10/06/2015 :</span>

<span class="sd">    Stress trop fort enracinement</span>

<span class="sd">    Trop d&#39;effet de stress en tout début de croissance :</span>

<span class="sd">    1) la plantule a des réserves et favorise l&#39;enracinement</span>

<span class="sd">    2) dynamique spécifique sur le réservoir de surface</span>

<span class="sd">    Cet effet stress sur l&#39;enracinement ne s&#39;applique que quand l&#39;enracinement</span>

<span class="sd">    est supérieur é la profondeur du réservoir de surface. Effet stres a un</span>

<span class="sd">    effet sur la vitesse de prof d&#39;enracinement au dessus d&#39;un certain seuil de</span>

<span class="sd">    cstr (on augmente le cstr de 0.3 pour que sa contrainte soit affaiblie sur</span>

<span class="sd">    la vitesse) La vitesse d&#39;enracinement potentielle de la plante peut etre</span>

<span class="sd">    bloque par manque d&#39;eau en profondeur (Hum). La profondeur d&#39;humectation est</span>

<span class="sd">    convertie en quantite d&#39;eau maximum equivalente</span>

<span class="sd">    IN:</span>

<span class="sd">    Vrac : mm (en mm/jour) : Vitesse racinaire journalière §§ Daily root depth</span>

<span class="sd">    Hum : mm Quantité d&#39;eau maximum jusqu&#39;au front d&#39;humectation §§ Maximum</span>

<span class="sd">    water capacity to humectation front</span>

<span class="sd">    StRuSurf : mm</span>

<span class="sd">    RU : mm/m</span>

<span class="sd">    RuSurf : mm/m</span>

<span class="sd">    INOUT:</span>

<span class="sd">    stRurMax : mm ==== ruRac</span>

<span class="sd">    stRur : mm ==== stockRac</span>

<span class="sd">    NB : on remet le nom de variables de CB plutôt que celles utilisées par MC dans le code Java</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># ! dayvrac et deltarur reset à chaque itération ; on traine donc le j sur les autres variables</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initialize_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="initplotmc">InitPlotMc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">InitPlotMc</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">grid_width</span><span class="p">,</span>
    <span class="n">grid_height</span><span class="p">,</span>
    <span class="n">paramITK</span><span class="p">,</span>
    <span class="n">paramTypeSol</span><span class="p">,</span>
    <span class="n">duration</span>
<span class="p">)</span>
</code></pre></div>

<p>Initializes variables related to crop residues boimass (mulch) in the data</p>
<p>xarray dataset. This code has been adapted from the original InitPlotMc
procedure, Bileau.pas code. Comments with tab indentation are from the
original code. As the rain is the first variable to be initialized in the
data xarray dataset, its dimensions are used to initialize the other
variables.</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">InitPlotMc</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">grid_width</span><span class="p">,</span><span class="w"> </span><span class="n">grid_height</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">,</span><span class="w"> </span><span class="n">paramTypeSol</span><span class="p">,</span><span class="w"> </span><span class="n">duration</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initializes variables related to crop residues boimass (mulch) in the data</span>

<span class="sd">    xarray dataset. This code has been adapted from the original InitPlotMc</span>

<span class="sd">    procedure, Bileau.pas code. Comments with tab indentation are from the</span>

<span class="sd">    original code. As the rain is the first variable to be initialized in the</span>

<span class="sd">    data xarray dataset, its dimensions are used to initialize the other</span>

<span class="sd">    variables.</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Soil maximum water storage capacity (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Capacité maximale de la RU (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   StRurMax := Ru * ProfRacIni / 1000;</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;] = data[&quot;ru&quot;] * paramITK[&quot;profRacIni&quot;] / 1000</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;profRacIni&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stRurMax&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Soil maximum water storage capacity&quot;}</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Soil maximum water storage capacity&quot;</span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Maximum water capacity of surface tank (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Reserve utile de l&#39;horizon de surface (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   RuSurf := EpaisseurSurf / 1000 * Ru;</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;ruSurf&quot;] = data[&quot;epaisseurSurf&quot;] / 1000 * data[&quot;ru&quot;]</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;ruSurf&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;Maximum water capacity of surface tank&quot;}</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Maximum water capacity of surface tank&quot;</span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1"># ?</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   //    PfTranspi := EpaisseurSurf * HumPf;</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   //    StTot := StockIniSurf - PfTranspi/2 + StockIniProf;</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   StTot := StockIniSurf  + StockIniProf;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniSurf&quot;] + paramTypeSol[&quot;stockIniProf&quot;]))</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! modifié pour faire correspondre les résultats de simulation, à remettre en place pour un calcul correct dès que possible</span><span class="w"></span>

<span class="w">    </span><span class="c1"># data[&quot;stTot&quot;] = np.full((grid_width, grid_height, duration), (paramTypeSol[&quot;stockIniProf&quot;]))</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stTot to total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stTot&quot;] = data[&quot;stockIniProf&quot;]</span><span class="w"></span>

<span class="w">    </span><span class="c1">#//data[&quot;total_tank_stock&quot;] = data[&quot;stockIniProf&quot;]</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! coorecting total_tank_stock initialization as it did not have the time dimensions that are required as stock evolves through time</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;stockIniProf&quot;</span><span class="p">])[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stTot&quot;].attrs = {&quot;units&quot;: &quot;mm&quot;, &quot;long_name&quot;: &quot;?&quot;}</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;?&quot;</span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Soil maximal depth (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Profondeur maximale de sol (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   ProfRU := EpaisseurSurf + EpaisseurProf;</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurProf&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;epaisseurSurf&quot;</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;profRu&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Soil maximal depth&quot;</span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Maximum water capacity to humectation front (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Quantité d&#39;eau maximum jusqu&#39;au front d&#39;humectation (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   // modif 10/06/2015  resilience stock d&#39;eau</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   // Front d&#39;humectation egal a RuSurf trop de stress initial</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   //    Hum := max(StTot, StRurMax);</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   Hum := max(RuSurf, StRurMax);</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   // Hum mis a profRuSurf</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   Hum := max(StTot, Hum);</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">duration</span><span class="p">,</span><span class="w"> </span><span class="n">grid_width</span><span class="p">,</span><span class="w"> </span><span class="n">grid_height</span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span><span class="w"></span>

<span class="w">                </span><span class="c1">#// data[&quot;ruSurf&quot;],</span><span class="w"></span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span><span class="n">duration</span><span class="p">}),</span><span class="w"></span>

<span class="w">                </span><span class="c1">#! renaming stRurMax with root_tank_capacity</span><span class="w"></span>

<span class="w">                </span><span class="c1">#// data[&quot;stRurMax&quot;],</span><span class="w"></span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">            </span><span class="p">),</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming stTot with total_tank_stock</span><span class="w"></span>

<span class="w">            </span><span class="c1">#// data[&quot;stTot&quot;],</span><span class="w"></span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">        </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="p">))</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;units&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;mm&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;long_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Maximum water capacity to humectation front&quot;</span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Previous value for Maximum water capacity to humectation front (mm)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#  HumPrec := Hum;</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="c1"># ?</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   StRurPrec := 0;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># Previous value for stTot</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   StRurMaxPrec := 0;</span><span class="w"></span>

<span class="w">    </span><span class="c1">#   //modif 10/06/2015 resilience stock d&#39;eau</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stTot with total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaminog stRuPrec with total_tank_stock_previous_value</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stRuPrec&quot;] =  data[&quot;stTot&quot;]</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="remplimc">RempliMc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">RempliMc</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the procedure PluieIrrig, of the original Pascal codes</p>
<p>bileau.pas and exmodules2.pas</p>
<p>wrapper function,
updates water_gathered_by_mulch, eauDispo, and mulch_water_stock</p>
<p>For more details, it is advised to refer to the works of Eric Scopel (UR
AIDA), and the PhD dissertation of Fernando Maceina. </p>
<p>Notes from CB, 2014 :</p>
<p>Hypotheses :
A chaque pluie, on estime la quantité d'eau pour saturer le couvert. On la
retire à l'eauDispo (pluie + irrig). On calcule la capacité maximum de
stockage fonction de la biomasse et du taux de saturation rapportée en mm
(humSatMc en kg H2O/kg de biomasse).
La pluie est en mm :
1 mm = 1 litre d'eau / m2
1 mm = 10 tonnes d'eau / hectare = 10 000 kg/ha
La biomasse est en kg/ha pour se rapporter à la quantité de pluie captée en
mm Kg H2O/kg Kg/ha et kg/m2 on divise par 10 000 (pour 3000 kg/ha à humSat
2.8 kg H2O/kg on a un stockage max de 0.84 mm de pluie !?) Cette capacité à
capter est fonction du taux de couverture du sol calculé comme le LTR SurfMc
est spécifié en ha/t (0.39), on rapporte en ha/kg en divisant par 1000 On
retire alors les mm d'eau captées à la pluie incidente. Le ruisselement est
ensuite calculé avec l'effet de contrainte du mulch</p>
<p>group 10</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">RempliMc</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Translated</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">procedure</span> <span class="nv">PluieIrrig</span>, <span class="nv">of</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">Pascal</span> <span class="nv">codes</span>

    <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span> <span class="nv">exmodules2</span>.<span class="nv">pas</span>

    <span class="nv">wrapper</span> <span class="nv">function</span>,

    <span class="nv">updates</span> <span class="nv">water_gathered_by_mulch</span>, <span class="nv">eauDispo</span>, <span class="nv">and</span> <span class="nv">mulch_water_stock</span>

    <span class="k">For</span> <span class="nv">more</span> <span class="nv">details</span>, <span class="nv">it</span> <span class="nv">is</span> <span class="nv">advised</span> <span class="nv">to</span> <span class="nv">refer</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">works</span> <span class="nv">of</span> <span class="nv">Eric</span> <span class="nv">Scopel</span> <span class="ss">(</span><span class="nv">UR</span>

    <span class="nv">AIDA</span><span class="ss">)</span>, <span class="nv">and</span> <span class="nv">the</span> <span class="nv">PhD</span> <span class="nv">dissertation</span> <span class="nv">of</span> <span class="nv">Fernando</span> <span class="nv">Maceina</span>.

    <span class="nv">Notes</span> <span class="nv">from</span> <span class="nv">CB</span>, <span class="mi">2014</span> :

    <span class="nv">Hypotheses</span> :

    <span class="nv">A</span> <span class="nv">chaque</span> <span class="nv">pluie</span>, <span class="nv">on</span> <span class="nv">estime</span> <span class="nv">la</span> <span class="nv">quantit</span>é <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau pour saturer le couvert. On la</span>

    <span class="nv">retire</span> à <span class="nv">l</span><span class="s1">&#39;</span><span class="s">eauDispo (pluie + irrig). On calcule la capacité maximum de</span>

    <span class="nv">stockage</span> <span class="nv">fonction</span> <span class="nv">de</span> <span class="nv">la</span> <span class="nv">biomasse</span> <span class="nv">et</span> <span class="nv">du</span> <span class="nv">taux</span> <span class="nv">de</span> <span class="nv">saturation</span> <span class="nv">rapport</span>é<span class="nv">e</span> <span class="nv">en</span> <span class="nv">mm</span>

    <span class="ss">(</span><span class="nv">humSatMc</span> <span class="nv">en</span> <span class="nv">kg</span> <span class="nv">H2O</span><span class="o">/</span><span class="nv">kg</span> <span class="nv">de</span> <span class="nv">biomasse</span><span class="ss">)</span>.

    <span class="nv">La</span> <span class="nv">pluie</span> <span class="nv">est</span> <span class="nv">en</span> <span class="nv">mm</span> :

    <span class="mi">1</span> <span class="nv">mm</span> <span class="o">=</span> <span class="mi">1</span> <span class="nv">litre</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau / m2</span>

    <span class="mi">1</span> <span class="nv">mm</span> <span class="o">=</span> <span class="mi">10</span> <span class="nv">tonnes</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau / hectare = 10 000 kg/ha</span>

    <span class="nv">La</span> <span class="nv">biomasse</span> <span class="nv">est</span> <span class="nv">en</span> <span class="nv">kg</span><span class="o">/</span><span class="nv">ha</span> <span class="nv">pour</span> <span class="nv">se</span> <span class="nv">rapporter</span> à <span class="nv">la</span> <span class="nv">quantit</span>é <span class="nv">de</span> <span class="nv">pluie</span> <span class="nv">capt</span>é<span class="nv">e</span> <span class="nv">en</span>

    <span class="nv">mm</span> <span class="nv">Kg</span> <span class="nv">H2O</span><span class="o">/</span><span class="nv">kg</span> <span class="nv">Kg</span><span class="o">/</span><span class="nv">ha</span> <span class="nv">et</span> <span class="nv">kg</span><span class="o">/</span><span class="nv">m2</span> <span class="nv">on</span> <span class="nv">divise</span> <span class="nv">par</span> <span class="mi">10</span> <span class="mi">000</span> <span class="ss">(</span><span class="nv">pour</span> <span class="mi">3000</span> <span class="nv">kg</span><span class="o">/</span><span class="nv">ha</span> à <span class="nv">humSat</span>

    <span class="mi">2</span>.<span class="mi">8</span> <span class="nv">kg</span> <span class="nv">H2O</span><span class="o">/</span><span class="nv">kg</span> <span class="nv">on</span> <span class="nv">a</span> <span class="nv">un</span> <span class="nv">stockage</span> <span class="nv">max</span> <span class="nv">de</span> <span class="mi">0</span>.<span class="mi">84</span> <span class="nv">mm</span> <span class="nv">de</span> <span class="nv">pluie</span> <span class="o">!</span>?<span class="ss">)</span> <span class="nv">Cette</span> <span class="nv">capacit</span>é à

    <span class="nv">capter</span> <span class="nv">est</span> <span class="nv">fonction</span> <span class="nv">du</span> <span class="nv">taux</span> <span class="nv">de</span> <span class="nv">couverture</span> <span class="nv">du</span> <span class="nv">sol</span> <span class="nv">calcul</span>é <span class="nv">comme</span> <span class="nv">le</span> <span class="nv">LTR</span> <span class="nv">SurfMc</span>

    <span class="nv">est</span> <span class="nv">sp</span>é<span class="nv">cifi</span>é <span class="nv">en</span> <span class="nv">ha</span><span class="o">/</span><span class="nv">t</span> <span class="ss">(</span><span class="mi">0</span>.<span class="mi">39</span><span class="ss">)</span>, <span class="nv">on</span> <span class="nv">rapporte</span> <span class="nv">en</span> <span class="nv">ha</span><span class="o">/</span><span class="nv">kg</span> <span class="nv">en</span> <span class="nv">divisant</span> <span class="nv">par</span> <span class="mi">1000</span> <span class="nv">On</span>

    <span class="nv">retire</span> <span class="nv">alors</span> <span class="nv">les</span> <span class="nv">mm</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau captées à la pluie incidente. Le ruisselement est</span>

    <span class="nv">ensuite</span> <span class="nv">calcul</span>é <span class="nv">avec</span> <span class="nv">l</span><span class="s1">&#39;</span><span class="s">effet de contrainte du mulch</span>

    <span class="nv">group</span> <span class="mi">10</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_water_captured_by_mulch</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_available_water_after_mulch_filling</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">update_mulch_water_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="apply_evaporation_on_surface_tank_stock">apply_evaporation_on_surface_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">apply_evaporation_on_surface_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">apply_evaporation_on_surface_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    # <span class="nv">qte</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau evapore a consommer sur le reservoir de surface</span>

    # <span class="nv">group</span> <span class="mi">60</span>

    #<span class="o">!</span> <span class="nv">replacing</span> <span class="nv">stRuSurf</span> <span class="nv">by</span> <span class="nv">surface_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="calculate_total_water_availability">calculate_total_water_availability</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">calculate_total_water_availability</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Calculates the total water available for a day by adding the rainfall and</p>
<p>the irrigation.</p>
<p>The total water available is computed by adding the rainfall for the day,
which is stored in the "rain" array, and the total daily irrigation, which
is stored in the "irrigTotDay" array.</p>
<p>This calculation is performed to allow for subsequent calculations of the
mulch filling and runoff. The mulch layer is considered to be directly under
the rainfall and irrigation, which is represented by the "irrigTotDay"
value.</p>
<p>Translated from the procedure PluieIrrig, of the original Pascal codes
bileau.pas and exmodules2.pas</p>
<p>This function computes the total water available for the day, by summing the
rain and the irrigation.</p>
<p>Notes from CB, 2014 :
Hypotheses : Le mulch ajoute une couche direct sous la pluie et irrig, ici
irrigTotDay qui est l'irrigation observée ou calculée, d'où on regroupe les
deux avant calcul de remplissage du mulch et ensuite calcul du ruissellement.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>The index of the current day.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray.Dataset</td>
<td>The data set containing information about the rainfall, irrigation, and water availability.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xarray.Dataset</td>
<td>The data set with updated information about the total water availability for the current day.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">calculate_total_water_availability</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">Calculates</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">rainfall</span><span class="w"> </span><span class="k">and</span><span class="w"></span>

<span class="w">    </span><span class="n">the</span><span class="w"> </span><span class="n">irrigation</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">The</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">computed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">rainfall</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">day</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">which</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">stored</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="s">&quot;rain&quot;</span><span class="w"> </span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">daily</span><span class="w"> </span><span class="n">irrigation</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"></span>

<span class="w">    </span><span class="n">is</span><span class="w"> </span><span class="n">stored</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="s">&quot;irrigTotDay&quot;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">This</span><span class="w"> </span><span class="n">calculation</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">performed</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">allow</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">subsequent</span><span class="w"> </span><span class="n">calculations</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">mulch</span><span class="w"> </span><span class="n">filling</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">runoff</span><span class="p">.</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">mulch</span><span class="w"> </span><span class="n">layer</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">considered</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="n">under</span><span class="w"></span>

<span class="w">    </span><span class="n">the</span><span class="w"> </span><span class="n">rainfall</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">irrigation</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">represented</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="s">&quot;irrigTotDay&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">value</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">Translated</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">procedure</span><span class="w"> </span><span class="n">PluieIrrig</span><span class="p">,</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="n">Pascal</span><span class="w"> </span><span class="n">codes</span><span class="w"></span>

<span class="w">    </span><span class="n">bileau</span><span class="p">.</span><span class="n">pas</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">exmodules2</span><span class="p">.</span><span class="n">pas</span><span class="w"></span>

<span class="w">    </span><span class="n">This</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">computes</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">day</span><span class="p">,</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">summing</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">rain</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">irrigation</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">Notes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">CB</span><span class="p">,</span><span class="w"> </span><span class="mh">2014</span><span class="w"> </span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="n">Hypotheses</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Le</span><span class="w"> </span><span class="n">mulch</span><span class="w"> </span><span class="n">ajoute</span><span class="w"> </span><span class="n">une</span><span class="w"> </span><span class="n">couche</span><span class="w"> </span><span class="n">direct</span><span class="w"> </span><span class="n">sous</span><span class="w"> </span><span class="n">la</span><span class="w"> </span><span class="n">pluie</span><span class="w"> </span><span class="n">et</span><span class="w"> </span><span class="n">irrig</span><span class="p">,</span><span class="w"> </span><span class="n">ici</span><span class="w"></span>

<span class="w">    </span><span class="n">irrigTotDay</span><span class="w"> </span><span class="n">qui</span><span class="w"> </span><span class="n">est</span><span class="w"> </span><span class="n">l</span><span class="p">&#39;</span><span class="n">irrigation</span><span class="w"> </span><span class="n">observée</span><span class="w"> </span><span class="n">ou</span><span class="w"> </span><span class="n">calculée</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">&#39;</span><span class="n">où</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">regroupe</span><span class="w"> </span><span class="n">les</span><span class="w"></span>

<span class="w">    </span><span class="n">deux</span><span class="w"> </span><span class="n">avant</span><span class="w"> </span><span class="n">calcul</span><span class="w"> </span><span class="n">de</span><span class="w"> </span><span class="n">remplissage</span><span class="w"> </span><span class="n">du</span><span class="w"> </span><span class="n">mulch</span><span class="w"> </span><span class="n">et</span><span class="w"> </span><span class="n">ensuite</span><span class="w"> </span><span class="n">calcul</span><span class="w"> </span><span class="n">du</span><span class="w"> </span><span class="n">ruissellement</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="nl">Args:</span><span class="w"></span>

<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">day</span><span class="p">.</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="n">xarray</span><span class="p">.</span><span class="n">Dataset</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">containing</span><span class="w"> </span><span class="n">information</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">rainfall</span><span class="p">,</span><span class="w"> </span><span class="n">irrigation</span><span class="p">,</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">availability</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="nl">Returns:</span><span class="w"></span>

<span class="w">        </span><span class="n">xarray</span><span class="p">.</span><span class="nl">Dataset:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">updated</span><span class="w"> </span><span class="n">information</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">availability</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">day</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;irrigTotDay&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="compute_daily_irrigation">compute_daily_irrigation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_daily_irrigation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>Computes the Total Daily Irrigation (mm)</p>
<p>If we are in the automatic irrigation mode, and between phases 0 and 6, and if
the filling of the irrigation tank is below the target filling value
(irrigAutoTarget, decimal percentage), we first compute 90% of the difference
between the current volume of water in the irrigation tank (irrigation_tank_stock)
and the total capacity of the irrigation tank (irrigation_tank_capacity), 
bounded by a minimum of 0 and a maximum of maxIrrig. 
This computed value represents the amount of water to be added to the irrigation tank.
If the above conditions are not met, the computed value is 0.</p>
<p>Then, we calculate the total irrigation of the day by summing the
estimated irrigation need (irrigation) with the previous irrigation history of the day 
(irrigTotDay).</p>
<p>irrigTotDay : "total irrigation of the day, both from the irrigation history
and the estimated irrigation need" (mm) // irrigation_total_day</p>
<p>if we are in automatic irrigation mode, and between phases 0 and 6, and if
the filling of the irrigation tank is below the target filling value
(irrigAutoTarget, decimal percentage), we first compute 90% of the difference
between irrigation_tank_stock and irrigation_tank_capacity (that is to say,
90% of the volume needed to fill the irrigation tank), bounded by a minimum
of 0 and a maximum of maxIrrig. Else, the computed value is 0.</p>
<p>Then, we calculate the total irrigation of the day by summing the
estimated irrigation need with the irrigation history of the day.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>None</td>
<td>An integer representing the current day.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>None</td>
<td>A xarray dataset.</td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td>None</td>
<td>A dictionary of parameters.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>A xarray dataset with the updated irrigationTotDay field.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">compute_daily_irrigation</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Computes</span> <span class="nv">the</span> <span class="nv">Total</span> <span class="nv">Daily</span> <span class="nv">Irrigation</span> <span class="ss">(</span><span class="nv">mm</span><span class="ss">)</span>

    <span class="k">If</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">automatic</span> <span class="nv">irrigation</span> <span class="nv">mode</span>, <span class="nv">and</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">0</span> <span class="nv">and</span> <span class="mi">6</span>, <span class="nv">and</span> <span class="k">if</span>

    <span class="nv">the</span> <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">is</span> <span class="nv">below</span> <span class="nv">the</span> <span class="nv">target</span> <span class="nv">filling</span> <span class="nv">value</span>

    <span class="ss">(</span><span class="nv">irrigAutoTarget</span>, <span class="nv">decimal</span> <span class="nv">percentage</span><span class="ss">)</span>, <span class="nv">we</span> <span class="nv">first</span> <span class="nv">compute</span> <span class="mi">90</span><span class="o">%</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">difference</span>

    <span class="nv">between</span> <span class="nv">the</span> <span class="nv">current</span> <span class="nv">volume</span> <span class="nv">of</span> <span class="nv">water</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="ss">(</span><span class="nv">irrigation_tank_stock</span><span class="ss">)</span>

    <span class="nv">and</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="ss">(</span><span class="nv">irrigation_tank_capacity</span><span class="ss">)</span>,

    <span class="nv">bounded</span> <span class="nv">by</span> <span class="nv">a</span> <span class="nv">minimum</span> <span class="nv">of</span> <span class="mi">0</span> <span class="nv">and</span> <span class="nv">a</span> <span class="nv">maximum</span> <span class="nv">of</span> <span class="nv">maxIrrig</span>.

    <span class="nv">This</span> <span class="nv">computed</span> <span class="nv">value</span> <span class="nv">represents</span> <span class="nv">the</span> <span class="nv">amount</span> <span class="nv">of</span> <span class="nv">water</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">added</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span>.

    <span class="k">If</span> <span class="nv">the</span> <span class="nv">above</span> <span class="nv">conditions</span> <span class="nv">are</span> <span class="nv">not</span> <span class="nv">met</span>, <span class="nv">the</span> <span class="nv">computed</span> <span class="nv">value</span> <span class="nv">is</span> <span class="mi">0</span>.

    <span class="k">Then</span>, <span class="nv">we</span> <span class="nv">calculate</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">irrigation</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">day</span> <span class="nv">by</span> <span class="nv">summing</span> <span class="nv">the</span>

    <span class="nv">estimated</span> <span class="nv">irrigation</span> <span class="nv">need</span> <span class="ss">(</span><span class="nv">irrigation</span><span class="ss">)</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">previous</span> <span class="nv">irrigation</span> <span class="nv">history</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">day</span>

    <span class="ss">(</span><span class="nv">irrigTotDay</span><span class="ss">)</span>.

    <span class="nv">irrigTotDay</span> : <span class="s2">&quot;</span><span class="s">total irrigation of the day, both from the irrigation history</span>

    <span class="nv">and</span> <span class="nv">the</span> <span class="nv">estimated</span> <span class="nv">irrigation</span> <span class="nv">need</span><span class="s2">&quot;</span><span class="s"> (mm) // irrigation_total_day</span>

    <span class="k">if</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">in</span> <span class="nv">automatic</span> <span class="nv">irrigation</span> <span class="nv">mode</span>, <span class="nv">and</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">0</span> <span class="nv">and</span> <span class="mi">6</span>, <span class="nv">and</span> <span class="k">if</span>

    <span class="nv">the</span> <span class="nv">filling</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">is</span> <span class="nv">below</span> <span class="nv">the</span> <span class="nv">target</span> <span class="nv">filling</span> <span class="nv">value</span>

    <span class="ss">(</span><span class="nv">irrigAutoTarget</span>, <span class="nv">decimal</span> <span class="nv">percentage</span><span class="ss">)</span>, <span class="nv">we</span> <span class="nv">first</span> <span class="nv">compute</span> <span class="mi">90</span><span class="o">%</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">difference</span>

    <span class="nv">between</span> <span class="nv">irrigation_tank_stock</span> <span class="nv">and</span> <span class="nv">irrigation_tank_capacity</span> <span class="ss">(</span><span class="nv">that</span> <span class="nv">is</span> <span class="nv">to</span> <span class="nv">say</span>,

    <span class="mi">90</span><span class="o">%</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">volume</span> <span class="nv">needed</span> <span class="nv">to</span> <span class="nv">fill</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span><span class="ss">)</span>, <span class="nv">bounded</span> <span class="nv">by</span> <span class="nv">a</span> <span class="nv">minimum</span>

    <span class="nv">of</span> <span class="mi">0</span> <span class="nv">and</span> <span class="nv">a</span> <span class="nv">maximum</span> <span class="nv">of</span> <span class="nv">maxIrrig</span>. <span class="k">Else</span>, <span class="nv">the</span> <span class="nv">computed</span> <span class="nv">value</span> <span class="nv">is</span> <span class="mi">0</span>.

    <span class="k">Then</span>, <span class="nv">we</span> <span class="nv">calculate</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">irrigation</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">day</span> <span class="nv">by</span> <span class="nv">summing</span> <span class="nv">the</span>

    <span class="nv">estimated</span> <span class="nv">irrigation</span> <span class="nv">need</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">history</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">day</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span>: <span class="nv">An</span> <span class="nv">integer</span> <span class="nv">representing</span> <span class="nv">the</span> <span class="nv">current</span> <span class="nv">day</span>.

        <span class="nv">data</span>: <span class="nv">A</span> <span class="nv">xarray</span> <span class="nv">dataset</span>.

        <span class="nv">paramITK</span>: <span class="nv">A</span> <span class="nv">dictionary</span> <span class="nv">of</span> <span class="nv">parameters</span>.

    <span class="nv">Returns</span>:

        <span class="nv">data</span>: <span class="nv">A</span> <span class="nv">xarray</span> <span class="nv">dataset</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">updated</span> <span class="nv">irrigationTotDay</span> <span class="nv">field</span>.

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stockIrr</span> <span class="nv">with</span> <span class="nv">irrigation_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruIrr</span> <span class="nv">with</span> <span class="nv">irrigation_tank_capacity</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigAuto</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">==</span> <span class="nv">True</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">&lt;</span> <span class="mi">6</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">/</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] \

            <span class="o">&lt;</span> <span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">irrigAutoTarget</span><span class="s2">&quot;</span>]<span class="ss">)</span>

    # <span class="nv">group</span> <span class="mi">3</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigTotDay</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">=</span> <span class="nv">xr</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span>

            <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

                <span class="mi">0</span>,

                # <span class="o">!</span> <span class="nv">replacing</span> <span class="nv">correctedIrrigation</span> <span class="nv">by</span> <span class="nv">irrigation</span>

                #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stockIrr</span> <span class="nv">with</span> <span class="nv">irrigation_tank_stock</span>

                #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruIrr</span> <span class="nv">with</span> <span class="nv">irrigation_tank_capacity</span>

                # <span class="o">//</span> <span class="ss">((</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruIrr</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stockIrr</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]<span class="ss">)</span> <span class="o">*</span> <span class="mi">0</span>.<span class="mi">9</span><span class="ss">)</span> <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">correctedIrrigation</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]<span class="ss">)</span>,

                <span class="ss">((</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]<span class="ss">)</span> <span class="o">*</span> <span class="mi">0</span>.<span class="mi">9</span><span class="ss">)</span> \

                    <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]

                <span class="ss">)</span>,

            <span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">maxIrrig</span><span class="s2">&quot;</span>]

        <span class="ss">)</span>,

        <span class="mi">0</span>,

    <span class="ss">)</span>

    # <span class="nv">group</span> <span class="mi">4</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigTotDay</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">=</span> <span class="ss">(</span>

        # <span class="o">!</span> <span class="nv">replacing</span> <span class="nv">correctedIrrigation</span> <span class="nv">by</span> <span class="nv">irrigation</span>

        # <span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">correctedIrrigation</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigTotDay</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]<span class="ss">)</span>.<span class="nv">copy</span><span class="ss">()</span>

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigTotDay</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="compute_evapotranspiration">compute_evapotranspiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_evapotranspiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">compute_evapotranspiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_fesw</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_kce</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_soil_potential_evaporation</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_soil_evaporation</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_FEMcW_and_update_mulch_water_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_ftsw</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_kcp</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_potential_plant_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_kcTot</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_pFact</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_cstr</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span> <span class="o">=</span> <span class="nv">estimate_plant_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="condition_end_of_cycle">condition_end_of_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">condition_end_of_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Returns conditions needed to apply functions related to end of cycle.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">condition_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Returns</span> <span class="nv">conditions</span> <span class="nv">needed</span> <span class="nv">to</span> <span class="nv">apply</span> <span class="nv">functions</span> <span class="nv">related</span> <span class="nv">to</span> <span class="k">end</span> <span class="nv">of</span> <span class="nv">cycle</span>.

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">7</span><span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">condition</span>
</code></pre></div>

</details>
<h3 id="condition_total_tank_overflow">condition_total_tank_overflow</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">condition_total_tank_overflow</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p><em>summary</em></p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">condition_total_tank_overflow</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span><span class="s">_summary_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">condition</span>
</code></pre></div>

</details>
<h3 id="conditions_remplires">conditions_rempliRes</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">conditions_rempliRes</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p><em>summary</em></p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">conditions_rempliRes</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span><span class="s">_summary_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuVar</span> <span class="nv">with</span> <span class="nv">delta_total_tank_stock</span>

    #<span class="o">//</span><span class="nv">condition_1</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">condition_1</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMaxPrec</span> <span class="nv">to</span> <span class="nv">root_tank_capacity_previous_season</span>

    #<span class="o">//</span> <span class="nv">condition_2</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMaxPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">condition_2</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity_previous_season</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    #<span class="o">!</span> <span class="nv">we</span> <span class="nv">replace</span> <span class="nv">humPrec</span> <span class="nv">by</span> <span class="nv">hum</span> <span class="nv">with</span> <span class="nv">indice</span> <span class="nv">j</span><span class="o">-</span><span class="mi">1</span>

    #<span class="o">//</span> <span class="nv">condition_3</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">humPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">condition_3</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">humPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">condition_1</span>, <span class="nv">condition_2</span>, <span class="nv">condition_3</span>
</code></pre></div>

</details>
<h3 id="estimate_femcw_and_update_mulch_water_stock">estimate_FEMcW_and_update_mulch_water_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_FEMcW_and_update_mulch_water_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function calculates the fraction of evaporable water from the mulch</p>
<p>(FEMcW).</p>
<p>If the mulch water stock is greater than 0, then we compute FEMcW, which we
consider to be equal to the filling ratio of the mulch water capacity. We
then update the mulch water stock by removing the water height equivalent to
the climate forcing demand, modulated by FEMcW and the plant cover (ltr).</p>
<p>This function is adapted from the procedure EvapMC, from bileau.pas and
exmodules 2.pas file from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_FEMcW_and_update_mulch_water_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">calculates</span> <span class="nv">the</span> <span class="nv">fraction</span> <span class="nv">of</span> <span class="nv">evaporable</span> <span class="nv">water</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">mulch</span>

    <span class="ss">(</span><span class="nv">FEMcW</span><span class="ss">)</span>.

    <span class="k">If</span> <span class="nv">the</span> <span class="nv">mulch</span> <span class="nv">water</span> <span class="nv">stock</span> <span class="nv">is</span> <span class="nv">greater</span> <span class="nv">than</span> <span class="mi">0</span>, <span class="k">then</span> <span class="nv">we</span> <span class="nv">compute</span> <span class="nv">FEMcW</span>, <span class="nv">which</span> <span class="nv">we</span>

    <span class="nv">consider</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">equal</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">filling</span> <span class="nv">ratio</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">mulch</span> <span class="nv">water</span> <span class="nv">capacity</span>. <span class="nv">We</span>

    <span class="k">then</span> <span class="nv">update</span> <span class="nv">the</span> <span class="nv">mulch</span> <span class="nv">water</span> <span class="nv">stock</span> <span class="nv">by</span> <span class="nv">removing</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">height</span> <span class="nv">equivalent</span> <span class="nv">to</span>

    <span class="nv">the</span> <span class="nv">climate</span> <span class="nv">forcing</span> <span class="nv">demand</span>, <span class="nv">modulated</span> <span class="nv">by</span> <span class="nv">FEMcW</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">plant</span> <span class="nv">cover</span> <span class="ss">(</span><span class="nv">ltr</span><span class="ss">)</span>.

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">is</span> <span class="nv">adapted</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">procedure</span> <span class="nv">EvapMC</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span>

    <span class="nv">exmodules</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">file</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">45</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">FEMcW</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        #<span class="o">!</span> <span class="nv">replacing</span> <span class="nv">stockMc</span> <span class="nv">with</span> <span class="nv">mulch_water_stock</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stockMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">mulch_water_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span>,

        #<span class="o">!</span> <span class="nv">inverting</span> <span class="nv">the</span> <span class="nv">fraction</span> <span class="nv">to</span> <span class="nv">get</span> <span class="nv">stock</span> <span class="nv">over</span> <span class="nv">capacity</span>, <span class="nv">and</span> <span class="nv">not</span> <span class="nv">the</span> <span class="nv">other</span> <span class="nv">way</span> <span class="nv">round</span>

        #<span class="o">//</span> <span class="ss">(</span><span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">humSatMc</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">biomMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="mi">0</span>.<span class="mi">001</span><span class="ss">)</span> <span class="o">/</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stockMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">mulch_water_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="ss">(</span><span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">humSatMc</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">biomMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="mi">1000</span><span class="ss">)</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">FEMcW</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    # <span class="nv">group</span> <span class="mi">46</span>

    #<span class="o">!</span> <span class="nv">replacing</span> <span class="nv">stockMc</span> <span class="nv">with</span> <span class="nv">mulch_water_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stockMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">mulch_water_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

        <span class="mi">0</span>,

        #<span class="o">!</span> <span class="nv">removing</span> <span class="nv">the</span> <span class="nv">power</span> <span class="nv">of</span> <span class="mi">2</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">equation</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stockMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ltr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ET0</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">FEMcW</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">**</span><span class="mi">2</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">mulch_water_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ltr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ET0</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">FEMcW</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">**</span><span class="mi">2</span><span class="ss">)</span>,

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_cstr">estimate_cstr</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_cstr</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the water stress coefficient cstr.</p>
<p>It uses ftsw and pFact. cstr is bounded in [0, 1].</p>
<p>This function is based on the CstrPFactor procedure, from bileau.pas,
exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_cstr</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">stress</span> <span class="nv">coefficient</span> <span class="nv">cstr</span>.

    <span class="nv">It</span> <span class="nv">uses</span> <span class="nv">ftsw</span> <span class="nv">and</span> <span class="nv">pFact</span>. <span class="nv">cstr</span> <span class="nv">is</span> <span class="nv">bounded</span> <span class="nv">in</span> [<span class="mi">0</span>, <span class="mi">1</span>].

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">CstrPFactor</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span>,

    <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span>, <span class="nv">risocas</span>.<span class="nv">pas</span> <span class="nv">files</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="nv">group</span> <span class="mi">55</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">cstr</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">((</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ftsw</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="ss">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">pFact</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">))</span>, <span class="mi">1</span><span class="ss">)</span>

    # <span class="nv">group</span> <span class="mi">56</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">cstr</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">cstr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_delta_root_tank_capacity">estimate_delta_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_delta_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Updates daily root capacity variation (delta_root_tank_capacity, in mm</p>
<p>water/day) based on the current phase of the plant, the daily root growth
speed, and the drought stress coefficient.</p>
<p>The daily root capacity variation is calculated as the product of soil water
storage capacity (ru), the daily root growth speed (vRac), and a coefficient
(cstr + 0.3). This coefficient is capped at 1.0.</p>
<p>The daily root capacity variation is modulated by drought stress only when the
root tank capacity is greater than the surface tank capacity and the current
phase is strictly greater than 1 and at the day of phase change. If the root
tank capacity is lower than the surface tank capacity or if the current phase is
1 or below or not at the day of phase change, the daily root capacity variation
remains unchanged. </p>
<p>The drought stress coefficient, cstr, measures the level of drought stress with
0 being full stress. The root growth speed is assumed to still occur during a
drought stress as a matter of survival, with a certain level of tolerance given
by the [0.3, 1] bound of the coefficient.</p>
<p>Updating delta_root_tank_capacity / dayVrac (daily variation in water height
accessible to roots, mm water/day) :</p>
<p>At the day of phase change, for phases strictly above 1, and for which
root_tank_capacity is greater than surface_tank_capacity, the variation of
root tank capacity delta_root_tank_capacity is computed as the product of
soil water storage capacity (ru, mm/m), the daily root growth speed (vRac,
mm/day), and a coefficient, the latter being equal to the drought stress
coefficient (cstr) plus 0.3, with a maximum bound of 1.0. </p>
<p>That is to say, when the root_tank_capacity is greater than
surface_tank_capacity, the root growth speed is modulated by drought stress.
When root_tank_capacity is lower than surface_tank_capacity, the root growth
speed is not modulated by drought stress.</p>
<p>When we are not at the day of phase change, or if we are at phase of 1 and
below, delta_root_change_capacity is unchanged.</p>
<p>cstr is the drought stress coefficient, with a value of 0 meaning full stress.</p>
<p>Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian
BARON, this is based on the hypothesis that during a drought stress (cstr =
0), the plant will still grow roots as a matter of survival. Furthermore,
using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr
interval, there is no effect of drought stress on the root growth speed,
allowing for a certain level of tolerance of the plant.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>The current iteration step of the process.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray.Dataset</td>
<td>The input data containing relevant information.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>xarray.Dataset</td>
<td>The updated input data with the daily root capacity variation calculated and stored.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_delta_root_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updates daily root capacity variation (delta_root_tank_capacity, in mm</span>

<span class="sd">    water/day) based on the current phase of the plant, the daily root growth</span>

<span class="sd">    speed, and the drought stress coefficient.</span>

<span class="sd">    The daily root capacity variation is calculated as the product of soil water</span>

<span class="sd">    storage capacity (ru), the daily root growth speed (vRac), and a coefficient</span>

<span class="sd">    (cstr + 0.3). This coefficient is capped at 1.0.</span>

<span class="sd">    The daily root capacity variation is modulated by drought stress only when the</span>

<span class="sd">    root tank capacity is greater than the surface tank capacity and the current</span>

<span class="sd">    phase is strictly greater than 1 and at the day of phase change. If the root</span>

<span class="sd">    tank capacity is lower than the surface tank capacity or if the current phase is</span>

<span class="sd">    1 or below or not at the day of phase change, the daily root capacity variation</span>

<span class="sd">    remains unchanged.</span>

<span class="sd">    The drought stress coefficient, cstr, measures the level of drought stress with</span>

<span class="sd">    0 being full stress. The root growth speed is assumed to still occur during a</span>

<span class="sd">    drought stress as a matter of survival, with a certain level of tolerance given</span>

<span class="sd">    by the [0.3, 1] bound of the coefficient.</span>

<span class="sd">    Updating delta_root_tank_capacity / dayVrac (daily variation in water height</span>

<span class="sd">    accessible to roots, mm water/day) :</span>

<span class="sd">    At the day of phase change, for phases strictly above 1, and for which</span>

<span class="sd">    root_tank_capacity is greater than surface_tank_capacity, the variation of</span>

<span class="sd">    root tank capacity delta_root_tank_capacity is computed as the product of</span>

<span class="sd">    soil water storage capacity (ru, mm/m), the daily root growth speed (vRac,</span>

<span class="sd">    mm/day), and a coefficient, the latter being equal to the drought stress</span>

<span class="sd">    coefficient (cstr) plus 0.3, with a maximum bound of 1.0.</span>

<span class="sd">    That is to say, when the root_tank_capacity is greater than</span>

<span class="sd">    surface_tank_capacity, the root growth speed is modulated by drought stress.</span>

<span class="sd">    When root_tank_capacity is lower than surface_tank_capacity, the root growth</span>

<span class="sd">    speed is not modulated by drought stress.</span>

<span class="sd">    When we are not at the day of phase change, or if we are at phase of 1 and</span>

<span class="sd">    below, delta_root_change_capacity is unchanged.</span>

<span class="sd">    cstr is the drought stress coefficient, with a value of 0 meaning full stress.</span>

<span class="sd">    Why is delta_root_tank_capacity bounded in [0.3, 1] ? According to Chriatian</span>

<span class="sd">    BARON, this is based on the hypothesis that during a drought stress (cstr =</span>

<span class="sd">    0), the plant will still grow roots as a matter of survival. Furthermore,</span>

<span class="sd">    using the [0.3, 1] bound is a way to tell that in the [0.7, 1] cstr</span>

<span class="sd">    interval, there is no effect of drought stress on the root growth speed,</span>

<span class="sd">    allowing for a certain level of tolerance of the plant.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): The current iteration step of the process.</span>

<span class="sd">        data (xarray.Dataset): The input data containing relevant information.</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray.Dataset: The updated input data with the daily root capacity variation calculated and stored.</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 15</span><span class="w"></span>

<span class="w">    </span><span class="c1"># ! simplified conditions</span><span class="w"></span>

<span class="w">    </span><span class="c1"># // condition = (data[&quot;numPhase&quot;][j,:,:] &gt; 0) &amp; \</span><span class="w"></span>

<span class="w">    </span><span class="c1"># //       np.invert((data[&quot;numPhase&quot;][j,:,:] == 1) &amp; (data[&quot;changePhase&quot;][j,:,:] == 1))</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;changePhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming dayVrac to delta_root_tank_capacity</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;dayVrac&quot;][j,:,:] = np.where(</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming stRurMax to root_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming ruSurf to surface_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="c1">#// (data[&quot;stRurMax&quot;][j,:,:] &gt; data[&quot;ruSurf&quot;][j,:,:]),</span><span class="w"></span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span><span class="w"></span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cstr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.3</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;vRac&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ru&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">        </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="c1">#// data[&quot;dayVrac&quot;][j,:,:],</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_root_tank_capacity&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="estimate_fesw">estimate_fesw</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_fesw</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the fraction of evaporable soil water (fesw, mm).</p>
<p>fesw is defined as the ratio of water stock in the surface tank over 110% of
the surface tank capacity.</p>
<p>It is adapted from the EvalFESW procedure, from bileau.pas and
bhytypeFAO.pas files from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_fesw</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">the</span> <span class="nv">fraction</span> <span class="nv">of</span> <span class="nv">evaporable</span> <span class="nv">soil</span> <span class="nv">water</span> <span class="ss">(</span><span class="nv">fesw</span>, <span class="nv">mm</span><span class="ss">)</span>.

    <span class="nv">fesw</span> <span class="nv">is</span> <span class="nv">defined</span> <span class="nv">as</span> <span class="nv">the</span> <span class="nv">ratio</span> <span class="nv">of</span> <span class="nv">water</span> <span class="nv">stock</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">over</span> <span class="mi">110</span><span class="o">%</span> <span class="nv">of</span>

    <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">capacity</span>.

    <span class="nv">It</span> <span class="nv">is</span> <span class="nv">adapted</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">EvalFESW</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span>

    <span class="nv">bhytypeFAO</span>.<span class="nv">pas</span> <span class="nv">files</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurf</span> <span class="nv">to</span> <span class="nv">surface_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">fesw</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="mi">10</span><span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">fesw</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>] <span class="o">+</span> <span class="mi">0</span>.<span class="mi">1</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_ftsw">estimate_ftsw</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_ftsw</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the fraction of evaporable soil water (fesw) from</p>
<p>the root reservoir. </p>
<p>It is based on the EvalFTSW procedure, from the bileau.pas, exmodules 1 &amp;
2.pas, risocas.pas, riz.pas files from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_ftsw</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">the</span> <span class="nv">fraction</span> <span class="nv">of</span> <span class="nv">evaporable</span> <span class="nv">soil</span> <span class="nv">water</span> <span class="ss">(</span><span class="nv">fesw</span><span class="ss">)</span> <span class="nv">from</span>

    <span class="nv">the</span> <span class="nv">root</span> <span class="nv">reservoir</span>.

    <span class="nv">It</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">EvalFTSW</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">bileau</span>.<span class="nv">pas</span>, <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span>

    <span class="mi">2</span>.<span class="nv">pas</span>, <span class="nv">risocas</span>.<span class="nv">pas</span>, <span class="nv">riz</span>.<span class="nv">pas</span> <span class="nv">files</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ftsw</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="mi">0</span>,

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_kctot">estimate_kcTot</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_kcTot</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the total kc coefficient.</p>
<p>Computation is based on the kcp (transpiration coefficient) and kce
(evaporation from the soil) coefficients. Where the crop coefficient is 0
(meaning that there was no emergence yet), kcTot takes the value of kce.</p>
<p>This function is based on the EvalKcTot procedure, from the bileau.pas and
exmodules 1 &amp; 2.pas files, from the original FORTRAN code.</p>
<h1 id="note-code-has-been-modified-to-match-the-original-sarra-h-behavior">! Note : code has been modified to match the original SARRA-H behavior.</h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_kcTot</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">kc</span> <span class="nv">coefficient</span>.

    <span class="nv">Computation</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">kcp</span> <span class="ss">(</span><span class="nv">transpiration</span> <span class="nv">coefficient</span><span class="ss">)</span> <span class="nv">and</span> <span class="nv">kce</span>

    <span class="ss">(</span><span class="nv">evaporation</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">soil</span><span class="ss">)</span> <span class="nv">coefficients</span>. <span class="nv">Where</span> <span class="nv">the</span> <span class="nv">crop</span> <span class="nv">coefficient</span> <span class="nv">is</span> <span class="mi">0</span>

    <span class="ss">(</span><span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">there</span> <span class="nv">was</span> <span class="nv">no</span> <span class="nv">emergence</span> <span class="nv">yet</span><span class="ss">)</span>, <span class="nv">kcTot</span> <span class="nv">takes</span> <span class="nv">the</span> <span class="nv">value</span> <span class="nv">of</span> <span class="nv">kce</span>.

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">EvalKcTot</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span>

    <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">files</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    #<span class="o">!</span> <span class="nv">Note</span> : <span class="nv">code</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">modified</span> <span class="nv">to</span> <span class="nv">match</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">SARRA</span><span class="o">-</span><span class="nv">H</span> <span class="nv">behavior</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">added</span> <span class="nv">a</span> <span class="nv">condition</span> <span class="nv">on</span> <span class="mi">19</span><span class="o">/</span><span class="mi">08</span><span class="o">/</span><span class="mi">22</span> <span class="nv">to</span> <span class="nv">match</span> <span class="nv">SARRA</span><span class="o">-</span><span class="nv">H</span> <span class="nv">original</span> <span class="nv">behavior</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kcTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kcp</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">0</span>.<span class="mi">0</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kce</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kce</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kcp</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_kce">estimate_kce</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_kce</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the coefficient of evaporation from the soil (kce).</p>
<p>This approach takes into consideration three factors acting on limitation of
kce :</p>
<p>1) ltr : plant cover, 1 = no plant cover, 0 = full plant cover
2) Mulch - permanent covering effect : we consider a value of 1.0 for no
covering, and 0.0 is full covering with plastic sheet ; this mulch parameter
has been used in previous versions of the model where evolution of mulch
biomass was not explicitely taken into consideration, can be used in the
case of crops with self-mulching phenomena, where a standard mulch parameter
value of 0.7 can be applied.
3) Mulch - evolutive covering effect BiomMc : biomass of mulch  </p>
<p>This function has been adapted from EvalKceMC procedure, bileau.pas and
exmodules 2.pas from the original FORTRAN code. In its spirit, it looks like
it has been adapted from the dual crop coefficient from the FAO56 paper. But
this is still to confirm on a point of view of the history of the model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_kce</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">the</span> <span class="nv">coefficient</span> <span class="nv">of</span> <span class="nv">evaporation</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">soil</span> <span class="ss">(</span><span class="nv">kce</span><span class="ss">)</span>.

    <span class="nv">This</span> <span class="nv">approach</span> <span class="nv">takes</span> <span class="nv">into</span> <span class="nv">consideration</span> <span class="nv">three</span> <span class="nv">factors</span> <span class="nv">acting</span> <span class="nv">on</span> <span class="nv">limitation</span> <span class="nv">of</span>

    <span class="nv">kce</span> :

    <span class="mi">1</span><span class="ss">)</span> <span class="nv">ltr</span> : <span class="nv">plant</span> <span class="nv">cover</span>, <span class="mi">1</span> <span class="o">=</span> <span class="nv">no</span> <span class="nv">plant</span> <span class="nv">cover</span>, <span class="mi">0</span> <span class="o">=</span> <span class="nv">full</span> <span class="nv">plant</span> <span class="nv">cover</span>

    <span class="mi">2</span><span class="ss">)</span> <span class="nv">Mulch</span> <span class="o">-</span> <span class="nv">permanent</span> <span class="nv">covering</span> <span class="nv">effect</span> : <span class="nv">we</span> <span class="nv">consider</span> <span class="nv">a</span> <span class="nv">value</span> <span class="nv">of</span> <span class="mi">1</span>.<span class="mi">0</span> <span class="k">for</span> <span class="nv">no</span>

    <span class="nv">covering</span>, <span class="nv">and</span> <span class="mi">0</span>.<span class="mi">0</span> <span class="nv">is</span> <span class="nv">full</span> <span class="nv">covering</span> <span class="nv">with</span> <span class="nv">plastic</span> <span class="nv">sheet</span> <span class="c1">; this mulch parameter</span>

    <span class="nv">has</span> <span class="nv">been</span> <span class="nv">used</span> <span class="nv">in</span> <span class="nv">previous</span> <span class="nv">versions</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">model</span> <span class="nv">where</span> <span class="nv">evolution</span> <span class="nv">of</span> <span class="nv">mulch</span>

    <span class="nv">biomass</span> <span class="nv">was</span> <span class="nv">not</span> <span class="nv">explicitely</span> <span class="nv">taken</span> <span class="nv">into</span> <span class="nv">consideration</span>, <span class="nv">can</span> <span class="nv">be</span> <span class="nv">used</span> <span class="nv">in</span> <span class="nv">the</span>

    <span class="nv">case</span> <span class="nv">of</span> <span class="nv">crops</span> <span class="nv">with</span> <span class="nv">self</span><span class="o">-</span><span class="nv">mulching</span> <span class="nv">phenomena</span>, <span class="nv">where</span> <span class="nv">a</span> <span class="nv">standard</span> <span class="nv">mulch</span> <span class="nv">parameter</span>

    <span class="nv">value</span> <span class="nv">of</span> <span class="mi">0</span>.<span class="mi">7</span> <span class="nv">can</span> <span class="nv">be</span> <span class="nv">applied</span>.

    <span class="mi">3</span><span class="ss">)</span> <span class="nv">Mulch</span> <span class="o">-</span> <span class="nv">evolutive</span> <span class="nv">covering</span> <span class="nv">effect</span> <span class="nv">BiomMc</span> : <span class="nv">biomass</span> <span class="nv">of</span> <span class="nv">mulch</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">adapted</span> <span class="nv">from</span> <span class="nv">EvalKceMC</span> <span class="nv">procedure</span>, <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span>

    <span class="nv">exmodules</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>. <span class="nv">In</span> <span class="nv">its</span> <span class="nv">spirit</span>, <span class="nv">it</span> <span class="nv">looks</span> <span class="nv">like</span>

    <span class="nv">it</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">adapted</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">dual</span> <span class="nv">crop</span> <span class="nv">coefficient</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">FAO56</span> <span class="nv">paper</span>. <span class="nv">But</span>

    <span class="nv">this</span> <span class="nv">is</span> <span class="nv">still</span> <span class="nv">to</span> <span class="nv">confirm</span> <span class="nv">on</span> <span class="nv">a</span> <span class="nv">point</span> <span class="nv">of</span> <span class="nv">view</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">history</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">model</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kce</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ltr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">mulch</span><span class="s2">&quot;</span>] <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> \

        <span class="nv">np</span>.<span class="nv">exp</span><span class="ss">(</span><span class="o">-</span><span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">coefMc</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">surfMc</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">biomMc</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="mi">1000</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_pfact">estimate_pFact</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_pFact</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramVariete</span>
<span class="p">)</span>
</code></pre></div>

<p><em>summary</em></p>
<p>This function computes the pFactor, which is a bound coefficient used in the
computation of cstr from ftsw. This coefficient delimits the portion of the
FTSW below which water stress starts to influence the transpiration.</p>
<p>FAO reference for critical FTSW value for transpiration response (0 =
stomata respond immediately if FTSW&lt;1; 0.5 for most of the crops)</p>
<p>pFact is bounded in [0.1, 0.8].</p>
<p>For details see https://agritrop.cirad.fr/556855/1/document_556855.pdf</p>
<p>This function is based on the CstrPFactor procedure, from bileau.pas,
exmodules 1 &amp; 2.pas, risocas.pas files, from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramVariete</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_pFact</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramVariete</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span><span class="s">_summary_</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">the</span> <span class="nv">pFactor</span>, <span class="nv">which</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">bound</span> <span class="nv">coefficient</span> <span class="nv">used</span> <span class="nv">in</span> <span class="nv">the</span>

    <span class="nv">computation</span> <span class="nv">of</span> <span class="nv">cstr</span> <span class="nv">from</span> <span class="nv">ftsw</span>. <span class="nv">This</span> <span class="nv">coefficient</span> <span class="nv">delimits</span> <span class="nv">the</span> <span class="nv">portion</span> <span class="nv">of</span> <span class="nv">the</span>

    <span class="nv">FTSW</span> <span class="nv">below</span> <span class="nv">which</span> <span class="nv">water</span> <span class="nv">stress</span> <span class="nv">starts</span> <span class="nv">to</span> <span class="nv">influence</span> <span class="nv">the</span> <span class="nv">transpiration</span>.

    <span class="nv">FAO</span> <span class="nv">reference</span> <span class="k">for</span> <span class="nv">critical</span> <span class="nv">FTSW</span> <span class="nv">value</span> <span class="k">for</span> <span class="nv">transpiration</span> <span class="nv">response</span> <span class="ss">(</span><span class="mi">0</span> <span class="o">=</span>

    <span class="nv">stomata</span> <span class="nv">respond</span> <span class="nv">immediately</span> <span class="k">if</span> <span class="nv">FTSW</span><span class="o">&lt;</span><span class="mi">1</span><span class="c1">; 0.5 for most of the crops)</span>

    <span class="nv">pFact</span> <span class="nv">is</span> <span class="nv">bounded</span> <span class="nv">in</span> [<span class="mi">0</span>.<span class="mi">1</span>, <span class="mi">0</span>.<span class="mi">8</span>].

    <span class="k">For</span> <span class="nv">details</span> <span class="nv">see</span> <span class="nv">https</span>:<span class="o">//</span><span class="nv">agritrop</span>.<span class="nv">cirad</span>.<span class="nv">fr</span><span class="o">/</span><span class="mi">556855</span><span class="o">/</span><span class="mi">1</span><span class="o">/</span><span class="nv">document_556855</span>.<span class="nv">pdf</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">CstrPFactor</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span>,

    <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span>, <span class="nv">risocas</span>.<span class="nv">pas</span> <span class="nv">files</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramVariete</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">53</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">pFact</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">paramVariete</span>[<span class="s2">&quot;</span><span class="s">PFactor</span><span class="s2">&quot;</span>] <span class="o">+</span> \

        <span class="mi">0</span>.<span class="mi">04</span> <span class="o">*</span> <span class="ss">(</span><span class="mi">5</span> <span class="o">-</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kcp</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="mi">1</span><span class="ss">)</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ET0</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    # <span class="nv">group</span> <span class="mi">54</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">pFact</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span>

        <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

            <span class="mi">0</span>.<span class="mi">1</span>,

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">pFact</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="ss">)</span>,

        <span class="mi">0</span>.<span class="mi">8</span>,

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_plant_transpiration">estimate_plant_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_plant_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the transpiration from the plant.</p>
<p>This function is based on the EvalTranspi procedure, from bileau.pas,
bhytypeFAO.pas, exmodules 1 &amp; 2.pas, from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_plant_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">the</span> <span class="nv">transpiration</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">plant</span>.

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">EvalTranspi</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span>,

    <span class="nv">bhytypeFAO</span>.<span class="nv">pas</span>, <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">58</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">cstr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_potential_plant_transpiration">estimate_potential_plant_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_potential_plant_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes the potential transpiration from the plant.</p>
<p>Computation is based on the climate forcing (ET0), as well as the kcp coefficient.</p>
<p>This code is based on the DemandePlante procedure, from the bileau.pas, bhytypeFAO.pas, and
exmodules 1 &amp; 2.pas files from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_potential_plant_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">the</span> <span class="nv">potential</span> <span class="nv">transpiration</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">plant</span>.

    <span class="nv">Computation</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">climate</span> <span class="nv">forcing</span> <span class="ss">(</span><span class="nv">ET0</span><span class="ss">)</span>, <span class="nv">as</span> <span class="nv">well</span> <span class="nv">as</span> <span class="nv">the</span> <span class="nv">kcp</span> <span class="nv">coefficient</span>.

    <span class="nv">This</span> <span class="nv">code</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">DemandePlante</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">bileau</span>.<span class="nv">pas</span>, <span class="nv">bhytypeFAO</span>.<span class="nv">pas</span>, <span class="nv">and</span>

    <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">files</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">ggroup</span> <span class="mi">51</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kcp</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ET0</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_runoff">estimate_runoff</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_runoff</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Evaluation of runoff ("lame de ruissellement", lr, mm) :</p>
<p>If the quantity of rain (mm) is above the runoff threshold (seuilRuiss,
mm), runoff is computed as the difference between the available water
(eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by
the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0.</p>
<p>seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data</p>
<p>Question : should runoff be computed taking in consideration water captured by
mulch to account for mulch effect on runoff mitigation ?</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_runoff</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Evaluation of runoff (&quot;lame de ruissellement&quot;, lr, mm) :</span>

<span class="sd">    If the quantity of rain (mm) is above the runoff threshold (seuilRuiss,</span>

<span class="sd">    mm), runoff is computed as the difference between the available water</span>

<span class="sd">    (eauDispo, mm) and the runoff threshold (seuilRuiss, mm) multiplied by</span>

<span class="sd">    the runoff percentage (pourcRuiss, %). Else, runoff value is set to 0.</span>

<span class="sd">    seuiRuiss and pourcRuiss are defined in load_iSDA_soil_data</span>

<span class="sd">    Question : should runoff be computed taking in consideration water captured by</span>

<span class="sd">    mulch to account for mulch effect on runoff mitigation ?</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 11</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;lr&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;rain&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilRuiss&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;seuilRuiss&quot;</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;pourcRuiss&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="estimate_soil_evaporation">estimate_soil_evaporation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_soil_evaporation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes estimation of soil evaporation (mm, evap). It uses</p>
<p>the potential soil evaporation (evapPot) and the fraction of evaporable soil
water (fesw), bounded by the surface tank stock.</p>
<p>It has been adapted from the EvapRuSurf procedure, from bileau.pas and
exmodules 1 &amp; 2.pas file from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_soil_evaporation</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">estimation</span> <span class="nv">of</span> <span class="nv">soil</span> <span class="nv">evaporation</span> <span class="ss">(</span><span class="nv">mm</span>, <span class="nv">evap</span><span class="ss">)</span>. <span class="nv">It</span> <span class="nv">uses</span>

    <span class="nv">the</span> <span class="nv">potential</span> <span class="nv">soil</span> <span class="nv">evaporation</span> <span class="ss">(</span><span class="nv">evapPot</span><span class="ss">)</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">fraction</span> <span class="nv">of</span> <span class="nv">evaporable</span> <span class="nv">soil</span>

    <span class="nv">water</span> <span class="ss">(</span><span class="nv">fesw</span><span class="ss">)</span>, <span class="nv">bounded</span> <span class="nv">by</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">stock</span>.

    <span class="nv">It</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">adapted</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">EvapRuSurf</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span> <span class="nv">and</span>

    <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">file</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="o">!</span> <span class="nv">replacing</span> <span class="nv">stRuSurf</span> <span class="nv">by</span> <span class="nv">surface_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evapPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">fesw</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">**</span><span class="mi">2</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span>

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evapPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">fesw</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">**</span><span class="mi">2</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_soil_potential_evaporation">estimate_soil_potential_evaporation</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_soil_potential_evaporation</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function computes estimation of potential soil evaporation (mm,</p>
<p>evapPot). </p>
<p>It performs its computations solely from the evaporation forcing driven by
climatic demand, limited by the coefficient of evaporation from the soil
(kce).</p>
<p>Note : difference in humectation of the top and bottom tanks is not taken
into consideration in this approach.  The</p>
<p>This function has been adapted from DemandeSol procedure, from bileau.pas
and exmodules 1 &amp; 2.pas file from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_soil_potential_evaporation</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">computes</span> <span class="nv">estimation</span> <span class="nv">of</span> <span class="nv">potential</span> <span class="nv">soil</span> <span class="nv">evaporation</span> <span class="ss">(</span><span class="nv">mm</span>,

    <span class="nv">evapPot</span><span class="ss">)</span>.

    <span class="nv">It</span> <span class="nv">performs</span> <span class="nv">its</span> <span class="nv">computations</span> <span class="nv">solely</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">evaporation</span> <span class="nv">forcing</span> <span class="nv">driven</span> <span class="nv">by</span>

    <span class="nv">climatic</span> <span class="nv">demand</span>, <span class="nv">limited</span> <span class="nv">by</span> <span class="nv">the</span> <span class="nv">coefficient</span> <span class="nv">of</span> <span class="nv">evaporation</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">soil</span>

    <span class="ss">(</span><span class="nv">kce</span><span class="ss">)</span>.

    <span class="nv">Note</span> : <span class="nv">difference</span> <span class="nv">in</span> <span class="nv">humectation</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">top</span> <span class="nv">and</span> <span class="nv">bottom</span> <span class="nv">tanks</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">taken</span>

    <span class="nv">into</span> <span class="nv">consideration</span> <span class="nv">in</span> <span class="nv">this</span> <span class="nv">approach</span>.  <span class="nv">The</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">has</span> <span class="nv">been</span> <span class="nv">adapted</span> <span class="nv">from</span> <span class="nv">DemandeSol</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span>

    <span class="nv">and</span> <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">file</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">44</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evapPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ET0</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">kce</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_transpirable_surface_water">estimate_transpirable_surface_water</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_transpirable_surface_water</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the transpirable surface water. It removes</p>
<p>1/10th of surface tank capacity as water is condidered as bound.
This function is based on the ConsoResSep procedure, from bileau.pas,
exmodules 1 &amp; 2.pas files, from the original FORTRAN code.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_transpirable_surface_water</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">the</span> <span class="nv">transpirable</span> <span class="nv">surface</span> <span class="nv">water</span>. <span class="nv">It</span> <span class="nv">removes</span>

    <span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="nv">th</span> <span class="nv">of</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">capacity</span> <span class="nv">as</span> <span class="nv">water</span> <span class="nv">is</span> <span class="nv">condidered</span> <span class="nv">as</span> <span class="nv">bound</span>.

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">is</span> <span class="nv">based</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">ConsoResSep</span> <span class="nv">procedure</span>, <span class="nv">from</span> <span class="nv">bileau</span>.<span class="nv">pas</span>,

    <span class="nv">exmodules</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>.<span class="nv">pas</span> <span class="nv">files</span>, <span class="nv">from</span> <span class="nv">the</span> <span class="nv">original</span> <span class="nv">FORTRAN</span> <span class="nv">code</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">59</span>

    #<span class="o">!</span> <span class="nv">replacing</span> <span class="nv">stRuSurf</span> <span class="nv">by</span> <span class="nv">surface_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="mi">10</span><span class="ss">)</span>[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

        <span class="mi">0</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="mi">0</span>.<span class="mi">1</span>,

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_transpirable_water">estimate_transpirable_water</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_transpirable_water</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the daily volume of transpirable water.</p>
<p>eauTranspi (mm, water transpirable) is the water available for
transpiration from the surface reservoir.</p>
<p>If surface_tank_stock at the end of the previous day (index j-1) is
lower than 10% of the surface_tank_capacity, the water available for
transpirable water equals the water available for the day (eauDispo),
minus the difference between 1/10th of the surface_tank_capacity and
surface_tank_stock. This transpirable water has a min bound at 0 mm.</p>
<p>Said otherwise, a part of the water available for the day (eauDispo) is
considered as bound to the surface reservoir and cannot be transpired. </p>
<p>If surface_tank_stock at the end of the previous day (index j-1) is
upper than 10% of the surface_tank_capacity, transpirable water equals
eauDispo.</p>
<p>Remark : if the use of j-1 indices is too problematic, it seems feasible to
run this function just before update_surface_tank_stock.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_transpirable_water</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">the</span> <span class="nv">daily</span> <span class="nv">volume</span> <span class="nv">of</span> <span class="nv">transpirable</span> <span class="nv">water</span>.

    <span class="nv">eauTranspi</span> <span class="ss">(</span><span class="nv">mm</span>, <span class="nv">water</span> <span class="nv">transpirable</span><span class="ss">)</span> <span class="nv">is</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">available</span> <span class="k">for</span>

    <span class="nv">transpiration</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">reservoir</span>.

    <span class="k">If</span> <span class="nv">surface_tank_stock</span> <span class="nv">at</span> <span class="nv">the</span> <span class="k">end</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">previous</span> <span class="nv">day</span> <span class="ss">(</span><span class="nv">index</span> <span class="nv">j</span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span> <span class="nv">is</span>

    <span class="nv">lower</span> <span class="nv">than</span> <span class="mi">10</span><span class="o">%</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface_tank_capacity</span>, <span class="nv">the</span> <span class="nv">water</span> <span class="nv">available</span> <span class="k">for</span>

    <span class="nv">transpirable</span> <span class="nv">water</span> <span class="nv">equals</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">available</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">day</span> <span class="ss">(</span><span class="nv">eauDispo</span><span class="ss">)</span>,

    <span class="nv">minus</span> <span class="nv">the</span> <span class="nv">difference</span> <span class="nv">between</span> <span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="nv">th</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface_tank_capacity</span> <span class="nv">and</span>

    <span class="nv">surface_tank_stock</span>. <span class="nv">This</span> <span class="nv">transpirable</span> <span class="nv">water</span> <span class="nv">has</span> <span class="nv">a</span> <span class="nv">min</span> <span class="nv">bound</span> <span class="nv">at</span> <span class="mi">0</span> <span class="nv">mm</span>.

    <span class="nv">Said</span> <span class="nv">otherwise</span>, <span class="nv">a</span> <span class="nv">part</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">available</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">day</span> <span class="ss">(</span><span class="nv">eauDispo</span><span class="ss">)</span> <span class="nv">is</span>

    <span class="nv">considered</span> <span class="nv">as</span> <span class="nv">bound</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">reservoir</span> <span class="nv">and</span> <span class="nv">cannot</span> <span class="nv">be</span> <span class="nv">transpired</span>.

    <span class="k">If</span> <span class="nv">surface_tank_stock</span> <span class="nv">at</span> <span class="nv">the</span> <span class="k">end</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">previous</span> <span class="nv">day</span> <span class="ss">(</span><span class="nv">index</span> <span class="nv">j</span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span> <span class="nv">is</span>

    <span class="nv">upper</span> <span class="nv">than</span> <span class="mi">10</span><span class="o">%</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface_tank_capacity</span>, <span class="nv">transpirable</span> <span class="nv">water</span> <span class="nv">equals</span>

    <span class="nv">eauDispo</span>.

    <span class="nv">Remark</span> : <span class="k">if</span> <span class="nv">the</span> <span class="nv">use</span> <span class="nv">of</span> <span class="nv">j</span><span class="o">-</span><span class="mi">1</span> <span class="nv">indices</span> <span class="nv">is</span> <span class="nv">too</span> <span class="nv">problematic</span>, <span class="nv">it</span> <span class="nv">seems</span> <span class="nv">feasible</span> <span class="nv">to</span>

    <span class="nv">run</span> <span class="nv">this</span> <span class="nv">function</span> <span class="nv">just</span> <span class="nv">before</span> <span class="nv">update_surface_tank_stock</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">28</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauTranspi</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        # <span class="o">!</span> <span class="nv">modifying</span> <span class="nv">to</span> <span class="nv">replace</span> <span class="nv">stRuSurfPrec</span> <span class="nv">by</span> <span class="nv">stRuSurf</span> <span class="nv">at</span> <span class="nv">undex</span> <span class="nv">j</span><span class="o">-</span><span class="mi">1</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">to</span> <span class="nv">surface_tank_capacity</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurfPrec</span> <span class="nv">to</span> <span class="nv">surface_tank_stock</span>

        # <span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurfPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="mi">10</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span><span class="o">-</span><span class="mi">1</span>,:,:] <span class="o">&lt;</span> <span class="mi">0</span>.<span class="mi">1</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>],

        <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

            <span class="mi">0</span>,

            # <span class="o">!</span> <span class="nv">modifying</span> <span class="nv">to</span> <span class="nv">replace</span> <span class="nv">stRuSurfPrec</span> <span class="nv">by</span> <span class="nv">stRuSurf</span> <span class="nv">at</span> <span class="nv">iundex</span> <span class="nv">j</span><span class="o">-</span><span class="mi">1</span>

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">to</span> <span class="nv">surface_tank_capacity</span>

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurf</span> <span class="nv">to</span> <span class="nv">surface_tank_stock</span>

            # <span class="o">//</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="mi">10</span> <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurfPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="ss">(</span><span class="mi">0</span>.<span class="mi">1</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span><span class="o">-</span><span class="mi">1</span>,:,:]<span class="ss">)</span>

            <span class="ss">)</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="estimate_water_captured_by_mulch">estimate_water_captured_by_mulch</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_water_captured_by_mulch</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>Determination of water gathered by the mulch (eauCaptee, mm):</p>
<p>We determine the quantity of water gathered by mulch by multiplying the
available water (eauDispo, from rain and irrigation, mm) with a
exponential function of covering capacity of the considered mulch
(surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the
fraction of soil covered by mulch. The value of eauCaptee is bounded by
the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg
biomass), minus stock of water already present in it (stockMc, mm).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">estimate_water_captured_by_mulch</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">paramITK</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Determination of water gathered by the mulch (eauCaptee, mm):</span>

<span class="sd">    We determine the quantity of water gathered by mulch by multiplying the</span>

<span class="sd">    available water (eauDispo, from rain and irrigation, mm) with a</span>

<span class="sd">    exponential function of covering capacity of the considered mulch</span>

<span class="sd">    (surfMc, ha/t) and the mulch biomass (biomMc, kg/ha), representing the</span>

<span class="sd">    fraction of soil covered by mulch. The value of eauCaptee is bounded by</span>

<span class="sd">    the maximum capacity of the mulch to gather water (humSatMc, kg H2O/kg</span>

<span class="sd">    biomass), minus stock of water already present in it (stockMc, mm).</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">        paramITK (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 7</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! modyfing variable names to improve readability</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! replacing eauCaptee by water_gathered_by_mulch</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! replacing stockMc by mulch_water_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;eauCaptee&quot;][j,:,:] = np.minimum(</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_gathered_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;surfMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])),</span><span class="w"></span>

<span class="w">        </span><span class="c1">#// (paramITK[&quot;humSatMc&quot;] * data[&quot;biomMc&quot;][j,:,:] / 10000) - data[&quot;stockMc&quot;][j,:,:],</span><span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">paramITK</span><span class="p">[</span><span class="s2">&quot;humSatMc&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;biomMc&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="estimate_water_consumption_from_root_tank_stock">estimate_water_consumption_from_root_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">estimate_water_consumption_from_root_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates consoRur, which is the water to be consumed from</p>
<p>the root tank stock.</p>
<p>If soil evaporation (evap) is higher than transpirable surface water
(trSurf), then consumption from root tank stock equals trSurf. Else, it
equals evap.</p>
<h1 id="how-to-interpret-this">? how to interpret this ?</h1>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">estimate_water_consumption_from_root_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">consoRur</span>, <span class="nv">which</span> <span class="nv">is</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">consumed</span> <span class="nv">from</span>

    <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span>.

    <span class="k">If</span> <span class="nv">soil</span> <span class="nv">evaporation</span> <span class="ss">(</span><span class="nv">evap</span><span class="ss">)</span> <span class="nv">is</span> <span class="nv">higher</span> <span class="nv">than</span> <span class="nv">transpirable</span> <span class="nv">surface</span> <span class="nv">water</span>

    <span class="ss">(</span><span class="nv">trSurf</span><span class="ss">)</span>, <span class="k">then</span> <span class="nv">consumption</span> <span class="nv">from</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">equals</span> <span class="nv">trSurf</span>. <span class="k">Else</span>, <span class="nv">it</span>

    <span class="nv">equals</span> <span class="nv">evap</span>.

    #? <span class="nv">how</span> <span class="nv">to</span> <span class="nv">interpret</span> <span class="nv">this</span> ?

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="initialize_root_tank_capacity">initialize_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">initialize_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">paramITK</span>
<span class="p">)</span>
</code></pre></div>

<p>updating stRurMax/root_tank_capacity, step 1 :</p>
<p>stRurMax, also called ruRac in some versions of the model, is the root_tank_capacity.</p>
<p>At the phase change between phases 0 and 1 (initialisation), the maximum
root water storage is initialised by multiplying the initial root depth
(profRacIni, mm) with the soil water storage capacity (ru, mm/m). This
value is broadcasted on the time series. For every other day in the cycle,
the value remains unchanged.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>paramITK</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">initialize_root_tank_capacity</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span>, <span class="nv">paramITK</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">updating</span> <span class="nv">stRurMax</span><span class="o">/</span><span class="nv">root_tank_capacity</span>, <span class="nv">step</span> <span class="mi">1</span> :

    <span class="nv">stRurMax</span>, <span class="nv">also</span> <span class="nv">called</span> <span class="nv">ruRac</span> <span class="nv">in</span> <span class="nv">some</span> <span class="nv">versions</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">model</span>, <span class="nv">is</span> <span class="nv">the</span> <span class="nv">root_tank_capacity</span>.

    <span class="nv">At</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">change</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">0</span> <span class="nv">and</span> <span class="mi">1</span> <span class="ss">(</span><span class="nv">initialisation</span><span class="ss">)</span>, <span class="nv">the</span> <span class="nv">maximum</span>

    <span class="nv">root</span> <span class="nv">water</span> <span class="nv">storage</span> <span class="nv">is</span> <span class="nv">initialised</span> <span class="nv">by</span> <span class="nv">multiplying</span> <span class="nv">the</span> <span class="nv">initial</span> <span class="nv">root</span> <span class="nv">depth</span>

    <span class="ss">(</span><span class="nv">profRacIni</span>, <span class="nv">mm</span><span class="ss">)</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">soil</span> <span class="nv">water</span> <span class="nv">storage</span> <span class="nv">capacity</span> <span class="ss">(</span><span class="nv">ru</span>, <span class="nv">mm</span><span class="o">/</span><span class="nv">m</span><span class="ss">)</span>. <span class="nv">This</span>

    <span class="nv">value</span> <span class="nv">is</span> <span class="nv">broadcasted</span> <span class="nv">on</span> <span class="nv">the</span> <span class="nv">time</span> <span class="nv">series</span>. <span class="k">For</span> <span class="nv">every</span> <span class="nv">other</span> <span class="nv">day</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">cycle</span>,

    <span class="nv">the</span> <span class="nv">value</span> <span class="nv">remains</span> <span class="nv">unchanged</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">paramITK</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">14</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">xr</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span>,

        <span class="nv">paramITK</span>[<span class="s2">&quot;</span><span class="s">profRacIni</span><span class="s2">&quot;</span>] <span class="o">/</span> <span class="mi">1000</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ru</span><span class="s2">&quot;</span>],

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="remplires">rempliRes</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">rempliRes</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Translated from the procedure rempliRes, of the original Pascal codes</p>
<p>bileau.pas</p>
<p>Main hypotheses : 
- the water dynamics is represented by a filling from the top and an evolution 
of the reservoirs sizes when the filling is above the maximum quantity of the
current size (humectation front).
- when the maximum size is reached by filling, it is considered as drainage.
- inside a reservoir, water is distributed homogeneously (may be considered
valid up to 2m depth, according to CB, from other sources).</p>
<p>3 reservoirs are represented:
1) a global reservoir, evolving in depth according to the humectation front
2) a surface reservoir (fixed size) where evaporation and a part of the
transpiration occurs when roots are present
3) a root reservoir, evolving according to the root front (when roots are
present)</p>
<p>REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks</p>
<p>Notes from CB, 10/06/2015 :
prise en compte de stock d'eau résilient pour les simulation continues
Hypothèse de la MAJ des stock en fn de l'eau r�siliente de l'ann�e pr�c�dente
dans le cas des simulations pluri annuelle en continue (NbAn = 1):
A la r�colte on recup�re les stock d'eau (StRuPrec), la prof d'Humectation (Humprec)
et la prof d'enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien.
On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf)
Si le StRu avec l'apport d'eau devinet sup au Hum
alors on tient compte dans cette augmentation du stock r�silient avec deux cas possible :
Si StRu est &lt; � stRurMaxprec
alors on ajoute l'eau r�siliente contenue dans l'ancienne zone racinaire en fn
de la diff�rence de stock
Sinon on a de l'eau r�siliente au maximum de la CC jusqu'� l'ancienne HumPrec,
on rempli alors StRu de la diff�rence etre ces deux valeurs puis on fait la MAJ
des Dr, StRur, Hum etc...</p>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Translated from the procedure rempliRes, of the original Pascal codes</span>

<span class="sd">    bileau.pas</span>

<span class="sd">    Main hypotheses :</span>

<span class="sd">    - the water dynamics is represented by a filling from the top and an evolution</span>

<span class="sd">    of the reservoirs sizes when the filling is above the maximum quantity of the</span>

<span class="sd">    current size (humectation front).</span>

<span class="sd">    - when the maximum size is reached by filling, it is considered as drainage.</span>

<span class="sd">    - inside a reservoir, water is distributed homogeneously (may be considered</span>

<span class="sd">    valid up to 2m depth, according to CB, from other sources).</span>

<span class="sd">    3 reservoirs are represented:</span>

<span class="sd">    1) a global reservoir, evolving in depth according to the humectation front</span>

<span class="sd">    2) a surface reservoir (fixed size) where evaporation and a part of the</span>

<span class="sd">    transpiration occurs when roots are present</span>

<span class="sd">    3) a root reservoir, evolving according to the root front (when roots are</span>

<span class="sd">    present)</span>

<span class="sd">    REMARK : these reservoirs overlap, and instead of managing depths, we manage water stocks</span>

<span class="sd">    Notes from CB, 10/06/2015 :</span>

<span class="sd">    prise en compte de stock d&#39;eau résilient pour les simulation continues</span>

<span class="sd">    Hypothèse de la MAJ des stock en fn de l&#39;eau r�siliente de l&#39;ann�e pr�c�dente</span>

<span class="sd">    dans le cas des simulations pluri annuelle en continue (NbAn = 1):</span>

<span class="sd">    A la r�colte on recup�re les stock d&#39;eau (StRuPrec), la prof d&#39;Humectation (Humprec)</span>

<span class="sd">    et la prof d&#39;enracinement (stRurMaxprec). Pour le reservoir de surface on ne change rien.</span>

<span class="sd">    On MAJ le stRu avec le stock de surface stRuSurf, Hum avec le max de remplissage de surface (RuSurf)</span>

<span class="sd">    Si le StRu avec l&#39;apport d&#39;eau devinet sup au Hum</span>

<span class="sd">    alors on tient compte dans cette augmentation du stock r�silient avec deux cas possible :</span>

<span class="sd">    Si StRu est &lt; � stRurMaxprec</span>

<span class="sd">    alors on ajoute l&#39;eau r�siliente contenue dans l&#39;ancienne zone racinaire en fn</span>

<span class="sd">    de la diff�rence de stock</span>

<span class="sd">    Sinon on a de l&#39;eau r�siliente au maximum de la CC jusqu&#39;� l&#39;ancienne HumPrec,</span>

<span class="sd">    on rempli alors StRu de la diff�rence etre ces deux valeurs puis on fait la MAJ</span>

<span class="sd">    des Dr, StRur, Hum etc...</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># section 1 : updating the end_of_cycle memory variables</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_humPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_hum_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_stRurMaxPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_stRurPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_stRuPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reset_total_tank_capacity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1"># verif ok</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # filling the surface tank with available water</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_surface_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1"># verif ok</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # estimates transpirable water</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">estimate_transpirable_water</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1"># verif ok</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # increments total tank stock with transpirable water</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # (meaning that total tank stock may represent a transpirable water tank)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1"># verif ok</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # estimating positive delta between total_root_tank and stRuPrec</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_delta_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1"># verif ok</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # first we update total_tank_stock that can 1) take delta_total_tank_stock or 2) be unchanged</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="c1"># verif ok</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # then total_tank_stock_previous_value can 1) take 0 or 2) be unchanged</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_stRuPrec</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="c1">#????</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # delta_total_tank_stock can 1) be incremented of total_tank_stock_previous_value or 2) be unchanged</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_delta_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # # here, in case 1, In this function, if the variation of transpirable water</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # (delta_total_tank_stock) increases above the depth of humectation front</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # (hum), if the depth of humectation front (hum) is above the</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # root_tank_capacity_previous_season (condition 1 passed, and 2 failed,</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # which should be the case for most of the simulations that will be</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # single-season), and if the depth of humectation front (hum) has decreased</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # since the previous day (condition 3 passed), then total_tank_stock takes the value of</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # delta_total_tank_stock, total_tank_stock_previous_value equals 0, and</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # delta_total_tank_stock is incremented by total_tank_stock_previous_value.</span><span class="w"></span>

<span class="w">    </span><span class="c1"># #</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # in case 2, nothing happens.</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # update_hum manages increase in hum</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_hum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # in case of overflowing...</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # calculating drainage</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_dr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # limiting the total_tank_stock to the total_tank_capacity (when overflowing)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_total_tank_stock_step_3</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # update again hum value, but we could merge functions with update_hum</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_hum_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># # filling root_tank_stock with transpirable water, within the limits of total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_root_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="reset_total_tank_capacity">reset_total_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">reset_total_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function resets the value total_tank_capacity/stRuMax at each loop.</p>
<p>? Why redfining stRuMax at each loop ? Neither ru, profRu 
? nor total_tank_capacity are modified during the simulation.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">reset_total_tank_capacity</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">resets</span> <span class="nv">the</span> <span class="nv">value</span> <span class="nv">total_tank_capacity</span><span class="o">/</span><span class="nv">stRuMax</span> <span class="nv">at</span> <span class="nv">each</span> <span class="k">loop</span>.

    ? <span class="nv">Why</span> <span class="nv">redfining</span> <span class="nv">stRuMax</span> <span class="nv">at</span> <span class="nv">each</span> <span class="k">loop</span> ? <span class="nv">Neither</span> <span class="nv">ru</span>, <span class="nv">profRu</span>

    ? <span class="nv">nor</span> <span class="nv">total_tank_capacity</span> <span class="nv">are</span> <span class="nv">modified</span> <span class="nv">during</span> <span class="nv">the</span> <span class="nv">simulation</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">25</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuMax</span> <span class="nv">to</span> <span class="nv">total_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ru</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">profRu</span><span class="s2">&quot;</span>] <span class="o">/</span> <span class="mi">1000</span><span class="ss">)</span> #.<span class="nv">copy</span><span class="ss">()</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ru</span><span class="s2">&quot;</span>] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">profRu</span><span class="s2">&quot;</span>] <span class="o">/</span> <span class="mi">1000</span><span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_available_water_after_mulch_filling">update_available_water_after_mulch_filling</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_available_water_after_mulch_filling</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Updating available water (eauDispo, mm) : </p>
<p>As some water is gathered by the mulch, the available water is updated by
subtracting the gathered water (eauCaptee, mm) from the total available
water (eauDispo, mm). This value is bounded by 0, as the available water
cannot be negative.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_available_water_after_mulch_filling</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updating available water (eauDispo, mm) :</span>

<span class="sd">    As some water is gathered by the mulch, the available water is updated by</span>

<span class="sd">    subtracting the gathered water (eauCaptee, mm) from the total available</span>

<span class="sd">    water (eauDispo, mm). This value is bounded by 0, as the available water</span>

<span class="sd">    cannot be negative.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># ! correction as broadcasting on xarray seems less constrained than on numpy</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! modyfing variable names to improve readability</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! replacing eauCaptee by water_gathered_by_mulch</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 8</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;eauDispo&quot;][j:,:,:] =  np.maximum(data[&quot;eauDispo&quot;][j,:,:] - data[&quot;eauCaptee&quot;][j,:,:], 0) # //[...,np.newaxis]</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;eauDispo&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_gathered_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1"># //[...,np.newaxis]</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_available_water_after_runoff">update_available_water_after_runoff</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_available_water_after_runoff</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Updating available water (eauDispo, mm) :</p>
<p>The available water is updated by subtracting the runoff (lr, mm) from the
total available water (eauDispo, mm). This value is broadcasted onto the
days axis.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_available_water_after_runoff</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Updating</span> <span class="nv">available</span> <span class="nv">water</span> <span class="ss">(</span><span class="nv">eauDispo</span>, <span class="nv">mm</span><span class="ss">)</span> :

    <span class="nv">The</span> <span class="nv">available</span> <span class="nv">water</span> <span class="nv">is</span> <span class="nv">updated</span> <span class="nv">by</span> <span class="nv">subtracting</span> <span class="nv">the</span> <span class="nv">runoff</span> <span class="ss">(</span><span class="nv">lr</span>, <span class="nv">mm</span><span class="ss">)</span> <span class="nv">from</span> <span class="nv">the</span>

    <span class="nv">total</span> <span class="nv">available</span> <span class="nv">water</span> <span class="ss">(</span><span class="nv">eauDispo</span>, <span class="nv">mm</span><span class="ss">)</span>. <span class="nv">This</span> <span class="nv">value</span> <span class="nv">is</span> <span class="nv">broadcasted</span> <span class="nv">onto</span> <span class="nv">the</span>

    <span class="nv">days</span> <span class="nv">axis</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">12</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">lr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_delta_root_tank_capacity">update_delta_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_delta_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>updating delta_root_tank_capacity : </p>
<p>At the day of phase change, for phases strictly above 1, and for which the
difference between the water height to humectation front (hum, mm) and the
root_tank_capacity is less than the delta_root_tank_capacity,
delta_root_tank_capacity is updated to be equal to the difference between
the water height to humectation front and the root_tank_capacity. In other
words, the change in root tank capacity delta_root_tank_capacity is limited
by the water height to humectation front.</p>
<p>For any other day or if root_tank_capacity is above
delta_root_tank_capacity, delta_root_tank_capacity value is unchanged.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_delta_root_tank_capacity</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">updating</span> <span class="nv">delta_root_tank_capacity</span> :

    <span class="nv">At</span> <span class="nv">the</span> <span class="nv">day</span> <span class="nv">of</span> <span class="nv">phase</span> <span class="nv">change</span>, <span class="k">for</span> <span class="nv">phases</span> <span class="nv">strictly</span> <span class="nv">above</span> <span class="mi">1</span>, <span class="nv">and</span> <span class="k">for</span> <span class="nv">which</span> <span class="nv">the</span>

    <span class="nv">difference</span> <span class="nv">between</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">height</span> <span class="nv">to</span> <span class="nv">humectation</span> <span class="nv">front</span> <span class="ss">(</span><span class="nv">hum</span>, <span class="nv">mm</span><span class="ss">)</span> <span class="nv">and</span> <span class="nv">the</span>

    <span class="nv">root_tank_capacity</span> <span class="nv">is</span> <span class="nv">less</span> <span class="nv">than</span> <span class="nv">the</span> <span class="nv">delta_root_tank_capacity</span>,

    <span class="nv">delta_root_tank_capacity</span> <span class="nv">is</span> <span class="nv">updated</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">equal</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">difference</span> <span class="nv">between</span>

    <span class="nv">the</span> <span class="nv">water</span> <span class="nv">height</span> <span class="nv">to</span> <span class="nv">humectation</span> <span class="nv">front</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">root_tank_capacity</span>. <span class="nv">In</span> <span class="nv">other</span>

    <span class="nv">words</span>, <span class="nv">the</span> <span class="nv">change</span> <span class="nv">in</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">capacity</span> <span class="nv">delta_root_tank_capacity</span> <span class="nv">is</span> <span class="nv">limited</span>

    <span class="nv">by</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">height</span> <span class="nv">to</span> <span class="nv">humectation</span> <span class="nv">front</span>.

    <span class="k">For</span> <span class="nv">any</span> <span class="nv">other</span> <span class="nv">day</span> <span class="nv">or</span> <span class="k">if</span> <span class="nv">root_tank_capacity</span> <span class="nv">is</span> <span class="nv">above</span>

    <span class="nv">delta_root_tank_capacity</span>, <span class="nv">delta_root_tank_capacity</span> <span class="nv">value</span> <span class="nv">is</span> <span class="nv">unchanged</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">16</span>

    # <span class="o">!</span> <span class="nv">simplified</span> <span class="nv">conditions</span>

    # <span class="o">//</span> <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> <span class="o">&amp;</span> \

    # <span class="o">//</span>       <span class="nv">np</span>.<span class="nv">invert</span><span class="ss">((</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">))</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">1</span><span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">deltaRur</span> <span class="nv">with</span> <span class="nv">delta_root_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">deltaRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">dayVrac</span> <span class="nv">to</span> <span class="nv">delta_root_tank_capacity</span>

            #<span class="o">//</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span> <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">dayVrac</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span> <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">dayVrac</span> <span class="nv">to</span> <span class="nv">delta_root_tank_capacity</span>

            #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">dayVrac</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="ss">)</span>,

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">deltaRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_delta_total_tank_stock">update_delta_total_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_delta_total_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates delta_total_tank_stock</p>
<p>delta_total_tank_stock is the positive variation of transpirable water
stock. It is computed as the difference between the total_tank_stock and
stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is
initialized to be equal to total_tank_stock at the beginning of the
simulation. total_tank_stock is initialized with stockIrr parameter. Thus,
simulations should start with a 0 value.</p>
<p>stRuPrec is updated at each cycle with the update_struprec function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_delta_total_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function estimates delta_total_tank_stock</span>

<span class="sd">    delta_total_tank_stock is the positive variation of transpirable water</span>

<span class="sd">    stock. It is computed as the difference between the total_tank_stock and</span>

<span class="sd">    stRuPrec, bound in 0. Thus, it can only have a positive value. stRuPrec is</span>

<span class="sd">    initialized to be equal to total_tank_stock at the beginning of the</span>

<span class="sd">    simulation. total_tank_stock is initialized with stockIrr parameter. Thus,</span>

<span class="sd">    simulations should start with a 0 value.</span>

<span class="sd">    stRuPrec is updated at each cycle with the update_struprec function.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 30</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! we propose a different version based on stTot</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stTot to total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stRuVar to delta_total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stRuPrec to total_tank_stock_previous_value</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stRuVar&quot;][j:,:,:] = np.maximum(0, data[&quot;stTot&quot;][j,:,:] - data[&quot;stRuPrec&quot;][j,:,:])[...,np.newaxis]</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_delta_total_tank_stock_step_2">update_delta_total_tank_stock_step_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_delta_total_tank_stock_step_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_delta_total_tank_stock_step_2</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">condition_1</span>, <span class="nv">condition_2</span>, <span class="nv">condition_3</span> <span class="o">=</span> <span class="nv">conditions_rempliRes</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>

    # <span class="nv">groupe</span> <span class="mi">33</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuVar</span> <span class="nv">with</span> <span class="nv">delta_total_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition_1</span>,

        <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

            <span class="nv">condition_2</span>,

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuVar</span> <span class="nv">with</span> <span class="nv">delta_total_tank_stock</span>

            #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

                <span class="nv">condition_3</span>,

                #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuVar</span> <span class="nv">with</span> <span class="nv">delta_total_tank_stock</span>

                #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuPrec</span> <span class="nv">with</span> <span class="nv">total_tank_stock_previous_value</span>

                #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

                <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock_previous_value</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

                #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuVar</span> <span class="nv">with</span> <span class="nv">delta_total_tank_stock</span>

                #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

                <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

            <span class="ss">)</span>,

        <span class="ss">)</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuVar</span> <span class="nv">with</span> <span class="nv">delta_total_tank_stock</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuVar</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_dr">update_dr</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_dr</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function estimates the daily drainage (dr). When total tank overflows, it</p>
<p>computes drainage from the differences between the total_tank_stock (that is
to say the total and total_tank_capacity.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_dr</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">estimates</span> <span class="nv">the</span> <span class="nv">daily</span> <span class="nv">drainage</span> <span class="ss">(</span><span class="nv">dr</span><span class="ss">)</span>. <span class="nv">When</span> <span class="nv">total</span> <span class="nv">tank</span> <span class="nv">overflows</span>, <span class="nv">it</span>

    <span class="nv">computes</span> <span class="nv">drainage</span> <span class="nv">from</span> <span class="nv">the</span> <span class="nv">differences</span> <span class="nv">between</span> <span class="nv">the</span> <span class="nv">total_tank_stock</span> <span class="ss">(</span><span class="nv">that</span> <span class="nv">is</span>

    <span class="nv">to</span> <span class="nv">say</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">and</span> <span class="nv">total_tank_capacity</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuMax</span> <span class="nv">to</span> <span class="nv">total_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="nv">condition_total_tank_overflow</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>

    # <span class="nv">groupe</span> <span class="mi">36</span>

    # <span class="nv">essais</span> <span class="nv">stTot</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">dr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuMax</span> <span class="nv">to</span> <span class="nv">total_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="mi">0</span>,

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_etr_etm">update_etr_etm</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_etr_etm</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_etr_etm</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    # <span class="nv">group</span> <span class="mi">69</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">etr</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>.<span class="nv">copy</span><span class="ss">()</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    # <span class="nv">group</span> <span class="mi">70</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">etm</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evapPot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>.<span class="nv">copy</span><span class="ss">()</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_hum">update_hum</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_hum</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the depth to humectation front (hum) to be the maximum</p>
<p>value between the depth to humectation front (hum) and
delta_total_tank_stock (that is to say depth of humectation front can only
increase), bounded by total_tank_capacity (that is to say humectation front
can not go deep indefinitely).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_hum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    This function updates the depth to humectation front (hum) to be the maximum</span>

<span class="ss">    value between the depth to humectation front (hum) and</span>

<span class="ss">    delta_total_tank_stock (that is to say depth of humectation front can only</span>

<span class="ss">    increase), bounded by total_tank_capacity (that is to say humectation front</span>

<span class="ss">    can not go deep indefinitely).</span>

<span class="ss">    Args:</span>

<span class="ss">        j (_type_): _description_</span>

<span class="ss">        data (_type_): _description_</span>

<span class="ss">    Returns:</span>

<span class="ss">        _type_: _description_</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">groupe</span><span class="w"> </span><span class="mi">34</span><span class="w"></span>

<span class="w">    </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRuVar</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">delta_total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRuVar&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">)</span><span class="err">#</span><span class="o">[</span><span class="n">...,np.newaxis</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;delta_total_tank_stock&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">groupe</span><span class="w"> </span><span class="mi">35</span><span class="w"></span>

<span class="w">    </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRuMax</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">total_tank_capacity</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRuMax&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">)</span><span class="err">#</span><span class="o">[</span><span class="n">...,np.newaxis</span><span class="o">]</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">minimum</span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;total_tank_capacity&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;hum&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_humprec_for_end_of_cycle">update_humPrec_for_end_of_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_humPrec_for_end_of_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function saves information about the humectation front depth at the end</p>
<p>of a growth cycle so it can be used in the next cycle.</p>
<p>humPrec is initialized in the function InitPlotMc, and set to be equal to
hum, itself being initialized to take the maximum value between
surface_tank_capacity, root_tank_capacity and total_tank_stock.</p>
<p>At the harvest date (numPhase = 7), the humPrec variable is set to equal the
highest value between hum (mm, humectation front depth) and
surface_tank_capacity (mm). This value is broadcasted over the time
dimension.</p>
<p>At any other point in time, its value is unchanged.</p>
<p>This means...</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>number of the day</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray dataset</td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>xarray dataset: <em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_humPrec_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function saves information about the humectation front depth at the end</span>

<span class="sd">    of a growth cycle so it can be used in the next cycle.</span>

<span class="sd">    humPrec is initialized in the function InitPlotMc, and set to be equal to</span>

<span class="sd">    hum, itself being initialized to take the maximum value between</span>

<span class="sd">    surface_tank_capacity, root_tank_capacity and total_tank_stock.</span>

<span class="sd">    At the harvest date (numPhase = 7), the humPrec variable is set to equal the</span>

<span class="sd">    highest value between hum (mm, humectation front depth) and</span>

<span class="sd">    surface_tank_capacity (mm). This value is broadcasted over the time</span>

<span class="sd">    dimension.</span>

<span class="sd">    At any other point in time, its value is unchanged.</span>

<span class="sd">    This means...</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): number of the day</span>

<span class="sd">        data (xarray dataset): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray dataset: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 20</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="c1">#! renaming ruSurf to surface_tank_capacity</span><span class="w"></span>

<span class="w">        </span><span class="c1">#// np.maximum(data[&quot;hum&quot;][j,:,:], data[&quot;ruSurf&quot;][j,:,:]),</span><span class="w"></span>

<span class="w">        </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">]),</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;humPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_hum_for_end_of_cycle">update_hum_for_end_of_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_hum_for_end_of_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates information about the humectation front depth at the end</p>
<p>of a growth cycle.</p>
<p>At the harvest date (numPhase = 7), the hum variable is set to equal the
surface_tank_capacity (mm). This value is broadcasted over the time
dimension.</p>
<p>At any other point in time, its value is unchanged.</p>
<p>This means...</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_hum_for_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function updates information about the humectation front depth at the end</span>

<span class="sd">    of a growth cycle.</span>

<span class="sd">    At the harvest date (numPhase = 7), the hum variable is set to equal the</span>

<span class="sd">    surface_tank_capacity (mm). This value is broadcasted over the time</span>

<span class="sd">    dimension.</span>

<span class="sd">    At any other point in time, its value is unchanged.</span>

<span class="sd">    This means...</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 21</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">condition_end_of_cycle</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="c1">#! renaming ruSurf to surface_tank_capacity</span><span class="w"></span>

<span class="w">        </span><span class="c1">#// data[&quot;ruSurf&quot;][j,:,:],</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">],</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_hum_step_2">update_hum_step_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_hum_step_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>We update the depth to humectation front (hum) again, to reflect eventual changes in</p>
<p>total_tank_stock values.</p>
<p>? we could have placed the previous hum update function here</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_hum_step_2</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">We</span> <span class="nv">update</span> <span class="nv">the</span> <span class="nv">depth</span> <span class="nv">to</span> <span class="nv">humectation</span> <span class="nv">front</span> <span class="ss">(</span><span class="nv">hum</span><span class="ss">)</span> <span class="nv">again</span>, <span class="nv">to</span> <span class="nv">reflect</span> <span class="nv">eventual</span> <span class="nv">changes</span> <span class="nv">in</span>

    <span class="nv">total_tank_stock</span> <span class="nv">values</span>.

    ? <span class="nv">we</span> <span class="nv">could</span> <span class="nv">have</span> <span class="nv">placed</span> <span class="nv">the</span> <span class="nv">previous</span> <span class="nv">hum</span> <span class="nv">update</span> <span class="nv">function</span> <span class="nv">here</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">groupe</span> <span class="mi">38</span>

    # <span class="o">//</span> <span class="nv">avant</span> <span class="nv">modif</span> <span class="mi">10</span><span class="o">/</span><span class="mi">06</span><span class="o">/</span><span class="mi">2015</span>

    # <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    # <span class="nv">essais</span> <span class="nv">stTot</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">hum</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    #<span class="o">!</span> <span class="nv">en</span> <span class="nv">conflit</span> <span class="nv">avec</span> <span class="nv">le</span> <span class="nv">calcul</span> <span class="nv">pr</span>é<span class="nv">c</span>é<span class="nv">dent</span> <span class="nv">de</span> <span class="nv">hum</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_irrigation_tank_capacity">update_irrigation_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_irrigation_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Update Irrigation Tank Capacity</p>
<p>The function updates the maximum water capacity of irrigation tank based on
the conditions specified in the function. If the automatic irrigation mode
is ON, and if the current phase is between 0 and 6, and if the root tank
capacity is less than the surface tank capacity, meaning that the roots have
not reached the limit between the surface compartment and deep compartment,
then the irrigation tank capacity is set to the surface tank capacity, which
is given a minimum value equal to the surface tank capacity. Otherwise, the
irrigation tank capacity remains unchanged.</p>
<p>If we are in automatic irrigation mode, and between phases 0 and 6, and if
root_tank_capacity is less than surface_tank_capacity, meaning that roots
haven't reached the limit between the surface compartment and deep
compartment, then we define irrigation_tank_capacity as equal to
surface_tank_capacity, that is to say, we give to irrigation_tank_capacity a
minimum value that equals surface_tank_capacity. else, we do not modify
irrigation_tank_capacity value</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>Index of the time step being processed.</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray dataset</td>
<td>The input dataset containing all the information necessary to run the model.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>xarray dataset: The input dataset with updated values of the irrigation tank capacity.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_irrigation_tank_capacity</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Update</span> <span class="nv">Irrigation</span> <span class="nv">Tank</span> <span class="nv">Capacity</span>

    <span class="nv">The</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">maximum</span> <span class="nv">water</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">based</span> <span class="nv">on</span>

    <span class="nv">the</span> <span class="nv">conditions</span> <span class="nv">specified</span> <span class="nv">in</span> <span class="nv">the</span> <span class="nv">function</span>. <span class="k">If</span> <span class="nv">the</span> <span class="nv">automatic</span> <span class="nv">irrigation</span> <span class="nv">mode</span>

    <span class="nv">is</span> <span class="nv">ON</span>, <span class="nv">and</span> <span class="k">if</span> <span class="nv">the</span> <span class="nv">current</span> <span class="nv">phase</span> <span class="nv">is</span> <span class="nv">between</span> <span class="mi">0</span> <span class="nv">and</span> <span class="mi">6</span>, <span class="nv">and</span> <span class="k">if</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span>

    <span class="nv">capacity</span> <span class="nv">is</span> <span class="nv">less</span> <span class="nv">than</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">capacity</span>, <span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">the</span> <span class="nv">roots</span> <span class="nv">have</span>

    <span class="nv">not</span> <span class="nv">reached</span> <span class="nv">the</span> <span class="nv">limit</span> <span class="nv">between</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">compartment</span> <span class="nv">and</span> <span class="nv">deep</span> <span class="nv">compartment</span>,

    <span class="k">then</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">capacity</span> <span class="nv">is</span> <span class="nv">set</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">capacity</span>, <span class="nv">which</span>

    <span class="nv">is</span> <span class="nv">given</span> <span class="nv">a</span> <span class="nv">minimum</span> <span class="nv">value</span> <span class="nv">equal</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">capacity</span>. <span class="nv">Otherwise</span>, <span class="nv">the</span>

    <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">capacity</span> <span class="nv">remains</span> <span class="nv">unchanged</span>.

    <span class="k">If</span> <span class="nv">we</span> <span class="nv">are</span> <span class="nv">in</span> <span class="nv">automatic</span> <span class="nv">irrigation</span> <span class="nv">mode</span>, <span class="nv">and</span> <span class="nv">between</span> <span class="nv">phases</span> <span class="mi">0</span> <span class="nv">and</span> <span class="mi">6</span>, <span class="nv">and</span> <span class="k">if</span>

    <span class="nv">root_tank_capacity</span> <span class="nv">is</span> <span class="nv">less</span> <span class="nv">than</span> <span class="nv">surface_tank_capacity</span>, <span class="nv">meaning</span> <span class="nv">that</span> <span class="nv">roots</span>

    <span class="nv">haven</span><span class="s1">&#39;</span><span class="s">t reached the limit between the surface compartment and deep</span>

    <span class="nv">compartment</span>, <span class="k">then</span> <span class="nv">we</span> <span class="nv">define</span> <span class="nv">irrigation_tank_capacity</span> <span class="nv">as</span> <span class="nv">equal</span> <span class="nv">to</span>

    <span class="nv">surface_tank_capacity</span>, <span class="nv">that</span> <span class="nv">is</span> <span class="nv">to</span> <span class="nv">say</span>, <span class="nv">we</span> <span class="nv">give</span> <span class="nv">to</span> <span class="nv">irrigation_tank_capacity</span> <span class="nv">a</span>

    <span class="nv">minimum</span> <span class="nv">value</span> <span class="nv">that</span> <span class="nv">equals</span> <span class="nv">surface_tank_capacity</span>. <span class="k">else</span>, <span class="nv">we</span> <span class="k">do</span> <span class="nv">not</span> <span class="nv">modify</span>

    <span class="nv">irrigation_tank_capacity</span> <span class="nv">value</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">int</span><span class="ss">)</span>: <span class="nv">Index</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">time</span> <span class="nv">step</span> <span class="nv">being</span> <span class="nv">processed</span>.

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">xarray</span> <span class="nv">dataset</span><span class="ss">)</span>: <span class="nv">The</span> <span class="nv">input</span> <span class="nv">dataset</span> <span class="nv">containing</span> <span class="nv">all</span> <span class="nv">the</span> <span class="nv">information</span> <span class="nv">necessary</span> <span class="nv">to</span> <span class="nv">run</span> <span class="nv">the</span> <span class="nv">model</span>.

    <span class="nv">Returns</span>:

        <span class="nv">xarray</span> <span class="nv">dataset</span>: <span class="nv">The</span> <span class="nv">input</span> <span class="nv">dataset</span> <span class="nv">with</span> <span class="nv">updated</span> <span class="nv">values</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">irrigation</span> <span class="nv">tank</span> <span class="nv">capacity</span>.

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">2</span>

    <span class="nv">condition</span> <span class="o">=</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigAuto</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">==</span> <span class="nv">True</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span> <span class="o">&amp;</span> \

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">&lt;</span> <span class="mi">6</span><span class="ss">)</span>

    # <span class="nv">renaming</span> <span class="nv">ruIrr</span> <span class="nv">with</span> <span class="nv">irrigation_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruIrr</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

            #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_capacity</span>

            #<span class="o">//</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>]<span class="ss">)</span>,

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>],

            #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>],

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>],

            #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>],

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="ss">)</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">irrigation_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>, :, :],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_irrigation_tank_stock">update_irrigation_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_irrigation_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Update the Irrigation Tank Stock </p>
<p>In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and 
root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet 
reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock 
will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to 
surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td>int</td>
<td>Index of time step in data</td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td>xarray Dataset</td>
<td>Dataset that contains various data fields</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions.</td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_irrigation_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Update the Irrigation Tank Stock</span>

<span class="sd">    In case of automatic irrigation mode and if the simulation is between phases 0 and 6 and</span>

<span class="sd">    root_tank_capacity is lower than surface_tank_capacity (which indicates that the roots have not yet</span>

<span class="sd">    reached the limit between the surface compartment and deep compartment), the irrigation_tank_stock</span>

<span class="sd">    will be set to the value of surface_tank_stock, which means, it will take the minimum value equal to</span>

<span class="sd">    surface_tank_stock. For phase 7, the existing irrigation_tank_stock value will be kept unchanged.</span>

<span class="sd">    Args:</span>

<span class="sd">        j (int): Index of time step in data</span>

<span class="sd">        data (xarray Dataset): Dataset that contains various data fields</span>

<span class="sd">    Returns:</span>

<span class="sd">        xarray Dataset: updated data set with the irrigation_tank_stock field updated based on the conditions.</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigAuto&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">True</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>\<span class="w"></span>

<span class="w">        </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;numPhase&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 1</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! renaming stockIrr with irrigation_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#//data[&quot;stockIrr&quot;][j, :, :] = np.where(</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming stRurMax to root_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming ruSurf with surface_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="c1">#// (data[&quot;stRurMax&quot;] &lt; data[&quot;ruSurf&quot;]),</span><span class="w"></span>

<span class="w">            </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_capacity&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_capacity&quot;</span><span class="p">])[</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming stRuSurf to surface_tank_stock</span><span class="w"></span>

<span class="w">            </span><span class="c1">#// data[&quot;stRuSurf&quot;][j, :, :],</span><span class="w"></span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;surface_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span><span class="w"></span>

<span class="w">            </span><span class="c1">#! renaming stRur to root_tank_stock</span><span class="w"></span>

<span class="w">            </span><span class="c1">#// data[&quot;stRur&quot;][j, :, :],</span><span class="w"></span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;root_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span><span class="w"></span>

<span class="w">        </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;irrigation_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="p">:],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_mulch_water_stock">update_mulch_water_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_mulch_water_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Updating water stock in mulch (stockMc, mm) :</p>
<p>The water stock in mulch is updated by adding the gathered water (eauCaptee, mm)</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_mulch_water_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">):</span><span class="w"></span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Updating water stock in mulch (stockMc, mm) :</span>

<span class="sd">    The water stock in mulch is updated by adding the gathered water (eauCaptee, mm)</span>

<span class="sd">    Args:</span>

<span class="sd">        j (_type_): _description_</span>

<span class="sd">        data (_type_): _description_</span>

<span class="sd">    Returns:</span>

<span class="sd">        _type_: _description_</span>

<span class="sd">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="c1"># ! correction as broadcasting on xarray seems less constrained than on numpy</span><span class="w"></span>

<span class="w">    </span><span class="c1"># group 9</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! replacing eauCaptee by water_gathered_by_mulch</span><span class="w"></span>

<span class="w">    </span><span class="c1">#! replacing stockMc by mulch_water_stock</span><span class="w"></span>

<span class="w">    </span><span class="c1">#// data[&quot;stockMc&quot;][j:,:,:] = (data[&quot;stockMc&quot;][j,:,:] + data[&quot;eauCaptee&quot;][j,:,:]) # //[...,np.newaxis]</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">:,:,:]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mulch_water_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;water_gathered_by_mulch&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,:,:])</span><span class="w"> </span><span class="c1"># //[...,np.newaxis]</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_plant_transpiration">update_plant_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_plant_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>reajustement de la qte transpirable considerant que l'evap a eu lieu avant</p>
<p>mise a jour des stocks transpirables<br />
if plant transpiration is higher than the root tank stock, then plant 
transpiration is updated to be equal to the difference between the root tank stock and the
plant transpiration. Else, its value is unmodified.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_plant_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">reajustement</span> <span class="nv">de</span> <span class="nv">la</span> <span class="nv">qte</span> <span class="nv">transpirable</span> <span class="nv">considerant</span> <span class="nv">que</span> <span class="nv">l</span><span class="s1">&#39;</span><span class="s">evap a eu lieu avant</span>

    <span class="nv">mise</span> <span class="nv">a</span> <span class="nv">jour</span> <span class="nv">des</span> <span class="nv">stocks</span> <span class="nv">transpirables</span>

    <span class="k">if</span> <span class="nv">plant</span> <span class="nv">transpiration</span> <span class="nv">is</span> <span class="nv">higher</span> <span class="nv">than</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span>, <span class="k">then</span> <span class="nv">plant</span>

    <span class="nv">transpiration</span> <span class="nv">is</span> <span class="nv">updated</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">equal</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">difference</span> <span class="nv">between</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">and</span> <span class="nv">the</span>

    <span class="nv">plant</span> <span class="nv">transpiration</span>. <span class="k">Else</span>, <span class="nv">its</span> <span class="nv">value</span> <span class="nv">is</span> <span class="nv">unmodified</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">65</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        #<span class="o">//</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="mi">0</span><span class="ss">)</span>,

        <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="mi">0</span><span class="ss">)</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_capacity">update_root_tank_capacity</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_capacity</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>updating root_tank_capacity/stRurMax/ruRac, step 2 :</p>
<p>At the day of phase change, for phases strictly above 1, root_tank_capacity
is updated to be summed with the change in root water storage capacity delta_root_tank_capacity.
In other words, root_tank_capacity is incremented by the change in root water
storage capacity linked to root growth.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_root_tank_capacity</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">updating</span> <span class="nv">root_tank_capacity</span><span class="o">/</span><span class="nv">stRurMax</span><span class="o">/</span><span class="nv">ruRac</span>, <span class="nv">step</span> <span class="mi">2</span> :

    <span class="nv">At</span> <span class="nv">the</span> <span class="nv">day</span> <span class="nv">of</span> <span class="nv">phase</span> <span class="nv">change</span>, <span class="k">for</span> <span class="nv">phases</span> <span class="nv">strictly</span> <span class="nv">above</span> <span class="mi">1</span>, <span class="nv">root_tank_capacity</span>

    <span class="nv">is</span> <span class="nv">updated</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">summed</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">change</span> <span class="nv">in</span> <span class="nv">root</span> <span class="nv">water</span> <span class="nv">storage</span> <span class="nv">capacity</span> <span class="nv">delta_root_tank_capacity</span>.

    <span class="nv">In</span> <span class="nv">other</span> <span class="nv">words</span>, <span class="nv">root_tank_capacity</span> <span class="nv">is</span> <span class="nv">incremented</span> <span class="nv">by</span> <span class="nv">the</span> <span class="nv">change</span> <span class="nv">in</span> <span class="nv">root</span> <span class="nv">water</span>

    <span class="nv">storage</span> <span class="nv">capacity</span> <span class="nv">linked</span> <span class="nv">to</span> <span class="nv">root</span> <span class="nv">growth</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">17</span>

    # <span class="o">!</span> <span class="nv">simplified</span> <span class="nv">conditions</span>

    # <span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    # <span class="o">//</span>     <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span><span class="ss">)</span>,

    # <span class="o">//</span>     <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    # <span class="o">//</span>         <span class="nv">np</span>.<span class="nv">invert</span><span class="ss">((</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">))</span>,

    # <span class="o">//</span>         <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">deltaRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    # <span class="o">//</span>         <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    # <span class="o">//</span>     <span class="ss">)</span>,

    # <span class="o">//</span>     <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    # <span class="o">//</span> <span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">deltaRur</span> <span class="nv">to</span> <span class="nv">delta_root_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">numPhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">1</span><span class="ss">)</span> <span class="o">&amp;</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">changePhase</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">==</span> <span class="mi">1</span><span class="ss">)</span>,

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">deltaRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">delta_root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_stock">update_root_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>updating root_tank_stock/stRur/stockrac :</p>
<p>At the day of phase change, for phases strictly above 1, and for which
the root_tank_capacity is above surface_tank_capacity (meaning that
roots go beyond the surface water storage capacity), root_tank_stock
 is incremented by delta_root_tank_capacity.</p>
<p>However, if root_tank_capacity is BELOW surface_tank_capacity (meaning
that roots do not plunge into the deep reservoir), root_tank_stock is
updated to be equal to surface_tank_stock minus 1/10th of the
surface_tank_capacity, multiplied by the ratio between
root_tank_capacity and surface_tank_capacity. That is to say "we take at
the prorata of depth and surface stock".</p>
<p>For any other day, root_tank_stock is unchanged.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="n">update_root_tank_stock</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="k">data</span><span class="p">)</span><span class="err">:</span><span class="w"></span>

<span class="w">    </span><span class="ss">&quot;&quot;&quot;</span>

<span class="ss">    updating root_tank_stock/stRur/stockrac :</span>

<span class="ss">    At the day of phase change, for phases strictly above 1, and for which</span>

<span class="ss">    the root_tank_capacity is above surface_tank_capacity (meaning that</span>

<span class="ss">    roots go beyond the surface water storage capacity), root_tank_stock</span>

<span class="ss">     is incremented by delta_root_tank_capacity.</span>

<span class="ss">    However, if root_tank_capacity is BELOW surface_tank_capacity (meaning</span>

<span class="ss">    that roots do not plunge into the deep reservoir), root_tank_stock is</span>

<span class="ss">    updated to be equal to surface_tank_stock minus 1/10th of the</span>

<span class="ss">    surface_tank_capacity, multiplied by the ratio between</span>

<span class="ss">    root_tank_capacity and surface_tank_capacity. That is to say &quot;</span><span class="n">we</span><span class="w"> </span><span class="n">take</span><span class="w"> </span><span class="k">at</span><span class="w"></span>

<span class="w">    </span><span class="n">the</span><span class="w"> </span><span class="n">prorata</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">depth</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">surface</span><span class="w"> </span><span class="n">stock</span><span class="ss">&quot;.</span>

<span class="ss">    For any other day, root_tank_stock is unchanged.</span>

<span class="ss">    Args:</span>

<span class="ss">        j (_type_): _description_</span>

<span class="ss">        data (_type_): _description_</span>

<span class="ss">    Returns:</span>

<span class="ss">        _type_: _description_</span>

<span class="ss">    &quot;&quot;&quot;</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="mi">18</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="err">!</span><span class="w"> </span><span class="n">simplified</span><span class="w"> </span><span class="n">conditions</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">invert</span><span class="p">((</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;changePhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)),</span><span class="w"></span>

<span class="w">    </span><span class="k">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;numPhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;changePhase&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRur</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">root_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRur&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">    </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;root_tank_stock&quot;</span><span class="o">][</span><span class="n">j:,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="k">condition</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">xr</span><span class="p">.</span><span class="k">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRurMax</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">root_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">ruSurf</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">surface_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRurMax&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;ruSurf&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">),</span><span class="w"></span>

<span class="w">            </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;root_tank_capacity&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;surface_tank_capacity&quot;</span><span class="o">]</span><span class="p">),</span><span class="w"></span>

<span class="w">            </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRur</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">root_tank_stock</span><span class="w"></span>

<span class="w">            </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">deltaRur</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">delta_root_tank_capacity</span><span class="w"></span>

<span class="w">            </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRur&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;deltaRur&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;root_tank_stock&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;delta_root_tank_capacity&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRur</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">root_tank_stock</span><span class="w"></span>

<span class="w">            </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRuSurf</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">surface_tank_stock</span><span class="w"></span>

<span class="w">            </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">((</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRuSurf&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;ruSurf&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRurMax&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;ruSurf&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"></span>

<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">((</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;surface_tank_stock&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;surface_tank_capacity&quot;</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="k">data</span><span class="o">[</span><span class="n">&quot;root_tank_capacity&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;surface_tank_capacity&quot;</span><span class="o">]</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="p">).</span><span class="n">expand_dims</span><span class="p">(</span><span class="ss">&quot;time&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="err">#!</span><span class="w"> </span><span class="n">renaming</span><span class="w"> </span><span class="n">stRur</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">root_tank_stock</span><span class="w"></span>

<span class="w">        </span><span class="err">#</span><span class="o">//</span><span class="w"> </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;stRur&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="k">data</span><span class="o">[</span><span class="n">&quot;root_tank_stock&quot;</span><span class="o">][</span><span class="n">j,:,:</span><span class="o">]</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_root_tank_stock_step_2">update_root_tank_stock_step_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_stock_step_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>Finally, we update root tank stock (root_tank_stock) with the computed</p>
<p>values First we increment root_tank_stock with transpirable water
(eauTranspi), within the limits of root_tank_capacity. Then, we limit the
value of root_tank_stock within total_tank_stock</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_root_tank_stock_step_2</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">Finally</span>, <span class="nv">we</span> <span class="nv">update</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="ss">(</span><span class="nv">root_tank_stock</span><span class="ss">)</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">computed</span>

    <span class="nv">values</span> <span class="nv">First</span> <span class="nv">we</span> <span class="nv">increment</span> <span class="nv">root_tank_stock</span> <span class="nv">with</span> <span class="nv">transpirable</span> <span class="nv">water</span>

    <span class="ss">(</span><span class="nv">eauTranspi</span><span class="ss">)</span>, <span class="nv">within</span> <span class="nv">the</span> <span class="nv">limits</span> <span class="nv">of</span> <span class="nv">root_tank_capacity</span>. <span class="k">Then</span>, <span class="nv">we</span> <span class="nv">limit</span> <span class="nv">the</span>

    <span class="nv">value</span> <span class="nv">of</span> <span class="nv">root_tank_stock</span> <span class="nv">within</span> <span class="nv">total_tank_stock</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">groupe</span> <span class="mi">39</span>

    # <span class="nv">Rempli</span> <span class="nv">res</span> <span class="nv">racines</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauTranspi</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauTranspi</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    # <span class="nv">groupe</span> <span class="mi">40</span>

    # <span class="nv">essais</span> <span class="nv">stTot</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_stock_with_transpiration">update_root_tank_stock_with_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_stock_with_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p><em>summary</em></p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_root_tank_stock_with_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span><span class="s">_summary_</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">67</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_root_tank_stock_with_water_consumption">update_root_tank_stock_with_water_consumption</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_root_tank_stock_with_water_consumption</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates root tank stock according to water consumption.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_root_tank_stock_with_water_consumption</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">according</span> <span class="nv">to</span> <span class="nv">water</span> <span class="nv">consumption</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">64</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_struprec">update_stRuPrec</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_stRuPrec</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function performs the update of</p>
<p>total_tank_stock_previous_value/stRuPrec in the reservoir filling wrapper
function. It will decrease the total_tank_stock_previous_value depending on
the variation of transpirable water and height of humectation front.</p>
<p>test image markdown <img alt="Drag Racing" src="Dragster.jpg" /></p>
<p>In this function, if the variation of transpirable water
(delta_total_tank_stock) increases above the depth of humectation front
(hum), if the depth of humectation front (hum) is above the
root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which
should be the case for most of the simulations that will be single-season),
and if the depth of humectation front (hum) has decreased since the previous
day (condition 3 passed), then total_tank_stock_previous_value equals 0. If
the depth of humectation front did not change or increased since the
previous day (humPrec), then total_tank_stock_previous_value is unchanged.</p>
<p>Notably, root_tank_capacity_previous_season is initialized at 0, and takes
another value only at end of cycle ; hum is initialized at a value different
from 0 and evolves daily between delta_total_tank_stock and
total_tank_capacity.</p>
<p>humPrec is initialized with the same value as hum. However, in the
update_humPrec_for_end_of_cycle function, at the day of transition between
phase 7 and phase 0, it takes hum as value, with a minimum bound of
surface_tank_capacity.</p>
<p>Starting from second simulation season (root_tank_capacity_previous_season
!= 0), if the variation of transpirable water (delta_total_tank_stock)
increases above the depth of humectation front (hum), and if the depth of
humectation front stays below or equel to the total soil capacity
(conditions 1 and 2 passed), then we decrease the value of
total_tank_stock_previous_value by a the difference of water height between
the variation of total tank stock (delta_total_tank_stock) and the depth of
humectation front (hum), proportionally to the filling of the root tank
capacity of previous season (stRurPrec). Thus, if the root tank is empty,
total_tank_stock_previous_value will remain unchanged, and if the root tank
is full, total_tank_stock_previous_value will be decreased up to the amount
of water making the difference between quantity of water for humectation
front and the variation in daily transpirable water.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="nf">update_stRuPrec</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">This</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">performs</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">total_tank_stock_previous_value</span><span class="o">/</span><span class="n">stRuPrec</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">reservoir</span><span class="w"> </span><span class="n">filling</span><span class="w"> </span><span class="n">wrapper</span><span class="w"></span>

<span class="w">    </span><span class="n">function</span><span class="p">.</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">decrease</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total_tank_stock_previous_value</span><span class="w"> </span><span class="n">depending</span><span class="w"> </span><span class="n">on</span><span class="w"></span>

<span class="w">    </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">test</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="n">markdown</span><span class="w"> </span><span class="o">!</span><span class="p">[</span><span class="n">Drag</span><span class="w"> </span><span class="n">Racing</span><span class="p">](</span><span class="n">Dragster</span><span class="p">.</span><span class="n">jpg</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">delta_total_tank_stock</span><span class="p">)</span><span class="w"> </span><span class="n">increases</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">hum</span><span class="p">),</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="p">(</span><span class="n">hum</span><span class="p">)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">root_tank_capacity_previous_season</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">failed</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"></span>

<span class="w">    </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="no">for</span><span class="w"> </span><span class="no">most</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">simulations</span><span class="w"> </span><span class="no">that</span><span class="w"> </span><span class="no">will</span><span class="w"> </span><span class="no">be</span><span class="w"> </span><span class="no">single</span><span class="o">-</span><span class="no">season</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="no">and</span><span class="w"> </span><span class="no">if</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">depth</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">humectation</span><span class="w"> </span><span class="no">front</span><span class="w"> </span><span class="p">(</span><span class="no">hum</span><span class="p">)</span><span class="w"> </span><span class="no">has</span><span class="w"> </span><span class="no">decreased</span><span class="w"> </span><span class="no">since</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">previous</span><span class="w"></span>

<span class="w">    </span><span class="no">day</span><span class="w"> </span><span class="p">(</span><span class="no">condition</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">passed</span><span class="p">),</span><span class="w"> </span><span class="no">then</span><span class="w"> </span><span class="no">total_tank_stock_previous_value</span><span class="w"> </span><span class="no">equals</span><span class="w"> </span><span class="mf">0.</span><span class="w"> </span><span class="no">If</span><span class="w"></span>

<span class="w">    </span><span class="no">the</span><span class="w"> </span><span class="no">depth</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">humectation</span><span class="w"> </span><span class="no">front</span><span class="w"> </span><span class="no">did</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">change</span><span class="w"> </span><span class="no">or</span><span class="w"> </span><span class="no">increased</span><span class="w"> </span><span class="no">since</span><span class="w"> </span><span class="no">the</span><span class="w"></span>

<span class="w">    </span><span class="no">previous</span><span class="w"> </span><span class="no">day</span><span class="w"> </span><span class="p">(</span><span class="no">humPrec</span><span class="p">),</span><span class="w"> </span><span class="no">then</span><span class="w"> </span><span class="no">total_tank_stock_previous_value</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">unchanged</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="no">Notably</span><span class="p">,</span><span class="w"> </span><span class="no">root_tank_capacity_previous_season</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">initialized</span><span class="w"> </span><span class="no">at</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">takes</span><span class="w"></span>

<span class="w">    </span><span class="no">another</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="no">only</span><span class="w"> </span><span class="no">at</span><span class="w"> </span><span class="no">end</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">cycle</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">hum</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">different</span><span class="w"></span>

<span class="w">    </span><span class="n">from</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">evolves</span><span class="w"> </span><span class="n">daily</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="n">delta_total_tank_stock</span><span class="w"> </span><span class="n">and</span><span class="w"></span>

<span class="w">    </span><span class="n">total_tank_capacity</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">humPrec</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">hum</span><span class="p">.</span><span class="w"> </span><span class="n">However</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">update_humPrec_for_end_of_cycle</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transition</span><span class="w"> </span><span class="n">between</span><span class="w"></span>

<span class="w">    </span><span class="n">phase</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">hum</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">minimum</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">surface_tank_capacity</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">Starting</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="n">simulation</span><span class="w"> </span><span class="n">season</span><span class="w"> </span><span class="p">(</span><span class="n">root_tank_capacity_previous_season</span><span class="w"></span>

<span class="w">    </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="p">(</span><span class="n">delta_total_tank_stock</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">increases</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="p">(</span><span class="n">hum</span><span class="p">),</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="n">stays</span><span class="w"> </span><span class="n">below</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">equel</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">soil</span><span class="w"> </span><span class="n">capacity</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">conditions</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">passed</span><span class="p">),</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">decrease</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">total_tank_stock_previous_value</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="n">between</span><span class="w"></span>

<span class="w">    </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">tank</span><span class="w"> </span><span class="n">stock</span><span class="w"> </span><span class="p">(</span><span class="n">delta_total_tank_stock</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="p">(</span><span class="n">hum</span><span class="p">),</span><span class="w"> </span><span class="n">proportionally</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">filling</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">tank</span><span class="w"></span>

<span class="w">    </span><span class="n">capacity</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">season</span><span class="w"> </span><span class="p">(</span><span class="n">stRurPrec</span><span class="p">).</span><span class="w"> </span><span class="n">Thus</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">tank</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"></span>

<span class="w">    </span><span class="n">total_tank_stock_previous_value</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">remain</span><span class="w"> </span><span class="n">unchanged</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">tank</span><span class="w"></span>

<span class="w">    </span><span class="n">is</span><span class="w"> </span><span class="n">full</span><span class="p">,</span><span class="w"> </span><span class="n">total_tank_stock_previous_value</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">decreased</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">amount</span><span class="w"></span>

<span class="w">    </span><span class="n">of</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">making</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="n">quantity</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">humectation</span><span class="w"></span>

<span class="w">    </span><span class="n">front</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">daily</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="nl">Args</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">    </span><span class="nl">Returns</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="nl">_type_</span><span class="p">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition_1</span><span class="p">,</span><span class="w"> </span><span class="n">condition_2</span><span class="p">,</span><span class="w"> </span><span class="n">condition_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">conditions_rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="cp"># group 32</span>

<span class="w">    </span><span class="cp">#! renaming stRuPrec with total_tank_stock_previous_value</span>

<span class="w">    </span><span class="cp">#</span><span class="c1">// data[&quot;stRuPrec&quot;][j:,:,:] = np.where(</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition_1</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="n">condition_2</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="cp">#! replacing stRurPrec with ratio formula</span>

<span class="w">            </span><span class="cp">#! renaming stRuVar with delta_total_tank_stock</span>

<span class="w">            </span><span class="cp">#! renaming stRuPrec with total_tank_stock_previous_value</span>

<span class="w">            </span><span class="cp">#</span><span class="c1">//np.maximum(0, data[&quot;stRuPrec&quot;][j,:,:] - (data[&quot;stRuVar&quot;][j,:,:] - data[&quot;hum&quot;][j,:,:]) * data[&quot;stRurPrec&quot;][j,:,:]),</span>

<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]),</span><span class="w"></span>

<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="n">condition_3</span><span class="p">,</span><span class="w"></span>

<span class="w">                </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>

<span class="w">                </span><span class="cp">#! renaming stRuPrec with total_tank_stock_previous_value</span>

<span class="w">                </span><span class="cp">#</span><span class="c1">// data[&quot;stRuPrec&quot;][j,:,:],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">],</span><span class="w"></span>

<span class="w">            </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="cp">#! renaming stRuPrec with total_tank_stock_previous_value</span>

<span class="w">        </span><span class="cp">#</span><span class="c1">// data[&quot;stRuPrec&quot;][j,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock_previous_value&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_struprec_for_end_of_cycle">update_stRuPrec_for_end_of_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_stRuPrec_for_end_of_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>when the phase changes from 7 to 1, the stRuPrec (mm, previous water</p>
<p>storage capacity of the global reservoir) is set to equal the differe,ce
between stTot (mm, total water storage capacity of the global reservoir)
and stRurSurf (mm, water storage capacity of the surface reservoir)</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_stRuPrec_for_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">when</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">changes</span> <span class="nv">from</span> <span class="mi">7</span> <span class="nv">to</span> <span class="mi">1</span>, <span class="nv">the</span> <span class="nv">stRuPrec</span> <span class="ss">(</span><span class="nv">mm</span>, <span class="nv">previous</span> <span class="nv">water</span>

    <span class="nv">storage</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">global</span> <span class="nv">reservoir</span><span class="ss">)</span> <span class="nv">is</span> <span class="nv">set</span> <span class="nv">to</span> <span class="nv">equal</span> <span class="nv">the</span> <span class="nv">differe</span>,<span class="nv">ce</span>

    <span class="nv">between</span> <span class="nv">stTot</span> <span class="ss">(</span><span class="nv">mm</span>, <span class="nv">total</span> <span class="nv">water</span> <span class="nv">storage</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">global</span> <span class="nv">reservoir</span><span class="ss">)</span>

    <span class="nv">and</span> <span class="nv">stRurSurf</span> <span class="ss">(</span><span class="nv">mm</span>, <span class="nv">water</span> <span class="nv">storage</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">reservoir</span><span class="ss">)</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">24</span>

    #<span class="o">!</span> <span class="nv">stRurSurf</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">defined</span>... <span class="nv">we</span> <span class="nv">may</span> <span class="nv">want</span> <span class="nv">to</span> <span class="nv">drop</span> <span class="nv">this</span> <span class="nv">group</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="nv">condition_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuPrec</span> <span class="nv">to</span> <span class="nv">total_tank_stock_previous_value</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock_previous_value</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_stock</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], # <span class="nv">essai</span> <span class="nv">stTot</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuPrec</span> <span class="nv">to</span> <span class="nv">total_tank_stock_previous_value</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock_previous_value</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_strurmaxprec_for_end_of_cycle">update_stRurMaxPrec_for_end_of_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_stRurMaxPrec_for_end_of_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>When the phase changes from 7 to 1, the stRurMaxPrec (mm, previous</p>
<p>maximum water capacity to root front) is set to equal root_tank_capacity
(mm). Value is broadcasted along time dimension.
For every other day, it keeps its initial value of 0.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_stRurMaxPrec_for_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">When</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">changes</span> <span class="nv">from</span> <span class="mi">7</span> <span class="nv">to</span> <span class="mi">1</span>, <span class="nv">the</span> <span class="nv">stRurMaxPrec</span> <span class="ss">(</span><span class="nv">mm</span>, <span class="nv">previous</span>

    <span class="nv">maximum</span> <span class="nv">water</span> <span class="nv">capacity</span> <span class="nv">to</span> <span class="nv">root</span> <span class="nv">front</span><span class="ss">)</span> <span class="nv">is</span> <span class="nv">set</span> <span class="nv">to</span> <span class="nv">equal</span> <span class="nv">root_tank_capacity</span>

    <span class="ss">(</span><span class="nv">mm</span><span class="ss">)</span>. <span class="nv">Value</span> <span class="nv">is</span> <span class="nv">broadcasted</span> <span class="nv">along</span> <span class="nv">time</span> <span class="nv">dimension</span>.

    <span class="k">For</span> <span class="nv">every</span> <span class="nv">other</span> <span class="nv">day</span>, <span class="nv">it</span> <span class="nv">keeps</span> <span class="nv">its</span> <span class="nv">initial</span> <span class="nv">value</span> <span class="nv">of</span> <span class="mi">0</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">22</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="nv">condition_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMaxPrec</span> <span class="nv">to</span> <span class="nv">root_tank_capacity_previous_season</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMaxPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity_previous_season</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMaxPrec</span> <span class="nv">to</span> <span class="nv">root_tank_capacity_previous_season</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMaxPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity_previous_season</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_strurprec_for_end_of_cycle">update_stRurPrec_for_end_of_cycle</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_stRurPrec_for_end_of_cycle</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>when the phase changes from 7 to 1, stRurPrec is set to equal</p>
<p>stRur/stRurMax, that is to say the ratio of the water storage capacity of
the root reservoir. Otherwise, it stays at its initial value of 0. Its value
is broadcasted along j.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_stRurPrec_for_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">when</span> <span class="nv">the</span> <span class="nv">phase</span> <span class="nv">changes</span> <span class="nv">from</span> <span class="mi">7</span> <span class="nv">to</span> <span class="mi">1</span>, <span class="nv">stRurPrec</span> <span class="nv">is</span> <span class="nv">set</span> <span class="nv">to</span> <span class="nv">equal</span>

    <span class="nv">stRur</span><span class="o">/</span><span class="nv">stRurMax</span>, <span class="nv">that</span> <span class="nv">is</span> <span class="nv">to</span> <span class="nv">say</span> <span class="nv">the</span> <span class="nv">ratio</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">storage</span> <span class="nv">capacity</span> <span class="nv">of</span>

    <span class="nv">the</span> <span class="nv">root</span> <span class="nv">reservoir</span>. <span class="nv">Otherwise</span>, <span class="nv">it</span> <span class="nv">stays</span> <span class="nv">at</span> <span class="nv">its</span> <span class="nv">initial</span> <span class="nv">value</span> <span class="nv">of</span> <span class="mi">0</span>. <span class="nv">Its</span> <span class="nv">value</span>

    <span class="nv">is</span> <span class="nv">broadcasted</span> <span class="nv">along</span> <span class="nv">j</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">23</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="nv">condition_end_of_cycle</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">to</span> <span class="nv">root_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurPrec</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_surface_tank_stock">update_surface_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_surface_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the value of surface_tank_stock.</p>
<p>We update surface_tank_stock by adding the eauDispo, which as this point is
the water available from 1) rain, 2) irrigation for the day after estimation
of intake by mulch, and 3) runoff. However, we do not allow
surface_tank_stock to exceed 110% of the surface_tank_capacity.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_surface_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">value</span> <span class="nv">of</span> <span class="nv">surface_tank_stock</span>.

    <span class="nv">We</span> <span class="nv">update</span> <span class="nv">surface_tank_stock</span> <span class="nv">by</span> <span class="nv">adding</span> <span class="nv">the</span> <span class="nv">eauDispo</span>, <span class="nv">which</span> <span class="nv">as</span> <span class="nv">this</span> <span class="nv">point</span> <span class="nv">is</span>

    <span class="nv">the</span> <span class="nv">water</span> <span class="nv">available</span> <span class="nv">from</span> <span class="mi">1</span><span class="ss">)</span> <span class="nv">rain</span>, <span class="mi">2</span><span class="ss">)</span> <span class="nv">irrigation</span> <span class="k">for</span> <span class="nv">the</span> <span class="nv">day</span> <span class="nv">after</span> <span class="nv">estimation</span>

    <span class="nv">of</span> <span class="nv">intake</span> <span class="nv">by</span> <span class="nv">mulch</span>, <span class="nv">and</span> <span class="mi">3</span><span class="ss">)</span> <span class="nv">runoff</span>. <span class="nv">However</span>, <span class="nv">we</span> <span class="k">do</span> <span class="nv">not</span> <span class="nv">allow</span>

    <span class="nv">surface_tank_stock</span> <span class="nv">to</span> <span class="nv">exceed</span> <span class="mi">110</span><span class="o">%</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">surface_tank_capacity</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">27</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurf</span> <span class="nv">to</span> <span class="nv">surface_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauDispo</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">to</span> <span class="nv">surface_tank_capacity</span>

        #<span class="o">//</span> <span class="mi">1</span>.<span class="mi">1</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]

        <span class="mi">1</span>.<span class="mi">1</span> <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>]

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_surface_tank_stock_according_to_transpiration">update_surface_tank_stock_according_to_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_surface_tank_stock_according_to_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the surface tank stock to reflect plant</p>
<p>transpiration.</p>
<p>if the root tank stock is above 0, then surface tank stock is updated by
subtracting the plant transpiration modulated by the ratio between the
transpirable water and the root tank stock.</p>
<p>That is to say, the more transpirable water is close to the root tank stock,
the more of transpirated water by plant will be removed from surface tank stock.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_surface_tank_stock_according_to_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">to</span> <span class="nv">reflect</span> <span class="nv">plant</span>

    <span class="nv">transpiration</span>.

    <span class="k">if</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">is</span> <span class="nv">above</span> <span class="mi">0</span>, <span class="k">then</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">is</span> <span class="nv">updated</span> <span class="nv">by</span>

    <span class="nv">subtracting</span> <span class="nv">the</span> <span class="nv">plant</span> <span class="nv">transpiration</span> <span class="nv">modulated</span> <span class="nv">by</span> <span class="nv">the</span> <span class="nv">ratio</span> <span class="nv">between</span> <span class="nv">the</span>

    <span class="nv">transpirable</span> <span class="nv">water</span> <span class="nv">and</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span>.

    <span class="nv">That</span> <span class="nv">is</span> <span class="nv">to</span> <span class="nv">say</span>, <span class="nv">the</span> <span class="nv">more</span> <span class="nv">transpirable</span> <span class="nv">water</span> <span class="nv">is</span> <span class="nv">close</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">stock</span>,

    <span class="nv">the</span> <span class="nv">more</span> <span class="nv">of</span> <span class="nv">transpirated</span> <span class="nv">water</span> <span class="nv">by</span> <span class="nv">plant</span> <span class="nv">will</span> <span class="nv">be</span> <span class="nv">removed</span> <span class="nv">from</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">stock</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">66</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">surface_tank_stock</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span>,

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="mi">0</span>,

        #<span class="o">//</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="mi">1</span><span class="ss">))</span>, <span class="mi">0</span><span class="ss">)</span>,

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_stock</span>

        #<span class="o">//</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="mi">1</span><span class="ss">))</span>, <span class="mi">0</span><span class="ss">)</span>,

        <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span>

            <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> \

                <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">np</span>.<span class="nv">minimum</span><span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">trSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="o">/</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:], <span class="mi">1</span><span class="ss">))</span>,

            <span class="mi">0</span>,

        <span class="ss">)</span>,

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock">update_total_tank_stock</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This functions updates the value of total_tank_stock with the value of</p>
<p>transpirable water.</p>
<p>? why incrementing stTot by eauTranspi ?
? we then consider that transpirable water is the water that fills the total_tank_stock ?</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_total_tank_stock</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">functions</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">value</span> <span class="nv">of</span> <span class="nv">total_tank_stock</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">value</span> <span class="nv">of</span>

    <span class="nv">transpirable</span> <span class="nv">water</span>.

    ? <span class="nv">why</span> <span class="nv">incrementing</span> <span class="nv">stTot</span> <span class="nv">by</span> <span class="nv">eauTranspi</span> ?

    ? <span class="nv">we</span> <span class="k">then</span> <span class="nv">consider</span> <span class="nv">that</span> <span class="nv">transpirable</span> <span class="nv">water</span> <span class="nv">is</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">that</span> <span class="nv">fills</span> <span class="nv">the</span> <span class="nv">total_tank_stock</span> ?

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">29</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">with</span> <span class="nv">total_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauTranspi</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>.<span class="nv">copy</span><span class="ss">()</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">+</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">eauTranspi</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock_step_2">update_total_tank_stock_step_2</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock_step_2</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function performs the second update of total_tank_stock/stTot/stRu in the</p>
<p>reservoir filling wrapper function. It will increase the total_tank_stock
depending on the variation of transpirable water and height of humectation
front.</p>
<p>test image markdown
<img alt="Drag Racing" src="Dragster.jpg" /></p>
<p>In this function, if the variation of transpirable water
(delta_total_tank_stock) increases above the depth of humectation front
(hum), if the depth of humectation front (hum) is above the
root_tank_capacity_previous_season (condition 1 passed, and 2 failed, which
should be the case for most of the simulations that will be single-season),
and if the depth of humectation front (hum) has decreased since the previous
day, then total_tank_stock takes delta_total_tank_stock as value. If the
depth of humectation front did not change or increased since the previous
day (humPrec), then total_tank_stock is unchanged.</p>
<p>Notably, root_tank_capacity_previous_season is initialized at 0, and takes
another value only at end of cycle ; hum is initialized at a value different
from 0 and evolves daily between delta_total_tank_stock and
total_tank_capacity.</p>
<p>humPrec is initialized with the same value as hum. However, in the
update_humPrec_for_end_of_cycle function, at the day of transition between
phase 7 and phase 0, it takes hum as value, with a minimum bound of
surface_tank_capacity.</p>
<p>Starting from second simulation season (root_tank_capacity_previous_season
!= 0), if the variation of transpirable water (delta_total_tank_stock)
increases above the depth of humectation front (hum), and if the depth of
humectation front stays below or equel to the total soil capacity
(conditions 1 and 2 passed), then we increase the value of total_tank_stock
by a the difference of water height between the variation of total tank
stock (delta_total_tank_stock) and the depth of humectation front (hum),
proportionally to the filling of the root tank capacity of previous season
(stRurPrec). Thus, if the root tank is empty, total_tank_stock will remain
unchanged, and if the root tank is full, total_tank_stock will be increased
up to the amount of water making the difference between quantity of water
for humectation front and the variation in daily transpirable water.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="n">def</span><span class="w"> </span><span class="nf">update_total_tank_stock_step_2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="o">:</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">This</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">performs</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="n">update</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">total_tank_stock</span><span class="o">/</span><span class="n">stTot</span><span class="o">/</span><span class="n">stRu</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">reservoir</span><span class="w"> </span><span class="n">filling</span><span class="w"> </span><span class="n">wrapper</span><span class="w"> </span><span class="n">function</span><span class="p">.</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">increase</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="n">depending</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"></span>

<span class="w">    </span><span class="n">front</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">test</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="n">markdown</span><span class="w"></span>

<span class="w">    </span><span class="o">!</span><span class="p">[</span><span class="n">Drag</span><span class="w"> </span><span class="n">Racing</span><span class="p">](</span><span class="n">Dragster</span><span class="p">.</span><span class="n">jpg</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">In</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">delta_total_tank_stock</span><span class="p">)</span><span class="w"> </span><span class="n">increases</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">hum</span><span class="p">),</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="p">(</span><span class="n">hum</span><span class="p">)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">root_tank_capacity_previous_season</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">passed</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">failed</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"></span>

<span class="w">    </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="no">for</span><span class="w"> </span><span class="no">most</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">simulations</span><span class="w"> </span><span class="no">that</span><span class="w"> </span><span class="no">will</span><span class="w"> </span><span class="no">be</span><span class="w"> </span><span class="no">single</span><span class="o">-</span><span class="no">season</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="no">and</span><span class="w"> </span><span class="no">if</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">depth</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">humectation</span><span class="w"> </span><span class="no">front</span><span class="w"> </span><span class="p">(</span><span class="no">hum</span><span class="p">)</span><span class="w"> </span><span class="no">has</span><span class="w"> </span><span class="no">decreased</span><span class="w"> </span><span class="no">since</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">previous</span><span class="w"></span>

<span class="w">    </span><span class="no">day</span><span class="p">,</span><span class="w"> </span><span class="no">then</span><span class="w"> </span><span class="no">total_tank_stock</span><span class="w"> </span><span class="no">takes</span><span class="w"> </span><span class="no">delta_total_tank_stock</span><span class="w"> </span><span class="no">as</span><span class="w"> </span><span class="no">value</span><span class="p">.</span><span class="w"> </span><span class="no">If</span><span class="w"> </span><span class="no">the</span><span class="w"></span>

<span class="w">    </span><span class="no">depth</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">humectation</span><span class="w"> </span><span class="no">front</span><span class="w"> </span><span class="no">did</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">change</span><span class="w"> </span><span class="no">or</span><span class="w"> </span><span class="no">increased</span><span class="w"> </span><span class="no">since</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">previous</span><span class="w"></span>

<span class="w">    </span><span class="no">day</span><span class="w"> </span><span class="p">(</span><span class="no">humPrec</span><span class="p">),</span><span class="w"> </span><span class="no">then</span><span class="w"> </span><span class="no">total_tank_stock</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">unchanged</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="no">Notably</span><span class="p">,</span><span class="w"> </span><span class="no">root_tank_capacity_previous_season</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">initialized</span><span class="w"> </span><span class="no">at</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">and</span><span class="w"> </span><span class="no">takes</span><span class="w"></span>

<span class="w">    </span><span class="no">another</span><span class="w"> </span><span class="no">value</span><span class="w"> </span><span class="no">only</span><span class="w"> </span><span class="no">at</span><span class="w"> </span><span class="no">end</span><span class="w"> </span><span class="no">of</span><span class="w"> </span><span class="no">cycle</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">hum</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">different</span><span class="w"></span>

<span class="w">    </span><span class="n">from</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">evolves</span><span class="w"> </span><span class="n">daily</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="n">delta_total_tank_stock</span><span class="w"> </span><span class="n">and</span><span class="w"></span>

<span class="w">    </span><span class="n">total_tank_capacity</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">humPrec</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">hum</span><span class="p">.</span><span class="w"> </span><span class="n">However</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"></span>

<span class="w">    </span><span class="n">update_humPrec_for_end_of_cycle</span><span class="w"> </span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">day</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transition</span><span class="w"> </span><span class="n">between</span><span class="w"></span>

<span class="w">    </span><span class="n">phase</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="n">hum</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">minimum</span><span class="w"> </span><span class="n">bound</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">surface_tank_capacity</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="n">Starting</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="n">simulation</span><span class="w"> </span><span class="n">season</span><span class="w"> </span><span class="p">(</span><span class="n">root_tank_capacity_previous_season</span><span class="w"></span>

<span class="w">    </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="p">(</span><span class="n">delta_total_tank_stock</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="n">increases</span><span class="w"> </span><span class="n">above</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="p">(</span><span class="n">hum</span><span class="p">),</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"></span>

<span class="w">    </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="n">stays</span><span class="w"> </span><span class="n">below</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">equel</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">soil</span><span class="w"> </span><span class="n">capacity</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">conditions</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">passed</span><span class="p">),</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">we</span><span class="w"> </span><span class="n">increase</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">total_tank_stock</span><span class="w"></span>

<span class="w">    </span><span class="n">by</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">tank</span><span class="w"></span>

<span class="w">    </span><span class="n">stock</span><span class="w"> </span><span class="p">(</span><span class="n">delta_total_tank_stock</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="p">(</span><span class="n">hum</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="n">proportionally</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">filling</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">tank</span><span class="w"> </span><span class="n">capacity</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">season</span><span class="w"></span>

<span class="w">    </span><span class="p">(</span><span class="n">stRurPrec</span><span class="p">).</span><span class="w"> </span><span class="n">Thus</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">tank</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">empty</span><span class="p">,</span><span class="w"> </span><span class="n">total_tank_stock</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">remain</span><span class="w"></span>

<span class="w">    </span><span class="n">unchanged</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">tank</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">full</span><span class="p">,</span><span class="w"> </span><span class="n">total_tank_stock</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">increased</span><span class="w"></span>

<span class="w">    </span><span class="n">up</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">water</span><span class="w"> </span><span class="n">making</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">difference</span><span class="w"> </span><span class="n">between</span><span class="w"> </span><span class="n">quantity</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">water</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">humectation</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">variation</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">daily</span><span class="w"> </span><span class="n">transpirable</span><span class="w"> </span><span class="n">water</span><span class="p">.</span><span class="w"></span>

<span class="w">    </span><span class="nl">Args</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="n">j</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">        </span><span class="n">data</span><span class="w"> </span><span class="p">(</span><span class="n">_type_</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">    </span><span class="nl">Returns</span><span class="p">:</span><span class="w"></span>

<span class="w">        </span><span class="nl">_type_</span><span class="p">:</span><span class="w"> </span><span class="n">_description_</span><span class="w"></span>

<span class="w">    </span><span class="s">&quot;&quot;&quot;</span>

<span class="w">    </span><span class="n">condition_1</span><span class="p">,</span><span class="w"> </span><span class="n">condition_2</span><span class="p">,</span><span class="w"> </span><span class="n">condition_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">conditions_rempliRes</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">data</span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="cp">#! renaming stTot to total_tank_stock</span>

<span class="w">    </span><span class="cp">#</span><span class="c1">// data[&quot;stTot&quot;][j:,:,:] = np.where(</span>

<span class="w">    </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">        </span><span class="n">condition_1</span><span class="p">,</span><span class="w"></span>

<span class="w">        </span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">            </span><span class="cp">#!</span>

<span class="w">            </span><span class="n">condition_2</span><span class="p">,</span><span class="w"></span>

<span class="w">            </span><span class="cp">#! we replace stRurPrec with stRur at indice j-1</span>

<span class="w">            </span><span class="cp">#! renaming stRur to root_tank_stock</span>

<span class="w">            </span><span class="cp">#! renaming stTot to total_tank_stock</span>

<span class="w">            </span><span class="cp">#! renaming stRuVar with delta_total_tank_stock</span>

<span class="w">            </span><span class="cp">#</span><span class="c1">// data[&quot;stTot&quot;][j,:,:] + (data[&quot;stRuVar&quot;][j,:,:] - data[&quot;hum&quot;][j,:,:]) * data[&quot;stRurPrec&quot;][j,:,:],</span>

<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;hum&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;stRurPrec&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">],</span><span class="w"></span>

<span class="w">            </span><span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="w"></span>

<span class="w">                </span><span class="n">condition_3</span><span class="p">,</span><span class="w"></span>

<span class="w">                </span><span class="cp">#! renaming stRuVar with delta_total_tank_stock</span>

<span class="w">                </span><span class="cp">#</span><span class="c1">//data[&quot;stRuVar&quot;][j,:,:],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;delta_total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">],</span><span class="w"></span>

<span class="w">                </span><span class="cp">#! renaming stTot to total_tank_stock</span>

<span class="w">                </span><span class="cp">#</span><span class="c1">// data[&quot;stTot&quot;][j,:,:],</span>

<span class="w">                </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">],</span><span class="w"></span>

<span class="w">            </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="p">),</span><span class="w"></span>

<span class="w">        </span><span class="cp">#! renaming stTot to total_tank_stock</span>

<span class="w">        </span><span class="cp">#</span><span class="c1">// data[&quot;stTot&quot;][j,:,:],</span>

<span class="w">        </span><span class="n">data</span><span class="p">[</span><span class="s">&quot;total_tank_stock&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">],</span><span class="w"></span>

<span class="w">    </span><span class="p">)</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock_step_3">update_total_tank_stock_step_3</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock_step_3</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the total tank stock where these is overflow occuring.</p>
<p>When capacity of total tank is exceeded, it corrects the stock value with
maximum capacity of total tank.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_total_tank_stock_step_3</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">where</span> <span class="nv">these</span> <span class="nv">is</span> <span class="nv">overflow</span> <span class="nv">occuring</span>.

    <span class="nv">When</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">total</span> <span class="nv">tank</span> <span class="nv">is</span> <span class="nv">exceeded</span>, <span class="nv">it</span> <span class="nv">corrects</span> <span class="nv">the</span> <span class="nv">stock</span> <span class="nv">value</span> <span class="nv">with</span>

    <span class="nv">maximum</span> <span class="nv">capacity</span> <span class="nv">of</span> <span class="nv">total</span> <span class="nv">tank</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuMax</span> <span class="nv">to</span> <span class="nv">total_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">condition</span> <span class="o">=</span> <span class="ss">(</span><span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&gt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    <span class="nv">condition</span> <span class="o">=</span> <span class="nv">condition_total_tank_overflow</span><span class="ss">(</span><span class="nv">j</span>,<span class="nv">data</span><span class="ss">)</span>

    # <span class="nv">groupe</span> <span class="mi">37</span>

    # <span class="nv">essais</span> <span class="nv">stTot</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRuMax</span> <span class="nv">to</span> <span class="nv">total_tank_capacity</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        <span class="nv">condition</span>,

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRuMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        # <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock_with_transpiration">update_total_tank_stock_with_transpiration</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock_with_transpiration</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_total_tank_stock_with_transpiration</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    # <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRu</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>

    # <span class="nv">essais</span> <span class="nv">stTot</span>

    # <span class="nv">group</span> <span class="mi">68</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">tr</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>] ## <span class="nv">ok</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_total_tank_stock_with_water_consumption">update_total_tank_stock_with_water_consumption</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_total_tank_stock_with_water_consumption</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the total tank stock by subtracting the lower water consumption</p>
<p>value from estimate_water_consumption_from_root_tank_stock</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_total_tank_stock_with_water_consumption</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">total</span> <span class="nv">tank</span> <span class="nv">stock</span> <span class="nv">by</span> <span class="nv">subtracting</span> <span class="nv">the</span> <span class="nv">lower</span> <span class="nv">water</span> <span class="nv">consumption</span>

    <span class="nv">value</span> <span class="nv">from</span> <span class="nv">estimate_water_consumption_from_root_tank_stock</span>

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    # <span class="nv">group</span> <span class="mi">62</span>

    #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stTot</span> <span class="nv">to</span> <span class="nv">total_tank_stock</span>

    #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stTot</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">maximum</span><span class="ss">(</span><span class="mi">0</span>, <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">total_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">-</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:]<span class="ss">)</span>#[...,<span class="nv">np</span>.<span class="nv">newaxis</span>]

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
<h3 id="update_water_consumption_according_to_rooting">update_water_consumption_according_to_rooting</h3>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">update_water_consumption_according_to_rooting</span><span class="p">(</span>
    <span class="n">j</span><span class="p">,</span>
    <span class="n">data</span>
<span class="p">)</span>
</code></pre></div>

<p>This function updates the water consumption consoRur according to</p>
<p>rooting depth.</p>
<p>If the root tank capacity is lower than the surface tank capacity,
meaning than the roots did not dive into the deep tank yet, then the
water consumption is updated to equal the evaporation at the prorata of
the exploration of surface tank by the roots.</p>
<p>Else, consoRur keeps it value, which was previously computed by
estimate_water_consumption_from_root_tank_stock.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>j</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
<tr>
<td>data</td>
<td><em>type</em></td>
<td><em>description</em></td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>type</em></td>
<td><em>description</em></td>
</tr>
</tbody>
</table>
<details class="example">
<summary>View Source</summary>
<div class="codehilite"><pre><span></span><code><span class="nv">def</span> <span class="nv">update_water_consumption_according_to_rooting</span><span class="ss">(</span><span class="nv">j</span>, <span class="nv">data</span><span class="ss">)</span>:

    <span class="s2">&quot;&quot;&quot;</span>

    <span class="nv">This</span> <span class="nv">function</span> <span class="nv">updates</span> <span class="nv">the</span> <span class="nv">water</span> <span class="nv">consumption</span> <span class="nv">consoRur</span> <span class="nv">according</span> <span class="nv">to</span>

    <span class="nv">rooting</span> <span class="nv">depth</span>.

    <span class="k">If</span> <span class="nv">the</span> <span class="nv">root</span> <span class="nv">tank</span> <span class="nv">capacity</span> <span class="nv">is</span> <span class="nv">lower</span> <span class="nv">than</span> <span class="nv">the</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">capacity</span>,

    <span class="nv">meaning</span> <span class="nv">than</span> <span class="nv">the</span> <span class="nv">roots</span> <span class="nv">did</span> <span class="nv">not</span> <span class="nv">dive</span> <span class="nv">into</span> <span class="nv">the</span> <span class="nv">deep</span> <span class="nv">tank</span> <span class="nv">yet</span>, <span class="k">then</span> <span class="nv">the</span>

    <span class="nv">water</span> <span class="nv">consumption</span> <span class="nv">is</span> <span class="nv">updated</span> <span class="nv">to</span> <span class="nv">equal</span> <span class="nv">the</span> <span class="nv">evaporation</span> <span class="nv">at</span> <span class="nv">the</span> <span class="nv">prorata</span> <span class="nv">of</span>

    <span class="nv">the</span> <span class="nv">exploration</span> <span class="nv">of</span> <span class="nv">surface</span> <span class="nv">tank</span> <span class="nv">by</span> <span class="nv">the</span> <span class="nv">roots</span>.

    <span class="k">Else</span>, <span class="nv">consoRur</span> <span class="nv">keeps</span> <span class="nv">it</span> <span class="nv">value</span>, <span class="nv">which</span> <span class="nv">was</span> <span class="nv">previously</span> <span class="nv">computed</span> <span class="nv">by</span>

    <span class="nv">estimate_water_consumption_from_root_tank_stock</span>.

    <span class="nv">Args</span>:

        <span class="nv">j</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

        <span class="nv">data</span> <span class="ss">(</span><span class="nv">_type_</span><span class="ss">)</span>: <span class="nv">_description_</span>

    <span class="nv">Returns</span>:

        <span class="nv">_type_</span>: <span class="nv">_description_</span>

    <span class="s2">&quot;&quot;&quot;</span>

    #  <span class="nv">fraction</span> <span class="nv">d</span><span class="s1">&#39;</span><span class="s">eau evapore sur la part transpirable qd les racines sont moins</span>

    #  <span class="nv">profondes</span> <span class="nv">que</span> <span class="nv">le</span> <span class="nv">reservoir</span> <span class="nv">de</span> <span class="nv">surface</span>, <span class="nv">mise</span> <span class="nv">a</span> <span class="nv">jour</span> <span class="nv">des</span> <span class="nv">stocks</span> <span class="nv">transpirables</span>

    # <span class="nv">group</span> <span class="mi">63</span>

    <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">=</span> <span class="nv">np</span>.<span class="nv">where</span><span class="ss">(</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRurMax</span> <span class="nv">with</span> <span class="nv">root_tank_capacity</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRurMax</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_capacity</span><span class="s2">&quot;</span>][<span class="nv">j</span>:,:,:] <span class="o">&lt;</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>],

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">stRur</span> <span class="nv">to</span> <span class="nv">root_tank_stock</span>

        #<span class="o">!</span> <span class="nv">renaming</span> <span class="nv">ruSurf</span> <span class="nv">with</span> <span class="nv">surface_tank_capacity</span>

        #<span class="o">//</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">stRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">ruSurf</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">evap</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">*</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">root_tank_stock</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:] <span class="o">/</span> <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">surface_tank_capacity</span><span class="s2">&quot;</span>],

        <span class="nv">data</span>[<span class="s2">&quot;</span><span class="s">consoRur</span><span class="s2">&quot;</span>][<span class="nv">j</span>,:,:],

    <span class="ss">)</span>

    <span class="k">return</span> <span class="nv">data</span>
</code></pre></div>

</details>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../bilan_carbo/" class="btn btn-neutral float-left" title="Bilan Carbo"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../bilan_pheno/" class="btn btn-neutral float-right" title="Bilan Pheno">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../bilan_carbo/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../bilan_pheno/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme_extra.js" defer></script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
